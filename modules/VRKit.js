/* Built for whs v2.2.0-beta.0 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.VRKit = {})));
}(this, (function (exports) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /* WhitestormJS Framework v2.2.0-alpha.0 */function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}var runtime=createCommonjsModule(function(module){/**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */!function(global){var Op=Object.prototype;var hasOwn=Op.hasOwnProperty;var undefined;// More compressible than void 0.
  var $Symbol=typeof Symbol==="function"?Symbol:{};var iteratorSymbol=$Symbol.iterator||"@@iterator";var asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator";var toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";var runtime=global.regeneratorRuntime;if(runtime){{// If regeneratorRuntime is defined globally and we're in a module,
  // make the exports object identical to regeneratorRuntime.
  module.exports=runtime;}// Don't bother evaluating the rest of this file if the runtime was
  // already defined globally.
  return;}// Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime=global.regeneratorRuntime=module.exports;function wrap(innerFn,outerFn,self,tryLocsList){// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator;var generator=Object.create(protoGenerator.prototype);var context=new Context(tryLocsList||[]);// The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke=makeInvokeMethod(innerFn,self,context);return generator;}runtime.wrap=wrap;// Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn,obj,arg){try{return {type:"normal",arg:fn.call(obj,arg)};}catch(err){return {type:"throw",arg:err};}}var GenStateSuspendedStart="suspendedStart";var GenStateSuspendedYield="suspendedYield";var GenStateExecuting="executing";var GenStateCompleted="completed";// Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel={};// Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}// This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype={};IteratorPrototype[iteratorSymbol]=function(){return this;};var getProto=Object.getPrototypeOf;var NativeIteratorPrototype=getProto&&getProto(getProto(values([])));if(NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)){// This environment has a native %IteratorPrototype%; use it instead
  // of the polyfill.
  IteratorPrototype=NativeIteratorPrototype;}var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);GeneratorFunction.prototype=Gp.constructor=GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor=GeneratorFunction;GeneratorFunctionPrototype[toStringTagSymbol]=GeneratorFunction.displayName="GeneratorFunction";// Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){prototype[method]=function(arg){return this._invoke(method,arg);};});}runtime.isGeneratorFunction=function(genFun){var ctor=typeof genFun==="function"&&genFun.constructor;return ctor?ctor===GeneratorFunction||// For the native GeneratorFunction constructor, the best we can
  // do is to check its .name property.
  (ctor.displayName||ctor.name)==="GeneratorFunction":false;};runtime.mark=function(genFun){if(Object.setPrototypeOf){Object.setPrototypeOf(genFun,GeneratorFunctionPrototype);}else{genFun.__proto__=GeneratorFunctionPrototype;if(!(toStringTagSymbol in genFun)){genFun[toStringTagSymbol]="GeneratorFunction";}}genFun.prototype=Object.create(Gp);return genFun;};// Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap=function(arg){return {__await:arg};};function AsyncIterator(generator){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if(record.type==="throw"){reject(record.arg);}else{var result=record.arg;var value=result.value;if(value&&typeof value==="object"&&hasOwn.call(value,"__await")){return Promise.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);});}return Promise.resolve(value).then(function(unwrapped){// When a yielded Promise is resolved, its final value becomes
  // the .value of the Promise<{value,done}> result for the
  // current iteration. If the Promise is rejected, however, the
  // result for this iteration will be rejected with the same
  // reason. Note that rejections of yielded Promises are not
  // thrown back into the generator function, as is the case
  // when an awaited Promise is rejected. This difference in
  // behavior between yield and await is important, because it
  // allows the consumer to decide what to do with the yielded
  // rejection (swallow it and continue, manually .throw it back
  // into the generator, abandon iteration, whatever). With
  // await, by contrast, there is no opportunity to examine the
  // rejection reason outside the generator function, so the
  // only option is to throw it from the await expression, and
  // let the generator function handle the exception.
  result.value=unwrapped;resolve(result);},reject);}}var previousPromise;function enqueue(method,arg){function callInvokeWithMethodAndArg(){return new Promise(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=// If enqueue has been called before, then we want to wait until
  // all previous Promises have been resolved before calling invoke,
  // so that results are always delivered in the correct order. If
  // enqueue has not been called before, then it is important to
  // call invoke immediately, without waiting on a callback to fire,
  // so that the async generator function has the opportunity to do
  // any necessary setup in a predictable way. This predictability
  // is why the Promise constructor synchronously invokes its
  // executor callback, and why async functions synchronously
  // execute code before the first await. Since we implement simple
  // async functions in terms of async generators, it is especially
  // important to get this right, even though it requires care.
  previousPromise?previousPromise.then(callInvokeWithMethodAndArg,// Avoid propagating failures to Promises returned by later
  // invocations of the iterator.
  callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}// Define the unified helper method that is used to implement .next,
  // .throw, and .return (see defineIteratorMethods).
  this._invoke=enqueue;}defineIteratorMethods(AsyncIterator.prototype);AsyncIterator.prototype[asyncIteratorSymbol]=function(){return this;};runtime.AsyncIterator=AsyncIterator;// Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async=function(innerFn,outerFn,self,tryLocsList){var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList));return runtime.isGeneratorFunction(outerFn)?iter// If outerFn is a generator, return the full iterator.
  :iter.next().then(function(result){return result.done?result.value:iter.next();});};function makeInvokeMethod(innerFn,self,context){var state=GenStateSuspendedStart;return function invoke(method,arg){if(state===GenStateExecuting){throw new Error("Generator is already running");}if(state===GenStateCompleted){if(method==="throw"){throw arg;}// Be forgiving, per 25.3.3.3.3 of the spec:
  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
  return doneResult();}context.method=method;context.arg=arg;while(true){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if(context.method==="next"){// Setting context._sent for legacy support of Babel's
  // function.sent implementation.
  context.sent=context._sent=context.arg;}else if(context.method==="throw"){if(state===GenStateSuspendedStart){state=GenStateCompleted;throw context.arg;}context.dispatchException(context.arg);}else if(context.method==="return"){context.abrupt("return",context.arg);}state=GenStateExecuting;var record=tryCatch(innerFn,self,context);if(record.type==="normal"){// If an exception is thrown from innerFn, we leave state ===
  // GenStateExecuting and loop back for another invocation.
  state=context.done?GenStateCompleted:GenStateSuspendedYield;if(record.arg===ContinueSentinel){continue;}return {value:record.arg,done:context.done};}else if(record.type==="throw"){state=GenStateCompleted;// Dispatch the exception by looping back around to the
  // context.dispatchException(context.arg) call above.
  context.method="throw";context.arg=record.arg;}}};}// Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(method===undefined){// A .throw or .return when the delegate iterator has no .throw
  // method always terminates the yield* loop.
  context.delegate=null;if(context.method==="throw"){if(delegate.iterator.return){// If the delegate iterator has a return method, give it a
  // chance to clean up.
  context.method="return";context.arg=undefined;maybeInvokeDelegate(delegate,context);if(context.method==="throw"){// If maybeInvokeDelegate(context) changed context.method from
  // "return" to "throw", let that override the TypeError below.
  return ContinueSentinel;}}context.method="throw";context.arg=new TypeError("The iterator does not provide a 'throw' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if(record.type==="throw"){context.method="throw";context.arg=record.arg;context.delegate=null;return ContinueSentinel;}var info=record.arg;if(!info){context.method="throw";context.arg=new TypeError("iterator result is not an object");context.delegate=null;return ContinueSentinel;}if(info.done){// Assign the result of the finished delegate to the temporary
  // variable specified by delegate.resultName (see delegateYield).
  context[delegate.resultName]=info.value;// Resume execution at the desired location (see delegateYield).
  context.next=delegate.nextLoc;// If context.method was "throw" but the delegate handled the
  // exception, let the outer generator proceed normally. If
  // context.method was "next", forget context.arg since it has been
  // "consumed" by the delegate iterator. If context.method was
  // "return", allow the original .return call to continue in the
  // outer generator.
  if(context.method!=="return"){context.method="next";context.arg=undefined;}}else{// Re-yield the result returned by the delegate method.
  return info;}// The delegate iterator is finished, so forget it and continue with
  // the outer generator.
  context.delegate=null;return ContinueSentinel;}// Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);Gp[toStringTagSymbol]="Generator";// A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol]=function(){return this;};Gp.toString=function(){return "[object Generator]";};function pushTryEntry(locs){var entry={tryLoc:locs[0]};if(1 in locs){entry.catchLoc=locs[1];}if(2 in locs){entry.finallyLoc=locs[2];entry.afterLoc=locs[3];}this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal";delete record.arg;entry.completion=record;}function Context(tryLocsList){// The root entry object (effectively a try statement without a catch
  // or a finally block) gives us a place to store values thrown from
  // locations where there is no enclosing try statement.
  this.tryEntries=[{tryLoc:"root"}];tryLocsList.forEach(pushTryEntry,this);this.reset(true);}runtime.keys=function(object){var keys=[];for(var key in object){keys.push(key);}keys.reverse();// Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.
  return function next(){while(keys.length){var key=keys.pop();if(key in object){next.value=key;next.done=false;return next;}}// To avoid creating an additional object, we just hang the .value
  // and .done properties off the next function object itself. This
  // also ensures that the minifier will not anonymize the function.
  next.done=true;return next;};};function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod){return iteratorMethod.call(iterable);}if(typeof iterable.next==="function"){return iterable;}if(!isNaN(iterable.length)){var i=-1,next=function next(){while(++i<iterable.length){if(hasOwn.call(iterable,i)){next.value=iterable[i];next.done=false;return next;}}next.value=undefined;next.done=true;return next;};return next.next=next;}}// Return an iterator with no values.
  return {next:doneResult};}runtime.values=values;function doneResult(){return {value:undefined,done:true};}Context.prototype={constructor:Context,reset:function(skipTempReset){this.prev=0;this.next=0;// Resetting context._sent for legacy support of Babel's
  // function.sent implementation.
  this.sent=this._sent=undefined;this.done=false;this.delegate=null;this.method="next";this.arg=undefined;this.tryEntries.forEach(resetTryEntry);if(!skipTempReset){for(var name in this){// Not sure about the optimal order of these conditions:
  if(name.charAt(0)==="t"&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))){this[name]=undefined;}}}},stop:function(){this.done=true;var rootEntry=this.tryEntries[0];var rootRecord=rootEntry.completion;if(rootRecord.type==="throw"){throw rootRecord.arg;}return this.rval;},dispatchException:function(exception){if(this.done){throw exception;}var context=this;function handle(loc,caught){record.type="throw";record.arg=exception;context.next=loc;if(caught){// If the dispatched exception was caught by a catch block,
  // then let that catch block handle the exception normally.
  context.method="next";context.arg=undefined;}return !!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];var record=entry.completion;if(entry.tryLoc==="root"){// Exception thrown outside of any try block that could handle
  // it, so set the completion value of the entire function to
  // throw the exception.
  return handle("end");}if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc");var hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}else if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else if(hasCatch){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}}else if(hasFinally){if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else{throw new Error("try statement without catch or finally");}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}if(finallyEntry&&(type==="break"||type==="continue")&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc){// Ignore the finally entry if control is not jumping to a
  // location outside the try/catch block.
  finallyEntry=null;}var record=finallyEntry?finallyEntry.completion:{};record.type=type;record.arg=arg;if(finallyEntry){this.method="next";this.next=finallyEntry.finallyLoc;return ContinueSentinel;}return this.complete(record);},complete:function(record,afterLoc){if(record.type==="throw"){throw record.arg;}if(record.type==="break"||record.type==="continue"){this.next=record.arg;}else if(record.type==="return"){this.rval=this.arg=record.arg;this.method="return";this.next="end";}else if(record.type==="normal"&&afterLoc){this.next=afterLoc;}return ContinueSentinel;},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc){this.complete(entry.completion,entry.afterLoc);resetTryEntry(entry);return ContinueSentinel;}}},"catch":function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if(record.type==="throw"){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}// The context.catch method must only be called with a location
  // argument that corresponds to a known catch block.
  throw new Error("illegal catch attempt");},delegateYield:function(iterable,resultName,nextLoc){this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc};if(this.method==="next"){// Deliberately forget the last sent value so that we don't
  // accidentally pass it on to the delegate.
  this.arg=undefined;}return ContinueSentinel;}};}(// In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  function(){return this;}()||Function("return this")());});/**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ // This method of obtaining a reference to the global object needs to be
  // kept identical to the way it is obtained in runtime.js
  var g=function(){return this;}()||Function("return this")();// Use `getOwnPropertyNames` because not all browsers support calling
  // `hasOwnProperty` on the global `self` object in a worker. See #183.
  var hadRuntime=g.regeneratorRuntime&&Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime")>=0;// Save the old regeneratorRuntime in case it needs to be restored later.
  var oldRuntime=hadRuntime&&g.regeneratorRuntime;// Force reevalutation of runtime.js.
  g.regeneratorRuntime=undefined;var runtimeModule=runtime;if(hadRuntime){// Restore the original runtime.
  g.regeneratorRuntime=oldRuntime;}else{// Remove the global property added by runtime.js.
  try{delete g.regeneratorRuntime;}catch(e){g.regeneratorRuntime=undefined;}}var regenerator=runtimeModule;// 7.1.4 ToInteger
  var ceil=Math.ceil;var floor=Math.floor;var _toInteger=function(it){return isNaN(it=+it)?0:(it>0?floor:ceil)(it);};// 7.2.1 RequireObjectCoercible(argument)
  var _defined=function(it){if(it==undefined)throw TypeError("Can't call method on  "+it);return it;};// true  -> String#at
  // false -> String#codePointAt
  var _stringAt=function(TO_STRING){return function(that,pos){var s=String(_defined(that));var i=_toInteger(pos);var l=s.length;var a,b;if(i<0||i>=l)return TO_STRING?'':undefined;a=s.charCodeAt(i);return a<0xd800||a>0xdbff||i+1===l||(b=s.charCodeAt(i+1))<0xdc00||b>0xdfff?TO_STRING?s.charAt(i):a:TO_STRING?s.slice(i,i+2):(a-0xd800<<10)+(b-0xdc00)+0x10000;};};var _library=true;var _global=createCommonjsModule(function(module){// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global=module.exports=typeof window!='undefined'&&window.Math==Math?window:typeof self!='undefined'&&self.Math==Math?self// eslint-disable-next-line no-new-func
  :Function('return this')();if(typeof __g=='number')__g=global;// eslint-disable-line no-undef
  });var _core=createCommonjsModule(function(module){var core=module.exports={version:'2.5.6'};if(typeof __e=='number')__e=core;// eslint-disable-line no-undef
  });var _core_1=_core.version;var _aFunction=function(it){if(typeof it!='function')throw TypeError(it+' is not a function!');return it;};// optional / simple context binding
  var _ctx=function(fn,that,length){_aFunction(fn);if(that===undefined)return fn;switch(length){case 1:return function(a){return fn.call(that,a);};case 2:return function(a,b){return fn.call(that,a,b);};case 3:return function(a,b,c){return fn.call(that,a,b,c);};}return function()/* ...args */{return fn.apply(that,arguments);};};var _isObject=function(it){return typeof it==='object'?it!==null:typeof it==='function';};var _anObject=function(it){if(!_isObject(it))throw TypeError(it+' is not an object!');return it;};var _fails=function(exec){try{return !!exec();}catch(e){return true;}};// Thank's IE8 for his funny defineProperty
  var _descriptors=!_fails(function(){return Object.defineProperty({},'a',{get:function(){return 7;}}).a!=7;});var document$1=_global.document;// typeof document.createElement is 'object' in old IE
  var is=_isObject(document$1)&&_isObject(document$1.createElement);var _domCreate=function(it){return is?document$1.createElement(it):{};};var _ie8DomDefine=!_descriptors&&!_fails(function(){return Object.defineProperty(_domCreate('div'),'a',{get:function(){return 7;}}).a!=7;});// 7.1.1 ToPrimitive(input [, PreferredType])
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var _toPrimitive=function(it,S){if(!_isObject(it))return it;var fn,val;if(S&&typeof(fn=it.toString)=='function'&&!_isObject(val=fn.call(it)))return val;if(typeof(fn=it.valueOf)=='function'&&!_isObject(val=fn.call(it)))return val;if(!S&&typeof(fn=it.toString)=='function'&&!_isObject(val=fn.call(it)))return val;throw TypeError("Can't convert object to primitive value");};var dP=Object.defineProperty;var f=_descriptors?Object.defineProperty:function defineProperty(O,P,Attributes){_anObject(O);P=_toPrimitive(P,true);_anObject(Attributes);if(_ie8DomDefine)try{return dP(O,P,Attributes);}catch(e){/* empty */}if('get'in Attributes||'set'in Attributes)throw TypeError('Accessors not supported!');if('value'in Attributes)O[P]=Attributes.value;return O;};var _objectDp={f:f};var _propertyDesc=function(bitmap,value){return {enumerable:!(bitmap&1),configurable:!(bitmap&2),writable:!(bitmap&4),value:value};};var _hide=_descriptors?function(object,key,value){return _objectDp.f(object,key,_propertyDesc(1,value));}:function(object,key,value){object[key]=value;return object;};var hasOwnProperty={}.hasOwnProperty;var _has=function(it,key){return hasOwnProperty.call(it,key);};var PROTOTYPE='prototype';var $export=function(type,name,source){var IS_FORCED=type&$export.F;var IS_GLOBAL=type&$export.G;var IS_STATIC=type&$export.S;var IS_PROTO=type&$export.P;var IS_BIND=type&$export.B;var IS_WRAP=type&$export.W;var exports=IS_GLOBAL?_core:_core[name]||(_core[name]={});var expProto=exports[PROTOTYPE];var target=IS_GLOBAL?_global:IS_STATIC?_global[name]:(_global[name]||{})[PROTOTYPE];var key,own,out;if(IS_GLOBAL)source=name;for(key in source){// contains in native
  own=!IS_FORCED&&target&&target[key]!==undefined;if(own&&_has(exports,key))continue;// export native or passed
  out=own?target[key]:source[key];// prevent global pollution for namespaces
  exports[key]=IS_GLOBAL&&typeof target[key]!='function'?source[key]// bind timers to global for call from export context
  :IS_BIND&&own?_ctx(out,_global)// wrap global constructors for prevent change them in library
  :IS_WRAP&&target[key]==out?function(C){var F=function(a,b,c){if(this instanceof C){switch(arguments.length){case 0:return new C();case 1:return new C(a);case 2:return new C(a,b);}return new C(a,b,c);}return C.apply(this,arguments);};F[PROTOTYPE]=C[PROTOTYPE];return F;// make static versions for prototype methods
  }(out):IS_PROTO&&typeof out=='function'?_ctx(Function.call,out):out;// export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
  if(IS_PROTO){(exports.virtual||(exports.virtual={}))[key]=out;// export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
  if(type&$export.R&&expProto&&!expProto[key])_hide(expProto,key,out);}}};// type bitmap
  $export.F=1;// forced
  $export.G=2;// global
  $export.S=4;// static
  $export.P=8;// proto
  $export.B=16;// bind
  $export.W=32;// wrap
  $export.U=64;// safe
  $export.R=128;// real proto method for `library`
  var _export=$export;var _redefine=_hide;var _iterators={};var toString={}.toString;var _cof=function(it){return toString.call(it).slice(8,-1);};// fallback for non-array-like ES3 and non-enumerable old V8 strings
  // eslint-disable-next-line no-prototype-builtins
  var _iobject=Object('z').propertyIsEnumerable(0)?Object:function(it){return _cof(it)=='String'?it.split(''):Object(it);};// to indexed object, toObject with fallback for non-array-like ES3 strings
  var _toIobject=function(it){return _iobject(_defined(it));};// 7.1.15 ToLength
  var min=Math.min;var _toLength=function(it){return it>0?min(_toInteger(it),0x1fffffffffffff):0;// pow(2, 53) - 1 == 9007199254740991
  };var max=Math.max;var min$1=Math.min;var _toAbsoluteIndex=function(index,length){index=_toInteger(index);return index<0?max(index+length,0):min$1(index,length);};// false -> Array#indexOf
  // true  -> Array#includes
  var _arrayIncludes=function(IS_INCLUDES){return function($this,el,fromIndex){var O=_toIobject($this);var length=_toLength(O.length);var index=_toAbsoluteIndex(fromIndex,length);var value;// Array#includes uses SameValueZero equality algorithm
  // eslint-disable-next-line no-self-compare
  if(IS_INCLUDES&&el!=el)while(length>index){value=O[index++];// eslint-disable-next-line no-self-compare
  if(value!=value)return true;// Array#indexOf ignores holes, Array#includes - not
  }else for(;length>index;index++)if(IS_INCLUDES||index in O){if(O[index]===el)return IS_INCLUDES||index||0;}return !IS_INCLUDES&&-1;};};var _shared=createCommonjsModule(function(module){var SHARED='__core-js_shared__';var store=_global[SHARED]||(_global[SHARED]={});(module.exports=function(key,value){return store[key]||(store[key]=value!==undefined?value:{});})('versions',[]).push({version:_core.version,mode:'pure',copyright:'Â© 2018 Denis Pushkarev (zloirock.ru)'});});var id$1=0;var px=Math.random();var _uid=function(key){return 'Symbol('.concat(key===undefined?'':key,')_',(++id$1+px).toString(36));};var shared=_shared('keys');var _sharedKey=function(key){return shared[key]||(shared[key]=_uid(key));};var arrayIndexOf=_arrayIncludes(false);var IE_PROTO=_sharedKey('IE_PROTO');var _objectKeysInternal=function(object,names){var O=_toIobject(object);var i=0;var result=[];var key;for(key in O)if(key!=IE_PROTO)_has(O,key)&&result.push(key);// Don't enum bug & hidden keys
  while(names.length>i)if(_has(O,key=names[i++])){~arrayIndexOf(result,key)||result.push(key);}return result;};// IE 8- don't enum bug keys
  var _enumBugKeys='constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');// 19.1.2.14 / 15.2.3.14 Object.keys(O)
  var _objectKeys=Object.keys||function keys(O){return _objectKeysInternal(O,_enumBugKeys);};var _objectDps=_descriptors?Object.defineProperties:function defineProperties(O,Properties){_anObject(O);var keys=_objectKeys(Properties);var length=keys.length;var i=0;var P;while(length>i)_objectDp.f(O,P=keys[i++],Properties[P]);return O;};var document$2=_global.document;var _html=document$2&&document$2.documentElement;// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  var IE_PROTO$1=_sharedKey('IE_PROTO');var Empty=function(){/* empty */};var PROTOTYPE$1='prototype';// Create object with fake `null` prototype: use iframe Object with cleared prototype
  var createDict=function(){// Thrash, waste and sodomy: IE GC bug
  var iframe=_domCreate('iframe');var i=_enumBugKeys.length;var lt='<';var gt='>';var iframeDocument;iframe.style.display='none';_html.appendChild(iframe);iframe.src='javascript:';// eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument=iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(lt+'script'+gt+'document.F=Object'+lt+'/script'+gt);iframeDocument.close();createDict=iframeDocument.F;while(i--)delete createDict[PROTOTYPE$1][_enumBugKeys[i]];return createDict();};var _objectCreate=Object.create||function create(O,Properties){var result;if(O!==null){Empty[PROTOTYPE$1]=_anObject(O);result=new Empty();Empty[PROTOTYPE$1]=null;// add "__proto__" for Object.getPrototypeOf polyfill
  result[IE_PROTO$1]=O;}else result=createDict();return Properties===undefined?result:_objectDps(result,Properties);};var _wks=createCommonjsModule(function(module){var store=_shared('wks');var Symbol=_global.Symbol;var USE_SYMBOL=typeof Symbol=='function';var $exports=module.exports=function(name){return store[name]||(store[name]=USE_SYMBOL&&Symbol[name]||(USE_SYMBOL?Symbol:_uid)('Symbol.'+name));};$exports.store=store;});var def=_objectDp.f;var TAG=_wks('toStringTag');var _setToStringTag=function(it,tag,stat){if(it&&!_has(it=stat?it:it.prototype,TAG))def(it,TAG,{configurable:true,value:tag});};var IteratorPrototype={};// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
  _hide(IteratorPrototype,_wks('iterator'),function(){return this;});var _iterCreate=function(Constructor,NAME,next){Constructor.prototype=_objectCreate(IteratorPrototype,{next:_propertyDesc(1,next)});_setToStringTag(Constructor,NAME+' Iterator');};// 7.1.13 ToObject(argument)
  var _toObject=function(it){return Object(_defined(it));};// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
  var IE_PROTO$2=_sharedKey('IE_PROTO');var ObjectProto=Object.prototype;var _objectGpo=Object.getPrototypeOf||function(O){O=_toObject(O);if(_has(O,IE_PROTO$2))return O[IE_PROTO$2];if(typeof O.constructor=='function'&&O instanceof O.constructor){return O.constructor.prototype;}return O instanceof Object?ObjectProto:null;};var ITERATOR=_wks('iterator');var BUGGY=!([].keys&&'next'in[].keys());// Safari has buggy iterators w/o `next`
  var FF_ITERATOR='@@iterator';var KEYS='keys';var VALUES='values';var returnThis=function(){return this;};var _iterDefine=function(Base,NAME,Constructor,next,DEFAULT,IS_SET,FORCED){_iterCreate(Constructor,NAME,next);var getMethod=function(kind){if(!BUGGY&&kind in proto)return proto[kind];switch(kind){case KEYS:return function keys(){return new Constructor(this,kind);};case VALUES:return function values(){return new Constructor(this,kind);};}return function entries(){return new Constructor(this,kind);};};var TAG=NAME+' Iterator';var DEF_VALUES=DEFAULT==VALUES;var VALUES_BUG=false;var proto=Base.prototype;var $native=proto[ITERATOR]||proto[FF_ITERATOR]||DEFAULT&&proto[DEFAULT];var $default=$native||getMethod(DEFAULT);var $entries=DEFAULT?!DEF_VALUES?$default:getMethod('entries'):undefined;var $anyNative=NAME=='Array'?proto.entries||$native:$native;var methods,key,IteratorPrototype;// Fix native
  if($anyNative){IteratorPrototype=_objectGpo($anyNative.call(new Base()));if(IteratorPrototype!==Object.prototype&&IteratorPrototype.next){// Set @@toStringTag to native iterators
  _setToStringTag(IteratorPrototype,TAG,true);// fix for some old engines
  }}// fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES&&$native&&$native.name!==VALUES){VALUES_BUG=true;$default=function values(){return $native.call(this);};}// Define iterator
  if((FORCED)&&(BUGGY||VALUES_BUG||!proto[ITERATOR])){_hide(proto,ITERATOR,$default);}// Plug for library
  _iterators[NAME]=$default;_iterators[TAG]=returnThis;if(DEFAULT){methods={values:DEF_VALUES?$default:getMethod(VALUES),keys:IS_SET?$default:getMethod(KEYS),entries:$entries};if(FORCED)for(key in methods){if(!(key in proto))_redefine(proto,key,methods[key]);}else _export(_export.P+_export.F*(BUGGY||VALUES_BUG),NAME,methods);}return methods;};var $at=_stringAt(true);// 21.1.3.27 String.prototype[@@iterator]()
  _iterDefine(String,'String',function(iterated){this._t=String(iterated);// target
  this._i=0;// next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
  },function(){var O=this._t;var index=this._i;var point;if(index>=O.length)return {value:undefined,done:true};point=$at(O,index);this._i+=point.length;return {value:point,done:false};});var _iterStep=function(done,value){return {value:value,done:!!done};};// 22.1.3.4 Array.prototype.entries()
  // 22.1.3.13 Array.prototype.keys()
  // 22.1.3.29 Array.prototype.values()
  // 22.1.3.30 Array.prototype[@@iterator]()
  var es6_array_iterator=_iterDefine(Array,'Array',function(iterated,kind){this._t=_toIobject(iterated);// target
  this._i=0;// next index
  this._k=kind;// kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
  },function(){var O=this._t;var kind=this._k;var index=this._i++;if(!O||index>=O.length){this._t=undefined;return _iterStep(1);}if(kind=='keys')return _iterStep(0,index);if(kind=='values')return _iterStep(0,O[index]);return _iterStep(0,[index,O[index]]);},'values');// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
  _iterators.Arguments=_iterators.Array;var TO_STRING_TAG=_wks('toStringTag');var DOMIterables=('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,'+'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,'+'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,'+'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,'+'TextTrackList,TouchList').split(',');for(var i=0;i<DOMIterables.length;i++){var NAME=DOMIterables[i];var Collection=_global[NAME];var proto=Collection&&Collection.prototype;if(proto&&!proto[TO_STRING_TAG])_hide(proto,TO_STRING_TAG,NAME);_iterators[NAME]=_iterators.Array;}// getting tag from 19.1.3.6 Object.prototype.toString()
  var TAG$1=_wks('toStringTag');// ES3 wrong here
  var ARG=_cof(function(){return arguments;}())=='Arguments';// fallback for IE11 Script Access Denied error
  var tryGet=function(it,key){try{return it[key];}catch(e){/* empty */}};var _classof=function(it){var O,T,B;return it===undefined?'Undefined':it===null?'Null'// @@toStringTag case
  :typeof(T=tryGet(O=Object(it),TAG$1))=='string'?T// builtinTag case
  :ARG?_cof(O)// ES3 arguments fallback
  :(B=_cof(O))=='Object'&&typeof O.callee=='function'?'Arguments':B;};var _anInstance=function(it,Constructor,name,forbiddenField){if(!(it instanceof Constructor)||forbiddenField!==undefined&&forbiddenField in it){throw TypeError(name+': incorrect invocation!');}return it;};// call something on iterator step with safe closing on error
  var _iterCall=function(iterator,fn,value,entries){try{return entries?fn(_anObject(value)[0],value[1]):fn(value);// 7.4.6 IteratorClose(iterator, completion)
  }catch(e){var ret=iterator['return'];if(ret!==undefined)_anObject(ret.call(iterator));throw e;}};// check on default Array iterator
  var ITERATOR$1=_wks('iterator');var ArrayProto=Array.prototype;var _isArrayIter=function(it){return it!==undefined&&(_iterators.Array===it||ArrayProto[ITERATOR$1]===it);};var ITERATOR$2=_wks('iterator');var core_getIteratorMethod=_core.getIteratorMethod=function(it){if(it!=undefined)return it[ITERATOR$2]||it['@@iterator']||_iterators[_classof(it)];};var _forOf=createCommonjsModule(function(module){var BREAK={};var RETURN={};var exports=module.exports=function(iterable,entries,fn,that,ITERATOR){var iterFn=ITERATOR?function(){return iterable;}:core_getIteratorMethod(iterable);var f=_ctx(fn,that,entries?2:1);var index=0;var length,step,iterator,result;if(typeof iterFn!='function')throw TypeError(iterable+' is not iterable!');// fast case for arrays with default iterator
  if(_isArrayIter(iterFn))for(length=_toLength(iterable.length);length>index;index++){result=entries?f(_anObject(step=iterable[index])[0],step[1]):f(iterable[index]);if(result===BREAK||result===RETURN)return result;}else for(iterator=iterFn.call(iterable);!(step=iterator.next()).done;){result=_iterCall(iterator,f,step.value,entries);if(result===BREAK||result===RETURN)return result;}};exports.BREAK=BREAK;exports.RETURN=RETURN;});// 7.3.20 SpeciesConstructor(O, defaultConstructor)
  var SPECIES=_wks('species');var _speciesConstructor=function(O,D){var C=_anObject(O).constructor;var S;return C===undefined||(S=_anObject(C)[SPECIES])==undefined?D:_aFunction(S);};// fast apply, http://jsperf.lnkit.com/fast-apply/5
  var _invoke=function(fn,args,that){var un=that===undefined;switch(args.length){case 0:return un?fn():fn.call(that);case 1:return un?fn(args[0]):fn.call(that,args[0]);case 2:return un?fn(args[0],args[1]):fn.call(that,args[0],args[1]);case 3:return un?fn(args[0],args[1],args[2]):fn.call(that,args[0],args[1],args[2]);case 4:return un?fn(args[0],args[1],args[2],args[3]):fn.call(that,args[0],args[1],args[2],args[3]);}return fn.apply(that,args);};var process=_global.process;var setTask=_global.setImmediate;var clearTask=_global.clearImmediate;var MessageChannel=_global.MessageChannel;var Dispatch=_global.Dispatch;var counter=0;var queue={};var ONREADYSTATECHANGE='onreadystatechange';var defer,channel,port;var run=function(){var id=+this;// eslint-disable-next-line no-prototype-builtins
  if(queue.hasOwnProperty(id)){var fn=queue[id];delete queue[id];fn();}};var listener=function(event){run.call(event.data);};// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
  if(!setTask||!clearTask){setTask=function setImmediate(fn){var args=[];var i=1;while(arguments.length>i)args.push(arguments[i++]);queue[++counter]=function(){// eslint-disable-next-line no-new-func
  _invoke(typeof fn=='function'?fn:Function(fn),args);};defer(counter);return counter;};clearTask=function clearImmediate(id){delete queue[id];};// Node.js 0.8-
  if(_cof(process)=='process'){defer=function(id){process.nextTick(_ctx(run,id,1));};// Sphere (JS game engine) Dispatch API
  }else if(Dispatch&&Dispatch.now){defer=function(id){Dispatch.now(_ctx(run,id,1));};// Browsers with MessageChannel, includes WebWorkers
  }else if(MessageChannel){channel=new MessageChannel();port=channel.port2;channel.port1.onmessage=listener;defer=_ctx(port.postMessage,port,1);// Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  }else if(_global.addEventListener&&typeof postMessage=='function'&&!_global.importScripts){defer=function(id){_global.postMessage(id+'','*');};_global.addEventListener('message',listener,false);// IE8-
  }else if(ONREADYSTATECHANGE in _domCreate('script')){defer=function(id){_html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE]=function(){_html.removeChild(this);run.call(id);};};// Rest old browsers
  }else{defer=function(id){setTimeout(_ctx(run,id,1),0);};}}var _task={set:setTask,clear:clearTask};var macrotask=_task.set;var Observer=_global.MutationObserver||_global.WebKitMutationObserver;var process$1=_global.process;var Promise$1=_global.Promise;var isNode=_cof(process$1)=='process';var _microtask=function(){var head,last,notify;var flush=function(){var parent,fn;if(isNode&&(parent=process$1.domain))parent.exit();while(head){fn=head.fn;head=head.next;try{fn();}catch(e){if(head)notify();else last=undefined;throw e;}}last=undefined;if(parent)parent.enter();};// Node.js
  if(isNode){notify=function(){process$1.nextTick(flush);};// browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  }else if(Observer&&!(_global.navigator&&_global.navigator.standalone)){var toggle=true;var node=document.createTextNode('');new Observer(flush).observe(node,{characterData:true});// eslint-disable-line no-new
  notify=function(){node.data=toggle=!toggle;};// environments with maybe non-completely correct, but existent Promise
  }else if(Promise$1&&Promise$1.resolve){// Promise.resolve without an argument throws an error in LG WebOS 2
  var promise=Promise$1.resolve(undefined);notify=function(){promise.then(flush);};// for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  }else{notify=function(){// strange IE + webpack dev server bug - use .call(global)
  macrotask.call(_global,flush);};}return function(fn){var task={fn:fn,next:undefined};if(last)last.next=task;if(!head){head=task;notify();}last=task;};};// 25.4.1.5 NewPromiseCapability(C)
  function PromiseCapability(C){var resolve,reject;this.promise=new C(function($$resolve,$$reject){if(resolve!==undefined||reject!==undefined)throw TypeError('Bad Promise constructor');resolve=$$resolve;reject=$$reject;});this.resolve=_aFunction(resolve);this.reject=_aFunction(reject);}var f$1=function(C){return new PromiseCapability(C);};var _newPromiseCapability={f:f$1};var _perform=function(exec){try{return {e:false,v:exec()};}catch(e){return {e:true,v:e};}};var navigator$1=_global.navigator;var _userAgent=navigator$1&&navigator$1.userAgent||'';var _promiseResolve=function(C,x){_anObject(C);if(_isObject(x)&&x.constructor===C)return x;var promiseCapability=_newPromiseCapability.f(C);var resolve=promiseCapability.resolve;resolve(x);return promiseCapability.promise;};var _redefineAll=function(target,src,safe){for(var key in src){if(safe&&target[key])target[key]=src[key];else _hide(target,key,src[key]);}return target;};var SPECIES$1=_wks('species');var _setSpecies=function(KEY){var C=typeof _core[KEY]=='function'?_core[KEY]:_global[KEY];if(_descriptors&&C&&!C[SPECIES$1])_objectDp.f(C,SPECIES$1,{configurable:true,get:function(){return this;}});};var ITERATOR$3=_wks('iterator');var SAFE_CLOSING=false;try{var riter=[7][ITERATOR$3]();riter['return']=function(){SAFE_CLOSING=true;};}catch(e){/* empty */}var _iterDetect=function(exec,skipClosing){if(!skipClosing&&!SAFE_CLOSING)return false;var safe=false;try{var arr=[7];var iter=arr[ITERATOR$3]();iter.next=function(){return {done:safe=true};};arr[ITERATOR$3]=function(){return iter;};exec(arr);}catch(e){/* empty */}return safe;};var task=_task.set;var microtask=_microtask();var PROMISE='Promise';var TypeError$1=_global.TypeError;var process$2=_global.process;var versions=process$2&&process$2.versions;var v8=versions&&versions.v8||'';var $Promise=_global[PROMISE];var isNode$1=_classof(process$2)=='process';var empty=function(){/* empty */};var Internal,newGenericPromiseCapability,OwnPromiseCapability,Wrapper;var newPromiseCapability=newGenericPromiseCapability=_newPromiseCapability.f;var USE_NATIVE=!!function(){try{// correct subclassing with @@species support
  var promise=$Promise.resolve(1);var FakePromise=(promise.constructor={})[_wks('species')]=function(exec){exec(empty,empty);};// unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return (isNode$1||typeof PromiseRejectionEvent=='function')&&promise.then(empty)instanceof FakePromise// v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // we can't detect it synchronously, so just check versions
  &&v8.indexOf('6.6')!==0&&_userAgent.indexOf('Chrome/66')===-1;}catch(e){/* empty */}}();// helpers
  var isThenable=function(it){var then;return _isObject(it)&&typeof(then=it.then)=='function'?then:false;};var notify=function(promise,isReject){if(promise._n)return;promise._n=true;var chain=promise._c;microtask(function(){var value=promise._v;var ok=promise._s==1;var i=0;var run=function(reaction){var handler=ok?reaction.ok:reaction.fail;var resolve=reaction.resolve;var reject=reaction.reject;var domain=reaction.domain;var result,then,exited;try{if(handler){if(!ok){if(promise._h==2)onHandleUnhandled(promise);promise._h=1;}if(handler===true)result=value;else{if(domain)domain.enter();result=handler(value);// may throw
  if(domain){domain.exit();exited=true;}}if(result===reaction.promise){reject(TypeError$1('Promise-chain cycle'));}else if(then=isThenable(result)){then.call(result,resolve,reject);}else resolve(result);}else reject(value);}catch(e){if(domain&&!exited)domain.exit();reject(e);}};while(chain.length>i)run(chain[i++]);// variable length - can't use forEach
  promise._c=[];promise._n=false;if(isReject&&!promise._h)onUnhandled(promise);});};var onUnhandled=function(promise){task.call(_global,function(){var value=promise._v;var unhandled=isUnhandled(promise);var result,handler,console;if(unhandled){result=_perform(function(){if(isNode$1){process$2.emit('unhandledRejection',value,promise);}else if(handler=_global.onunhandledrejection){handler({promise:promise,reason:value});}else if((console=_global.console)&&console.error){console.error('Unhandled promise rejection',value);}});// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
  promise._h=isNode$1||isUnhandled(promise)?2:1;}promise._a=undefined;if(unhandled&&result.e)throw result.v;});};var isUnhandled=function(promise){return promise._h!==1&&(promise._a||promise._c).length===0;};var onHandleUnhandled=function(promise){task.call(_global,function(){var handler;if(isNode$1){process$2.emit('rejectionHandled',promise);}else if(handler=_global.onrejectionhandled){handler({promise:promise,reason:promise._v});}});};var $reject=function(value){var promise=this;if(promise._d)return;promise._d=true;promise=promise._w||promise;// unwrap
  promise._v=value;promise._s=2;if(!promise._a)promise._a=promise._c.slice();notify(promise,true);};var $resolve=function(value){var promise=this;var then;if(promise._d)return;promise._d=true;promise=promise._w||promise;// unwrap
  try{if(promise===value)throw TypeError$1("Promise can't be resolved itself");if(then=isThenable(value)){microtask(function(){var wrapper={_w:promise,_d:false};// wrap
  try{then.call(value,_ctx($resolve,wrapper,1),_ctx($reject,wrapper,1));}catch(e){$reject.call(wrapper,e);}});}else{promise._v=value;promise._s=1;notify(promise,false);}}catch(e){$reject.call({_w:promise,_d:false},e);// wrap
  }};// constructor polyfill
  if(!USE_NATIVE){// 25.4.3.1 Promise(executor)
  $Promise=function Promise(executor){_anInstance(this,$Promise,PROMISE,'_h');_aFunction(executor);Internal.call(this);try{executor(_ctx($resolve,this,1),_ctx($reject,this,1));}catch(err){$reject.call(this,err);}};// eslint-disable-next-line no-unused-vars
  Internal=function Promise(executor){this._c=[];// <- awaiting reactions
  this._a=undefined;// <- checked in isUnhandled reactions
  this._s=0;// <- state
  this._d=false;// <- done
  this._v=undefined;// <- value
  this._h=0;// <- rejection state, 0 - default, 1 - handled, 2 - unhandled
  this._n=false;// <- notify
  };Internal.prototype=_redefineAll($Promise.prototype,{// 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
  then:function then(onFulfilled,onRejected){var reaction=newPromiseCapability(_speciesConstructor(this,$Promise));reaction.ok=typeof onFulfilled=='function'?onFulfilled:true;reaction.fail=typeof onRejected=='function'&&onRejected;reaction.domain=isNode$1?process$2.domain:undefined;this._c.push(reaction);if(this._a)this._a.push(reaction);if(this._s)notify(this,false);return reaction.promise;},// 25.4.5.1 Promise.prototype.catch(onRejected)
  'catch':function(onRejected){return this.then(undefined,onRejected);}});OwnPromiseCapability=function(){var promise=new Internal();this.promise=promise;this.resolve=_ctx($resolve,promise,1);this.reject=_ctx($reject,promise,1);};_newPromiseCapability.f=newPromiseCapability=function(C){return C===$Promise||C===Wrapper?new OwnPromiseCapability(C):newGenericPromiseCapability(C);};}_export(_export.G+_export.W+_export.F*!USE_NATIVE,{Promise:$Promise});_setToStringTag($Promise,PROMISE);_setSpecies(PROMISE);Wrapper=_core[PROMISE];// statics
  _export(_export.S+_export.F*!USE_NATIVE,PROMISE,{// 25.4.4.5 Promise.reject(r)
  reject:function reject(r){var capability=newPromiseCapability(this);var $$reject=capability.reject;$$reject(r);return capability.promise;}});_export(_export.S+_export.F*(_library),PROMISE,{// 25.4.4.6 Promise.resolve(x)
  resolve:function resolve(x){return _promiseResolve(this===Wrapper?$Promise:this,x);}});_export(_export.S+_export.F*!(USE_NATIVE&&_iterDetect(function(iter){$Promise.all(iter)['catch'](empty);})),PROMISE,{// 25.4.4.1 Promise.all(iterable)
  all:function all(iterable){var C=this;var capability=newPromiseCapability(C);var resolve=capability.resolve;var reject=capability.reject;var result=_perform(function(){var values=[];var index=0;var remaining=1;_forOf(iterable,false,function(promise){var $index=index++;var alreadyCalled=false;values.push(undefined);remaining++;C.resolve(promise).then(function(value){if(alreadyCalled)return;alreadyCalled=true;values[$index]=value;--remaining||resolve(values);},reject);});--remaining||resolve(values);});if(result.e)reject(result.v);return capability.promise;},// 25.4.4.4 Promise.race(iterable)
  race:function race(iterable){var C=this;var capability=newPromiseCapability(C);var reject=capability.reject;var result=_perform(function(){_forOf(iterable,false,function(promise){C.resolve(promise).then(capability.resolve,reject);});});if(result.e)reject(result.v);return capability.promise;}});_export(_export.P+_export.R,'Promise',{'finally':function(onFinally){var C=_speciesConstructor(this,_core.Promise||_global.Promise);var isFunction=typeof onFinally=='function';return this.then(isFunction?function(x){return _promiseResolve(C,onFinally()).then(function(){return x;});}:onFinally,isFunction?function(e){return _promiseResolve(C,onFinally()).then(function(){throw e;});}:onFinally);}});// https://github.com/tc39/proposal-promise-try
  _export(_export.S,'Promise',{'try':function(callbackfn){var promiseCapability=_newPromiseCapability.f(this);var result=_perform(callbackfn);(result.e?promiseCapability.reject:promiseCapability.resolve)(result.v);return promiseCapability.promise;}});var promise=_core.Promise;var promise$1=promise;function _asyncToGenerator$1(fn){return function(){var self=this,args=arguments;return new promise$1(function(resolve,reject){var gen=fn.apply(self,args);function step(key,arg){try{var info=gen[key](arg);var value=info.value;}catch(error){reject(error);return;}if(info.done){resolve(value);}else{promise$1.resolve(value).then(_next,_throw);}}function _next(value){step("next",value);}function _throw(err){step("throw",err);}_next();});};}var asyncToGenerator=_asyncToGenerator$1;var f$2={}.propertyIsEnumerable;var _objectPie={f:f$2};var gOPD=Object.getOwnPropertyDescriptor;var f$3=_descriptors?gOPD:function getOwnPropertyDescriptor(O,P){O=_toIobject(O);P=_toPrimitive(P,true);if(_ie8DomDefine)try{return gOPD(O,P);}catch(e){/* empty */}if(_has(O,P))return _propertyDesc(!_objectPie.f.call(O,P),O[P]);};var _objectGopd={f:f$3};// most Object methods by ES6 should accept primitives
  var _objectSap=function(KEY,exec){var fn=(_core.Object||{})[KEY]||Object[KEY];var exp={};exp[KEY]=exec(fn);_export(_export.S+_export.F*_fails(function(){fn(1);}),'Object',exp);};// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  var $getOwnPropertyDescriptor=_objectGopd.f;_objectSap('getOwnPropertyDescriptor',function(){return function getOwnPropertyDescriptor(it,key){return $getOwnPropertyDescriptor(_toIobject(it),key);};});var $Object=_core.Object;var getOwnPropertyDescriptor=function getOwnPropertyDescriptor(it,key){return $Object.getOwnPropertyDescriptor(it,key);};var getOwnPropertyDescriptor$1=getOwnPropertyDescriptor;var _meta=createCommonjsModule(function(module){var META=_uid('meta');var setDesc=_objectDp.f;var id=0;var isExtensible=Object.isExtensible||function(){return true;};var FREEZE=!_fails(function(){return isExtensible(Object.preventExtensions({}));});var setMeta=function(it){setDesc(it,META,{value:{i:'O'+ ++id,// object ID
  w:{}// weak collections IDs
  }});};var fastKey=function(it,create){// return primitive with prefix
  if(!_isObject(it))return typeof it=='symbol'?it:(typeof it=='string'?'S':'P')+it;if(!_has(it,META)){// can't set metadata to uncaught frozen object
  if(!isExtensible(it))return 'F';// not necessary to add metadata
  if(!create)return 'E';// add missing metadata
  setMeta(it);// return object ID
  }return it[META].i;};var getWeak=function(it,create){if(!_has(it,META)){// can't set metadata to uncaught frozen object
  if(!isExtensible(it))return true;// not necessary to add metadata
  if(!create)return false;// add missing metadata
  setMeta(it);// return hash weak collections IDs
  }return it[META].w;};// add metadata on freeze-family methods calling
  var onFreeze=function(it){if(FREEZE&&meta.NEED&&isExtensible(it)&&!_has(it,META))setMeta(it);return it;};var meta=module.exports={KEY:META,NEED:false,fastKey:fastKey,getWeak:getWeak,onFreeze:onFreeze};});var _meta_1=_meta.KEY;var _meta_2=_meta.NEED;var _meta_3=_meta.fastKey;var _meta_4=_meta.getWeak;var _meta_5=_meta.onFreeze;var f$4=_wks;var _wksExt={f:f$4};var defineProperty=_objectDp.f;var _wksDefine=function(name){var $Symbol=_core.Symbol||(_core.Symbol={});if(name.charAt(0)!='_'&&!(name in $Symbol))defineProperty($Symbol,name,{value:_wksExt.f(name)});};var f$5=Object.getOwnPropertySymbols;var _objectGops={f:f$5};// all enumerable object keys, includes symbols
  var _enumKeys=function(it){var result=_objectKeys(it);var getSymbols=_objectGops.f;if(getSymbols){var symbols=getSymbols(it);var isEnum=_objectPie.f;var i=0;var key;while(symbols.length>i)if(isEnum.call(it,key=symbols[i++]))result.push(key);}return result;};// 7.2.2 IsArray(argument)
  var _isArray=Array.isArray||function isArray(arg){return _cof(arg)=='Array';};// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
  var hiddenKeys=_enumBugKeys.concat('length','prototype');var f$6=Object.getOwnPropertyNames||function getOwnPropertyNames(O){return _objectKeysInternal(O,hiddenKeys);};var _objectGopn={f:f$6};// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
  var gOPN=_objectGopn.f;var toString$1={}.toString;var windowNames=typeof window=='object'&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];var getWindowNames=function(it){try{return gOPN(it);}catch(e){return windowNames.slice();}};var f$7=function getOwnPropertyNames(it){return windowNames&&toString$1.call(it)=='[object Window]'?getWindowNames(it):gOPN(_toIobject(it));};var _objectGopnExt={f:f$7};// ECMAScript 6 symbols shim
  var META=_meta.KEY;var gOPD$1=_objectGopd.f;var dP$1=_objectDp.f;var gOPN$1=_objectGopnExt.f;var $Symbol=_global.Symbol;var $JSON=_global.JSON;var _stringify=$JSON&&$JSON.stringify;var PROTOTYPE$2='prototype';var HIDDEN=_wks('_hidden');var TO_PRIMITIVE=_wks('toPrimitive');var isEnum={}.propertyIsEnumerable;var SymbolRegistry=_shared('symbol-registry');var AllSymbols=_shared('symbols');var OPSymbols=_shared('op-symbols');var ObjectProto$1=Object[PROTOTYPE$2];var USE_NATIVE$1=typeof $Symbol=='function';var QObject=_global.QObject;// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
  var setter=!QObject||!QObject[PROTOTYPE$2]||!QObject[PROTOTYPE$2].findChild;// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
  var setSymbolDesc=_descriptors&&_fails(function(){return _objectCreate(dP$1({},'a',{get:function(){return dP$1(this,'a',{value:7}).a;}})).a!=7;})?function(it,key,D){var protoDesc=gOPD$1(ObjectProto$1,key);if(protoDesc)delete ObjectProto$1[key];dP$1(it,key,D);if(protoDesc&&it!==ObjectProto$1)dP$1(ObjectProto$1,key,protoDesc);}:dP$1;var wrap=function(tag){var sym=AllSymbols[tag]=_objectCreate($Symbol[PROTOTYPE$2]);sym._k=tag;return sym;};var isSymbol=USE_NATIVE$1&&typeof $Symbol.iterator=='symbol'?function(it){return typeof it=='symbol';}:function(it){return it instanceof $Symbol;};var $defineProperty=function defineProperty(it,key,D){if(it===ObjectProto$1)$defineProperty(OPSymbols,key,D);_anObject(it);key=_toPrimitive(key,true);_anObject(D);if(_has(AllSymbols,key)){if(!D.enumerable){if(!_has(it,HIDDEN))dP$1(it,HIDDEN,_propertyDesc(1,{}));it[HIDDEN][key]=true;}else{if(_has(it,HIDDEN)&&it[HIDDEN][key])it[HIDDEN][key]=false;D=_objectCreate(D,{enumerable:_propertyDesc(0,false)});}return setSymbolDesc(it,key,D);}return dP$1(it,key,D);};var $defineProperties=function defineProperties(it,P){_anObject(it);var keys=_enumKeys(P=_toIobject(P));var i=0;var l=keys.length;var key;while(l>i)$defineProperty(it,key=keys[i++],P[key]);return it;};var $create=function create(it,P){return P===undefined?_objectCreate(it):$defineProperties(_objectCreate(it),P);};var $propertyIsEnumerable=function propertyIsEnumerable(key){var E=isEnum.call(this,key=_toPrimitive(key,true));if(this===ObjectProto$1&&_has(AllSymbols,key)&&!_has(OPSymbols,key))return false;return E||!_has(this,key)||!_has(AllSymbols,key)||_has(this,HIDDEN)&&this[HIDDEN][key]?E:true;};var $getOwnPropertyDescriptor$1=function getOwnPropertyDescriptor(it,key){it=_toIobject(it);key=_toPrimitive(key,true);if(it===ObjectProto$1&&_has(AllSymbols,key)&&!_has(OPSymbols,key))return;var D=gOPD$1(it,key);if(D&&_has(AllSymbols,key)&&!(_has(it,HIDDEN)&&it[HIDDEN][key]))D.enumerable=true;return D;};var $getOwnPropertyNames=function getOwnPropertyNames(it){var names=gOPN$1(_toIobject(it));var result=[];var i=0;var key;while(names.length>i){if(!_has(AllSymbols,key=names[i++])&&key!=HIDDEN&&key!=META)result.push(key);}return result;};var $getOwnPropertySymbols=function getOwnPropertySymbols(it){var IS_OP=it===ObjectProto$1;var names=gOPN$1(IS_OP?OPSymbols:_toIobject(it));var result=[];var i=0;var key;while(names.length>i){if(_has(AllSymbols,key=names[i++])&&(IS_OP?_has(ObjectProto$1,key):true))result.push(AllSymbols[key]);}return result;};// 19.4.1.1 Symbol([description])
  if(!USE_NATIVE$1){$Symbol=function Symbol(){if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');var tag=_uid(arguments.length>0?arguments[0]:undefined);var $set=function(value){if(this===ObjectProto$1)$set.call(OPSymbols,value);if(_has(this,HIDDEN)&&_has(this[HIDDEN],tag))this[HIDDEN][tag]=false;setSymbolDesc(this,tag,_propertyDesc(1,value));};if(_descriptors&&setter)setSymbolDesc(ObjectProto$1,tag,{configurable:true,set:$set});return wrap(tag);};_redefine($Symbol[PROTOTYPE$2],'toString',function toString(){return this._k;});_objectGopd.f=$getOwnPropertyDescriptor$1;_objectDp.f=$defineProperty;_objectGopn.f=_objectGopnExt.f=$getOwnPropertyNames;_objectPie.f=$propertyIsEnumerable;_objectGops.f=$getOwnPropertySymbols;if(_descriptors&&!_library){_redefine(ObjectProto$1,'propertyIsEnumerable',$propertyIsEnumerable,true);}_wksExt.f=function(name){return wrap(_wks(name));};}_export(_export.G+_export.W+_export.F*!USE_NATIVE$1,{Symbol:$Symbol});for(var es6Symbols=// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','),j=0;es6Symbols.length>j;)_wks(es6Symbols[j++]);for(var wellKnownSymbols=_objectKeys(_wks.store),k=0;wellKnownSymbols.length>k;)_wksDefine(wellKnownSymbols[k++]);_export(_export.S+_export.F*!USE_NATIVE$1,'Symbol',{// 19.4.2.1 Symbol.for(key)
  'for':function(key){return _has(SymbolRegistry,key+='')?SymbolRegistry[key]:SymbolRegistry[key]=$Symbol(key);},// 19.4.2.5 Symbol.keyFor(sym)
  keyFor:function keyFor(sym){if(!isSymbol(sym))throw TypeError(sym+' is not a symbol!');for(var key in SymbolRegistry)if(SymbolRegistry[key]===sym)return key;},useSetter:function(){setter=true;},useSimple:function(){setter=false;}});_export(_export.S+_export.F*!USE_NATIVE$1,'Object',{// 19.1.2.2 Object.create(O [, Properties])
  create:$create,// 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty:$defineProperty,// 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties:$defineProperties,// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor:$getOwnPropertyDescriptor$1,// 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames:$getOwnPropertyNames,// 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols:$getOwnPropertySymbols});// 24.3.2 JSON.stringify(value [, replacer [, space]])
  $JSON&&_export(_export.S+_export.F*(!USE_NATIVE$1||_fails(function(){var S=$Symbol();// MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S])!='[null]'||_stringify({a:S})!='{}'||_stringify(Object(S))!='{}';})),'JSON',{stringify:function stringify(it){var args=[it];var i=1;var replacer,$replacer;while(arguments.length>i)args.push(arguments[i++]);$replacer=replacer=args[1];if(!_isObject(replacer)&&it===undefined||isSymbol(it))return;// IE8 returns string on undefined
  if(!_isArray(replacer))replacer=function(key,value){if(typeof $replacer=='function')value=$replacer.call(this,key,value);if(!isSymbol(value))return value;};args[1]=replacer;return _stringify.apply($JSON,args);}});// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE]||_hide($Symbol[PROTOTYPE$2],TO_PRIMITIVE,$Symbol[PROTOTYPE$2].valueOf);// 19.4.3.5 Symbol.prototype[@@toStringTag]
  _setToStringTag($Symbol,'Symbol');// 20.2.1.9 Math[@@toStringTag]
  _setToStringTag(Math,'Math',true);// 24.3.3 JSON[@@toStringTag]
  _setToStringTag(_global.JSON,'JSON',true);var getOwnPropertySymbols=_core.Object.getOwnPropertySymbols;var getOwnPropertySymbols$1=getOwnPropertySymbols;// 19.1.2.14 Object.keys(O)
  _objectSap('keys',function(){return function keys(it){return _objectKeys(_toObject(it));};});var keys=_core.Object.keys;var keys$1=keys;// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
  _export(_export.S+_export.F*!_descriptors,'Object',{defineProperty:_objectDp.f});var $Object$1=_core.Object;var defineProperty$1=function defineProperty(it,key,desc){return $Object$1.defineProperty(it,key,desc);};var defineProperty$2=defineProperty$1;function _defineProperty$1(obj,key,value){if(key in obj){defineProperty$2(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}var defineProperty$3=_defineProperty$1;function _objectSpread$1(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};var ownKeys=keys$1(source);if(typeof getOwnPropertySymbols$1==='function'){ownKeys=ownKeys.concat(getOwnPropertySymbols$1(source).filter(function(sym){return getOwnPropertyDescriptor$1(source,sym).enumerable;}));}ownKeys.forEach(function(key){defineProperty$3(target,key,source[key]);});}return target;}var objectSpread=_objectSpread$1;function _classCallCheck$1(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var classCallCheck=_classCallCheck$1;// Works with __proto__ only. Old v8 can't work with null proto objects.
  /* eslint-disable no-proto */var check=function(O,proto){_anObject(O);if(!_isObject(proto)&&proto!==null)throw TypeError(proto+": can't set as prototype!");};var _setProto={set:Object.setPrototypeOf||('__proto__'in{}?// eslint-disable-line
  function(test,buggy,set){try{set=_ctx(Function.call,_objectGopd.f(Object.prototype,'__proto__').set,2);set(test,[]);buggy=!(test instanceof Array);}catch(e){buggy=true;}return function setPrototypeOf(O,proto){check(O,proto);if(buggy)O.__proto__=proto;else set(O,proto);return O;};}({},false):undefined),check:check};// 19.1.3.19 Object.setPrototypeOf(O, proto)
  _export(_export.S,'Object',{setPrototypeOf:_setProto.set});var setPrototypeOf=_core.Object.setPrototypeOf;var setPrototypeOf$1=setPrototypeOf;var setPrototypeOf$2=createCommonjsModule(function(module){function _setPrototypeOf$$1(o,p){module.exports=_setPrototypeOf$$1=setPrototypeOf$1||function _setPrototypeOf$$1(o,p){o.__proto__=p;return o;};return _setPrototypeOf$$1(o,p);}module.exports=_setPrototypeOf$$1;});function _inherits$1(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}setPrototypeOf$2(subClass.prototype,superClass&&superClass.prototype);if(superClass)setPrototypeOf$2(subClass,superClass);}var inherits=_inherits$1;function _defineProperties$1(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;defineProperty$2(target,descriptor.key,descriptor);}}function _createClass$1(Constructor,protoProps,staticProps){if(protoProps)_defineProperties$1(Constructor.prototype,protoProps);if(staticProps)_defineProperties$1(Constructor,staticProps);return Constructor;}var createClass=_createClass$1;var iterator=_wksExt.f('iterator');var iterator$1=iterator;_wksDefine('asyncIterator');_wksDefine('observable');var symbol=_core.Symbol;var symbol$1=symbol;var _typeof_1=createCommonjsModule(function(module){function _typeof2(obj){if(typeof symbol$1==="function"&&typeof iterator$1==="symbol"){_typeof2=function _typeof2(obj){return typeof obj;};}else{_typeof2=function _typeof2(obj){return obj&&typeof symbol$1==="function"&&obj.constructor===symbol$1&&obj!==symbol$1.prototype?"symbol":typeof obj;};}return _typeof2(obj);}function _typeof$$1(obj){if(typeof symbol$1==="function"&&_typeof2(iterator$1)==="symbol"){module.exports=_typeof$$1=function _typeof$$1(obj){return _typeof2(obj);};}else{module.exports=_typeof$$1=function _typeof$$1(obj){return obj&&typeof symbol$1==="function"&&obj.constructor===symbol$1&&obj!==symbol$1.prototype?"symbol":_typeof2(obj);};}return _typeof$$1(obj);}module.exports=_typeof$$1;});function _assertThisInitialized$1(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}var assertThisInitialized=_assertThisInitialized$1;function _possibleConstructorReturn$1(self,call){if(call&&(_typeof_1(call)==="object"||typeof call==="function")){return call;}return assertThisInitialized(self);}var possibleConstructorReturn=_possibleConstructorReturn$1;// 19.1.2.9 Object.getPrototypeOf(O)
  _objectSap('getPrototypeOf',function(){return function getPrototypeOf(it){return _objectGpo(_toObject(it));};});var getPrototypeOf=_core.Object.getPrototypeOf;var getPrototypeOf$1=getPrototypeOf;var getPrototypeOf$2=createCommonjsModule(function(module){function _getPrototypeOf$$1(o){module.exports=_getPrototypeOf$$1=getPrototypeOf$1||function _getPrototypeOf$$1(o){return o.__proto__;};return _getPrototypeOf$$1(o);}module.exports=_getPrototypeOf$$1;});var extend=function extend(object){for(var _len=arguments.length,extensions=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){extensions[_key-1]=arguments[_key];}// $.extend alternative, ... is the spread operator.
  for(var _i=0;_i<extensions.length;_i++){var extension=extensions[_i];// console.log(extension);
  // console.log(typeof extension);
  if(!extension)continue;// Ignore null and undefined objects and parameters.
  var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=Object.getOwnPropertyNames(extension)[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var prop=_step.value;// Do not traverse the prototype chain.
  if(object[prop]!==undefined&&extension[prop]&&object[prop].toString()==='[object Object]'&&extension[prop].toString()==='[object Object]'){// Goes deep only if object[prop] and extension[prop] are both objects !
  if(object[prop].constructor===Object)extend(object[prop],extension[prop]);}else object[prop]=typeof object[prop]==='undefined'?extension[prop]:object[prop];if(typeof object[prop]==='undefined'&&Array.isArray(extension[prop]))object[prop]=extension[prop].slice();// Add values that do not already exist.
  else if(typeof object[prop]==='undefined'&&Array.isArray(extension[prop]))object[prop]=extension[prop];}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}return object;};var instruct=function instruct(array,instArray){var tempObject={};for(var i=0,max=instArray.length;i<max;i++){var guide=instArray[i];tempObject[guide]=array[i];}return tempObject;};var transformData=function transformData(object,instructions){for(var key in instructions){if(Array.isArray(object[key]))object[key]=instruct(object[key],instructions[key]);else if(object[key]instanceof Object&&!Array.isArray(instructions[key]))object[key]=transformData(object[key],instructions[key]);}return object;};if(Number.EPSILON===undefined){Number.EPSILON=Math.pow(2,-52);}if(Number.isInteger===undefined){// Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger=function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};}//
  if(Math.sign===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if('name'in Function.prototype===false){// Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype,'name',{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(Object.assign===undefined){// Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  (function(){Object.assign=function(target){if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};})();}/**
   * https://github.com/mrdoob/eventdispatcher.js/
   */function EventDispatcher(){}Object.assign(EventDispatcher.prototype,{addEventListener:function(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}}}});var REVISION='92';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var PCFShadowMap=1;var PCFSoftShadowMap=2;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var NoColors=0;var FaceColors=1;var VertexColors=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var Uncharted2ToneMapping=3;var CineonToneMapping=4;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var SphericalReflectionMapping=305;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipMapNearestFilter=1004;var NearestMipMapLinearFilter=1005;var LinearFilter=1006;var LinearMipMapNearestFilter=1007;var LinearMipMapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var DepthFormat=1026;var DepthStencilFormat=1027;var RGB_S3TC_DXT1_Format=33776;var RGBA_S3TC_DXT1_Format=33777;var RGBA_S3TC_DXT3_Format=33778;var RGBA_S3TC_DXT5_Format=33779;var RGB_PVRTC_4BPPV1_Format=35840;var RGB_PVRTC_2BPPV1_Format=35841;var RGBA_PVRTC_4BPPV1_Format=35842;var RGBA_PVRTC_2BPPV1_Format=35843;var RGB_ETC1_Format=36196;var RGBA_ASTC_4x4_Format=37808;var RGBA_ASTC_5x4_Format=37809;var RGBA_ASTC_5x5_Format=37810;var RGBA_ASTC_6x5_Format=37811;var RGBA_ASTC_6x6_Format=37812;var RGBA_ASTC_8x5_Format=37813;var RGBA_ASTC_8x6_Format=37814;var RGBA_ASTC_8x8_Format=37815;var RGBA_ASTC_10x5_Format=37816;var RGBA_ASTC_10x6_Format=37817;var RGBA_ASTC_10x8_Format=37818;var RGBA_ASTC_10x10_Format=37819;var RGBA_ASTC_12x10_Format=37820;var RGBA_ASTC_12x12_Format=37821;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */var _Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  var lut=[];for(var i=0;i<256;i++){lut[i]=(i<16?'0':'')+i.toString(16);}return function generateUUID(){var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;var uuid=lut[d0&0xff]+lut[d0>>8&0xff]+lut[d0>>16&0xff]+lut[d0>>24&0xff]+'-'+lut[d1&0xff]+lut[d1>>8&0xff]+'-'+lut[d1>>16&0x0f|0x40]+lut[d1>>24&0xff]+'-'+lut[d2&0x3f|0x80]+lut[d2>>8&0xff]+'-'+lut[d2>>16&0xff]+lut[d2>>24&0xff]+lut[d3&0xff]+lut[d3>>8&0xff]+lut[d3>>16&0xff]+lut[d3>>24&0xff];// .toUpperCase() here flattens concatenated strings to save heap memory space.
  return uuid.toUpperCase();};}(),clamp:function(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo:function(n,m){return (n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear:function(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
  lerp:function(x,y,t){return (1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
  smoothstep:function(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
  randInt:function(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
  randFloat:function(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
  randFloatSpread:function(range){return range*(0.5-Math.random());},degToRad:function(degrees){return degrees*_Math.DEG2RAD;},radToDeg:function(radians){return radians*_Math.RAD2DEG;},isPowerOfTwo:function(value){return (value&value-1)===0&&value!==0;},ceilPowerOfTwo:function(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));},floorPowerOfTwo:function(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}};/**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */function Vector2(x,y){this.x=x||0;this.y=y||0;}Object.defineProperties(Vector2.prototype,{"width":{get:function(){return this.x;},set:function(value){this.x=value;}},"height":{get:function(){return this.y;},set:function(value){this.y=value;}}});Object.assign(Vector2.prototype,{isVector2:true,set:function(x,y){this.x=x;this.y=y;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y);},copy:function(v){this.x=v.x;this.y=v.y;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function(s){this.x+=s;this.y+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function(s){this.x-=s;this.y-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;return this;},divide:function(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},applyMatrix3:function(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function(){var min=new Vector2();var max=new Vector2();return function clampScalar(minVal,maxVal){min.set(minVal,minVal);max.set(maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function(){this.x=-this.x;this.y=-this.y;return this;},dot:function(v){return this.x*v.x+this.y*v.y;},lengthSq:function(){return this.x*this.x+this.y*this.y;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y);},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function(){return this.divideScalar(this.length()||1);},angle:function(){// computes the angle in radians with respect to the positive x-axis
  var angle=Math.atan2(this.y,this.x);if(angle<0)angle+=2*Math.PI;return angle;},distanceTo:function(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},manhattanDistanceTo:function(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function(length){return this.normalize().multiplyScalar(length);},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function(v){return v.x===this.x&&v.y===this.y;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix4.prototype,{isMatrix4:true,set:function(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function(){return new Matrix4().fromArray(this.elements);},copy:function(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;},copyPosition:function(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function(){var v1=new Vector3();return function extractRotation(m){var te=this.elements;var me=m.elements;var scaleX=1/v1.setFromMatrixColumn(m,0).length();var scaleY=1/v1.setFromMatrixColumn(m,1).length();var scaleZ=1/v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;return this;};}(),makeRotationFromEuler:function(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// last column
  te[3]=0;te[7]=0;te[11]=0;// bottom row
  te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function(q){var te=this.elements;var x=q._x,y=q._y,z=q._z,w=q._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;te[0]=1-(yy+zz);te[4]=xy-wz;te[8]=xz+wy;te[1]=xy+wz;te[5]=1-(xx+zz);te[9]=yz-wx;te[2]=xz-wy;te[6]=yz+wx;te[10]=1-(xx+yy);// last column
  te[3]=0;te[7]=0;te[11]=0;// bottom row
  te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},lookAt:function(){var x=new Vector3();var y=new Vector3();var z=new Vector3();return function lookAt(eye,target,up){var te=this.elements;z.subVectors(eye,target);if(z.lengthSq()===0){// eye and target are in the same position
  z.z=1;}z.normalize();x.crossVectors(up,z);if(x.lengthSq()===0){// up and z are parallel
  if(Math.abs(up.z)===1){z.x+=0.0001;}else{z.z+=0.0001;}z.normalize();x.crossVectors(up,z);}x.normalize();y.crossVectors(z,x);te[0]=x.x;te[4]=y.x;te[8]=z.x;te[1]=x.y;te[5]=y.y;te[9]=z.y;te[2]=x.z;te[6]=y.z;te[10]=z.z;return this;};}(),multiply:function(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyScalar:function(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix4(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),determinant:function(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
  //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
  return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function(v){var te=this.elements;te[12]=v.x;te[13]=v.y;te[14]=v.z;return this;},getInverse:function(m,throwOnDegenerate){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){var msg="THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
  var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function(x,y,z){this.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1);return this;},compose:function(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this;},decompose:function(){var vector=new Vector3();var matrix=new Matrix4();return function decompose(position,quaternion,scale){var te=this.elements;var sx=vector.set(te[0],te[1],te[2]).length();var sy=vector.set(te[4],te[5],te[6]).length();var sz=vector.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
  var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
  matrix.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix.elements[0]*=invSX;matrix.elements[1]*=invSX;matrix.elements[2]*=invSX;matrix.elements[4]*=invSY;matrix.elements[5]*=invSY;matrix.elements[6]*=invSY;matrix.elements[8]*=invSZ;matrix.elements[9]*=invSZ;matrix.elements[10]*=invSZ;quaternion.setFromRotationMatrix(matrix);scale.x=sx;scale.y=sy;scale.z=sz;return this;};}(),makePerspective:function(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}});/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}Object.assign(Quaternion,{slerp:function(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
  var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
  if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
  if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});Object.defineProperties(Quaternion.prototype,{x:{get:function(){return this._x;},set:function(value){this._x=value;this.onChangeCallback();}},y:{get:function(){return this._y;},set:function(value){this._y=value;this.onChangeCallback();}},z:{get:function(){return this._z;},set:function(value){this._z=value;this.onChangeCallback();}},w:{get:function(){return this._w;},set:function(value){this._w=value;this.onChangeCallback();}}});Object.assign(Quaternion.prototype,{set:function(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this.onChangeCallback();return this;},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this.onChangeCallback();return this;},setFromEuler:function(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler.order;// http://www.mathworks.com/matlabcentral/fileexchange/
  // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  //	content/SpinCalc.m
  var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this.onChangeCallback();return this;},setFromAxisAngle:function(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
  // assumes axis is normalized
  var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this.onChangeCallback();return this;},setFromRotationMatrix:function(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this.onChangeCallback();return this;},setFromUnitVectors:function(){// assumes direction vectors vFrom and vTo are normalized
  var v1=new Vector3();var r;var EPS=0.000001;return function setFromUnitVectors(vFrom,vTo){if(v1===undefined)v1=new Vector3();r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){v1.set(-vFrom.y,vFrom.x,0);}else{v1.set(0,-vFrom.z,vFrom.y);}}else{v1.crossVectors(vFrom,vTo);}this._x=v1.x;this._y=v1.y;this._z=v1.z;this._w=r;return this.normalize();};}(),inverse:function(){// quaternion is assumed to have unit length
  return this.conjugate();},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this;},dot:function(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this.onChangeCallback();return this;},multiply:function(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
  var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this.onChangeCallback();return this;},slerp:function(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
  var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<0.001){this._w=0.5*(w+this._w);this._x=0.5*(x+this._x);this._y=0.5*(y+this._y);this._z=0.5*(z+this._z);return this;}var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this.onChangeCallback();return this;},equals:function(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this.onChangeCallback();return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},onChange:function(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function(){}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}Object.assign(Vector3.prototype,{isVector3:true,set:function(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setZ:function(z){this.z=z;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y,this.z);},copy:function(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function(){var quaternion=new Quaternion();return function applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(quaternion.setFromEuler(euler));};}(),applyAxisAngle:function(){var quaternion=new Quaternion();return function applyAxisAngle(axis,angle){return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));};}(),applyMatrix3:function(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyMatrix4:function(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;},applyQuaternion:function(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
  var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
  this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function(){var matrix=new Matrix4();return function project(camera){matrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));return this.applyMatrix4(matrix);};}(),unproject:function(){var matrix=new Matrix4();return function unproject(camera){matrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));return this.applyMatrix4(matrix);};}(),transformDirection:function(m){// input: THREE.Matrix4 affine matrix
  // vector interpreted as a direction
  var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function(){var min=new Vector3();var max=new Vector3();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function(v){return this.x*v.x+this.y*v.y+this.z*v.z;},// TODO lengthSquared?
  lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function(){return this.divideScalar(this.length()||1);},setLength:function(length){return this.normalize().multiplyScalar(length);},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}return this.crossVectors(this,v);},crossVectors:function(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function(vector){var scalar=vector.dot(this)/vector.lengthSq();return this.copy(vector).multiplyScalar(scalar);},projectOnPlane:function(){var v1=new Vector3();return function projectOnPlane(planeNormal){v1.copy(this).projectOnVector(planeNormal);return this.sub(v1);};}(),reflect:function(){// reflect incident vector off plane orthogonal to normal
  // normal is assumed to have unit length
  var v1=new Vector3();return function reflect(normal){return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));};}(),angleTo:function(v){var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());// clamp, to handle numerical problems
  return Math.acos(_Math.clamp(theta,-1,1));},distanceTo:function(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},manhattanDistanceTo:function(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function(s){var sinPhiRadius=Math.sin(s.phi)*s.radius;this.x=sinPhiRadius*Math.sin(s.theta);this.y=Math.cos(s.phi)*s.radius;this.z=sinPhiRadius*Math.cos(s.theta);return this;},setFromCylindrical:function(c){this.x=c.radius*Math.sin(c.theta);this.y=c.y;this.z=c.radius*Math.cos(c.theta);return this;},setFromMatrixPosition:function(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;},setFromMatrixScale:function(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function(m,index){return this.fromArray(m.elements,index*4);},equals:function(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}});/**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix3.prototype,{isMatrix3:true,set:function(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function(){return new this.constructor().fromArray(this.elements);},copy:function(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;},setFromMatrix4:function(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix3(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),multiply:function(m){return this.multiplyMatrices(this,m);},premultiply:function(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;},multiplyScalar:function(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function(matrix,throwOnDegenerate){if(matrix&&matrix.isMatrix4){console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){var msg="THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},setUvTransform:function(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);},scale:function(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;},rotate:function(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;},translate:function(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;},equals:function(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){Object.defineProperty(this,'id',{value:textureId++});this.uuid=_Math.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Texture,isTexture:true,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}function getDataURL(image){var canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else{canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=image.width;canvas.height=image.height;var context=canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else{context.drawImage(image,0,0,image.width,image.height);}}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(this.image!==undefined){// TODO: Move to THREE.Image
  var image=this.image;if(image.uuid===undefined){image.uuid=_Math.generateUUID();// UGH
  }if(!isRootObject&&meta.images[image.uuid]===undefined){meta.images[image.uuid]={uuid:image.uuid,url:getDataURL(image)};}output.image=image.uuid;}if(!isRootObject){meta.textures[this.uuid]=output;}return output;},dispose:function(){this.dispatchEvent({type:'dispose'});},transformUv:function(uv){if(this.mapping!==UVMapping)return;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}}});Object.defineProperty(Texture.prototype,"needsUpdate",{set:function(value){if(value===true)this.version++;}});/**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}Object.assign(Vector4.prototype,{isVector4:true,set:function(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function(x){this.x=x;return this;},setY:function(y){this.y=y;return this;},setZ:function(z){this.z=z;return this;},setW:function(w){this.w=w;return this;},setComponent:function(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;},applyMatrix4:function(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
  // q is assumed to be normalized
  this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
  // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var angle,x,y,z,// variables for result
  epsilon=0.01,// margin to allow for rounding errors
  epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
  te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
  // first check for identity matrix which must have +1 for all terms
  // in leading diagonal and zero in other terms
  if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
  this.set(1,0,0,0);return this;// zero angle, arbitrary axis
  }// otherwise this singularity is angle = 180
  angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
  if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
  if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
  if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
  }// as we have reached here there are no singularities so we can handle normally
  var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
  if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
  // caught by singularity test above, but I've left it in just in case
  this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function(min,max){// assumes min < max, componentwise
  this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function(){var min,max;return function clampScalar(minVal,maxVal){if(min===undefined){min=new Vector4();max=new Vector4();}min.set(minVal,minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function(){return this.divideScalar(this.length()||1);},setLength:function(length){return this.normalize().multiplyScalar(length);},lerp:function(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}});/**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */ /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */function WebGLRenderTarget(width,height,options){this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};if(options.minFilter===undefined)options.minFilter=LinearFilter;this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}WebGLRenderTarget.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:WebGLRenderTarget,isWebGLRenderTarget:true,setSize:function(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
   * @author alteredq / http://alteredqualia.com
   */function WebGLRenderTargetCube(width,height,options){WebGLRenderTarget.call(this,width,height,options);this.activeCubeFace=0;// PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
  this.activeMipMapLevel=0;}WebGLRenderTargetCube.prototype=Object.create(WebGLRenderTarget.prototype);WebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;/**
   * @author alteredq / http://alteredqualia.com/
   */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}DataTexture.prototype=Object.create(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}Object.assign(Box3.prototype,{isBox3:true,set:function(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromBufferAttribute:function(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromPoints:function(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector3();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),setFromObject:function(object){this.makeEmpty();return this.expandByObject(object);},clone:function(){return new this.constructor().copy(this);},copy:function(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function(target){if(target===undefined){console.warn('THREE.Box3: .getCenter() target is now required');target=new Vector3();}return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function(target){if(target===undefined){console.warn('THREE.Box3: .getSize() target is now required');target=new Vector3();}return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);},expandByPoint:function(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},expandByObject:function(){// Computes the world-axis-aligned bounding box of an object (including its children),
  // accounting for both the object's, and children's, world transforms
  var scope,i,l;var v1=new Vector3();function traverse(node){var geometry=node.geometry;if(geometry!==undefined){if(geometry.isGeometry){var vertices=geometry.vertices;for(i=0,l=vertices.length;i<l;i++){v1.copy(vertices[i]);v1.applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}else if(geometry.isBufferGeometry){var attribute=geometry.attributes.position;if(attribute!==undefined){for(i=0,l=attribute.count;i<l;i++){v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}}}}return function expandByObject(object){scope=this;object.updateMatrixWorld(true);object.traverse(traverse);return this;};}(),containsPoint:function(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  if(target===undefined){console.warn('THREE.Box3: .getParameter() target is now required');target=new Vector3();}return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function(box){// using 6 splitting planes to rule out intersections.
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function(){var closestPoint=new Vector3();return function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
  this.clampPoint(sphere.center,closestPoint);// If that point is inside the sphere, the AABB and sphere intersect.
  return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;};}(),intersectsPlane:function(plane){// We compute the minimum and maximum dot product values. If those values
  // are on the same side (back or front) of the plane, then there is no intersection.
  var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=plane.constant&&max>=plane.constant;},intersectsTriangle:function(){// triangle centered vertices
  var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();// triangle edge vectors
  var f0=new Vector3();var f1=new Vector3();var f2=new Vector3();var testAxis=new Vector3();var center=new Vector3();var extents=new Vector3();var triangleNormal=new Vector3();function satForAxes(axes){var i,j;for(i=0,j=axes.length-3;i<=j;i+=3){testAxis.fromArray(axes,i);// project the aabb onto the seperating axis
  var r=extents.x*Math.abs(testAxis.x)+extents.y*Math.abs(testAxis.y)+extents.z*Math.abs(testAxis.z);// project all 3 vertices of the triangle onto the seperating axis
  var p0=v0.dot(testAxis);var p1=v1.dot(testAxis);var p2=v2.dot(testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
  if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
  // the axis is seperating and we can exit
  return false;}}return true;}return function intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
  this.getCenter(center);extents.subVectors(this.max,center);// translate triangle to aabb origin
  v0.subVectors(triangle.a,center);v1.subVectors(triangle.b,center);v2.subVectors(triangle.c,center);// compute edge vectors for triangle
  f0.subVectors(v1,v0);f1.subVectors(v2,v1);f2.subVectors(v0,v2);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
  // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
  // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
  var axes=[0,-f0.z,f0.y,0,-f1.z,f1.y,0,-f2.z,f2.y,f0.z,0,-f0.x,f1.z,0,-f1.x,f2.z,0,-f2.x,-f0.y,f0.x,0,-f1.y,f1.x,0,-f2.y,f2.x,0];if(!satForAxes(axes)){return false;}// test 3 face normals from the aabb
  axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes)){return false;}// finally testing the face normal of the triangle
  // use already existing triangle edge vectors here
  triangleNormal.crossVectors(f0,f1);axes=[triangleNormal.x,triangleNormal.y,triangleNormal.z];return satForAxes(axes);};}(),clampPoint:function(point,target){if(target===undefined){console.warn('THREE.Box3: .clampPoint() target is now required');target=new Vector3();}return target.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector3();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),getBoundingSphere:function(){var v1=new Vector3();return function getBoundingSphere(target){if(target===undefined){console.warn('THREE.Box3: .getBoundingSphere() target is now required');target=new Sphere();}this.getCenter(target.center);target.radius=this.getSize(v1).length()*0.5;return target;};}(),intersect:function(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  if(this.isEmpty())this.makeEmpty();return this;},union:function(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function(){var points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];return function applyMatrix4(matrix){// transform of empty box is an empty box.
  if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
  points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
  points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
  points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
  points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
  points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
  points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
  points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
  this.setFromPoints(points);return this;};}(),translate:function(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}Object.assign(Sphere.prototype,{set:function(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function(){var box=new Box3();return function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{box.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function(){return this.radius<=0;},containsPoint:function(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function(box){return box.intersectsSphere(this);},intersectsPlane:function(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;},clampPoint:function(point,target){var deltaLengthSq=this.center.distanceToSquared(point);if(target===undefined){console.warn('THREE.Sphere: .clampPoint() target is now required');target=new Vector3();}target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;},getBoundingBox:function(target){if(target===undefined){console.warn('THREE.Sphere: .getBoundingBox() target is now required');target=new Box3();}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;},applyMatrix4:function(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function(offset){this.center.add(offset);return this;},equals:function(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}});/**
   * @author bhouston / http://clara.io
   */function Plane(normal,constant){// normal is assumed to be normalized
  this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}Object.assign(Plane.prototype,{set:function(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;},setFromCoplanarPoints:function(){var v1=new Vector3();var v2=new Vector3();return function setFromCoplanarPoints(a,b,c){var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
  this.setFromNormalAndCoplanarPoint(normal,a);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function(){// Note: will lead to a divide by zero if the plane is invalid.
  var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function(point,target){if(target===undefined){console.warn('THREE.Plane: .projectPoint() target is now required');target=new Vector3();}return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);},intersectLine:function(){var v1=new Vector3();return function intersectLine(line,target){if(target===undefined){console.warn('THREE.Plane: .intersectLine() target is now required');target=new Vector3();}var direction=line.delta(v1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
  if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
  return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return target.copy(direction).multiplyScalar(t).add(line.start);};}(),intersectsLine:function(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
  var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function(box){return box.intersectsPlane(this);},intersectsSphere:function(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function(target){if(target===undefined){console.warn('THREE.Plane: .coplanarPoint() target is now required');target=new Vector3();}return target.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function(){var v1=new Vector3();var m1=new Matrix3();return function applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;};}(),translate:function(offset){this.constant-=offset.dot(this.normal);return this;},equals:function(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}Object.assign(Frustum.prototype,{set:function(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromMatrix:function(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function(){var sphere=new Sphere();return function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSprite:function(){var sphere=new Sphere();return function intersectsSprite(sprite){sphere.center.set(0,0,0);sphere.radius=0.7071067811865476;sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSphere:function(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function(){var p1=new Vector3(),p2=new Vector3();return function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];p1.x=plane.normal.x>0?box.min.x:box.max.x;p2.x=plane.normal.x>0?box.max.x:box.min.x;p1.y=plane.normal.y>0?box.min.y:box.max.y;p2.y=plane.normal.y>0?box.max.y:box.min.y;p1.z=plane.normal.z>0?box.min.z:box.max.z;p2.z=plane.normal.z>0?box.max.z:box.min.z;var d1=plane.distanceToPoint(p1);var d2=plane.distanceToPoint(p2);// if both outside plane, no intersection
  if(d1<0&&d2<0){return false;}}return true;};}(),containsPoint:function(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}});var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="\nvec3 transformed = vec3( position );\n";var beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";var bsdfs="float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var defaultnormal_vertex="vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";var encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var fog_vertex="\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var lights_pars_begin="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";var lights_pars_maps="#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";var map_particle_fragment="#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var normal_fragment_begin="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";var normal_fragment_maps="#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\t\tscale *= float( gl_FrontFacing ) * 2.0 - 1.0;\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var project_vertex="vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";var dithering_fragment="#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";var dithering_pars_fragment="#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var tonemapping_pars_fragment="#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var cube_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var distanceRGBA_frag="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";var distanceRGBA_vert="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";var equirect_frag="uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var equirect_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var shadow_frag="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";var shadow_vert="#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars_begin:lights_pars_begin,lights_pars_maps:lights_pars_maps,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normalmap_pars_fragment:normalmap_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert};/**
   * Uniform Utilities
   */var UniformsUtils={merge:function(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=this.clone(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;},clone:function(uniforms_src){var uniforms_dst={};for(var u in uniforms_src){uniforms_dst[u]={};for(var p in uniforms_src[u]){var parameter_src=uniforms_src[u][p];if(parameter_src&&(parameter_src.isColor||parameter_src.isMatrix3||parameter_src.isMatrix4||parameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||parameter_src.isTexture)){uniforms_dst[u][p]=parameter_src.clone();}else if(Array.isArray(parameter_src)){uniforms_dst[u][p]=parameter_src.slice();}else{uniforms_dst[u][p]=parameter_src;}}}return uniforms_dst;}};/**
   * @author mrdoob / http://mrdoob.com/
   */var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
  return this.set(r);}return this.setRGB(r,g,b);}Object.assign(Color.prototype,{isColor:true,r:1,g:1,b:1,set:function(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function(){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}return function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
  h=_Math.euclideanModulo(h,1);s=_Math.clamp(s,0,1);l=_Math.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;};}(),setStyle:function(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
  var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
  this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
  var hex=m[1];var size=hex.length;if(size===3){// #ff0
  this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
  this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){// color keywords
  var hex=ColorKeywords[style];if(hex!==undefined){// red
  this.setHex(hex);}else{// unknown color
  console.warn('THREE.Color: Unknown color '+style);}}return this;},clone:function(){return new this.constructor(this.r,this.g,this.b);},copy:function(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function(){var r=this.r,g=this.g,b=this.b;this.r=r*r;this.g=g*g;this.b=b*b;return this;},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this;},getHex:function(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function(){return ('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function(target){// h,s,l ranges are in 0.0 - 1.0
  if(target===undefined){console.warn('THREE.Color: .getHSL() target is now required');target={h:0,s:0,l:0};}var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;},getStyle:function(){return 'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function(){var hsl={};return function(h,s,l){this.getHSL(hsl);hsl.h+=h;hsl.s+=s;hsl.l+=l;this.setHSL(hsl.h,hsl.s,hsl.l);return this;};}(),add:function(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},equals:function(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function(){return this.getHex();}});/**
   * Uniforms library for shared webgl shaders
   */var UniformsLib={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()}}};/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   */var ShaderLib={basic:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0.5},envMapIntensity:{value:1// temporary
  }}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},points:{uniforms:UniformsUtils.merge([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:UniformsUtils.merge([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:UniformsUtils.merge([ShaderLib.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLAttributes(gl){var buffers=new WeakMap();function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=gl.FLOAT;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}return {buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(attribute.dynamic===false){gl.bufferData(bufferType,array,gl.STATIC_DRAW);}else if(updateRange.count===-1){// Not using update ranges
  gl.bufferSubData(bufferType,0,array);}else if(updateRange.count===0){console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));updateRange.count=-1;// reset range
  }}//
  function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return {get:get,remove:remove,update:update};}/**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';Object.defineProperties(Euler.prototype,{x:{get:function(){return this._x;},set:function(value){this._x=value;this.onChangeCallback();}},y:{get:function(){return this._y;},set:function(value){this._y=value;this.onChangeCallback();}},z:{get:function(){return this._z;},set:function(value){this._z=value;this.onChangeCallback();}},order:{get:function(){return this._order;},set:function(value){this._order=value;this.onChangeCallback();}}});Object.assign(Euler.prototype,{isEuler:true,set:function(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this.onChangeCallback();return this;},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this.onChangeCallback();return this;},setFromRotationMatrix:function(m,order,update){var clamp=_Math.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this.onChangeCallback();return this;},setFromQuaternion:function(){var matrix=new Matrix4();return function setFromQuaternion(q,order,update){matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(matrix,order,update);};}(),setFromVector3:function(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function(){// WARNING: this discards revolution information -bhouston
  var q=new Quaternion();return function reorder(newOrder){q.setFromEuler(this);return this.setFromQuaternion(q,newOrder);};}(),equals:function(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this.onChangeCallback();return this;},toArray:function(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},onChange:function(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function(){}});/**
   * @author mrdoob / http://mrdoob.com/
   */function Layers(){this.mask=1|0;}Object.assign(Layers.prototype,{set:function(channel){this.mask=1<<channel|0;},enable:function(channel){this.mask|=1<<channel|0;},toggle:function(channel){this.mask^=1<<channel|0;},disable:function(channel){this.mask&=~(1<<channel|0);},test:function(layers){return (this.mask&layers.mask)!==0;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */var object3DId=0;function Object3D(){Object.defineProperty(this,'id',{value:object3DId++});this.uuid=_Math.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation.onChange(onRotationChange);quaternion.onChange(onQuaternionChange);Object.defineProperties(this,{position:{enumerable:true,value:position},rotation:{enumerable:true,value:rotation},quaternion:{enumerable:true,value:quaternion},scale:{enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Object3D,isObject3D:true,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix:function(matrix){this.matrix.multiplyMatrices(matrix,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);},applyQuaternion:function(q){this.quaternion.premultiply(q);return this;},setRotationFromAxisAngle:function(axis,angle){// assumes axis is normalized
  this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
  this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function(q){// assumes q is normalized
  this.quaternion.copy(q);},rotateOnAxis:function(){// rotate object on axis in object space
  // axis is assumed to be normalized
  var q1=new Quaternion();return function rotateOnAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(q1);return this;};}(),rotateOnWorldAxis:function(){// rotate object on axis in world space
  // axis is assumed to be normalized
  // method assumes no rotated parent
  var q1=new Quaternion();return function rotateOnWorldAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(q1);return this;};}(),rotateX:function(){var v1=new Vector3(1,0,0);return function rotateX(angle){return this.rotateOnAxis(v1,angle);};}(),rotateY:function(){var v1=new Vector3(0,1,0);return function rotateY(angle){return this.rotateOnAxis(v1,angle);};}(),rotateZ:function(){var v1=new Vector3(0,0,1);return function rotateZ(angle){return this.rotateOnAxis(v1,angle);};}(),translateOnAxis:function(){// translate object by distance along axis in object space
  // axis is assumed to be normalized
  var v1=new Vector3();return function translateOnAxis(axis,distance){v1.copy(axis).applyQuaternion(this.quaternion);this.position.add(v1.multiplyScalar(distance));return this;};}(),translateX:function(){var v1=new Vector3(1,0,0);return function translateX(distance){return this.translateOnAxis(v1,distance);};}(),translateY:function(){var v1=new Vector3(0,1,0);return function translateY(distance){return this.translateOnAxis(v1,distance);};}(),translateZ:function(){var v1=new Vector3(0,0,1);return function translateZ(distance){return this.translateOnAxis(v1,distance);};}(),localToWorld:function(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function(){var m1=new Matrix4();return function worldToLocal(vector){return vector.applyMatrix4(m1.getInverse(this.matrixWorld));};}(),lookAt:function(){// This method does not support objects with rotated and/or translated parent(s)
  var m1=new Matrix4();var vector=new Vector3();return function lookAt(x,y,z){if(x.isVector3){vector.copy(x);}else{vector.set(x,y,z);}if(this.isCamera){m1.lookAt(this.position,vector,this.up);}else{m1.lookAt(vector,this.position,this.up);}this.quaternion.setFromRotationMatrix(m1);};}(),add:function(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;object.dispatchEvent({type:'added'});this.children.push(object);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;object.dispatchEvent({type:'removed'});this.children.splice(index,1);}return this;},getObjectById:function(id){return this.getObjectByProperty('id',id);},getObjectByName:function(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldPosition() target is now required');target=new Vector3();}this.updateMatrixWorld(true);return target.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function(){var position=new Vector3();var scale=new Vector3();return function getWorldQuaternion(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');target=new Quaternion();}this.updateMatrixWorld(true);this.matrixWorld.decompose(position,target,scale);return target;};}(),getWorldScale:function(){var position=new Vector3();var quaternion=new Quaternion();return function getWorldScale(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldScale() target is now required');target=new Vector3();}this.updateMatrixWorld(true);this.matrixWorld.decompose(position,quaternion,target);return target;};}(),getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldDirection() target is now required');target=new Vector3();}this.getWorldQuaternion(quaternion);return target.set(0,0,1).applyQuaternion(quaternion);};}(),raycast:function(){},traverse:function(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
  var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},toJSON:function(meta){// meta is a string when called from JSON.stringify
  var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
  // not providing it implies that this is the root object
  // being serialized.
  if(isRootObject){// initialize meta obj
  meta={geometries:{},materials:{},textures:{},images:{},shapes:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
  var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;//
  function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.geometry!==undefined){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){var shapes=parameters.shapes;if(Array.isArray(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];serialize(meta.shapes,shape);}}else{serialize(meta.shapes,shapes);}}}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
  if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);var shapes=extractFromCache(meta.shapes);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(shapes.length>0)output.shapes=shapes;}output.object=object;return output;// extract data from the cache hash
  // remove metadata on each item
  // and return as array
  function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function(recursive){return new this.constructor().copy(this,recursive);},copy:function(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
  */function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();}Camera.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:true,copy:function(source,recursive){Object3D.prototype.copy.call(this,source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);return this;},getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(target){if(target===undefined){console.warn('THREE.Camera: .getWorldDirection() target is now required');target=new Vector3();}this.getWorldQuaternion(quaternion);return target.set(0,0,-1).applyQuaternion(quaternion);};}(),updateMatrixWorld:function(force){Object3D.prototype.updateMatrixWorld.call(this,force);this.matrixWorldInverse.getInverse(this.matrixWorld);},clone:function(){return new this.constructor().copy(this);}});/**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;},setViewOffset:function(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var zoomW=this.zoom/(this.view.width/this.view.fullWidth);var zoomH=this.zoom/(this.view.height/this.view.fullHeight);var scaleW=(this.right-this.left)/this.view.width;var scaleH=(this.top-this.bottom)/this.view.height;left+=scaleW*(this.view.offsetX/zoomW);right=left+scaleW*(this.view.width/zoomW);top-=scaleH*(this.view.offsetY/zoomH);bottom=top-scaleH*(this.view.height/zoomH);}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}Object.assign(Face3.prototype,{clone:function(){return new this.constructor().copy(this);},copy:function(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */var geometryId=0;// Geometry uses even numbers as Id
  function Geometry(){Object.defineProperty(this,'id',{value:geometryId+=2});this.uuid=_Math.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
  this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}Geometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Geometry,isGeometry:true,applyMatrix:function(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function(){// rotate geometry around world x-axis
  var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
  var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
  var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
  var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
  var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),fromBufferGeometry:function(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];var tempNormals=[];var tempUVs=[];var tempUVs2=[];for(var i=0,j=0;i<positions.length;i+=3,j+=2){scope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));if(normals!==undefined){tempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));}if(colors!==undefined){scope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));}if(uvs!==undefined){tempUVs.push(new Vector2(uvs[j],uvs[j+1]));}if(uvs2!==undefined){tempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));}}function addFace(a,b,c,materialIndex){var vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];var vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);}}var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){if(indices!==undefined){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}else{addFace(j,j+1,j+2,group.materialIndex);}}}}else{if(indices!==undefined){for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function(){var offset=new Vector3();return function center(){this.computeBoundingBox();this.boundingBox.getCenter(offset).negate();this.translate(offset.x,offset.y,offset.z);return this;};}(),normalize:function(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix(matrix);return this;},computeFaceNormals:function(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
  // http://www.iquilezles.org/www/articles/normals/normals.htm
  var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function(){var i,il,f,fl,face;// save original normals
  // - create temp variables on first access
  //   otherwise just copy (for faster repeated calls)
  for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
  var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
  if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
  tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
  tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
  var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
  for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeBoundingBox:function(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function(geometry,matrix,materialIndexOffset){if(!(geometry&&geometry.isGeometry)){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,uvs1=this.faceVertexUvs[0],uvs2=geometry.faceVertexUvs[0],colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
  for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
  for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
  for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
  for(i=0,il=uvs2.length;i<il;i++){var uv=uvs2[i],uvCopy=[];if(uv===undefined){continue;}for(var j=0,jl=uv.length;j<jl;j++){uvCopy.push(uv[j].clone());}uvs1.push(uvCopy);}},mergeMesh:function(mesh){if(!(mesh&&mesh.isMesh)){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}if(mesh.matrixAutoUpdate)mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
  	 * Checks for duplicate vertices with hashmap.
  	 * Duplicated vertices are removed
  	 * and faces' vertices are updated.
  	 */mergeVertices:function(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
  var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
  // have to remove them from the geometry.
  var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
  // we have to remove the face as nothing can be saved
  for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
  var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},setFromPoints:function(points){this.vertices=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];this.vertices.push(new Vector3(point.x,point.y,point.z||0));}return this;},sortFacesByMaterialIndex:function(){var faces=this.faces;var length=faces.length;// tag faces
  for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
  function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
  var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function(){var data={metadata:{version:4.5,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
  var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
  faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
  data.data.faces=faces;return data;},clone:function(){/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */return new Geometry().copy(this);},copy:function(source){var i,il,j,jl,k,kl;// reset
  this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// name
  this.name=source.name;// vertices
  var vertices=source.vertices;for(i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}// colors
  var colors=source.colors;for(i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}// faces
  var faces=source.faces;for(i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}// face vertex uvs
  for(i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}// morph targets
  var morphTargets=source.morphTargets;for(i=0,il=morphTargets.length;i<il;i++){var morphTarget={};morphTarget.name=morphTargets[i].name;// vertices
  if(morphTargets[i].vertices!==undefined){morphTarget.vertices=[];for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){morphTarget.vertices.push(morphTargets[i].vertices[j].clone());}}// normals
  if(morphTargets[i].normals!==undefined){morphTarget.normals=[];for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){morphTarget.normals.push(morphTargets[i].normals[j].clone());}}this.morphTargets.push(morphTarget);}// morph normals
  var morphNormals=source.morphNormals;for(i=0,il=morphNormals.length;i<il;i++){var morphNormal={};// vertex normals
  if(morphNormals[i].vertexNormals!==undefined){morphNormal.vertexNormals=[];for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){var srcVertexNormal=morphNormals[i].vertexNormals[j];var destVertexNormal={};destVertexNormal.a=srcVertexNormal.a.clone();destVertexNormal.b=srcVertexNormal.b.clone();destVertexNormal.c=srcVertexNormal.c.clone();morphNormal.vertexNormals.push(destVertexNormal);}}// face normals
  if(morphNormals[i].faceNormals!==undefined){morphNormal.faceNormals=[];for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());}}this.morphNormals.push(morphNormal);}// skin weights
  var skinWeights=source.skinWeights;for(i=0,il=skinWeights.length;i<il;i++){this.skinWeights.push(skinWeights[i].clone());}// skin indices
  var skinIndices=source.skinIndices;for(i=0,il=skinIndices.length;i<il;i++){this.skinIndices.push(skinIndices[i].clone());}// line distances
  var lineDistances=source.lineDistances;for(i=0,il=lineDistances.length;i<il;i++){this.lineDistances.push(lineDistances[i]);}// bounding box
  var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
  var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// update flags
  this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=source.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
   * @author mrdoob / http://mrdoob.com/
   */function BufferAttribute(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.dynamic=false;this.updateRange={offset:0,count:-1};this.version=0;}Object.defineProperty(BufferAttribute.prototype,'needsUpdate',{set:function(value){if(value===true)this.version++;}});Object.assign(BufferAttribute.prototype,{isBufferAttribute:true,onUploadCallback:function(){},setArray:function(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.itemSize:0;this.array=array;return this;},setDynamic:function(value){this.dynamic=value;return this;},copy:function(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.dynamic=source.dynamic;return this;},copyAt:function(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function(array){this.array.set(array);return this;},copyColorsArray:function(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyVector2sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},set:function(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function(index){return this.array[index*this.itemSize];},setX:function(index,x){this.array[index*this.itemSize]=x;return this;},getY:function(index){return this.array[index*this.itemSize+1];},setY:function(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function(index){return this.array[index*this.itemSize+2];},setZ:function(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function(index){return this.array[index*this.itemSize+3];},setW:function(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function(callback){this.onUploadCallback=callback;return this;},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this);}});//
  function Int8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int8Array(array),itemSize,normalized);}Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8Array(array),itemSize,normalized);}Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize,normalized);}Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int16Array(array),itemSize,normalized);}Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint16Array(array),itemSize,normalized);}Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int32Array(array),itemSize,normalized);}Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint32Array(array),itemSize,normalized);}Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float32Array(array),itemSize,normalized);}Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float64Array(array),itemSize,normalized);}Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
   * @author mrdoob / http://mrdoob.com/
   */function DirectGeometry(){this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
  this.boundingBox=null;this.boundingSphere=null;// update flags
  this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}Object.assign(DirectGeometry.prototype,{computeGroups:function(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
  if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
  var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]=[];}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]=[];}this.morphTargets.normal=morphTargetsNormal;}// skins
  var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
  for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
  for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
  if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function arrayMax(array){if(array.length===0)return -Infinity;var max=array[0];for(var i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */var bufferGeometryId=1;// BufferGeometry uses odd numbers as Id
  function BufferGeometry(){Object.defineProperty(this,'id',{value:bufferGeometryId+=2});this.uuid=_Math.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};}BufferGeometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:BufferGeometry,isBufferGeometry:true,getIndex:function(){return this.index;},setIndex:function(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}},addAttribute:function(name,attribute){if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));return;}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return;}this.attributes[name]=attribute;return this;},getAttribute:function(name){return this.attributes[name];},removeAttribute:function(name){delete this.attributes[name];return this;},addGroup:function(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function(){this.groups=[];},setDrawRange:function(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix:function(matrix){var position=this.attributes.position;if(position!==undefined){matrix.applyToBufferAttribute(position);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normalMatrix.applyToBufferAttribute(normal);normal.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function(){// rotate geometry around world x-axis
  var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
  var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
  var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
  var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
  var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),center:function(){var offset=new Vector3();return function center(){this.computeBoundingBox();this.boundingBox.getCenter(offset).negate();this.translate(offset.x,offset.y,offset.z);return this;};}(),setFromObject:function(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
  var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));this.addAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},setFromPoints:function(points){var position=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];position.push(point.x,point.y,point.z||0);}this.addAttribute('position',new Float32BufferAttribute(position,3));return this;},updateFromObject:function(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}// groups
  this.groups=geometry.groups;// morphs
  for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.length*3,3);array.push(attribute.copyVector3sArray(morphTarget));}this.morphAttributes[name]=array;}// skinning
  if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
  if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function(){var box=new Box3();var vector=new Vector3();return function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;if(position){var center=this.boundingSphere.center;box.setFromBufferAttribute(position);box.getCenter(center);// hoping to find a boundingSphere with a radius smaller than the
  // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
  var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){vector.x=position.getX(i);vector.y=position.getY(i);vector.z=position.getZ(i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}};}(),computeFaceNormals:function(){// backwards compatibility
  },computeVertexNormals:function(){var index=this.index;var attributes=this.attributes;var groups=this.groups;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
  var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
  if(index){var indices=index.array;if(groups.length===0){this.addGroup(0,indices.length);}for(var j=0,jl=groups.length;j<jl;++j){var group=groups[j];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}}else{// non-indexed elements (unconnected triangle soup)
  for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined){offset=0;console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');}var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeSize=attribute2.itemSize;for(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function(){var vector=new Vector3();return function normalizeNormals(){var normals=this.attributes.normal;for(var i=0,il=normals.count;i<il;i++){vector.x=normals.getX(i);vector.y=normals.getY(i);vector.z=normals.getZ(i);vector.normalize();normals.setXYZ(i,vector.x,vector.y,vector.z);}};}(),toNonIndexed:function(){if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;for(var name in attributes){var attribute=attributes[name];var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}geometry2.addAttribute(name,new BufferAttribute(array2,itemSize));}var groups=this.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;},toJSON:function(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){var array=Array.prototype.slice.call(index.array);data.data.index={type:index.array.constructor.name,array:array};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var array=Array.prototype.slice.call(attribute.array);data.data.attributes[key]={itemSize:attribute.itemSize,type:attribute.array.constructor.name,array:array,normalized:attribute.normalized};}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function(){/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */return new BufferGeometry().copy(this);},copy:function(source){var name,i,l;// reset
  this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
  this.name=source.name;// index
  var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
  var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}// morph attributes
  var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
  for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}// groups
  var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
  var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
  var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
  this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */ // BoxGeometry
  function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){Geometry.call(this);this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};this.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));this.mergeVertices();}BoxGeometry.prototype=Object.create(Geometry.prototype);BoxGeometry.prototype.constructor=BoxGeometry;// BoxBufferGeometry
  function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){BufferGeometry.call(this);this.type='BoxBufferGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;width=width||1;height=height||1;depth=depth||1;// segments
  widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
  buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
  buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
  buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
  buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
  buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
  buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
  // build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var ix,iy;var vector=new Vector3();// generate vertices, normals and uvs
  for(iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
  vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
  vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
  vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
  normals.push(vector.x,vector.y,vector.z);// uvs
  uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
  vertexCounter+=1;}}// indices
  // 1. you need three indices to draw a single face
  // 2. a single segment consists of two faces
  // 3. so we need to generate six (2*3) indices per segment
  for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// faces
  indices.push(a,b,d);indices.push(b,c,d);// increase counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
  groupStart+=groupCount;// update total number of vertices
  numberOfVertices+=vertexCounter;}}BoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */ // PlaneGeometry
  function PlaneGeometry(width,height,widthSegments,heightSegments){Geometry.call(this);this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));this.mergeVertices();}PlaneGeometry.prototype=Object.create(Geometry.prototype);PlaneGeometry.prototype.constructor=PlaneGeometry;// PlaneBufferGeometry
  function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};width=width||1;height=height||1;var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var ix,iy;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
  for(iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}// indices
  for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */var materialId=0;function Material(){Object.defineProperty(this,'id',{value:materialId++});this.uuid=_Math.generateUUID();this.name='';this.type='Material';this.fog=true;this.lights=true;this.blending=NormalBlending;this.side=FrontSide;this.flatShading=false;this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors
  this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
  this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.premultipliedAlpha=false;this.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
  this.visible=true;this.userData={};this.needsUpdate=true;}Material.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:Material,isMaterial:true,onBeforeCompile:function(){},setValues:function(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue;}// for backward compatability if shading is set in the constructor
  if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else if(key==='overdraw'){// ensure overdraw is backwards-compatible with legacy boolean type
  this[key]=Number(newValue);}else{this[key]=newValue;}}},toJSON:function(meta){var isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
  data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
  }if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;// rotation (SpriteMaterial)
  if(this.rotation!==0)data.rotation=this.rotation;if(this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.morphTargets===true)data.morphTargets=true;if(this.skinning===true)data.skinning=true;if(this.visible===false)data.visible=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
  function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.name=source.name;this.fog=source.fog;this.lights=source.lights;this.blending=source.blending;this.side=source.side;this.flatShading=source.flatShading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.overdraw=source.overdraw;this.visible=source.visible;this.userData=JSON.parse(JSON.stringify(source.userData));this.clipShadows=source.clipShadows;this.clipIntersection=source.clipIntersection;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i)dstPlanes[i]=srcPlanes[i].clone();}this.clippingPlanes=dstPlanes;this.shadowSide=source.shadowSide;return this;},dispose:function(){this.dispatchEvent({type:'dispose'});}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
  this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.lights=false;this.setValues(parameters);}MeshBasicMaterial.prototype=Object.create(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
  this.lights=false;// set to use scene lights
  this.clipping=false;// set to use user-defined clipping planes
  this.skinning=false;// set to use skinning attribute streams
  this.morphTargets=false;// set to use morph targets
  this.morphNormals=false;// set to use morph normals
  this.extensions={derivatives:false,// set to use derivatives
  fragDepth:false,// set to use fragment depth values
  drawBuffers:false,// set to use draw buffers
  shaderTextureLOD:false// set to use shader texture LOD
  };// When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;this.uniformsNeedUpdate=false;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=Object.create(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=UniformsUtils.clone(source.uniforms);this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms=this.uniforms;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;return data;};/**
   * @author bhouston / http://clara.io
   */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3();}Object.assign(Ray.prototype,{set:function(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function(t,target){if(target===undefined){console.warn('THREE.Ray: .at() target is now required');target=new Vector3();}return target.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function(){var v1=new Vector3();return function recast(t){this.origin.copy(this.at(t,v1));return this;};}(),closestPointToPoint:function(point,target){if(target===undefined){console.warn('THREE.Ray: .closestPointToPoint() target is now required');target=new Vector3();}target.subVectors(point,this.origin);var directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function(){var v1=new Vector3();return function distanceSqToPoint(point){var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);// point behind the ray
  if(directionDistance<0){return this.origin.distanceToSquared(point);}v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return v1.distanceToSquared(point);};}(),distanceSqToSegment:function(){var segCenter=new Vector3();var segDir=new Vector3();var diff=new Vector3();return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  // It returns the min distance between the ray and the segment
  // defined by v0 and v1
  // It can also set two optional targets :
  // - The closest point on the ray
  // - The closest point on the segment
  segCenter.copy(v0).add(v1).multiplyScalar(0.5);segDir.copy(v1).sub(v0).normalize();diff.copy(this.origin).sub(segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(segDir);var b0=diff.dot(this.direction);var b1=-diff.dot(segDir);var c=diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
  s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
  // Minimum at interior points of ray and segment.
  var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
  s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
  s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
  s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
  s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
  s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
  s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);}return sqrDist;};}(),intersectSphere:function(){var v1=new Vector3();return function intersectSphere(sphere,target){v1.subVectors(sphere.center,this.origin);var tca=v1.dot(this.direction);var d2=v1.dot(v1)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
  var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
  var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
  if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
  // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  // in order to always return an intersect point that is in front of the ray.
  if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
  return this.at(t0,target);};}(),intersectsSphere:function(sphere){return this.distanceToPoint(sphere.center)<=sphere.radius;},distanceToPlane:function(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
  if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
  return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
  return t>=0?t:null;},intersectPlane:function(plane,target){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);},intersectsPlane:function(plane){// check if the ray lies on the plane first
  var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
  return false;},intersectBox:function(box,target){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
  // (result of 0 * Infinity). x !== x returns true if x is NaN
  if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
  if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);},intersectsBox:function(){var v=new Vector3();return function intersectsBox(box){return this.intersectBox(box,v)!==null;};}(),intersectTriangle:function(){// Compute the offset origin, edges, and normal.
  var diff=new Vector3();var edge1=new Vector3();var edge2=new Vector3();var normal=new Vector3();return function intersectTriangle(a,b,c,backfaceCulling,target){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
  edge1.subVectors(b,a);edge2.subVectors(c,a);normal.crossVectors(edge1,edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  var DdN=this.direction.dot(normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));// b1 < 0, no intersection
  if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));// b2 < 0, no intersection
  if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
  if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
  var QdN=-sign*diff.dot(normal);// t < 0, no intersection
  if(QdN<0){return null;}// Ray intersects triangle.
  return this.at(QdN/DdN,target);};}(),applyMatrix4:function(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;},equals:function(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}});/**
   * @author bhouston / http://clara.io
   */function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}Object.assign(Line3.prototype,{set:function(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function(target){if(target===undefined){console.warn('THREE.Line3: .getCenter() target is now required');target=new Vector3();}return target.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function(target){if(target===undefined){console.warn('THREE.Line3: .delta() target is now required');target=new Vector3();}return target.subVectors(this.end,this.start);},distanceSq:function(){return this.start.distanceToSquared(this.end);},distance:function(){return this.start.distanceTo(this.end);},at:function(t,target){if(target===undefined){console.warn('THREE.Line3: .at() target is now required');target=new Vector3();}return this.delta(target).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function(){var startP=new Vector3();var startEnd=new Vector3();return function closestPointToPointParameter(point,clampToLine){startP.subVectors(point,this.start);startEnd.subVectors(this.end,this.start);var startEnd2=startEnd.dot(startEnd);var startEnd_startP=startEnd.dot(startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=_Math.clamp(t,0,1);}return t;};}(),closestPointToPoint:function(point,clampToLine,target){var t=this.closestPointToPointParameter(point,clampToLine);if(target===undefined){console.warn('THREE.Line3: .closestPointToPoint() target is now required');target=new Vector3();}return this.delta(target).multiplyScalar(t).add(this.start);},applyMatrix4:function(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function(line){return line.start.equals(this.start)&&line.end.equals(this.end);}});/**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}Object.assign(Triangle,{getNormal:function(){var v0=new Vector3();return function getNormal(a,b,c,target){if(target===undefined){console.warn('THREE.Triangle: .getNormal() target is now required');target=new Vector3();}target.subVectors(c,b);v0.subVectors(a,b);target.cross(v0);var targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);};}(),// static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord:function(){var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();return function getBarycoord(point,a,b,c,target){v0.subVectors(c,a);v1.subVectors(b,a);v2.subVectors(point,a);var dot00=v0.dot(v0);var dot01=v0.dot(v1);var dot02=v0.dot(v2);var dot11=v1.dot(v1);var dot12=v1.dot(v2);var denom=dot00*dot11-dot01*dot01;if(target===undefined){console.warn('THREE.Triangle: .getBarycoord() target is now required');target=new Vector3();}// collinear or singular triangle
  if(denom===0){// arbitrary location outside of triangle?
  // not sure if this is the best idea, maybe should be returning undefined
  return target.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
  return target.set(1-u-v,v,u);};}(),containsPoint:function(){var v1=new Vector3();return function containsPoint(point,a,b,c){Triangle.getBarycoord(point,a,b,c,v1);return v1.x>=0&&v1.y>=0&&v1.x+v1.y<=1;};}()});Object.assign(Triangle.prototype,{set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function(){return new this.constructor().copy(this);},copy:function(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},getArea:function(){var v0=new Vector3();var v1=new Vector3();return function getArea(){v0.subVectors(this.c,this.b);v1.subVectors(this.a,this.b);return v0.cross(v1).length()*0.5;};}(),getMidpoint:function(target){if(target===undefined){console.warn('THREE.Triangle: .getMidpoint() target is now required');target=new Vector3();}return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},getNormal:function(target){return Triangle.getNormal(this.a,this.b,this.c,target);},getPlane:function(target){if(target===undefined){console.warn('THREE.Triangle: .getPlane() target is now required');target=new Vector3();}return target.setFromCoplanarPoints(this.a,this.b,this.c);},getBarycoord:function(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);},containsPoint:function(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},intersectsBox:function(box){return box.intersectsTriangle(this);},closestPointToPoint:function(){var plane=new Plane();var edgeList=[new Line3(),new Line3(),new Line3()];var projectedPoint=new Vector3();var closestPoint=new Vector3();return function closestPointToPoint(point,target){if(target===undefined){console.warn('THREE.Triangle: .closestPointToPoint() target is now required');target=new Vector3();}var minDistance=Infinity;// project the point onto the plane of the triangle
  plane.setFromCoplanarPoints(this.a,this.b,this.c);plane.projectPoint(point,projectedPoint);// check if the projection lies within the triangle
  if(this.containsPoint(projectedPoint)===true){// if so, this is the closest point
  target.copy(projectedPoint);}else{// if not, the point falls outside the triangle. the target is the closest point to the triangle's edges or vertices
  edgeList[0].set(this.a,this.b);edgeList[1].set(this.b,this.c);edgeList[2].set(this.c,this.a);for(var i=0;i<edgeList.length;i++){edgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);var distance=projectedPoint.distanceToSquared(closestPoint);if(distance<minDistance){minDistance=distance;target.copy(closestPoint);}}}return target;};}(),equals:function(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});this.drawMode=TrianglesDrawMode;this.updateMorphTargets();}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:true,setDrawMode:function(value){this.drawMode=value;},copy:function(source){Object3D.prototype.copy.call(this,source);this.drawMode=source.drawMode;if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}return this;},updateMorphTargets:function(){var geometry=this.geometry;var m,ml,name;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphAttribute.length;m<ml;m++){name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphTargets.length;m<ml;m++){name=morphTargets[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}},raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();var vA=new Vector3();var vB=new Vector3();var vC=new Vector3();var tempA=new Vector3();var tempB=new Vector3();var tempC=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();var barycoord=new Vector3();var intersectionPoint=new Vector3();var intersectionPointWorld=new Vector3();function uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){Triangle.getBarycoord(point,p1,p2,p3,barycoord);uv1.multiplyScalar(barycoord.x);uv2.multiplyScalar(barycoord.y);uv3.multiplyScalar(barycoord.z);uv1.add(uv2).add(uv3);return uv1.clone();}function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;intersectionPointWorld.copy(point);intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return {distance:distance,point:intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){vA.fromBufferAttribute(position,a);vB.fromBufferAttribute(position,b);vC.fromBufferAttribute(position,c);var intersection=checkIntersection(object,object.material,raycaster,ray,vA,vB,vC,intersectionPoint);if(intersection){if(uv){uvA.fromBufferAttribute(uv,a);uvB.fromBufferAttribute(uv,b);uvC.fromBufferAttribute(uv,c);intersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);}var face=new Face3(a,b,c);Triangle.getNormal(vA,vB,vC,face.normal);intersection.face=face;intersection.faceIndex=a;}return intersection;}return function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
  inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);// Check boundingBox before continuing
  if(geometry.boundingBox!==null){if(ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var uv=geometry.attributes.uv;var i,l;if(index!==null){// indexed buffer geometry
  for(i=0,l=index.count;i<l;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics
  intersects.push(intersection);}}}else if(position!==undefined){// non-indexed buffer geometry
  for(i=0,l=position.count;i<l;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection)intersects.push(intersection);}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isMultiMaterial=Array.isArray(material);var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];if(faceMaterial.morphTargets===true){var morphTargets=geometry.morphTargets;var morphInfluences=this.morphTargetInfluences;vA.set(0,0,0);vB.set(0,0,0);vC.set(0,0,0);for(var t=0,tl=morphTargets.length;t<tl;t++){var influence=morphInfluences[t];if(influence===0)continue;var targets=morphTargets[t].vertices;vA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);vB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);vC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);}vA.add(fvA);vB.add(fvB);vC.add(fvC);fvA=vA;fvB=vB;fvC=vC;}intersection=checkIntersection(this,faceMaterial,raycaster,ray,fvA,fvB,fvC,intersectionPoint);if(intersection){if(uvs&&uvs[f]){var uvs_f=uvs[f];uvA.copy(uvs_f[0]);uvB.copy(uvs_f[1]);uvC.copy(uvs_f[2]);intersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLBackground(renderer,state,geometries,premultipliedAlpha){var clearColor=new Color(0x000000);var clearAlpha=0;var planeCamera,planeMesh;var boxMesh;function render(renderList,scene,camera,forceClear){var background=scene.background;if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&background.isCubeTexture){if(boxMesh===undefined){boxMesh=new Mesh(new BoxBufferGeometry(1,1,1),new ShaderMaterial({uniforms:ShaderLib.cube.uniforms,vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:true,depthWrite:false,fog:false}));boxMesh.geometry.removeAttribute('normal');boxMesh.geometry.removeAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};geometries.update(boxMesh.geometry);}boxMesh.material.uniforms.tCube.value=background;renderList.push(boxMesh,boxMesh.geometry,boxMesh.material,0,null);}else if(background&&background.isTexture){if(planeCamera===undefined){planeCamera=new OrthographicCamera(-1,1,1,-1,0,1);planeMesh=new Mesh(new PlaneBufferGeometry(2,2),new MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));geometries.update(planeMesh.geometry);}planeMesh.material.map=background;// TODO Push this to renderList
  renderer.renderBufferDirect(planeCamera,null,planeMesh.geometry,planeMesh.material,planeMesh,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return {getClearColor:function(){return clearColor;},setClearColor:function(color,alpha){clearColor.set(color);clearAlpha=alpha!==undefined?alpha:1;setClear(clearColor,clearAlpha);},getClearAlpha:function(){return clearAlpha;},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLBufferRenderer(gl,extensions,info){var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode);}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}var position=geometry.attributes.position;if(position.isInterleavedBufferAttribute){count=position.data.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}else{extension.drawArraysInstancedANGLE(mode,start,count,geometry.maxInstancedCount);}info.update(count,mode,geometry.maxInstancedCount);}//
  this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return 'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return 'mediump';}}return 'lowp';}var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);var maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);var maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);var maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);var maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;return {getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures};}/**
   * @author tschw
   */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
  // run another frame in order to reset the state:
  numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
  if(renderingShadows){// there's no global clipping
  projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
  dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;return dstArray;}}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLExtensions(gl){var extensions={};return {get:function(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}extensions[name]=extension;return extension;}};}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLGeometries(gl,attributes,info){var geometries={};var wireframeAttributes={};function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries[geometry.id];if(buffergeometry.index!==null){attributes.remove(buffergeometry.index);}for(var name in buffergeometry.attributes){attributes.remove(buffergeometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];// TODO Remove duplicate code
  var attribute=wireframeAttributes[geometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[geometry.id];}attribute=wireframeAttributes[buffergeometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[buffergeometry.id];}//
  info.memory.geometries--;}function get(object,geometry){var buffergeometry=geometries[geometry.id];if(buffergeometry)return buffergeometry;geometry.addEventListener('dispose',onGeometryDispose);if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries[geometry.id]=buffergeometry;info.memory.geometries++;return buffergeometry;}function update(geometry){var index=geometry.index;var geometryAttributes=geometry.attributes;if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}for(var name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}// morph targets
  var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],gl.ARRAY_BUFFER);}}}function getWireframeAttribute(geometry){var attribute=wireframeAttributes[geometry.id];if(attribute)return attribute;var indices=[];var geometryIndex=geometry.index;var geometryAttributes=geometry.attributes;// console.time( 'wireframe' );
  if(geometryIndex!==null){var array=geometryIndex.array;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=geometryAttributes.position.array;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}// console.timeEnd( 'wireframe' );
  attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attributes.update(attribute,gl.ELEMENT_ARRAY_BUFFER);wireframeAttributes[geometry.id]=attribute;return attribute;}return {get:get,update:update,getWireframeAttribute:getWireframeAttribute};}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLIndexedBufferRenderer(gl,extensions,info){var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode);}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}extension.drawElementsInstancedANGLE(mode,count,type,start*bytesPerElement,geometry.maxInstancedCount);info.update(count,mode,geometry.maxInstancedCount);}//
  this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}/**
   * @author Mugen87 / https://github.com/Mugen87
   */function WebGLInfo(gl){var memory={geometries:0,textures:0};var render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){instanceCount=instanceCount||1;render.calls++;switch(mode){case gl.TRIANGLES:render.triangles+=instanceCount*(count/3);break;case gl.TRIANGLE_STRIP:case gl.TRIANGLE_FAN:render.triangles+=instanceCount*(count-2);break;case gl.LINES:render.lines+=instanceCount*(count/2);break;case gl.LINE_STRIP:render.lines+=instanceCount*(count-1);break;case gl.LINE_LOOP:render.lines+=instanceCount*count;break;case gl.POINTS:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return {memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}/**
   * @author mrdoob / http://mrdoob.com/
   */function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function WebGLMorphtargets(gl){var influencesList={};var morphInfluences=new Float32Array(8);function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;var length=objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined){// initialise list
  influences=[];for(var i=0;i<length;i++){influences[i]=[i,0];}influencesList[geometry.id]=influences;}var morphTargets=material.morphTargets&&geometry.morphAttributes.position;var morphNormals=material.morphNormals&&geometry.morphAttributes.normal;// Remove current morphAttributes
  for(var i=0;i<length;i++){var influence=influences[i];if(influence[1]!==0){if(morphTargets)geometry.removeAttribute('morphTarget'+i);if(morphNormals)geometry.removeAttribute('morphNormal'+i);}}// Collect influences
  for(var i=0;i<length;i++){var influence=influences[i];influence[0]=i;influence[1]=objectInfluences[i];}influences.sort(absNumericalSort);// Add morphAttributes
  for(var i=0;i<8;i++){var influence=influences[i];if(influence){var index=influence[0];var value=influence[1];if(value){if(morphTargets)geometry.addAttribute('morphTarget'+i,morphTargets[index]);if(morphNormals)geometry.addAttribute('morphNormal'+i,morphNormals[index]);morphInfluences[i]=value;continue;}}morphInfluences[i]=0;}program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}return {update:update};}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLObjects(geometries,info){var updateList={};function update(object){var frame=info.render.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
  if(updateList[buffergeometry.id]!==frame){if(geometry.isGeometry){buffergeometry.updateFromObject(object);}geometries.update(buffergeometry);updateList[buffergeometry.id]=frame;}return buffergeometry;}function dispose(){updateList={};}return {update:update,dispose:dispose};}/**
   * @author mrdoob / http://mrdoob.com/
   */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=Object.create(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;Object.defineProperty(CubeTexture.prototype,'images',{get:function(){return this.image;},set:function(value){this.image=value;}});/**
   * @author tschw
   *
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [renderer] )
   *
   * 		uploads a uniform value(s)
   *  	the 'renderer' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (renderer factorizations):
   *
   * .upload( gl, seq, values, renderer )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (renderer factorizations):
   *
   * .setValue( gl, name, value )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .set( gl, obj, prop )
   *
   * 		sets uniform from object and property with same name than uniform
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */var emptyTexture=new Texture();var emptyCubeTexture=new CubeTexture();// --- Base for inner nodes (including the root) ---
  function UniformContainer(){this.seq=[];this.map={};}// --- Utilities ---
  // Array Caches (provide typed arrays for temporary by size)
  var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
  var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);// Flattening for arrays of vectors and matrices
  function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983
  var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}// Texture unit allocation
  function allocTexUnits(renderer,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i)r[i]=renderer.allocTextureUnit();return r;}// --- Setters ---
  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.
  // Single scalar
  function setValue1f(gl,v){gl.uniform1f(this.addr,v);}function setValue1i(gl,v){gl.uniform1i(this.addr,v);}// Single float vector (from flat array or THREE.VectorN)
  function setValue2fv(gl,v){if(v.x===undefined){gl.uniform2fv(this.addr,v);}else{gl.uniform2f(this.addr,v.x,v.y);}}function setValue3fv(gl,v){if(v.x!==undefined){gl.uniform3f(this.addr,v.x,v.y,v.z);}else if(v.r!==undefined){gl.uniform3f(this.addr,v.r,v.g,v.b);}else{gl.uniform3fv(this.addr,v);}}function setValue4fv(gl,v){if(v.x===undefined){gl.uniform4fv(this.addr,v);}else{gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);}}// Single matrix (from flat array or MatrixN)
  function setValue2fm(gl,v){gl.uniformMatrix2fv(this.addr,false,v.elements||v);}function setValue3fm(gl,v){if(v.elements===undefined){gl.uniformMatrix3fv(this.addr,false,v);}else{mat3array.set(v.elements);gl.uniformMatrix3fv(this.addr,false,mat3array);}}function setValue4fm(gl,v){if(v.elements===undefined){gl.uniformMatrix4fv(this.addr,false,v);}else{mat4array.set(v.elements);gl.uniformMatrix4fv(this.addr,false,mat4array);}}// Single texture (2D / Cube)
  function setValueT1(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTexture2D(v||emptyTexture,unit);}function setValueT6(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
  function setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}function setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}function setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}// Helper to pick the right setter for the singular case
  function getSingularSetter(type){switch(type){case 0x1406:return setValue1f;// FLOAT
  case 0x8b50:return setValue2fv;// _VEC2
  case 0x8b51:return setValue3fv;// _VEC3
  case 0x8b52:return setValue4fv;// _VEC4
  case 0x8b5a:return setValue2fm;// _MAT2
  case 0x8b5b:return setValue3fm;// _MAT3
  case 0x8b5c:return setValue4fm;// _MAT4
  case 0x8b5e:case 0x8d66:return setValueT1;// SAMPLER_2D, SAMPLER_EXTERNAL_OES
  case 0x8b60:return setValueT6;// SAMPLER_CUBE
  case 0x1404:case 0x8b56:return setValue1i;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
  case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
  case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
  }}// Array of scalars
  function setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}function setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
  function setValueV2a(gl,v){gl.uniform2fv(this.addr,flatten(v,this.size,2));}function setValueV3a(gl,v){gl.uniform3fv(this.addr,flatten(v,this.size,3));}function setValueV4a(gl,v){gl.uniform4fv(this.addr,flatten(v,this.size,4));}// Array of matrices (flat or from THREE clases)
  function setValueM2a(gl,v){gl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));}function setValueM3a(gl,v){gl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));}function setValueM4a(gl,v){gl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));}// Array of textures (2D / Cube)
  function setValueT1a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
  function getPureArraySetter(type){switch(type){case 0x1406:return setValue1fv;// FLOAT
  case 0x8b50:return setValueV2a;// _VEC2
  case 0x8b51:return setValueV3a;// _VEC3
  case 0x8b52:return setValueV4a;// _VEC4
  case 0x8b5a:return setValueM2a;// _MAT2
  case 0x8b5b:return setValueM3a;// _MAT3
  case 0x8b5c:return setValueM4a;// _MAT4
  case 0x8b5e:return setValueT1a;// SAMPLER_2D
  case 0x8b60:return setValueT6a;// SAMPLER_CUBE
  case 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL
  case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
  case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
  case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
  }}// --- Uniform Classes ---
  function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
  }function StructuredUniform(id){this.id=id;UniformContainer.call(this);// mix-in
  }StructuredUniform.prototype.setValue=function(gl,value){// Note: Don't need an extra 'renderer' parameter, since samplers
  // are not allowed in structured uniforms.
  var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id]);}};// --- Top-level ---
  // Parser - builds up the property tree from the path strings
  var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.
  function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
  RePathPart.lastIndex=0;for(;;){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
  if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
  addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
  var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
  function WebGLUniforms(gl,program,renderer){UniformContainer.call(this);this.renderer=renderer;var n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,this.renderer);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
  WebGLUniforms.upload=function(gl,seq,values,renderer){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
  u.setValue(gl,v.value,renderer);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
   * @author mrdoob / http://mrdoob.com/
   */function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){console.error('THREE.WebGLShader: Shader couldn\'t compile.');}if(gl.getShaderInfoLog(shader)!==''){console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));}// --enable-privileged-webgl-extension
  // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
  return shader;}/**
   * @author mrdoob / http://mrdoob.com/
   */var programIdCount=0;function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return ['Linear','( value )'];case sRGBEncoding:return ['sRGB','( value )'];case RGBEEncoding:return ['RGBE','( value )'];case RGBM7Encoding:return ['RGBM','( value, 7.0 )'];case RGBM16Encoding:return ['RGBM','( value, 16.0 )'];case RGBDEncoding:return ['RGBD','( value, 256.0 )'];case GammaEncoding:return ['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+encoding);}}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return 'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case Uncharted2ToneMapping:toneMappingName='Uncharted2';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return 'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(extensions,parameters,rendererExtensions){extensions=extensions||{};var chunks=[extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
  attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}function parseIncludes(string){var pattern=/^[ \t]*#include +<([\w\d.]+)>/gm;function replace(match,include){var replace=ShaderChunk[include];if(replace===undefined){throw new Error('Can not resolve #include <'+include+'>');}return parseIncludes(replace);}return string.replace(pattern,replace);}function unrollLoops(string){var pattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;function replace(match,start,end,snippet){var unroll='';for(var i=parseInt(start);i<parseInt(end);i++){unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');}return unroll;}return string.replace(pattern,replace);}function WebGLProgram(renderer,extensions,code,material,shader,parameters){var gl=renderer.context;var defines=material.defines;var vertexShader=shader.vertexShader;var fragmentShader=shader.fragmentShader;var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}var envMapTypeDefine='ENVMAP_TYPE_CUBE';var envMapModeDefine='ENVMAP_MODE_REFLECTION';var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';if(parameters.envMap){switch(material.envMap.mapping){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}switch(material.envMap.mapping){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}switch(material.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;// console.log( 'building new program ' );
  //
  var customExtensions=generateExtensions(material.extensions,parameters,extensions);var customDefines=generateDefines(defines);//
  var program=gl.createProgram();var prefixVertex,prefixFragment;if(material.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else{prefixVertex=['precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+shader.name,customDefines,parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,'precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+shader.name,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'','#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.envMap&&extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
  parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
  parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding):'',parameters.depthPacking?'#define DEPTH_PACKING '+material.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=parseIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=parseIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );
  var glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);var glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
  if(material.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,material.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
  gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);var programLog=gl.getProgramInfoLog(program).trim();var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();var runnable=true;var haveDiagnostics=true;// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  // console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
  if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,material:material,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}// clean up
  gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
  var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program,renderer);}return cachedUniforms;};// set up caching for attribute locations
  var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
  this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};// DEPRECATED
  Object.defineProperties(this,{uniforms:{get:function(){console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');return this.getUniforms();}},attributes:{get:function(){console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');return this.getAttributes();}}});//
  this.name=shader.name;this.id=programIdCount++;this.code=code;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLPrograms(renderer,extensions,capabilities){var programs=[];var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow'};var parameterNames=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];function allocateBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(capabilities.floatVertexTextures){return 1024;}else{// default for when object is not specified
  // ( for example when prebuilding shader to be used with multiple objects )
  //
  //  - leave some extra space for other uniforms
  //  - limit here is ANGLE's 254 max uniform vectors
  //    (up to 54 should be safe)
  var nVertexUniforms=capabilities.maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map,gammaOverrideLinear){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  if(encoding===LinearEncoding&&gammaOverrideLinear){encoding=GammaEncoding;}return encoding;}this.getParameters=function(material,lights,shadows,fog,nClipPlanes,nClipIntersection,object){var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
  // (not to blow over maxLights budget)
  var maxBones=object.isSkinnedMesh?allocateBones(object):0;var precision=capabilities.precision;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var currentRenderTarget=renderer.getRenderTarget();var parameters={shaderID:shaderID,precision:precision,supportsVertexTextures:capabilities.vertexTextures,outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),envMap:!!material.envMap,envMapMode:material.envMap&&material.envMap.mapping,envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,combine:material.combine,vertexColors:material.vertexColors,fog:!!fog,useFog:material.fog,fogExp:fog&&fog.isFogExp2,flatShading:material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,skinning:material.skinning&&maxBones>0,maxBones:maxBones,useVertexTexture:capabilities.floatVertexTextures,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:renderer.toneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false};return parameters;};this.getProgramCode=function(material,parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(material.fragmentShader);array.push(material.vertexShader);}if(material.defines!==undefined){for(var name in material.defines){array.push(name);array.push(material.defines[name]);}}for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}array.push(material.onBeforeCompile.toString());array.push(renderer.gammaOutput);return array.join();};this.acquireProgram=function(material,shader,parameters,code){var program;// Check if code has been already compiled
  for(var p=0,pl=programs.length;p<pl;p++){var programInfo=programs[p];if(programInfo.code===code){program=programInfo;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,extensions,code,material,shader,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
  var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
  program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
  this.programs=programs;}/**
   * @author fordacious / fordacious.github.io
   */function WebGLProperties(){var properties=new WeakMap();function get(object){var map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new WeakMap();}return {get:get,remove:remove,update:update,dispose:dispose};}/**
   * @author mrdoob / http://mrdoob.com/
   */function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program&&b.program&&a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transparent=[];function init(){renderItemsIndex=0;opaque.length=0;transparent.length=0;}function push(object,geometry,material,z,group){var renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:material.program,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else{renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=material.program;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}(material.transparent===true?transparent:opaque).push(renderItem);renderItemsIndex++;}function sort(){if(opaque.length>1)opaque.sort(painterSortStable);if(transparent.length>1)transparent.sort(reversePainterSortStable);}return {opaque:opaque,transparent:transparent,init:init,push:push,sort:sort};}function WebGLRenderLists(){var lists={};function get(scene,camera){var hash=scene.id+','+camera.id;var list=lists[hash];if(list===undefined){// console.log( 'THREE.WebGLRenderLists:', hash );
  list=new WebGLRenderList();lists[hash]=list;}return list;}function dispose(){lists={};}return {get:get,dispose:dispose};}/**
   * @author mrdoob / http://mrdoob.com/
   */function UniformsCache(){var lights={};return {get:function(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color(),shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()// TODO (abelnation): set RectAreaLight shadow uniforms
  };break;}lights[light.id]=uniforms;return uniforms;}};}var count=0;function WebGLLights(){var cache=new UniformsCache();var state={id:count++,hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};var vector3=new Vector3();var matrix4=new Matrix4();var matrix42=new Matrix4();function setup(lights,shadows,camera){var r=0,g=0,b=0;var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var viewMatrix=camera.matrixWorldInverse;for(var i=0,l=lights.length;i<l;i++){var light=lights[i];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;state.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){var uniforms=cache.get(light);// (a) intensity is the total visible light emitted
  //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
  // (b) intensity is the brightness of the light
  uniforms.color.copy(color).multiplyScalar(intensity);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
  matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);// TODO (abelnation): RectAreaLight distance?
  // uniforms.distance = distance;
  state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;uniforms.shadowCameraNear=shadow.camera.near;uniforms.shadowCameraFar=shadow.camera.far;}state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){var uniforms=cache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.hash=state.id+','+directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+shadows.length;}return {setup:setup,state:state};}/**
   * @author Mugen87 / https://github.com/Mugen87
   */function WebGLRenderState(){var lights=new WebGLLights();var lightsArray=[];var shadowsArray=[];var spritesArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;spritesArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function pushSprite(shadowLight){spritesArray.push(shadowLight);}function setupLights(camera){lights.setup(lightsArray,shadowsArray,camera);}var state={lightsArray:lightsArray,shadowsArray:shadowsArray,spritesArray:spritesArray,lights:lights};return {init:init,state:state,setupLights:setupLights,pushLight:pushLight,pushShadow:pushShadow,pushSprite:pushSprite};}function WebGLRenderStates(){var renderStates={};function get(scene,camera){var hash=scene.id+','+camera.id;var renderState=renderStates[hash];if(renderState===undefined){renderState=new WebGLRenderState();renderStates[hash]=renderState;}return renderState;}function dispose(){renderStates={};}return {get:get,dispose:dispose};}/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDepthMaterial.prototype=Object.create(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;};/**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  referencePosition: <float>,
   *  nearDistance: <float>,
   *  farDistance: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>
   *
   * }
   */function MeshDistanceMaterial(parameters){Material.call(this);this.type='MeshDistanceMaterial';this.referencePosition=new Vector3();this.nearDistance=1;this.farDistance=1000;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDistanceMaterial.prototype=Object.create(Material.prototype);MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial;MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;MeshDistanceMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;};/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */function WebGLShadowMap(_renderer,_objects,maxTextureSize){var _frustum=new Frustum(),_projScreenMatrix=new Matrix4(),_shadowMapSize=new Vector2(),_maxShadowMapSize=new Vector2(maxTextureSize,maxTextureSize),_lookTarget=new Vector3(),_lightPositionWorld=new Vector3(),_MorphingFlag=1,_SkinningFlag=2,_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,_depthMaterials=new Array(_NumberOfMaterialVariants),_distanceMaterials=new Array(_NumberOfMaterialVariants),_materialCache={};var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};var cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];var cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];var cube2DViewPorts=[new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4()];// init
  for(var i=0;i!==_NumberOfMaterialVariants;++i){var useMorphing=(i&_MorphingFlag)!==0;var useSkinning=(i&_SkinningFlag)!==0;var depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking,morphTargets:useMorphing,skinning:useSkinning});_depthMaterials[i]=depthMaterial;//
  var distanceMaterial=new MeshDistanceMaterial({morphTargets:useMorphing,skinning:useSkinning});_distanceMaterials[i]=distanceMaterial;}//
  var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;// TODO Clean up (needed in case of contextlost)
  var _gl=_renderer.context;var _state=_renderer.state;// Set GL state for depth map.
  _state.disable(_gl.BLEND);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
  var faceCount;for(var i=0,il=lights.length;i<il;i++){var light=lights[i];var shadow=light.shadow;var isPointLight=light&&light.isPointLight;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}var shadowCamera=shadow.camera;_shadowMapSize.copy(shadow.mapSize);_shadowMapSize.min(_maxShadowMapSize);if(isPointLight){var vpWidth=_shadowMapSize.x;var vpHeight=_shadowMapSize.y;// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);// negative X
  cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);// positive Z
  cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);// negative Z
  cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);// positive Y
  cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);// negative Y
  cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);_shadowMapSize.x*=4.0;_shadowMapSize.y*=2.0;}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadowCamera.updateProjectionMatrix();}if(shadow.isSpotLightShadow){shadow.update(light);}var shadowMap=shadow.map;var shadowMatrix=shadow.matrix;_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld);if(isPointLight){faceCount=6;// for point lights we set the shadow matrix to be a translation-only matrix
  // equal to inverse of the light's position
  shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);}else{faceCount=1;_lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();// compute shadow matrix
  shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}_renderer.setRenderTarget(shadowMap);_renderer.clear();// render shadow map for each cube face (if omni-directional) or
  // run a single pass if not
  for(var face=0;face<faceCount;face++){if(isPointLight){_lookTarget.copy(shadowCamera.position);_lookTarget.add(cubeDirections[face]);shadowCamera.up.copy(cubeUps[face]);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();var vpDimensions=cube2DViewPorts[face];_state.viewport(vpDimensions);}// update camera matrices and frustum
  _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);// set object matrices & frustum culling
  renderObject(scene,camera,shadowCamera,isPointLight);}}scope.needsUpdate=false;};function getDepthMaterial(object,material,isPointLight,lightPositionWorld,shadowCameraNear,shadowCameraFar){var geometry=object.geometry;var result=null;var materialVariants=_depthMaterials;var customMaterial=object.customDepthMaterial;if(isPointLight){materialVariants=_distanceMaterials;customMaterial=object.customDistanceMaterial;}if(!customMaterial){var useMorphing=false;if(material.morphTargets){if(geometry&&geometry.isBufferGeometry){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry&&geometry.isGeometry){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}if(object.isSkinnedMesh&&material.skinning===false){console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);}var useSkinning=object.isSkinnedMesh&&material.skinning;var variantIndex=0;if(useMorphing)variantIndex|=_MorphingFlag;if(useSkinning)variantIndex|=_SkinningFlag;result=materialVariants[variantIndex];}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
  // appropriate state
  var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;result.side=material.shadowSide!=null?material.shadowSide:shadowSide[material.side];result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(isPointLight&&result.isMeshDistanceMaterial){result.referencePosition.copy(lightPositionWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,isPointLight){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if(object.castShadow&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,isPointLight);}}}/**
   * @author mrdoob / http://mrdoob.com/
   */function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}CanvasTexture.prototype=Object.create(Texture.prototype);CanvasTexture.prototype.constructor=CanvasTexture;/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */function WebGLSpriteRenderer(renderer,gl,state,textures,capabilities){var vertexBuffer,elementBuffer;var program,attributes,uniforms;var texture;// decompose matrixWorld
  var spritePosition=new Vector3();var spriteRotation=new Quaternion();var spriteScale=new Vector3();function init(){var vertices=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);program=createProgram();attributes={position:gl.getAttribLocation(program,'position'),uv:gl.getAttribLocation(program,'uv')};uniforms={uvOffset:gl.getUniformLocation(program,'uvOffset'),uvScale:gl.getUniformLocation(program,'uvScale'),rotation:gl.getUniformLocation(program,'rotation'),center:gl.getUniformLocation(program,'center'),scale:gl.getUniformLocation(program,'scale'),color:gl.getUniformLocation(program,'color'),map:gl.getUniformLocation(program,'map'),opacity:gl.getUniformLocation(program,'opacity'),modelViewMatrix:gl.getUniformLocation(program,'modelViewMatrix'),projectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),fogType:gl.getUniformLocation(program,'fogType'),fogDensity:gl.getUniformLocation(program,'fogDensity'),fogNear:gl.getUniformLocation(program,'fogNear'),fogFar:gl.getUniformLocation(program,'fogFar'),fogColor:gl.getUniformLocation(program,'fogColor'),fogDepth:gl.getUniformLocation(program,'fogDepth'),alphaTest:gl.getUniformLocation(program,'alphaTest')};var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=8;canvas.height=8;var context=canvas.getContext('2d');context.fillStyle='white';context.fillRect(0,0,8,8);texture=new CanvasTexture(canvas);}this.render=function(sprites,scene,camera){if(sprites.length===0)return;// setup gl
  if(program===undefined){init();}state.useProgram(program);state.initAttributes();state.enableAttribute(attributes.position);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();state.disable(gl.CULL_FACE);state.enable(gl.BLEND);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.position,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.uniformMatrix4fv(uniforms.projectionMatrix,false,camera.projectionMatrix.elements);state.activeTexture(gl.TEXTURE0);gl.uniform1i(uniforms.map,0);var oldFogType=0;var sceneFogType=0;var fog=scene.fog;if(fog){gl.uniform3f(uniforms.fogColor,fog.color.r,fog.color.g,fog.color.b);if(fog.isFog){gl.uniform1f(uniforms.fogNear,fog.near);gl.uniform1f(uniforms.fogFar,fog.far);gl.uniform1i(uniforms.fogType,1);oldFogType=1;sceneFogType=1;}else if(fog.isFogExp2){gl.uniform1f(uniforms.fogDensity,fog.density);gl.uniform1i(uniforms.fogType,2);oldFogType=2;sceneFogType=2;}}else{gl.uniform1i(uniforms.fogType,0);oldFogType=0;sceneFogType=0;}// update positions and sort
  for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,sprite.matrixWorld);sprite.z=-sprite.modelViewMatrix.elements[14];}sprites.sort(painterSortStable);// render all sprites
  var scale=[];var center=[];for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];var material=sprite.material;if(material.visible===false)continue;sprite.onBeforeRender(renderer,scene,camera,undefined,material,undefined);gl.uniform1f(uniforms.alphaTest,material.alphaTest);gl.uniformMatrix4fv(uniforms.modelViewMatrix,false,sprite.modelViewMatrix.elements);sprite.matrixWorld.decompose(spritePosition,spriteRotation,spriteScale);scale[0]=spriteScale.x;scale[1]=spriteScale.y;center[0]=sprite.center.x-0.5;center[1]=sprite.center.y-0.5;var fogType=0;if(scene.fog&&material.fog){fogType=sceneFogType;}if(oldFogType!==fogType){gl.uniform1i(uniforms.fogType,fogType);oldFogType=fogType;}if(material.map!==null){gl.uniform2f(uniforms.uvOffset,material.map.offset.x,material.map.offset.y);gl.uniform2f(uniforms.uvScale,material.map.repeat.x,material.map.repeat.y);}else{gl.uniform2f(uniforms.uvOffset,0,0);gl.uniform2f(uniforms.uvScale,1,1);}gl.uniform1f(uniforms.opacity,material.opacity);gl.uniform3f(uniforms.color,material.color.r,material.color.g,material.color.b);gl.uniform1f(uniforms.rotation,material.rotation);gl.uniform2fv(uniforms.center,center);gl.uniform2fv(uniforms.scale,scale);state.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);state.buffers.depth.setTest(material.depthTest);state.buffers.depth.setMask(material.depthWrite);state.buffers.color.setMask(material.colorWrite);textures.setTexture2D(material.map||texture,0);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);sprite.onAfterRender(renderer,scene,camera,undefined,material,undefined);}// restore gl
  state.enable(gl.CULL_FACE);state.reset();};function createProgram(){var program=gl.createProgram();var vertexShader=gl.createShader(gl.VERTEX_SHADER);var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(vertexShader,['precision '+capabilities.precision+' float;','#define SHADER_NAME '+'SpriteMaterial','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform float rotation;','uniform vec2 center;','uniform vec2 scale;','uniform vec2 uvOffset;','uniform vec2 uvScale;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','varying float fogDepth;','void main() {','	vUV = uvOffset + uv * uvScale;','	vec2 alignedPosition = ( position - center ) * scale;','	vec2 rotatedPosition;','	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;','	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;','	vec4 mvPosition;','	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );','	mvPosition.xy += rotatedPosition;','	gl_Position = projectionMatrix * mvPosition;','	fogDepth = - mvPosition.z;','}'].join('\n'));gl.shaderSource(fragmentShader,['precision '+capabilities.precision+' float;','#define SHADER_NAME '+'SpriteMaterial','uniform vec3 color;','uniform sampler2D map;','uniform float opacity;','uniform int fogType;','uniform vec3 fogColor;','uniform float fogDensity;','uniform float fogNear;','uniform float fogFar;','uniform float alphaTest;','varying vec2 vUV;','varying float fogDepth;','void main() {','	vec4 texture = texture2D( map, vUV );','	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );','	if ( gl_FragColor.a < alphaTest ) discard;','	if ( fogType > 0 ) {','		float fogFactor = 0.0;','		if ( fogType == 1 ) {','			fogFactor = smoothstep( fogNear, fogFar, fogDepth );','		} else {','			const float LOG2 = 1.442695;','			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );','			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );','		}','		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );','	}','}'].join('\n'));gl.compileShader(vertexShader);gl.compileShader(fragmentShader);gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);return program;}function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return b.id-a.id;}}}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLState(gl,extensions,utils){function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return {setMask:function(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function(lock){locked=lock;},setClear:function(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
  }};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return {setTest:function(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else{disable(gl.DEPTH_TEST);}},setMask:function(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}}else{gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function(lock){locked=lock;},setClear:function(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return {setTest:function(stencilTest){if(stencilTest){enable(gl.STENCIL_TEST);}else{disable(gl.STENCIL_TEST);}},setMask:function(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function(lock){locked=lock;},setClear:function(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
  var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var capabilities={};var compressedTextureFormats=null;var currentProgram=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);var lineWidthAvailable=false;var version=0;var glVersion=gl.getParameter(gl.VERSION);if(glVersion.indexOf('WebGL')!==-1){version=parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
  var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}return texture;}var emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);// init
  colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);enable(gl.BLEND);setBlending(NormalBlending);//
  function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==0){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,0);attributeDivisors[attribute]=0;}}function enableAttributeAndDivisor(attribute,meshPerAttribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(capabilities[id]!==true){gl.enable(id);capabilities[id]=true;}}function disable(id){if(capabilities[id]!==false){gl.disable(id);capabilities[id]=false;}}function getCompressedTextureFormats(){if(compressedTextureFormats===null){compressedTextureFormats=[];if(extensions.get('WEBGL_compressed_texture_pvrtc')||extensions.get('WEBGL_compressed_texture_s3tc')||extensions.get('WEBGL_compressed_texture_etc1')||extensions.get('WEBGL_compressed_texture_astc')){var formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);for(var i=0;i<formats.length;i++){compressedTextureFormats.push(formats[i]);}}}return compressedTextureFormats;}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending!==NoBlending){enable(gl.BLEND);}else{disable(gl.BLEND);}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){switch(blending){case AdditiveBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);}break;case SubtractiveBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);}break;case MultiplyBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.SRC_COLOR);}break;default:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}}}currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;}else{blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(utils.convert(blendEquation),utils.convert(blendEquationAlpha));currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(utils.convert(blendSrc),utils.convert(blendDst),utils.convert(blendSrcAlpha),utils.convert(blendDstAlpha));currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}}currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);var flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.transparent===true?setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):setBlending(NoBlending);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}//
  function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else{gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else{gl.cullFace(gl.FRONT_AND_BACK);}}}else{disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(gl.POLYGON_OFFSET_FILL);}}function setScissorTest(scissorTest){if(scissorTest){enable(gl.SCISSOR_TEST);}else{disable(gl.SCISSOR_TEST);}}// texture
  function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
  function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
  function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}capabilities={};compressedTextureFormats=null;currentTextureSlot=null;currentBoundTextures={};currentProgram=null;currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return {buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,getCompressedTextureFormats:getCompressedTextureFormats,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,scissor:scissor,viewport:viewport,reset:reset};}/**
   * @author mrdoob / http://mrdoob.com/
   */function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){var _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof WebGL2RenderingContext;/* global WebGL2RenderingContext */var _videoTextures={};var _canvas;//
  function clampToMaxSize(image,maxSize){if(image.width>maxSize||image.height>maxSize){if('data'in image){console.warn('THREE.WebGLRenderer: image in DataTexture is too big ('+image.width+'x'+image.height+').');return;}// Warning: Scaling through the canvas will only work with images that use
  // premultiplied alpha.
  var scale=maxSize/Math.max(image.width,image.height);var canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');canvas.width=Math.floor(image.width*scale);canvas.height=Math.floor(image.height*scale);var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function isPowerOfTwo(image){return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);}function makePowerOfTwo(image){if(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement||image instanceof ImageBitmap){if(_canvas===undefined)_canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');_canvas.width=_Math.floorPowerOfTwo(image.width);_canvas.height=_Math.floorPowerOfTwo(image.height);var context=_canvas.getContext('2d');context.drawImage(image,0,0,_canvas.width,_canvas.height);console.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+_canvas.width+'x'+_canvas.height,image);return _canvas;}return image;}function textureNeedsPowerOfTwo(texture){return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,isPowerOfTwo){return texture.generateMipmaps&&isPowerOfTwo&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target,texture,width,height){_gl.generateMipmap(target);var textureProperties=properties.get(texture);// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
  textureProperties.__maxMipLevel=Math.log(Math.max(width,height))*Math.LOG2E;}// Fallback filters for non-power-of-2 textures
  function filterFallback(f){if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){return _gl.NEAREST;}return _gl.LINEAR;}//
  function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){delete _videoTextures[texture.id];}info.memory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);info.memory.textures--;}//
  function deallocateTexture(texture){var textureProperties=properties.get(texture);if(texture.image&&textureProperties.__image__webglTextureCube){// cube texture
  _gl.deleteTexture(textureProperties.__image__webglTextureCube);}else{// 2D texture
  if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);}// remove all webgl properties
  properties.remove(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLRenderTargetCube){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);}properties.remove(renderTarget.texture);properties.remove(renderTarget);}//
  function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.image.length===6){if(texture.version>0&&textureProperties.__version!==texture.version){if(!textureProperties.__image__webglTextureCube){texture.addEventListener('dispose',onTextureDispose);textureProperties.__image__webglTextureCube=_gl.createTexture();info.memory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);var isCompressed=texture&&texture.isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],isPowerOfTwoImage=isPowerOfTwo(image),glFormat=utils.convert(texture.format),glType=utils.convert(texture.type);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);for(var i=0;i<6;i++){if(!isCompressed){if(isDataTexture){state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);}}else{var mipmap,mipmaps=cubeImage[i].mipmaps;for(var j=0,jl=mipmaps.length;j<jl;j++){mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}if(!isCompressed){textureProperties.__maxMipLevel=0;}else{textureProperties.__maxMipLevel=mipmaps.length-1;}if(textureNeedsGenerateMipmaps(texture,isPowerOfTwoImage)){// We assume images for cube map have the same size.
  generateMipmap(_gl.TEXTURE_CUBE_MAP,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);}}}function setTextureCubeDynamic(texture,slot){state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);}function setTextureParameters(textureType,texture,isPowerOfTwoImage){var extension;if(isPowerOfTwoImage){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,utils.convert(texture.wrapS));_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,utils.convert(texture.wrapT));_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,utils.convert(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,utils.convert(texture.minFilter));}else{_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);}}extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function uploadTexture(textureProperties,texture,slot){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);var image=clampToMaxSize(texture.image,capabilities.maxTextureSize);if(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){image=makePowerOfTwo(image);}var isPowerOfTwoImage=isPowerOfTwo(image),glFormat=utils.convert(texture.format),glType=utils.convert(texture.type);setTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
  var internalFormat=_gl.DEPTH_COMPONENT;if(texture.type===FloatType){if(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');internalFormat=_gl.DEPTH_COMPONENT32F;}else if(_isWebGL2){// WebGL 2.0 requires signed internalformat for glTexImage2D
  internalFormat=_gl.DEPTH_COMPONENT16;}if(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}// Depth stencil textures need the DEPTH_STENCIL internal format
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.format===DepthStencilFormat){internalFormat=_gl.DEPTH_STENCIL;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}state.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else{state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}textureProperties.__maxMipLevel=mipmaps.length-1;}else{// regular Texture (image, video, canvas)
  // use manually created mipmaps if available
  // if there are no manual mipmaps
  // set 0 level mipmap and then use GL to generate other mipmap levels
  if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);textureProperties.__maxMipLevel=0;}}if(textureNeedsGenerateMipmaps(texture,isPowerOfTwoImage)){generateMipmap(_gl.TEXTURE_2D,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=utils.convert(renderTarget.texture.format);var glType=utils.convert(renderTarget.texture.type);state.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage(renderbuffer,renderTarget){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else{// FIXME: We don't support !depth !stencil
  _gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
  function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
  if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLRenderTargetCube===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);}}else{_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);}}_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Set up GL resources for the render target
  function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;var isCube=renderTarget.isWebGLRenderTargetCube===true;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);// Setup framebuffer
  if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}// Setup color buffer
  if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);}if(textureNeedsGenerateMipmaps(renderTarget.texture,isTargetPowerOfTwo)){generateMipmap(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,renderTarget.width,renderTarget.height);}state.bindTexture(_gl.TEXTURE_CUBE_MAP,null);}else{state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);if(textureNeedsGenerateMipmaps(renderTarget.texture,isTargetPowerOfTwo)){generateMipmap(_gl.TEXTURE_2D,renderTarget.texture,renderTarget.width,renderTarget.height);}state.bindTexture(_gl.TEXTURE_2D,null);}// Setup depth and stencil buffers
  if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);if(textureNeedsGenerateMipmaps(texture,isTargetPowerOfTwo)){var target=renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target,texture,renderTarget.width,renderTarget.height);state.bindTexture(target,null);}}function updateVideoTexture(texture){var id=texture.id;var frame=info.render.frame;// Check the last frame we updated the VideoTexture
  if(_videoTextures[id]!==frame){_videoTextures[id]=frame;texture.update();}}this.setTexture2D=setTexture2D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;}/**
   * @author thespite / http://www.twitter.com/thespite
   */function WebGLUtils(gl,extensions){function convert(p){var extension;if(p===RepeatWrapping)return gl.REPEAT;if(p===ClampToEdgeWrapping)return gl.CLAMP_TO_EDGE;if(p===MirroredRepeatWrapping)return gl.MIRRORED_REPEAT;if(p===NearestFilter)return gl.NEAREST;if(p===NearestMipMapNearestFilter)return gl.NEAREST_MIPMAP_NEAREST;if(p===NearestMipMapLinearFilter)return gl.NEAREST_MIPMAP_LINEAR;if(p===LinearFilter)return gl.LINEAR;if(p===LinearMipMapNearestFilter)return gl.LINEAR_MIPMAP_NEAREST;if(p===LinearMipMapLinearFilter)return gl.LINEAR_MIPMAP_LINEAR;if(p===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedShort565Type)return gl.UNSIGNED_SHORT_5_6_5;if(p===ByteType)return gl.BYTE;if(p===ShortType)return gl.SHORT;if(p===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p===IntType)return gl.INT;if(p===UnsignedIntType)return gl.UNSIGNED_INT;if(p===FloatType)return gl.FLOAT;if(p===HalfFloatType){extension=extensions.get('OES_texture_half_float');if(extension!==null)return extension.HALF_FLOAT_OES;}if(p===AlphaFormat)return gl.ALPHA;if(p===RGBFormat)return gl.RGB;if(p===RGBAFormat)return gl.RGBA;if(p===LuminanceFormat)return gl.LUMINANCE;if(p===LuminanceAlphaFormat)return gl.LUMINANCE_ALPHA;if(p===DepthFormat)return gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return gl.DEPTH_STENCIL;if(p===AddEquation)return gl.FUNC_ADD;if(p===SubtractEquation)return gl.FUNC_SUBTRACT;if(p===ReverseSubtractEquation)return gl.FUNC_REVERSE_SUBTRACT;if(p===ZeroFactor)return gl.ZERO;if(p===OneFactor)return gl.ONE;if(p===SrcColorFactor)return gl.SRC_COLOR;if(p===OneMinusSrcColorFactor)return gl.ONE_MINUS_SRC_COLOR;if(p===SrcAlphaFactor)return gl.SRC_ALPHA;if(p===OneMinusSrcAlphaFactor)return gl.ONE_MINUS_SRC_ALPHA;if(p===DstAlphaFactor)return gl.DST_ALPHA;if(p===OneMinusDstAlphaFactor)return gl.ONE_MINUS_DST_ALPHA;if(p===DstColorFactor)return gl.DST_COLOR;if(p===OneMinusDstColorFactor)return gl.ONE_MINUS_DST_COLOR;if(p===SrcAlphaSaturateFactor)return gl.SRC_ALPHA_SATURATE;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;}if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){return p;}}if(p===MinEquation||p===MaxEquation){extension=extensions.get('EXT_blend_minmax');if(extension!==null){if(p===MinEquation)return extension.MIN_EXT;if(p===MaxEquation)return extension.MAX_EXT;}}if(p===UnsignedInt248Type){extension=extensions.get('WEBGL_depth_texture');if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;}return 0;}return {convert:convert};}/**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
  this.filmOffset=0;// horizontal film offset (same unit as gauge)
  this.updateProjectionMatrix();}PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */setFocalLength:function(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
  var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */getFocalLength:function(){var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function(){return _Math.RAD2DEG*2*Math.atan(Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function(){// film not completely covered in portrait format (aspect < 1)
  return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function(){// film not completely covered in landscape format (aspect > 1)
  return this.filmGauge/Math.max(this.aspect,1);},/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   var w = 1920;
  	 *   var h = 1080;
  	 *   var fullWidth = w * 3;
  	 *   var fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */setViewOffset:function(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function(){var near=this.near,top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function ArrayCamera(array){PerspectiveCamera.call(this);this.cameras=array||[];}ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:true});/**
   * @author mrdoob / http://mrdoob.com/
   */function WebVRManager(renderer){var scope=this;var device=null;var frameData=null;var poseTarget=null;var standingMatrix=new Matrix4();var standingMatrixInverse=new Matrix4();if(typeof window!=='undefined'&&'VRFrameData'in window){frameData=new window.VRFrameData();window.addEventListener('vrdisplaypresentchange',onVRDisplayPresentChange,false);}var matrixWorldInverse=new Matrix4();var tempQuaternion=new Quaternion();var tempPosition=new Vector3();var cameraL=new PerspectiveCamera();cameraL.bounds=new Vector4(0.0,0.0,0.5,1.0);cameraL.layers.enable(1);var cameraR=new PerspectiveCamera();cameraR.bounds=new Vector4(0.5,0.0,0.5,1.0);cameraR.layers.enable(2);var cameraVR=new ArrayCamera([cameraL,cameraR]);cameraVR.layers.enable(1);cameraVR.layers.enable(2);//
  function isPresenting(){return device!==null&&device.isPresenting===true;}var currentSize,currentPixelRatio;function onVRDisplayPresentChange(){if(isPresenting()){var eyeParameters=device.getEyeParameters('left');var renderWidth=eyeParameters.renderWidth;var renderHeight=eyeParameters.renderHeight;currentPixelRatio=renderer.getPixelRatio();currentSize=renderer.getSize();renderer.setDrawingBufferSize(renderWidth*2,renderHeight,1);}else if(scope.enabled){renderer.setDrawingBufferSize(currentSize.width,currentSize.height,currentPixelRatio);}}//
  this.enabled=false;this.userHeight=1.6;this.getDevice=function(){return device;};this.setDevice=function(value){if(value!==undefined)device=value;};this.setPoseTarget=function(object){if(object!==undefined)poseTarget=object;};this.getCamera=function(camera){if(device===null)return camera;device.depthNear=camera.near;device.depthFar=camera.far;device.getFrameData(frameData);//
  var stageParameters=device.stageParameters;if(stageParameters){standingMatrix.fromArray(stageParameters.sittingToStandingTransform);}else{standingMatrix.makeTranslation(0,scope.userHeight,0);}var pose=frameData.pose;var poseObject=poseTarget!==null?poseTarget:camera;// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
  poseObject.matrix.copy(standingMatrix);poseObject.matrix.decompose(poseObject.position,poseObject.quaternion,poseObject.scale);if(pose.orientation!==null){tempQuaternion.fromArray(pose.orientation);poseObject.quaternion.multiply(tempQuaternion);}if(pose.position!==null){tempQuaternion.setFromRotationMatrix(standingMatrix);tempPosition.fromArray(pose.position);tempPosition.applyQuaternion(tempQuaternion);poseObject.position.add(tempPosition);}poseObject.updateMatrixWorld();if(device.isPresenting===false)return camera;//
  cameraL.near=camera.near;cameraR.near=camera.near;cameraL.far=camera.far;cameraR.far=camera.far;cameraVR.matrixWorld.copy(camera.matrixWorld);cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);// TODO (mrdoob) Double check this code
  standingMatrixInverse.getInverse(standingMatrix);cameraL.matrixWorldInverse.multiply(standingMatrixInverse);cameraR.matrixWorldInverse.multiply(standingMatrixInverse);var parent=poseObject.parent;if(parent!==null){matrixWorldInverse.getInverse(parent.matrixWorld);cameraL.matrixWorldInverse.multiply(matrixWorldInverse);cameraR.matrixWorldInverse.multiply(matrixWorldInverse);}// envMap and Mirror needs camera.matrixWorld
  cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);// HACK (mrdoob)
  // https://github.com/w3c/webvr/issues/203
  cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);//
  var layers=device.getLayers();if(layers.length){var layer=layers[0];if(layer.leftBounds!==null&&layer.leftBounds.length===4){cameraL.bounds.fromArray(layer.leftBounds);}if(layer.rightBounds!==null&&layer.rightBounds.length===4){cameraR.bounds.fromArray(layer.rightBounds);}}return cameraVR;};this.getStandingMatrix=function(){return standingMatrix;};this.submitFrame=function(){if(isPresenting())device.submitFrame();};this.dispose=function(){if(typeof window!=='undefined'){window.removeEventListener('vrdisplaypresentchange',onVRDisplayPresentChange);}};}/**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   * @author tschw
   */function WebGLRenderer(parameters){console.log('THREE.WebGLRenderer',REVISION);parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default';var currentRenderList=null;var currentRenderState=null;// public properties
  this.domElement=_canvas;this.context=null;// clearing
  this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
  this.sortObjects=true;// user-defined clipping
  this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
  this.gammaFactor=2.0;// for backwards compatibility
  this.gammaInput=false;this.gammaOutput=false;// physical lights
  this.physicallyCorrectLights=false;// tone mapping
  this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// morphs
  this.maxMorphTargets=8;this.maxMorphNormals=4;// internal properties
  var _this=this,_isContextLost=false,// internal state cache
  _currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,_currentGeometryProgram='',_currentCamera=null,_currentArrayCamera=null,_currentViewport=new Vector4(),_currentScissor=new Vector4(),_currentScissorTest=null,//
  _usedTextureUnits=0,//
  _width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_viewport=new Vector4(0,0,_width,_height),_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,// frustum
  _frustum=new Frustum(),// clipping
  _clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,// camera matrices cache
  _projScreenMatrix=new Matrix4(),_vector3=new Vector3();function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
  var _gl;try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference};// event listeners must be registered before WebGL context is created, see #12753
  _canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw new Error('Error creating WebGL context with your selected attributes.');}else{throw new Error('Error creating WebGL context.');}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
  if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return {'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);}var extensions,capabilities,state,info;var properties,textures,attributes,geometries,objects;var programCache,renderLists,renderStates;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var spriteRenderer;var utils;function initGLContext(){extensions=new WebGLExtensions(_gl);extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_float_linear');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('OES_element_index_uint');extensions.get('ANGLE_instanced_arrays');utils=new WebGLUtils(_gl,extensions);capabilities=new WebGLCapabilities(_gl,extensions,parameters);state=new WebGLState(_gl,extensions,utils);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);attributes=new WebGLAttributes(_gl);geometries=new WebGLGeometries(_gl,attributes,info);objects=new WebGLObjects(geometries,info);morphtargets=new WebGLMorphtargets(_gl);programCache=new WebGLPrograms(_this,extensions,capabilities);renderLists=new WebGLRenderLists();renderStates=new WebGLRenderStates();background=new WebGLBackground(_this,state,geometries,_premultipliedAlpha);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info);spriteRenderer=new WebGLSpriteRenderer(_this,_gl,state,textures,capabilities);info.programs=programCache.programs;_this.context=_gl;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.state=state;_this.info=info;}initGLContext();// vr
  var vr=new WebVRManager(_this);this.vr=vr;// shadow map
  var shadowMap=new WebGLShadowMap(_this,objects,capabilities.maxTextureSize);this.shadowMap=shadowMap;// API
  this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(){return {width:_width,height:_height};};this.setSize=function(width,height,updateStyle){var device=vr.getDevice();if(device&&device.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=width*_pixelRatio;_canvas.height=height*_pixelRatio;if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(){return {width:_width*_pixelRatio,height:_height*_pixelRatio};};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=width*pixelRatio;_canvas.height=height*pixelRatio;this.setViewport(0,0,width,height);};this.getCurrentViewport=function(){return _currentViewport;};this.setViewport=function(x,y,width,height){_viewport.set(x,_height-y-height,width,height);state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));};this.setScissor=function(x,y,width,height){_scissor.set(x,_height-y-height,width,height);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};// Clearing
  this.getClearColor=function(){return background.getClearColor();};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;if(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;if(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};this.clearTarget=function(renderTarget,color,depth,stencil){this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};//
  this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();renderStates.dispose();properties.dispose();objects.dispose();vr.dispose();stopAnimation();};// Events
  function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore()/* event */{console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;initGLContext();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
  function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.remove(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
  function renderObjectImmediate(object,program,material){object.render(function(object){_this.renderBufferImmediate(object,program,material);});}this.renderBufferImmediate=function(object,program,material){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,_gl.FLOAT,false,0,0);}if(object.hasNormals){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);if(!material.isMeshPhongMaterial&&!material.isMeshStandardMaterial&&!material.isMeshNormalMaterial&&material.flatShading===true){for(var i=0,l=object.count*3;i<l;i+=9){var array=object.normalArray;var nx=(array[i+0]+array[i+3]+array[i+6])/3;var ny=(array[i+1]+array[i+4]+array[i+7])/3;var nz=(array[i+2]+array[i+5]+array[i+8])/3;array[i+0]=nx;array[i+1]=ny;array[i+2]=nz;array[i+3]=nx;array[i+4]=ny;array[i+5]=nz;array[i+6]=nx;array[i+7]=ny;array[i+8]=nz;}}_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,_gl.FLOAT,false,0,0);}if(object.hasUvs&&material.map){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(programAttributes.uv,2,_gl.FLOAT,false,0,0);}if(object.hasColors&&material.vertexColors!==NoColors){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,_gl.FLOAT,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(_gl.TRIANGLES,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,fog,geometry,material,object,group){var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;state.setMaterial(material,frontFaceCW);var program=setProgram(camera,fog,material,object);var geometryProgram=geometry.id+'_'+program.id+'_'+(material.wireframe===true);var updateBuffers=false;if(geometryProgram!==_currentGeometryProgram){_currentGeometryProgram=geometryProgram;updateBuffers=true;}if(object.morphTargetInfluences){morphtargets.update(object,geometry,material,program);updateBuffers=true;}//
  var index=geometry.index;var position=geometry.attributes.position;var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}if(updateBuffers){setupVertexAttributes(material,program,geometry);if(index!==null){_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,attribute.buffer);}}//
  var dataCount=Infinity;if(index!==null){dataCount=index.count;}else if(position!==undefined){dataCount=position.count;}var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
  if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else{switch(object.drawMode){case TrianglesDrawMode:renderer.setMode(_gl.TRIANGLES);break;case TriangleStripDrawMode:renderer.setMode(_gl.TRIANGLE_STRIP);break;case TriangleFanDrawMode:renderer.setMode(_gl.TRIANGLE_FAN);break;}}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
  state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else{renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}if(geometry&&geometry.isInstancedBufferGeometry){if(geometry.maxInstancedCount>0){renderer.renderInstances(geometry,drawStart,drawCount);}}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(material,program,geometry){if(geometry&&geometry.isInstancedBufferGeometry){if(extensions.get('ANGLE_instanced_arrays')===null){console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
  if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,offset*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,0);}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Compile
  this.compile=function(scene,camera){currentRenderState=renderStates.get(scene,camera);currentRenderState.init();scene.traverse(function(object){if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights(camera);scene.traverse(function(object){if(object.material){if(Array.isArray(object.material)){for(var i=0;i<object.material.length;i++){initMaterial(object.material[i],scene.fog,object);}}else{initMaterial(object.material,scene.fog,object);}}});};// Animation Loop
  var isAnimating=false;var onAnimationFrame=null;function startAnimation(){if(isAnimating)return;requestAnimationLoopFrame();isAnimating=true;}function stopAnimation(){isAnimating=false;}function requestAnimationLoopFrame(){var device=vr.getDevice();if(device&&device.isPresenting){device.requestAnimationFrame(animationLoop);}else{window.requestAnimationFrame(animationLoop);}}function animationLoop(time){if(isAnimating===false)return;onAnimationFrame(time);requestAnimationLoopFrame();}this.animate=function(callback){onAnimationFrame=callback;onAnimationFrame!==null?startAnimation():stopAnimation();};// Rendering
  this.render=function(scene,camera,renderTarget,forceClear){if(!(camera&&camera.isCamera)){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost)return;// reset caching for this frame
  _currentGeometryProgram='';_currentMaterialId=-1;_currentCamera=null;// update scene graph
  if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
  if(camera.parent===null)camera.updateMatrixWorld();if(vr.enabled){camera=vr.getCamera(camera);}//
  currentRenderState=renderStates.get(scene,camera);currentRenderState.init();scene.onBeforeRender(_this,scene,camera,renderTarget);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,camera);currentRenderList.init();projectObject(scene,camera,_this.sortObjects);if(_this.sortObjects===true){currentRenderList.sort();}//
  if(_clippingEnabled)_clipping.beginShadows();var shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);currentRenderState.setupLights(camera);if(_clippingEnabled)_clipping.endShadows();//
  if(this.info.autoReset)this.info.reset();if(renderTarget===undefined){renderTarget=null;}this.setRenderTarget(renderTarget);//
  background.render(currentRenderList,scene,camera,forceClear);// render scene
  var opaqueObjects=currentRenderList.opaque;var transparentObjects=currentRenderList.transparent;if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);}else{// opaque pass (front-to-back order)
  if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);// transparent pass (back-to-front order)
  if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);}// custom renderers
  var spritesArray=currentRenderState.state.spritesArray;spriteRenderer.render(spritesArray,scene,camera);// Generate mipmap if we're using any kind of mipmap filtering
  if(renderTarget){textures.updateRenderTargetMipmap(renderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
  state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);scene.onAfterRender(_this,scene,camera);if(vr.enabled){vr.submitFrame();}// _gl.finish();
  currentRenderList=null;currentRenderState=null;};/*
  	// TODO Duplicated code (Frustum)

  	var _sphere = new Sphere();

  	function isObjectViewable( object ) {

  		var geometry = object.geometry;

  		if ( geometry.boundingSphere === null )
  			geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere ).
  		applyMatrix4( object.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSpriteViewable( sprite ) {

  		_sphere.center.set( 0, 0, 0 );
  		_sphere.radius = 0.7071067811865476;
  		_sphere.applyMatrix4( sprite.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSphereViewable( sphere ) {

  		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

  		var numPlanes = _clipping.numPlanes;

  		if ( numPlanes === 0 ) return true;

  		var planes = _this.clippingPlanes,

  			center = sphere.center,
  			negRad = - sphere.radius,
  			i = 0;

  		do {

  			// out when deeper than radius in the negative halfspace
  			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

  		} while ( ++ i !== numPlanes );

  		return true;

  	}
  	*/function projectObject(object,camera,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){currentRenderState.pushSprite(object);}}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){object.skeleton.update();}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,_vector3.z,null);}}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,sortObjects);}}function renderObjects(renderList,scene,camera,overrideMaterial){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;if(camera.isArrayCamera){_currentArrayCamera=camera;var cameras=camera.cameras;for(var j=0,jl=cameras.length;j<jl;j++){var camera2=cameras[j];if(object.layers.test(camera2.layers)){var bounds=camera2.bounds;var x=bounds.x*_width;var y=bounds.y*_height;var width=bounds.z*_width;var height=bounds.w*_height;state.viewport(_currentViewport.set(x,y,width,height).multiplyScalar(_pixelRatio));renderObject(object,scene,camera2,geometry,material,group);}}}else{_currentArrayCamera=null;renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;state.setMaterial(material,frontFaceCW);var program=setProgram(camera,scene.fog,material,object);_currentGeometryProgram='';renderObjectImmediate(object,program,material);}else{_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);}function initMaterial(material,fog,object){var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;var shadowsArray=currentRenderState.state.shadowsArray;var parameters=programCache.getParameters(material,lights.state,shadowsArray,fog,_clipping.numPlanes,_clipping.numIntersection,object);var code=programCache.getProgramCode(material,parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
  material.addEventListener('dispose',onMaterialDispose);}else if(program.code!==code){// changed glsl or parameters
  releaseMaterialProgramReference(material);}else if(materialProperties.lightsHash!==lights.state.hash){properties.update(material,'lightsHash',lights.state.hash);programChange=false;}else if(parameters.shaderID!==undefined){// same glsl and uniform list
  return;}else{// only rebuild uniform list
  programChange=false;}if(programChange){if(parameters.shaderID){var shader=ShaderLib[parameters.shaderID];materialProperties.shader={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{materialProperties.shader={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}material.onBeforeCompile(materialProperties.shader,_this);program=programCache.acquireProgram(material,materialProperties.shader,parameters,code);materialProperties.program=program;material.program=program;}var programAttributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(programAttributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(programAttributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.shader.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=fog;// store the light setup it was created for
  materialProperties.lightsHash=lights.state.hash;if(material.lights){// wire up the material to this renderer's lighting state
  uniforms.ambientLightColor.value=lights.state.ambient;uniforms.directionalLights.value=lights.state.directional;uniforms.spotLights.value=lights.state.spot;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.pointLights.value=lights.state.point;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
  }var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setProgram(camera,fog,material,object){_usedTextureUnits=0;var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
  // object instead of the material, once it becomes feasible
  // (#8465, #8379)
  _clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.needsUpdate===false){if(materialProperties.program===undefined){material.needsUpdate=true;}else if(material.fog&&materialProperties.fog!==fog){material.needsUpdate=true;}else if(material.lights&&materialProperties.lightsHash!==lights.state.hash){material.needsUpdate=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){material.needsUpdate=true;}}if(material.needsUpdate){initMaterial(material,fog,object);material.needsUpdate=false;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.shader.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||camera!==_currentCamera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}// Avoid unneeded uniform updates per ArrayCamera's sub-camera
  if(_currentCamera!==(_currentArrayCamera||camera)){_currentCamera=_currentArrayCamera||camera;// lighting uniforms depend on the camera so enforce an update
  // now, in case this material supports lights - or later, when
  // the next material that does gets activated:
  refreshMaterial=true;// set to true on material change
  refreshLights=true;// remains set until update done
  }// load material specific uniforms
  // (shader material also gets them for the sake of genericity)
  if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning uniforms must be set even if material didn't change
  // auto-setting of texture unit for bone texture must go before other textures
  // not sure why, but otherwise weird things happen
  if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){var bones=skeleton.bones;if(capabilities.floatVertexTextures){if(skeleton.boneTexture===undefined){// layout (1 matrix = 4 pixels)
  //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
  var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
  size=_Math.ceilPowerOfTwo(size);size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
  boneMatrices.set(skeleton.boneMatrices);// copy current values
  var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);boneTexture.needsUpdate=true;skeleton.boneMatrices=boneMatrices;skeleton.boneTexture=boneTexture;skeleton.boneTextureSize=size;}p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);if(material.lights){// the current material requires lighting info
  // note: all lighting uniforms are always set correctly
  // they simply reference the renderer's state for their
  // values
  //
  // use the current material's .needsUpdate flags to set
  // the GL state when required
  markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
  if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial){refreshUniformsCommon(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(m_uniforms,material);if(material.isMeshToonMaterial){refreshUniformsToon(m_uniforms,material);}else{refreshUniformsPhong(m_uniforms,material);}}else if(material.isMeshStandardMaterial){refreshUniformsCommon(m_uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material);}else{refreshUniformsStandard(m_uniforms,material);}}else if(material.isMeshDepthMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDepth(m_uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDistance(m_uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsNormal(m_uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(m_uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isShadowMaterial){m_uniforms.color.value=material.color;m_uniforms.opacity.value=material.opacity;}// RectAreaLight Texture
  // TODO (mrdoob): Find a nicer implementation
  if(m_uniforms.ltc_1!==undefined)m_uniforms.ltc_1.value=UniformsLib.LTC_1;if(m_uniforms.ltc_2!==undefined)m_uniforms.ltc_2.value=UniformsLib.LTC_2;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);material.uniformsNeedUpdate=false;}// common matrices
  p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// Uniforms (refresh uniforms objects)
  function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value=material.color;}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}if(material.envMap){uniforms.envMap.value=material.envMap;// don't flip CubeTexture envMaps, flip everything else:
  //  WebGLRenderTargetCube will be flipped for backwards compatibility
  //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  uniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;uniforms.maxMipLevel.value=properties.get(material.envMap).__maxMipLevel;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
  // 1. color map
  // 2. specular map
  // 3. normal map
  // 4. bump map
  // 5. alpha map
  // 6. emissive map
  var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
  if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;uniforms.map.value=material.map;if(material.map!==null){if(material.map.matrixAutoUpdate===true){material.map.updateMatrix();}uniforms.uvTransform.value.copy(material.map.matrix);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value=fog.color;if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value=material.specular;uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
  if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){refreshUniformsPhong(uniforms,material);if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
  uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material){uniforms.clearCoat.value=material.clearCoat;uniforms.clearCoatRoughness.value=material.clearCoatRoughness;refreshUniformsStandard(uniforms,material);}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
  function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}// Textures
  function allocTextureUnit(){var textureUnit=_usedTextureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('THREE.WebGLRenderer: Trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}_usedTextureUnits+=1;return textureUnit;}this.allocTextureUnit=allocTextureUnit;// this.setTexture2D = setTexture2D;
  this.setTexture2D=function(){var warned=false;// backwards compatibility: peel texture.texture
  return function setTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(!warned){console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}textures.setTexture2D(texture,slot);};}();this.setTexture=function(){var warned=false;return function setTexture(texture,slot){if(!warned){console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");warned=true;}textures.setTexture2D(texture,slot);};}();this.setTextureCube=function(){var warned=false;return function setTextureCube(texture,slot){// backwards compatibility: peel texture.texture
  if(texture&&texture.isWebGLRenderTargetCube){if(!warned){console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
  // TODO: unify these code paths
  if(texture&&texture.isCubeTexture||Array.isArray(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
  // this function alone should take care of cube textures
  textures.setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLRenderTargetCube
  textures.setTextureCubeDynamic(texture,slot);}};}();this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){_currentRenderTarget=renderTarget;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var framebuffer=null;var isCube=false;if(renderTarget){var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLRenderTargetCube){framebuffer=__webglFramebuffer[renderTarget.activeCubeFace];isCube=true;}else{framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else{_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);_currentScissorTest=_scissorTest;}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_currentFramebuffer=framebuffer;}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)
  !(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
  !(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
  if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);}}}};this.copyFramebufferToTexture=function(position,texture,level){var width=texture.image.width;var height=texture.image.height;var glFormat=utils.convert(texture.format);this.setTexture2D(texture,0);_gl.copyTexImage2D(_gl.TEXTURE_2D,level||0,glFormat,position.x,position.y,width,height,0);};this.copyTextureToTexture=function(position,srcTexture,dstTexture,level){var width=srcTexture.image.width;var height=srcTexture.image.height;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);var pixels=srcTexture.isDataTexture?srcTexture.image.data:srcTexture.image;this.setTexture2D(dstTexture,0);_gl.texSubImage2D(_gl.TEXTURE_2D,level||0,position.x,position.y,width,height,glFormat,glType,pixels);};}/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function FogExp2(color,density){this.name='';this.color=new Color(color);this.density=density!==undefined?density:0.00025;}FogExp2.prototype.isFogExp2=true;FogExp2.prototype.clone=function(){return new FogExp2(this.color.getHex(),this.density);};FogExp2.prototype.toJSON=function()/* meta */{return {type:'FogExp2',color:this.color.getHex(),density:this.density};};/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function Fog(color,near,far){this.name='';this.color=new Color(color);this.near=near!==undefined?near:1;this.far=far!==undefined?far:1000;}Fog.prototype.isFog=true;Fog.prototype.clone=function(){return new Fog(this.color.getHex(),this.near,this.far);};Fog.prototype.toJSON=function()/* meta */{return {type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};};/**
   * @author mrdoob / http://mrdoob.com/
   */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
  }Scene.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Scene,copy:function(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}});/**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *	uvOffset: new THREE.Vector2(),
   *	uvScale: new THREE.Vector2()
   * }
   */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.rotation=0;this.fog=false;this.lights=false;this.setValues(parameters);}SpriteMaterial.prototype=Object.create(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.isSpriteMaterial=true;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.rotation=source.rotation;return this;};/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */function Sprite(material){Object3D.call(this);this.type='Sprite';this.material=material!==undefined?material:new SpriteMaterial();this.center=new Vector2(0.5,0.5);}Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function(){var intersectPoint=new Vector3();var worldPosition=new Vector3();var worldScale=new Vector3();return function raycast(raycaster,intersects){worldPosition.setFromMatrixPosition(this.matrixWorld);raycaster.ray.closestPointToPoint(worldPosition,intersectPoint);worldScale.setFromMatrixScale(this.matrixWorld);var guessSizeSq=worldScale.x*worldScale.y/4;if(worldPosition.distanceToSquared(intersectPoint)>guessSizeSq)return;var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:intersectPoint.clone(),face:null,object:this});};}(),clone:function(){return new this.constructor(this.material).copy(this);},copy:function(source){Object3D.prototype.copy.call(this,source);if(source.center!==undefined)this.center.copy(source.center);return this;}});/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */function LOD(){Object3D.call(this);this.type='LOD';Object.defineProperties(this,{levels:{enumerable:true,value:[]}});}LOD.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LOD,copy:function(source){Object3D.prototype.copy.call(this,source,false);var levels=source.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];this.addLevel(level.object.clone(),level.distance);}return this;},addLevel:function(object,distance){if(distance===undefined)distance=0;distance=Math.abs(distance);var levels=this.levels;for(var l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);},getObjectForDistance:function(distance){var levels=this.levels;for(var i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;},raycast:function(){var matrixPosition=new Vector3();return function raycast(raycaster,intersects){matrixPosition.setFromMatrixPosition(this.matrixWorld);var distance=raycaster.ray.origin.distanceTo(matrixPosition);this.getObjectForDistance(distance).raycast(raycaster,intersects);};}(),update:function(){var v1=new Vector3();var v2=new Vector3();return function update(camera){var levels=this.levels;if(levels.length>1){v1.setFromMatrixPosition(camera.matrixWorld);v2.setFromMatrixPosition(this.matrixWorld);var distance=v1.distanceTo(v2);levels[0].object.visible=true;for(var i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}for(;i<l;i++){levels[i].object.visible=false;}}};}(),toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.levels=[];var levels=this.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}});/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */function Skeleton(bones,boneInverses){// copy the bone array
  bones=bones||[];this.bones=bones.slice(0);this.boneMatrices=new Float32Array(this.bones.length*16);// use the supplied bone inverses or calculate the inverses
  if(boneInverses===undefined){this.calculateInverses();}else{if(this.bones.length===boneInverses.length){this.boneInverses=boneInverses.slice(0);}else{console.warn('THREE.Skeleton boneInverses is the wrong length.');this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){this.boneInverses.push(new Matrix4());}}}}Object.assign(Skeleton.prototype,{calculateInverses:function(){this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){var inverse=new Matrix4();if(this.bones[i]){inverse.getInverse(this.bones[i].matrixWorld);}this.boneInverses.push(inverse);}},pose:function(){var bone,i,il;// recover the bind-time world matrices
  for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){bone.matrixWorld.getInverse(this.boneInverses[i]);}}// compute the local matrices, positions, rotations and scales
  for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.getInverse(bone.parent.matrixWorld);bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}},update:function(){var offsetMatrix=new Matrix4();var identityMatrix=new Matrix4();return function update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
  for(var i=0,il=bones.length;i<il;i++){// compute the offset between the current and the original transform
  var matrix=bones[i]?bones[i].matrixWorld:identityMatrix;offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);offsetMatrix.toArray(boneMatrices,i*16);}if(boneTexture!==undefined){boneTexture.needsUpdate=true;}};}(),clone:function(){return new Skeleton(this.bones,this.boneInverses);},getBoneByName:function(name){for(var i=0,il=this.bones.length;i<il;i++){var bone=this.bones[i];if(bone.name===name){return bone;}}return undefined;}});/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */function Bone(){Object3D.call(this);this.type='Bone';}Bone.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Bone,isBone:true});/**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */function SkinnedMesh(geometry,material){Mesh.call(this,geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();var bones=this.initBones();var skeleton=new Skeleton(bones);this.bind(skeleton,this.matrixWorld);this.normalizeSkinWeights();}SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:true,initBones:function(){var bones=[],bone,gbone;var i,il;if(this.geometry&&this.geometry.bones!==undefined){// first, create array of 'Bone' objects from geometry data
  for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];// create new 'Bone' object
  bone=new Bone();bones.push(bone);// apply values
  bone.name=gbone.name;bone.position.fromArray(gbone.pos);bone.quaternion.fromArray(gbone.rotq);if(gbone.scl!==undefined)bone.scale.fromArray(gbone.scl);}// second, create bone hierarchy
  for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];if(gbone.parent!==-1&&gbone.parent!==null&&bones[gbone.parent]!==undefined){// subsequent bones in the hierarchy
  bones[gbone.parent].add(bones[i]);}else{// topmost bone, immediate child of the skinned mesh
  this.add(bones[i]);}}}// now the bones are part of the scene graph and children of the skinned mesh.
  // let's update the corresponding matrices
  this.updateMatrixWorld(true);return bones;},bind:function(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.getInverse(bindMatrix);},pose:function(){this.skeleton.pose();},normalizeSkinWeights:function(){var scale,i;if(this.geometry&&this.geometry.isGeometry){for(i=0;i<this.geometry.skinWeights.length;i++){var sw=this.geometry.skinWeights[i];scale=1.0/sw.manhattanLength();if(scale!==Infinity){sw.multiplyScalar(scale);}else{sw.set(1,0,0,0);// do something reasonable
  }}}else if(this.geometry&&this.geometry.isBufferGeometry){var vec=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(i=0;i<skinWeight.count;i++){vec.x=skinWeight.getX(i);vec.y=skinWeight.getY(i);vec.z=skinWeight.getZ(i);vec.w=skinWeight.getW(i);scale=1.0/vec.manhattanLength();if(scale!==Infinity){vec.multiplyScalar(scale);}else{vec.set(1,0,0,0);// do something reasonable
  }skinWeight.setXYZW(i,vec.x,vec.y,vec.z,vec.w);}}},updateMatrixWorld:function(force){Mesh.prototype.updateMatrixWorld.call(this,force);if(this.bindMode==='attached'){this.bindMatrixInverse.getInverse(this.matrixWorld);}else if(this.bindMode==='detached'){this.bindMatrixInverse.getInverse(this.bindMatrix);}else{console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}},clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.lights=false;this.setValues(parameters);}LineBasicMaterial.prototype=Object.create(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
   * @author mrdoob / http://mrdoob.com/
   */function Line(geometry,material,mode){if(mode===1){console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');return new LineSegments(geometry,material);}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});}Line.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Line,isLine:true,computeLineDistances:function(){var start=new Vector3();var end=new Vector3();return function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[0];for(var i=1,l=positionAttribute.count;i<l;i++){start.fromBufferAttribute(positionAttribute,i-1);end.fromBufferAttribute(positionAttribute,i);lineDistances[i]=lineDistances[i-1];lineDistances[i]+=start.distanceTo(end);}geometry.addAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){var vertices=geometry.vertices;var lineDistances=geometry.lineDistances;lineDistances[0]=0;for(var i=1,l=vertices.length;i<l;i++){lineDistances[i]=lineDistances[i-1];lineDistances[i]+=vertices[i-1].distanceTo(vertices[i]);}}return this;};}(),raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var precision=raycaster.linePrecision;var precisionSq=precision*precision;var geometry=this.geometry;var matrixWorld=this.matrixWorld;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
  inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
  var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
  // point: raycaster.ray.at( distance ),
  point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
   * @author mrdoob / http://mrdoob.com/
   */function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:true,computeLineDistances:function(){var start=new Vector3();var end=new Vector3();return function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
  if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[];for(var i=0,l=positionAttribute.count;i<l;i+=2){start.fromBufferAttribute(positionAttribute,i);end.fromBufferAttribute(positionAttribute,i+1);lineDistances[i]=i===0?0:lineDistances[i-1];lineDistances[i+1]=lineDistances[i]+start.distanceTo(end);}geometry.addAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){var vertices=geometry.vertices;var lineDistances=geometry.lineDistances;for(var i=0,l=vertices.length;i<l;i+=2){start.copy(vertices[i]);end.copy(vertices[i+1]);lineDistances[i]=i===0?0:lineDistances[i-1];lineDistances[i+1]=lineDistances[i]+start.distanceTo(end);}}return this;};}()});/**
   * @author mgreter / http://github.com/mgreter
   */function LineLoop(geometry,material){Line.call(this,geometry,material);this.type='LineLoop';}LineLoop.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineLoop,isLineLoop:true});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   * }
   */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.size=1;this.sizeAttenuation=true;this.lights=false;this.setValues(parameters);}PointsMaterial.prototype=Object.create(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
   * @author alteredq / http://alteredqualia.com/
   */function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var object=this;var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
  if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(sphere)===false)return;//
  inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var position=new Vector3();var intersectPoint=new Vector3();function testPoint(point,index){var rayPointDistanceSq=ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){ray.closestPointToPoint(point,intersectPoint);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint.clone(),index:index,face:null,object:object});}}if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];position.fromArray(positions,a*3);testPoint(position,a);}}else{for(var i=0,l=positions.length/3;i<l;i++){position.fromArray(positions,i*3);testPoint(position,i);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i);}}};}(),clone:function(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
   * @author mrdoob / http://mrdoob.com/
   */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Group,isGroup:true});/**
   * @author mrdoob / http://mrdoob.com/
   */function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.generateMipmaps=false;}VideoTexture.prototype=Object.assign(Object.create(Texture.prototype),{constructor:VideoTexture,isVideoTexture:true,update:function(){var video=this.image;if(video.readyState>=video.HAVE_CURRENT_DATA){this.needsUpdate=true;}}});/**
   * @author alteredq / http://alteredqualia.com/
   */function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
  // (also flipping doesn't work for compressed textures )
  this.flipY=false;// can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files
  this.generateMipmaps=false;}CompressedTexture.prototype=Object.create(Texture.prototype);CompressedTexture.prototype.constructor=CompressedTexture;CompressedTexture.prototype.isCompressedTexture=true;/**
   * @author Matt DesLauriers / @mattdesl
   * @author atix / arthursilber.de
   */function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}DepthTexture.prototype=Object.create(Texture.prototype);DepthTexture.prototype.constructor=DepthTexture;DepthTexture.prototype.isDepthTexture=true;/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */function WireframeGeometry(geometry){BufferGeometry.call(this);this.type='WireframeGeometry';// buffer
  var vertices=[];// helper variables
  var i,j,l,o,ol;var edge=[0,0],edges={},e,edge1,edge2;var key,keys=['a','b','c'];var vertex;// different logic for Geometry and BufferGeometry
  if(geometry&&geometry.isGeometry){// create a data structure that contains all edges without duplicates
  var faces=geometry.faces;for(i=0,l=faces.length;i<l;i++){var face=faces[i];for(j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
  edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}// generate vertices
  for(key in edges){e=edges[key];vertex=geometry.vertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=geometry.vertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}else if(geometry&&geometry.isBufferGeometry){var position,indices,groups;var group,start,count;var index1,index2;vertex=new Vector3();if(geometry.index!==null){// indexed BufferGeometry
  position=geometry.attributes.position;indices=geometry.index;groups=geometry.groups;if(groups.length===0){groups=[{start:0,count:indices.count,materialIndex:0}];}// create a data structure that contains all eges without duplicates
  for(o=0,ol=groups.length;o<ol;++o){group=groups[o];start=group.start;count=group.count;for(i=start,l=start+count;i<l;i+=3){for(j=0;j<3;j++){edge1=indices.getX(i+j);edge2=indices.getX(i+(j+1)%3);edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
  edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}}// generate vertices
  for(key in edges){e=edges[key];vertex.fromBufferAttribute(position,e.index1);vertices.push(vertex.x,vertex.y,vertex.z);vertex.fromBufferAttribute(position,e.index2);vertices.push(vertex.x,vertex.y,vertex.z);}}else{// non-indexed BufferGeometry
  position=geometry.attributes.position;for(i=0,l=position.count/3;i<l;i++){for(j=0;j<3;j++){// three edges per triangle, an edge is represented as (index1, index2)
  // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
  index1=3*i+j;vertex.fromBufferAttribute(position,index1);vertices.push(vertex.x,vertex.y,vertex.z);index2=3*i+(j+1)%3;vertex.fromBufferAttribute(position,index2);vertices.push(vertex.x,vertex.y,vertex.z);}}}}// build geometry
  this.addAttribute('position',new Float32BufferAttribute(vertices,3));}WireframeGeometry.prototype=Object.create(BufferGeometry.prototype);WireframeGeometry.prototype.constructor=WireframeGeometry;/**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
   */ // ParametricGeometry
  function ParametricGeometry(func,slices,stacks){Geometry.call(this);this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));this.mergeVertices();}ParametricGeometry.prototype=Object.create(Geometry.prototype);ParametricGeometry.prototype.constructor=ParametricGeometry;// ParametricBufferGeometry
  function ParametricBufferGeometry(func,slices,stacks){BufferGeometry.call(this);this.type='ParametricBufferGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];var EPS=0.00001;var normal=new Vector3();var p0=new Vector3(),p1=new Vector3();var pu=new Vector3(),pv=new Vector3();var i,j;// generate vertices, normals and uvs
  var sliceCount=slices+1;for(i=0;i<=stacks;i++){var v=i/stacks;for(j=0;j<=slices;j++){var u=j/slices;// vertex
  func(u,v,p0);vertices.push(p0.x,p0.y,p0.z);// normal
  // approximate tangent vectors via finite differences
  if(u-EPS>=0){func(u-EPS,v,p1);pu.subVectors(p0,p1);}else{func(u+EPS,v,p1);pu.subVectors(p1,p0);}if(v-EPS>=0){func(u,v-EPS,p1);pv.subVectors(p0,p1);}else{func(u,v+EPS,p1);pv.subVectors(p1,p0);}// cross product of tangent vectors returns surface normal
  normal.crossVectors(pu,pv).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u,v);}}// generate indices
  for(i=0;i<stacks;i++){for(j=0;j<slices;j++){var a=i*sliceCount+j;var b=i*sliceCount+j+1;var c=(i+1)*sliceCount+j+1;var d=(i+1)*sliceCount+j;// faces one and two
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;/**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */ // PolyhedronGeometry
  function PolyhedronGeometry(vertices,indices,radius,detail){Geometry.call(this);this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));this.mergeVertices();}PolyhedronGeometry.prototype=Object.create(Geometry.prototype);PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;// PolyhedronBufferGeometry
  function PolyhedronBufferGeometry(vertices,indices,radius,detail){BufferGeometry.call(this);this.type='PolyhedronBufferGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};radius=radius||1;detail=detail||0;// default buffer data
  var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
  subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
  appplyRadius(radius);// finally, create the uv data
  generateUVs();// build non-indexed geometry
  this.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){this.computeVertexNormals();// flat normals
  }else{this.normalizeNormals();// smooth normals
  }// helper functions
  function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
  for(var i=0;i<indices.length;i+=3){// get the vertices of the face
  getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
  subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=Math.pow(2,detail);// we use this multidimensional array as a data structure for creating the subdivision
  var v=[];var i,j;// construct all of the vertices for this subdivision
  for(i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
  for(i=0;i<cols;i++){for(j=0;j<2*(cols-i)-1;j++){var k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function appplyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
  for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
  for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
  var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
  if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
  function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
  function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}PolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;/**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */ // TetrahedronGeometry
  function TetrahedronGeometry(radius,detail){Geometry.call(this);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));this.mergeVertices();}TetrahedronGeometry.prototype=Object.create(Geometry.prototype);TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;// TetrahedronBufferGeometry
  function TetrahedronBufferGeometry(radius,detail){var vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];var indices=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='TetrahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}TetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;/**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */ // OctahedronGeometry
  function OctahedronGeometry(radius,detail){Geometry.call(this);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));this.mergeVertices();}OctahedronGeometry.prototype=Object.create(Geometry.prototype);OctahedronGeometry.prototype.constructor=OctahedronGeometry;// OctahedronBufferGeometry
  function OctahedronBufferGeometry(radius,detail){var vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];var indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='OctahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}OctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;/**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */ // IcosahedronGeometry
  function IcosahedronGeometry(radius,detail){Geometry.call(this);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));this.mergeVertices();}IcosahedronGeometry.prototype=Object.create(Geometry.prototype);IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;// IcosahedronBufferGeometry
  function IcosahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='IcosahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}IcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;/**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */ // DodecahedronGeometry
  function DodecahedronGeometry(radius,detail){Geometry.call(this);this.type='DodecahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));this.mergeVertices();}DodecahedronGeometry.prototype=Object.create(Geometry.prototype);DodecahedronGeometry.prototype.constructor=DodecahedronGeometry;// DodecahedronBufferGeometry
  function DodecahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var r=1/t;var vertices=[// (Â±1, Â±1, Â±1)
  -1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, Â±1/Ï, Â±Ï)
  0,-r,-t,0,-r,t,0,r,-t,0,r,t,// (Â±1/Ï, Â±Ï, 0)
  -r,-t,0,-r,t,0,r,-t,0,r,t,0,// (Â±Ï, 0, Â±1/Ï)
  -t,0,-r,t,0,-r,-t,0,r,t,0,r];var indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='DodecahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}DodecahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;/**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */ // TubeGeometry
  function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){Geometry.call(this);this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);// expose internals
  this.tangents=bufferGeometry.tangents;this.normals=bufferGeometry.normals;this.binormals=bufferGeometry.binormals;// create geometry
  this.fromBufferGeometry(bufferGeometry);this.mergeVertices();}TubeGeometry.prototype=Object.create(Geometry.prototype);TubeGeometry.prototype.constructor=TubeGeometry;// TubeBufferGeometry
  function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){BufferGeometry.call(this);this.type='TubeBufferGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};tubularSegments=tubularSegments||64;radius=radius||1;radialSegments=radialSegments||8;closed=closed||false;var frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
  this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
  var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var P=new Vector3();var i,j;// buffer
  var vertices=[];var normals=[];var uvs=[];var indices=[];// create buffer data
  generateBufferData();// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
  function generateBufferData(){for(i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
  // at the regular position on the given path
  //
  // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
  generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
  // this makes it easy compute correct values for closed geometries
  generateUVs();// finally create faces
  generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
  P=path.getPointAt(i/tubularSegments,P);// retrieve corresponding normal and binormal
  var N=frames.normals[i];var B=frames.binormals[i];// generate normals and vertices for the current segment
  for(j=0;j<=radialSegments;j++){var v=j/radialSegments*Math.PI*2;var sin=Math.sin(v);var cos=-Math.cos(v);// normal
  normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
  vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(i=0;i<=tubularSegments;i++){for(j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}TubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;/**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */ // TorusKnotGeometry
  function TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){Geometry.call(this);this.type='TorusKnotGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};if(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');this.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));this.mergeVertices();}TorusKnotGeometry.prototype=Object.create(Geometry.prototype);TorusKnotGeometry.prototype.constructor=TorusKnotGeometry;// TorusKnotBufferGeometry
  function TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){BufferGeometry.call(this);this.type='TorusKnotBufferGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};radius=radius||1;tube=tube||0.4;tubularSegments=Math.floor(tubularSegments)||64;radialSegments=Math.floor(radialSegments)||8;p=p||2;q=q||3;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var i,j;var vertex=new Vector3();var normal=new Vector3();var P1=new Vector3();var P2=new Vector3();var B=new Vector3();var T=new Vector3();var N=new Vector3();// generate vertices, normals and uvs
  for(i=0;i<=tubularSegments;++i){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
  var u=i/tubularSegments*p*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
  calculatePositionOnCurve(u,p,q,radius,P1);calculatePositionOnCurve(u+0.01,p,q,radius,P2);// calculate orthonormal basis
  T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);// normalize B, N. T can be ignored, we don't use it
  B.normalize();N.normalize();for(j=0;j<=radialSegments;++j){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
  var v=j/radialSegments*Math.PI*2;var cx=-tube*Math.cos(v);var cy=tube*Math.sin(v);// now calculate the final vertex position.
  // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
  vertex.x=P1.x+(cx*N.x+cy*B.x);vertex.y=P1.y+(cx*N.y+cy*B.y);vertex.z=P1.z+(cx*N.z+cy*B.z);vertices.push(vertex.x,vertex.y,vertex.z);// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
  normal.subVectors(vertex,P1).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
  for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){// indices
  var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// this function calculates the current position on the torus curve
  function calculatePositionOnCurve(u,p,q,radius,position){var cu=Math.cos(u);var su=Math.sin(u);var quOverP=q/p*u;var cs=Math.cos(quOverP);position.x=radius*(2+cs)*0.5*cu;position.y=radius*(2+cs)*su*0.5;position.z=radius*Math.sin(quOverP)*0.5;}}TorusKnotBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;/**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */ // TorusGeometry
  function TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){Geometry.call(this);this.type='TorusGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};this.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));this.mergeVertices();}TorusGeometry.prototype=Object.create(Geometry.prototype);TorusGeometry.prototype.constructor=TorusGeometry;// TorusBufferGeometry
  function TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){BufferGeometry.call(this);this.type='TorusBufferGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};radius=radius||1;tube=tube||0.4;radialSegments=Math.floor(radialSegments)||8;tubularSegments=Math.floor(tubularSegments)||6;arc=arc||Math.PI*2;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var center=new Vector3();var vertex=new Vector3();var normal=new Vector3();var j,i;// generate vertices, normals and uvs
  for(j=0;j<=radialSegments;j++){for(i=0;i<=tubularSegments;i++){var u=i/tubularSegments*arc;var v=j/radialSegments*Math.PI*2;// vertex
  vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);normal.subVectors(vertex,center).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
  for(j=1;j<=radialSegments;j++){for(i=1;i<=tubularSegments;i++){// indices
  var a=(tubularSegments+1)*j+i-1;var b=(tubularSegments+1)*(j-1)+i-1;var c=(tubularSegments+1)*(j-1)+i;var d=(tubularSegments+1)*j+i;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}TorusBufferGeometry.prototype=Object.create(BufferGeometry.prototype);TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;/**
   * @author Mugen87 / https://github.com/Mugen87
   * Port from https://github.com/mapbox/earcut (v2.1.2)
   */var Earcut={triangulate:function(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
  invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}};// create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim)last=insertNode(i,data[i],data[i+1],last);}else{for(i=end-dim;i>=start;i-=dim)last=insertNode(i,data[i],data[i+1],last);}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
  function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
  if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
  while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
  triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertice leads to less sliver triangles
  ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
  if(ear===stop){// try filtering points and slicing again
  if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
  }else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
  }else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear
  var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0){return false;}p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed
  var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
  var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);// first look for points inside the triangle in increasing z-order
  var p=ear.nextZ;while(p&&p.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.nextZ;}// then look for points in decreasing z-order
  p=ear.prevZ;while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}return true;}// go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
  removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently
  function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
  var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
  var c=splitPolygon(a,b);// filter colinear points around the cuts
  a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
  earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
  for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
  function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point
  var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
  if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order
  function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
  x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
  function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
  function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return (cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle
  function area(p,q,r){return (q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
  function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
  function intersects(p1,q1,p2,q2){if(equals(p1,q1)&&equals(p2,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b)){return true;}p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
  function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x){inside=!inside;}p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertice index in coordinates array
  this.i=i;// vertex coordinates
  this.x=x;this.y=y;// previous and next vertice nodes in a polygon ring
  this.prev=null;this.next=null;// z-order curve value
  this.z=null;// previous and next nodes in z-order
  this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
  this.steiner=false;}function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */var ShapeUtils={// calculate area of the contour polygon
  area:function(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},isClockWise:function(pts){return ShapeUtils.area(pts)<0;},triangulateShape:function(contour,holes){var vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
  var holeIndices=[];// array of hole indices
  var faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
  removeDupEndPts(contour);addContour(vertices,contour);//
  var holeIndex=contour.length;holes.forEach(removeDupEndPts);for(var i=0;i<holes.length;i++){holeIndices.push(holeIndex);holeIndex+=holes[i].length;addContour(vertices,holes[i]);}//
  var triangles=Earcut.triangulate(vertices,holeIndices);//
  for(var i=0;i<triangles.length;i+=3){faces.push(triangles.slice(i,i+3));}return faces;}};function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}function addContour(vertices,contour){for(var i=0;i<contour.length;i++){vertices.push(contour[i].x);vertices.push(contour[i].y);}}/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  amount: <int>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline is bevel
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */ // ExtrudeGeometry
  function ExtrudeGeometry(shapes,options){Geometry.call(this);this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));this.mergeVertices();}ExtrudeGeometry.prototype=Object.create(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;// ExtrudeBufferGeometry
  function ExtrudeBufferGeometry(shapes,options){BufferGeometry.call(this);this.type='ExtrudeBufferGeometry';this.parameters={shapes:shapes,options:options};shapes=Array.isArray(shapes)?shapes:[shapes];var scope=this;var verticesArray=[];var uvArray=[];for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];addShape(shape,options);}// build geometry
  this.addAttribute('position',new Float32BufferAttribute(verticesArray,3));this.addAttribute('uv',new Float32BufferAttribute(uvArray,2));this.computeVertexNormals();// functions
  function addShape(shape){var placeholder=[];// options
  var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var amount=options.amount!==undefined?options.amount:100;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var extrudePath=options.extrudePath;var uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;//
  var extrudePts,extrudeByPath=false;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
  // SETUP TNB variables
  // TODO1 - have a .isClosed in spline?
  splineTube=extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
  binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
  if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;}// Variables initialization
  var ahole,h,hl;// looping of holes
  var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
  for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
  for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
  function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
  //   shifted by 1 unit (length of normalized vector) to the left
  // if we walk along contour clockwise, this new contour is outside the old one
  //
  // inPt' is the intersection of the two lines parallel to the two
  //  adjacent edges of inPt at a distance of 1 unit on the left side.
  var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
  // good reading for geometry algorithms (here: line-line intersection)
  // http://geomalgorithms.com/a05-_intersect-1.html
  var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
  var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
  // length of vectors for normalizing
  var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
  var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
  var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
  v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
  //  but prevent crazy spikes
  var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
  var direction_eq=false;// assumes: opposite
  if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else{if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
  v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
  v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
  // console.log('i,j,k', i, j , k)
  contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
  oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
  for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
  t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
  for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
  for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize;// Back facing vertices
  for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
  normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
  // Including front facing vertices
  var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,amount/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
  normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
  for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,amount+z);}// expand holes
  for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,amount+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */ // Top and bottom faces
  buildLidFaces();// Sides faces
  buildSideFaces();/////  Internal functions
  function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
  var offset=vlen*layer;// Bottom faces
  for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
  for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
  for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
  for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,0);}// Create faces for the z-sides of the shape
  function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
  layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,1);}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
  var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}}}ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;var WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return [new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<0.01){return [new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return [new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float> // how far from text outline is bevel
   * }
   */ // TextGeometry
  function TextGeometry(text,parameters){Geometry.call(this);this.type='TextGeometry';this.parameters={text:text,parameters:parameters};this.fromBufferGeometry(new TextBufferGeometry(text,parameters));this.mergeVertices();}TextGeometry.prototype=Object.create(Geometry.prototype);TextGeometry.prototype.constructor=TextGeometry;// TextBufferGeometry
  function TextBufferGeometry(text,parameters){parameters=parameters||{};var font=parameters.font;if(!(font&&font.isFont)){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new Geometry();}var shapes=font.generateShapes(text,parameters.size,parameters.curveSegments);// translate parameters to ExtrudeGeometry API
  parameters.amount=parameters.height!==undefined?parameters.height:50;// defaults
  if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;ExtrudeBufferGeometry.call(this,shapes,parameters);this.type='TextBufferGeometry';}TextBufferGeometry.prototype=Object.create(ExtrudeBufferGeometry.prototype);TextBufferGeometry.prototype.constructor=TextBufferGeometry;/**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */ // SphereGeometry
  function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));this.mergeVertices();}SphereGeometry.prototype=Object.create(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;// SphereBufferGeometry
  function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=thetaStart+thetaLength;var ix,iy;var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
  for(iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;for(ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
  vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normal.set(vertex.x,vertex.y,vertex.z).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
  for(iy=0;iy<heightSegments;iy++){for(ix=0;ix<widthSegments;ix++){var a=grid[iy][ix+1];var b=grid[iy][ix];var c=grid[iy+1][ix];var d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */ // RingGeometry
  function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){Geometry.call(this);this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));this.mergeVertices();}RingGeometry.prototype=Object.create(Geometry.prototype);RingGeometry.prototype.constructor=RingGeometry;// RingBufferGeometry
  function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='RingBufferGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};innerRadius=innerRadius||0.5;outerRadius=outerRadius||1;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// some helper variables
  var segment;var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();var j,i;// generate vertices, normals and uvs
  for(j=0;j<=phiSegments;j++){for(i=0;i<=thetaSegments;i++){// values are generate from the inside of the ring to the outside
  segment=thetaStart+i/thetaSegments*thetaLength;// vertex
  vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,0,1);// uv
  uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
  radius+=radiusStep;}// indices
  for(j=0;j<phiSegments;j++){var thetaSegmentLevel=j*(thetaSegments+1);for(i=0;i<thetaSegments;i++){segment=i+thetaSegmentLevel;var a=segment;var b=segment+thetaSegments+1;var c=segment+thetaSegments+2;var d=segment+1;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}RingBufferGeometry.prototype=Object.create(BufferGeometry.prototype);RingBufferGeometry.prototype.constructor=RingBufferGeometry;/**
   * @author astrodud / http://astrodud.isgreat.org/
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */ // LatheGeometry
  function LatheGeometry(points,segments,phiStart,phiLength){Geometry.call(this);this.type='LatheGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};this.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));this.mergeVertices();}LatheGeometry.prototype=Object.create(Geometry.prototype);LatheGeometry.prototype.constructor=LatheGeometry;// LatheBufferGeometry
  function LatheBufferGeometry(points,segments,phiStart,phiLength){BufferGeometry.call(this);this.type='LatheBufferGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};segments=Math.floor(segments)||12;phiStart=phiStart||0;phiLength=phiLength||Math.PI*2;// clamp phiLength so it's in range of [ 0, 2PI ]
  phiLength=_Math.clamp(phiLength,0,Math.PI*2);// buffers
  var indices=[];var vertices=[];var uvs=[];// helper variables
  var base;var inverseSegments=1.0/segments;var vertex=new Vector3();var uv=new Vector2();var i,j;// generate vertices and uvs
  for(i=0;i<=segments;i++){var phi=phiStart+i*inverseSegments*phiLength;var sin=Math.sin(phi);var cos=Math.cos(phi);for(j=0;j<=points.length-1;j++){// vertex
  vertex.x=points[j].x*sin;vertex.y=points[j].y;vertex.z=points[j].x*cos;vertices.push(vertex.x,vertex.y,vertex.z);// uv
  uv.x=i/segments;uv.y=j/(points.length-1);uvs.push(uv.x,uv.y);}}// indices
  for(i=0;i<segments;i++){for(j=0;j<points.length-1;j++){base=j+i*points.length;var a=base;var b=base+points.length;var c=base+points.length+1;var d=base+1;// faces
  indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// generate normals
  this.computeVertexNormals();// if the geometry is closed, we need to average the normals along the seam.
  // because the corresponding vertices are identical (but still have different UVs).
  if(phiLength===Math.PI*2){var normals=this.attributes.normal.array;var n1=new Vector3();var n2=new Vector3();var n=new Vector3();// this is the buffer offset for the last line of vertices
  base=segments*points.length*3;for(i=0,j=0;i<points.length;i++,j+=3){// select the normal of the vertex in the first line
  n1.x=normals[j+0];n1.y=normals[j+1];n1.z=normals[j+2];// select the normal of the vertex in the last line
  n2.x=normals[base+j+0];n2.y=normals[base+j+1];n2.z=normals[base+j+2];// average normals
  n.addVectors(n1,n2).normalize();// assign the new values to both normals
  normals[j+0]=normals[base+j+0]=n.x;normals[j+1]=normals[base+j+1]=n.y;normals[j+2]=normals[base+j+2]=n.z;}}}LatheBufferGeometry.prototype=Object.create(BufferGeometry.prototype);LatheBufferGeometry.prototype.constructor=LatheBufferGeometry;/**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */ // ShapeGeometry
  function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if(typeof curveSegments==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=Object.create(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;ShapeGeometry.prototype.toJSON=function(){var data=Geometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;return toJSON(shapes,data);};// ShapeBufferGeometry
  function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
  if(Array.isArray(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
  groupStart+=groupCount;groupCount=0;}}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
  function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
  if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();// also check if holes are in the opposite direction
  for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
  for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
  for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
  }// incides
  for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;ShapeBufferGeometry.prototype.toJSON=function(){var data=BufferGeometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;return toJSON(shapes,data);};//
  function toJSON(shapes,data){data.shapes=[];if(Array.isArray(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];data.shapes.push(shape.uuid);}}else{data.shapes.push(shapes.uuid);}return data;}/**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */function EdgesGeometry(geometry,thresholdAngle){BufferGeometry.call(this);this.type='EdgesGeometry';this.parameters={thresholdAngle:thresholdAngle};thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;// buffer
  var vertices=[];// helper variables
  var thresholdDot=Math.cos(_Math.DEG2RAD*thresholdAngle);var edge=[0,0],edges={},edge1,edge2;var key,keys=['a','b','c'];// prepare source geometry
  var geometry2;if(geometry.isBufferGeometry){geometry2=new Geometry();geometry2.fromBufferGeometry(geometry);}else{geometry2=geometry.clone();}geometry2.mergeVertices();geometry2.computeFaceNormals();var sourceVertices=geometry2.vertices;var faces=geometry2.faces;// now create a data structure where each entry represents an edge with its adjoining faces
  for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1],face1:i,face2:undefined};}else{edges[key].face2=i;}}}// generate vertices
  for(key in edges){var e=edges[key];// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
  if(e.face2===undefined||faces[e.face1].normal.dot(faces[e.face2].normal)<=thresholdDot){var vertex=sourceVertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=sourceVertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}// build geometry
  this.addAttribute('position',new Float32BufferAttribute(vertices,3));}EdgesGeometry.prototype=Object.create(BufferGeometry.prototype);EdgesGeometry.prototype.constructor=EdgesGeometry;/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */ // CylinderGeometry
  function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){Geometry.call(this);this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));this.mergeVertices();}CylinderGeometry.prototype=Object.create(Geometry.prototype);CylinderGeometry.prototype.constructor=CylinderGeometry;// CylinderBufferGeometry
  function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CylinderBufferGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=this;radiusTop=radiusTop!==undefined?radiusTop:1;radiusBottom=radiusBottom!==undefined?radiusBottom:1;height=height||1;radialSegments=Math.floor(radialSegments)||8;heightSegments=Math.floor(heightSegments)||1;openEnded=openEnded!==undefined?openEnded:false;thetaStart=thetaStart!==undefined?thetaStart:0.0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var index=0;var indexArray=[];var halfHeight=height/2;var groupStart=0;// generate geometry
  generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){var x,y;var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
  var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
  for(y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
  var radius=v*(radiusBottom-radiusTop)+radiusTop;for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
  vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
  uvs.push(u,1-v);// save index of vertex in respective row
  indexRow.push(index++);}// now save vertices of the row in our index array
  indexArray.push(indexRow);}// generate indices
  for(x=0;x<radialSegments;x++){for(y=0;y<heightSegments;y++){// we use the index array to access the correct indices
  var a=indexArray[y][x];var b=indexArray[y+1][x];var c=indexArray[y+1][x+1];var d=indexArray[y][x+1];// faces
  indices.push(a,b,d);indices.push(b,c,d);// update group counter
  groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
  groupStart+=groupCount;}function generateCap(top){var x,centerIndexStart,centerIndexEnd;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// save the index of the first center vertex
  centerIndexStart=index;// first we generate the center vertex data of the cap.
  // because the geometry needs one set of uvs per face,
  // we must generate a center vertex per face/segment
  for(x=1;x<=radialSegments;x++){// vertex
  vertices.push(0,halfHeight*sign,0);// normal
  normals.push(0,sign,0);// uv
  uvs.push(0.5,0.5);// increase index
  index++;}// save the index of the last center vertex
  centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
  for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
  vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,sign,0);// uv
  uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
  index++;}// generate indices
  for(x=0;x<radialSegments;x++){var c=centerIndexStart+x;var i=centerIndexEnd+x;if(top===true){// face top
  indices.push(i,i+1,c);}else{// face bottom
  indices.push(i+1,i,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
  scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
  groupStart+=groupCount;}}CylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;/**
   * @author abelnation / http://github.com/abelnation
   */ // ConeGeometry
  function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeGeometry.prototype=Object.create(CylinderGeometry.prototype);ConeGeometry.prototype.constructor=ConeGeometry;// ConeBufferGeometry
  function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeBufferGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype);ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;/**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */ // CircleGeometry
  function CircleGeometry(radius,segments,thetaStart,thetaLength){Geometry.call(this);this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));this.mergeVertices();}CircleGeometry.prototype=Object.create(Geometry.prototype);CircleGeometry.prototype.constructor=CircleGeometry;// CircleBufferGeometry
  function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CircleBufferGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;segments=segments!==undefined?Math.max(3,segments):8;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
  var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
  var i,s;var vertex=new Vector3();var uv=new Vector2();// center point
  vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(s=0,i=3;s<=segments;s++,i+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
  vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
  normals.push(0,0,1);// uvs
  uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
  for(i=1;i<=segments;i++){indices.push(i,i+1,0);}// build geometry
  this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}CircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;var Geometries=Object.freeze({WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry});/**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  color: <THREE.Color>
   * }
   */function ShadowMaterial(parameters){Material.call(this);this.type='ShadowMaterial';this.color=new Color(0x000000);this.transparent=true;this.setValues(parameters);}ShadowMaterial.prototype=Object.create(Material.prototype);ShadowMaterial.prototype.constructor=ShadowMaterial;ShadowMaterial.prototype.isShadowMaterial=true;ShadowMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);return this;};/**
   * @author mrdoob / http://mrdoob.com/
   */function RawShaderMaterial(parameters){ShaderMaterial.call(this,parameters);this.type='RawShaderMaterial';}RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype);RawShaderMaterial.prototype.constructor=RawShaderMaterial;RawShaderMaterial.prototype.isRawShaderMaterial=true;/**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */function MeshStandardMaterial(parameters){Material.call(this);this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
  this.roughness=0.5;this.metalness=0.5;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshStandardMaterial.prototype=Object.create(Material.prototype);MeshStandardMaterial.prototype.constructor=MeshStandardMaterial;MeshStandardMaterial.prototype.isMeshStandardMaterial=true;MeshStandardMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  reflectivity: <float>
   * }
   */function MeshPhysicalMaterial(parameters){MeshStandardMaterial.call(this);this.defines={'PHYSICAL':''};this.type='MeshPhysicalMaterial';this.reflectivity=0.5;// maps to F0 = 0.04
  this.clearCoat=0.0;this.clearCoatRoughness=0.0;this.setValues(parameters);}MeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype);MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;MeshPhysicalMaterial.prototype.copy=function(source){MeshStandardMaterial.prototype.copy.call(this,source);this.defines={'PHYSICAL':''};this.reflectivity=source.reflectivity;this.clearCoat=source.clearCoat;this.clearCoatRoughness=source.clearCoatRoughness;return this;};/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
  this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=Object.create(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  gradientMap: new THREE.Texture( <Image> )
   * }
   */function MeshToonMaterial(parameters){MeshPhongMaterial.call(this);this.defines={'TOON':''};this.type='MeshToonMaterial';this.gradientMap=null;this.setValues(parameters);}MeshToonMaterial.prototype=Object.create(MeshPhongMaterial.prototype);MeshToonMaterial.prototype.constructor=MeshToonMaterial;MeshToonMaterial.prototype.isMeshToonMaterial=true;MeshToonMaterial.prototype.copy=function(source){MeshPhongMaterial.prototype.copy.call(this,source);this.gradientMap=source.gradientMap;return this;};/**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */function MeshNormalMaterial(parameters){Material.call(this);this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshNormalMaterial.prototype=Object.create(Material.prototype);MeshNormalMaterial.prototype.constructor=MeshNormalMaterial;MeshNormalMaterial.prototype.isMeshNormalMaterial=true;MeshNormalMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */function MeshLambertMaterial(parameters){Material.call(this);this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
  this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshLambertMaterial.prototype=Object.create(Material.prototype);MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;MeshLambertMaterial.prototype.isMeshLambertMaterial=true;MeshLambertMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */function LineDashedMaterial(parameters){LineBasicMaterial.call(this);this.type='LineDashedMaterial';this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters);}LineDashedMaterial.prototype=Object.create(LineBasicMaterial.prototype);LineDashedMaterial.prototype.constructor=LineDashedMaterial;LineDashedMaterial.prototype.isLineDashedMaterial=true;LineDashedMaterial.prototype.copy=function(source){LineBasicMaterial.prototype.copy.call(this,source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;};var Materials=Object.freeze({ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});/**
   * @author mrdoob / http://mrdoob.com/
   */var Cache={enabled:false,files:{},add:function(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
  this.files[key]=file;},get:function(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
  return this.files[key];},remove:function(key){delete this.files[key];},clear:function(){this.files={};}};/**
   * @author mrdoob / http://mrdoob.com/
   */function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false;var itemsLoaded=0;var itemsTotal=0;var urlModifier=undefined;this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};}var DefaultLoadingManager=new LoadingManager();/**
   * @author mrdoob / http://mrdoob.com/
   */var loading={};function FileLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FileLoader.prototype,{load:function(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
  if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Check for data: URI
  var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
  if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64)data=window.atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':var view=new Uint8Array(data.length);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([view.buffer],{type:mimeType});}else{response=view.buffer;}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
  response=data;break;}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  window.setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
  window.setTimeout(function(){if(onError)onError(error);scope.manager.itemEnd(url);scope.manager.itemError(url);},0);}}else{// Initialise array for duplicate requests
  loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=this.response;Cache.add(url,response);var callbacks=loading[url];delete loading[url];if(this.status===200){for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
  // e.g. 'file://' or 'data://'. Handle as success.
  console.warn('THREE.FileLoader: HTTP Status 0 received.');for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else{for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemEnd(url);scope.manager.itemError(url);}},false);request.addEventListener('progress',function(event){var callbacks=loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onProgress)callback.onProgress(event);}},false);request.addEventListener('error',function(event){var callbacks=loading[url];delete loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;},setPath:function(value){this.path=value;return this;},setResponseType:function(value){this.responseType=value;return this;},setWithCredentials:function(value){this.withCredentials=value;return this;},setMimeType:function(value){this.mimeType=value;return this;},setRequestHeader:function(value){this.requestHeader=value;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   *
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   */function CompressedTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
  this._parser=null;}Object.assign(CompressedTextureLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();texture.image=images;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope._parser(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){var loaded=0;for(var i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
  loader.load(url,function(buffer){var texDatas=scope._parser(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;},setPath:function(value){this.path=value;return this;}});/**
   * @author Nikos M. / https://github.com/foo123/
   *
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   */function DataTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
  this._parser=null;}Object.assign(DataTextureLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var texData=scope._parser(buffer);if(!texData)return;if(undefined!==texData.image){texture.image=texData.image;}else if(undefined!==texData.data){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=undefined!==texData.wrapS?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=undefined!==texData.wrapT?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=undefined!==texData.magFilter?texData.magFilter:LinearFilter;texture.minFilter=undefined!==texData.minFilter?texData.minFilter:LinearMipMapLinearFilter;texture.anisotropy=undefined!==texData.anisotropy?texData.anisotropy:1;if(undefined!==texData.format){texture.format=texData.format;}if(undefined!==texData.type){texture.type=texData.type;}if(undefined!==texData.mipmaps){texture.mipmaps=texData.mipmaps;}if(1===texData.mipmapCount){texture.minFilter=LinearFilter;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function ImageLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(ImageLoader.prototype,{crossOrigin:'Anonymous',load:function(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');image.addEventListener('load',function(){Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);},false);/*
  		image.addEventListener( 'progress', function ( event ) {

  			if ( onProgress ) onProgress( event );

  		}, false );
  		*/image.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function CubeTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(CubeTextureLoader.prototype,{crossOrigin:'Anonymous',load:function(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var i=0;i<urls.length;++i){loadTexture(i);}return texture;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function TextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(TextureLoader.prototype,{crossOrigin:'Anonymous',load:function(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  var isJPEG=url.search(/\.(jpg|jpeg)$/)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;},setCrossOrigin:function(value){this.crossOrigin=value;return this;},setPath:function(value){this.path=value;return this;}});/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/ /**************************************************************
   *	Abstract Curve base class
   **************************************************************/function Curve(){this.type='Curve';this.arcLengthDivisions=200;}Object.assign(Curve.prototype,{// Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint:function()/* t, optionalTarget */{console.warn('THREE.Curve: .getPoint() not implemented.');return null;},// Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt:function(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);},// Get sequence of points using getPoint( t )
  getPoints:function(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
  getSpacedPoints:function(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
  getLength:function(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
  getLengths:function(divisions){if(divisions===undefined)divisions=this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
  },updateArcLengths:function(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping:function(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
  if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
  var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
  comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
  }}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
  var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
  var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
  var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent:function(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
  if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
  var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
  for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
  // and in the direction of the minimum tangent xyz component
  normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
  for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>Number.EPSILON){vec.normalize();theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
  normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
  if(closed===true){theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
  normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return {tangents:tangents,normals:normals,binormals:binormals};},clone:function(){return new this.constructor().copy(this);},copy:function(source){this.arcLengthDivisions=source.arcLengthDivisions;return this;},toJSON:function(){var data={metadata:{version:4.5,type:'Curve',generator:'Curve.toJSON'}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data;},fromJSON:function(json){this.arcLengthDivisions=json.arcLengthDivisions;return this;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){Curve.call(this);this.type='EllipseCurve';this.aX=aX||0;this.aY=aY||0;this.xRadius=xRadius||1;this.yRadius=yRadius||1;this.aStartAngle=aStartAngle||0;this.aEndAngle=aEndAngle||2*Math.PI;this.aClockwise=aClockwise||false;this.aRotation=aRotation||0;}EllipseCurve.prototype=Object.create(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
  while(deltaAngle<0)deltaAngle+=twoPi;while(deltaAngle>twoPi)deltaAngle-=twoPi;if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
  x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);};EllipseCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this;};EllipseCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data;};EllipseCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this;};function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);this.type='ArcCurve';}ArcCurve.prototype=Object.create(EllipseCurve.prototype);ArcCurve.prototype.constructor=ArcCurve;ArcCurve.prototype.isArcCurve=true;/**
   * @author zz85 https://github.com/zz85
   *
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */ /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return {initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
  var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
  t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
  var tmp=new Vector3();var px$1=new CubicPoly();var py=new CubicPoly();var pz=new CubicPoly();function CatmullRomCurve3(points,closed,curveType,tension){Curve.call(this);this.type='CatmullRomCurve3';this.points=points||[];this.closed=closed||false;this.curveType=curveType||'centripetal';this.tension=tension||0.5;}CatmullRomCurve3.prototype=Object.create(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.isCatmullRomCurve3=true;CatmullRomCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var points=this.points;var l=points.length;var p=(l-(this.closed?0:1))*t;var intPoint=Math.floor(p);var weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
  if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
  tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
  tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.curveType==='centripetal'||this.curveType==='chordal'){// init Centripetal / Chordal Catmull-Rom
  var pow=this.curveType==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
  if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px$1.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.curveType==='catmullrom'){px$1.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);}point.set(px$1.calc(weight),py.calc(weight),pz.calc(weight));return point;};CatmullRomCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.points=[];for(var i=0,l=source.points.length;i<l;i++){var point=source.points[i];this.points.push(point.clone());}this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this;};CatmullRomCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.points=[];for(var i=0,l=this.points.length;i<l;i++){var point=this.points[i];data.points.push(point.toArray());}data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data;};CatmullRomCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.points=[];for(var i=0,l=json.points.length;i<l;i++){var point=json.points[i];this.points.push(new Vector3().fromArray(point));}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this;};/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/BÃ©zier_curve
   */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return (2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
  function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
  function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}function CubicBezierCurve(v0,v1,v2,v3){Curve.call(this);this.type='CubicBezierCurve';this.v0=v0||new Vector2();this.v1=v1||new Vector2();this.v2=v2||new Vector2();this.v3=v3||new Vector2();}CubicBezierCurve.prototype=Object.create(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.isCubicBezierCurve=true;CubicBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;};CubicBezierCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;};CubicBezierCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;};CubicBezierCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;};function CubicBezierCurve3(v0,v1,v2,v3){Curve.call(this);this.type='CubicBezierCurve3';this.v0=v0||new Vector3();this.v1=v1||new Vector3();this.v2=v2||new Vector3();this.v3=v3||new Vector3();}CubicBezierCurve3.prototype=Object.create(Curve.prototype);CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;CubicBezierCurve3.prototype.isCubicBezierCurve3=true;CubicBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;};CubicBezierCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;};CubicBezierCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;};CubicBezierCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;};function LineCurve(v1,v2){Curve.call(this);this.type='LineCurve';this.v1=v1||new Vector2();this.v2=v2||new Vector2();}LineCurve.prototype=Object.create(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
  LineCurve.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};LineCurve.prototype.getTangent=function()/* t */{var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};LineCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};LineCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};LineCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function LineCurve3(v1,v2){Curve.call(this);this.type='LineCurve3';this.v1=v1||new Vector3();this.v2=v2||new Vector3();}LineCurve3.prototype=Object.create(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.isLineCurve3=true;LineCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
  LineCurve3.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};LineCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};LineCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};LineCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function QuadraticBezierCurve(v0,v1,v2){Curve.call(this);this.type='QuadraticBezierCurve';this.v0=v0||new Vector2();this.v1=v1||new Vector2();this.v2=v2||new Vector2();}QuadraticBezierCurve.prototype=Object.create(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;QuadraticBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;};QuadraticBezierCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};QuadraticBezierCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};QuadraticBezierCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function QuadraticBezierCurve3(v0,v1,v2){Curve.call(this);this.type='QuadraticBezierCurve3';this.v0=v0||new Vector3();this.v1=v1||new Vector3();this.v2=v2||new Vector3();}QuadraticBezierCurve3.prototype=Object.create(Curve.prototype);QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;QuadraticBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;};QuadraticBezierCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};QuadraticBezierCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};QuadraticBezierCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function SplineCurve(points/* array of Vector2 */){Curve.call(this);this.type='SplineCurve';this.points=points||[];}SplineCurve.prototype=Object.create(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var points=this.points;var p=(points.length-1)*t;var intPoint=Math.floor(p);var weight=p-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;};SplineCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.points=[];for(var i=0,l=source.points.length;i<l;i++){var point=source.points[i];this.points.push(point.clone());}return this;};SplineCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.points=[];for(var i=0,l=this.points.length;i<l;i++){var point=this.points[i];data.points.push(point.toArray());}return data;};SplineCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.points=[];for(var i=0,l=json.points.length;i<l;i++){var point=json.points[i];this.points.push(new Vector2().fromArray(point));}return this;};var Curves=Object.freeze({ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   **/ /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/function CurvePath(){Curve.call(this);this.type='CurvePath';this.curves=[];this.autoClose=false;// Automatically closes the path
  }CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function(curve){this.curves.push(curve);},closePath:function(){// Add a line curve if start and end of lines are not connected
  var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint:function(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
  while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
  },// We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength:function(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
  updateArcLengths:function(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();},// Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths:function(){// We use cache values if curves and cache array are same length
  if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
  // Push sums into cached array
  var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function(divisions){if(divisions===undefined)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&curve.isLineCurve?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
  points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},copy:function(source){Curve.prototype.copy.call(this,source);this.curves=[];for(var i=0,l=source.curves.length;i<l;i++){var curve=source.curves[i];this.curves.push(curve.clone());}this.autoClose=source.autoClose;return this;},toJSON:function(){var data=Curve.prototype.toJSON.call(this);data.autoClose=this.autoClose;data.curves=[];for(var i=0,l=this.curves.length;i<l;i++){var curve=this.curves[i];data.curves.push(curve.toJSON());}return data;},fromJSON:function(json){Curve.prototype.fromJSON.call(this,json);this.autoClose=json.autoClose;this.curves=[];for(var i=0,l=json.curves.length;i<l;i++){var curve=json.curves[i];this.curves.push(new Curves[curve.type]().fromJSON(curve));}return this;}});/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Creates free form 2d path using series of points, lines or curves.
   **/function Path(points){CurvePath.call(this);this.type='Path';this.currentPoint=new Vector2();if(points){this.setFromPoints(points);}}Path.prototype=Object.assign(Object.create(CurvePath.prototype),{constructor:Path,setFromPoints:function(points){this.moveTo(points[0].x,points[0].y);for(var i=1,l=points.length;i<l;i++){this.lineTo(points[i].x,points[i].y);}},moveTo:function(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
  },lineTo:function(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);},quadraticCurveTo:function(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},bezierCurveTo:function(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},splineThru:function(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);},arc:function(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);},absarc:function(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);},ellipse:function(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);},absellipse:function(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
  var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);},copy:function(source){CurvePath.prototype.copy.call(this,source);this.currentPoint.copy(source.currentPoint);return this;},toJSON:function(){var data=CurvePath.prototype.toJSON.call(this);data.currentPoint=this.currentPoint.toArray();return data;},fromJSON:function(json){CurvePath.prototype.fromJSON.call(this,json);this.currentPoint.fromArray(json.currentPoint);return this;}});/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Defines a 2d shape plane using paths.
   **/ // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.
  function Shape(points){Path.call(this,points);this.uuid=_Math.generateUUID();this.type='Shape';this.holes=[];}Shape.prototype=Object.assign(Object.create(Path.prototype),{constructor:Shape,getPointsHoles:function(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// get points of shape and holes (keypoints based on segments parameter)
  extractPoints:function(divisions){return {shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},copy:function(source){Path.prototype.copy.call(this,source);this.holes=[];for(var i=0,l=source.holes.length;i<l;i++){var hole=source.holes[i];this.holes.push(hole.clone());}return this;},toJSON:function(){var data=Path.prototype.toJSON.call(this);data.uuid=this.uuid;data.holes=[];for(var i=0,l=this.holes.length;i<l;i++){var hole=this.holes[i];data.holes.push(hole.toJSON());}return data;},fromJSON:function(json){Path.prototype.fromJSON.call(this,json);this.uuid=json.uuid;this.holes=[];for(var i=0,l=json.holes.length;i<l;i++){var hole=json.holes[i];this.holes.push(new Path().fromJSON(hole));}return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Light,isLight:true,copy:function(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
   * @author alteredq / http://alteredqualia.com/
   */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.matrix=new Matrix4();}Object.assign(LightShadow.prototype,{copy:function(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function(){return new this.constructor().copy(this);},toJSON:function(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));}SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:true,update:function(light){var camera=this.camera;var fov=_Math.RAD2DEG*2*light.angle;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}}});/**
   * @author alteredq / http://alteredqualia.com/
   */function SpotLight(color,intensity,distance,angle,penumbra,decay){Light.call(this,color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();Object.defineProperty(this,'power',{get:function(){// intensity = power per solid angle.
  // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  return this.intensity*Math.PI;},set:function(power){// intensity = power per solid angle.
  // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  this.intensity=power/Math.PI;}});this.distance=distance!==undefined?distance:0;this.angle=angle!==undefined?angle:Math.PI/3;this.penumbra=penumbra!==undefined?penumbra:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
  this.shadow=new SpotLightShadow();}SpotLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:SpotLight,isSpotLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function PointLight(color,intensity,distance,decay){Light.call(this,color,intensity);this.type='PointLight';Object.defineProperty(this,'power',{get:function(){// intensity = power per solid angle.
  // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  return this.intensity*4*Math.PI;},set:function(power){// intensity = power per solid angle.
  // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  this.intensity=power/(4*Math.PI);}});this.distance=distance!==undefined?distance:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
  this.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));}PointLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:PointLight,isPointLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow});/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function AmbientLight(color,intensity){Light.call(this,color,intensity);this.type='AmbientLight';this.castShadow=undefined;}AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:AmbientLight,isAmbientLight:true});/**
   * @author abelnation / http://github.com/abelnation
   */function RectAreaLight(color,intensity,width,height){Light.call(this,color,intensity);this.type='RectAreaLight';this.width=width!==undefined?width:10;this.height=height!==undefined?height:10;}RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:true,copy:function(source){Light.prototype.copy.call(this,source);this.width=source.width;this.height=source.height;return this;},toJSON:function(meta){var data=Light.prototype.toJSON.call(this,meta);data.object.width=this.width;data.object.height=this.height;return data;}});/**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function BooleanKeyframeTrack(name,times,values){KeyframeTrack.call(this,name,times,values);}BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
  });/**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}Object.assign(Interpolant.prototype,{evaluate:function(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
  //- slower code:
  //-
  //- 				if ( t >= t1 || t1 === undefined ) {
  forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
  i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
  t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the right side of the index
  right=pp.length;break linear_scan;}//- slower code:
  //-					if ( t < t0 || t0 === undefined ) {
  if(!(t>=t0)){// looping?
  var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
  t0=t1global;}// linear reverse scan
  for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
  this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
  t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
  break seek;}}// prepare binary search on the left side of the index
  right=i1;i1=0;break linear_scan;}// the interval is valid
  break validate_interval;}// linear scan
  // binary search
  while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
  if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
  this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
  return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_;},copySampleValue_:function(index){// copies a sample value to the result buffer
  var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
  interpolate_:function()/* i1, t0, t, t1 */{throw new Error('call to abstract method');// implementations shall return this.resultBuffer
  },intervalChanged_:function()/* i1, t0, t1 */{// empty
  }});//!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign(Interpolant.prototype,{//( 0, t, t0 ), returns this.resultBuffer
  beforeStart_:Interpolant.prototype.copySampleValue_,//( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_:Interpolant.prototype.copySampleValue_});/**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
  DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
  });/**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
  });/**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
  // DefaultInterpolation is inherited
  });/**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
  iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
  iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
  // f''(t0) = 0 a.k.a. Natural Spline
  iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
  iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
  iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
  // f''(tN) = 0, a.k.a. Natural Spline
  iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
  var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
  for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
   * @author tschw
   */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}});/**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
  arraySlice:function(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
  // but array.subarray(from) or array.subarray(from, len) is correct
  return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
  convertArray:function(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
  !forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
  }return Array.prototype.slice.call(array);// create Array
  },isTypedArray:function(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
  getKeyframeOrder:function(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i)result[i]=i;result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray:function(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
  flattenJSON:function(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
  var value=key[valuePropertyName];if(value===undefined)return;// no data
  if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
  }key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
  do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}}};/**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function KeyframeTrack(name,times,values,interpolation){if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);this.validate();this.optimize();}// Static methods:
  Object.assign(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  parse:function(json){if(json.type===undefined){throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');}var trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
  if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we assume a constructor compatible with the base
  return new trackType(json.name,json.times,json.values,json.interpolation);}},toJSON:function(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
  if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
  json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
  return json;},_getTrackTypeForValueTypeName:function(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);}});Object.assign(KeyframeTrack.prototype,{constructor:KeyframeTrack,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
  if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
  }}console.warn('THREE.KeyframeTrack:',message);return;}this.createInterpolant=factoryMethod;},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
  shift:function(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale:function(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim:function(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
  if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
  if(from>=to)to=Math.max(to,1),from=to-1;var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate:function(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize:function(){var times=this.times,values=this.values,stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
  if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
  var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else{keep=true;}}// in-place compaction
  if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
  if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}return this;}});/**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
  // DefaultInterpolation is inherited
  });/**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=_Math.generateUUID();// this means it should figure out its duration by scanning the tracks
  if(this.duration<0){this.resetDuration();}this.optimize();}Object.assign(AnimationClip,{parse:function(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
  // last frame as well for perfect loop.
  if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
  // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
  // patterns like Walk_001, Walk_002, Run_001, Run_002
  for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
  parseAnimation:function(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}var addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
  if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
  if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
  var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
  if(!animationKeys||animationKeys.length===0)continue;// process morph targets
  if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
  var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
  // morphTargetInfluences except for the keys in which
  // the morphTarget is named.
  for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
  var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});Object.assign(AnimationClip.prototype,{resetDuration:function(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;},trim:function(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},optimize:function(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function MaterialLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.textures={};}Object.assign(MaterialLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},setTextures:function(value){this.textures=value;},parse:function(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;if(json.uniforms!==undefined)material.uniforms=json.uniforms;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;if(json.fog!==undefined)material.fog=json.fog;if(json.flatShading!==undefined)material.flatShading=json.flatShading;if(json.blending!==undefined)material.blending=json.blending;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.rotation!==undefined)material.rotation=json.rotation;if(json.linewidth!==1)material.linewidth=json.linewidth;if(json.dashSize!==undefined)material.dashSize=json.dashSize;if(json.gapSize!==undefined)material.gapSize=json.gapSize;if(json.scale!==undefined)material.scale=json.scale;if(json.polygonOffset!==undefined)material.polygonOffset=json.polygonOffset;if(json.polygonOffsetFactor!==undefined)material.polygonOffsetFactor=json.polygonOffsetFactor;if(json.polygonOffsetUnits!==undefined)material.polygonOffsetUnits=json.polygonOffsetUnits;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;if(json.dithering!==undefined)material.dithering=json.dithering;if(json.visible!==undefined)material.visible=json.visible;if(json.userData!==undefined)material.userData=json.userData;// Deprecated
  if(json.shading!==undefined)material.flatShading=json.shading===1;// THREE.FlatShading
  // for PointsMaterial
  if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
  if(json.map!==undefined)material.map=getTexture(json.map);if(json.alphaMap!==undefined){material.alphaMap=getTexture(json.alphaMap);material.transparent=true;}if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalScale!==undefined){var normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
  normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);return material;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function BufferGeometryLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(BufferGeometryLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function(json){var geometry=new BufferGeometry();var index=json.data.index;if(index!==undefined){var typedArray=new TYPED_ARRAYS[index.type](index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}var attributes=json.data.attributes;for(var key in attributes){var attribute=attributes[key];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);geometry.addAttribute(key,new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized));}var groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(var i=0,n=groups.length;i!==n;++i){var group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}var boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){var center=new Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}return geometry;}});var TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,// Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray:typeof Uint8ClampedArray!=='undefined'?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};/**
   * @author alteredq / http://alteredqualia.com/
   */function Loader(){}Loader.Handlers={handlers:[],add:function(regex,loader){this.handlers.push(regex,loader);},get:function(file){var handlers=this.handlers;for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.test(file)){return loader;}}return null;}};Object.assign(Loader.prototype,{crossOrigin:undefined,onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color=new Color();var textureLoader=new TextureLoader();var materialLoader=new MaterialLoader();return function createMaterial(m,texturePath,crossOrigin){// convert from old material format
  var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var loader=Loader.Handlers.get(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=_Math.generateUUID();textures[uuid]=texture;return uuid;}//
  var json={uuid:_Math.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=value;break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency':console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:console.error('THREE.Loader.createMaterial: Unsupported',name,value);break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()});/**
   * @author Don McCurdy / https://www.donmccurdy.com
   */var LoaderUtils={decodeText:function(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}// Avoid the String.fromCharCode.apply(null, array) shortcut, which
  // throws a "maximum call stack size exceeded" error for large arrays.
  var s='';for(var i=0,il=array.length;i<il;i++){// Implicitly assumes little-endian.
  s+=String.fromCharCode(array[i]);}// Merges multi-byte utf-8 characters.
  return decodeURIComponent(escape(s));},extractUrlBase:function(url){var index=url.lastIndexOf('/');if(index===-1)return './';return url.substr(0,index+1);}};/**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */function JSONLoader(manager){if(typeof manager==='boolean'){console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');manager=undefined;}this.manager=manager!==undefined?manager:DefaultLoadingManager;this.withCredentials=false;}Object.assign(JSONLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var texturePath=this.texturePath&&typeof this.texturePath==='string'?this.texturePath:LoaderUtils.extractUrlBase(url);var loader=new FileLoader(this.manager);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){var json=JSON.parse(text);var metadata=json.metadata;if(metadata!==undefined){var type=metadata.type;if(type!==undefined){if(type.toLowerCase()==='object'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');return;}}}var object=scope.parse(json,texturePath);onLoad(object.geometry,object.materials);},onProgress,onError);},setTexturePath:function(value){this.texturePath=value;},parse:function(){function parseModel(json,geometry){function isBitSet(value,position){return value&1<<position;}var i,j,fi,offset,zLength,colorIndex,normalIndex,uvIndex,materialIndex,type,isQuad,hasMaterial,hasFaceVertexUv,hasFaceNormal,hasFaceVertexNormal,hasFaceColor,hasFaceVertexColor,vertex,face,faceA,faceB,hex,normal,uvLayer,uv,u,v,faces=json.faces,vertices=json.vertices,normals=json.normals,colors=json.colors,scale=json.scale,nUvLayers=0;if(json.uvs!==undefined){// disregard empty arrays
  for(i=0;i<json.uvs.length;i++){if(json.uvs[i].length)nUvLayers++;}for(i=0;i<nUvLayers;i++){geometry.faceVertexUvs[i]=[];}}offset=0;zLength=vertices.length;while(offset<zLength){vertex=new Vector3();vertex.x=vertices[offset++]*scale;vertex.y=vertices[offset++]*scale;vertex.z=vertices[offset++]*scale;geometry.vertices.push(vertex);}offset=0;zLength=faces.length;while(offset<zLength){type=faces[offset++];isQuad=isBitSet(type,0);hasMaterial=isBitSet(type,1);hasFaceVertexUv=isBitSet(type,3);hasFaceNormal=isBitSet(type,4);hasFaceVertexNormal=isBitSet(type,5);hasFaceColor=isBitSet(type,6);hasFaceVertexColor=isBitSet(type,7);// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
  if(isQuad){faceA=new Face3();faceA.a=faces[offset];faceA.b=faces[offset+1];faceA.c=faces[offset+3];faceB=new Face3();faceB.a=faces[offset+1];faceB.b=faces[offset+2];faceB.c=faces[offset+3];offset+=4;if(hasMaterial){materialIndex=faces[offset++];faceA.materialIndex=materialIndex;faceB.materialIndex=materialIndex;}// to get face <=> uv index correspondence
  fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];geometry.faceVertexUvs[i][fi+1]=[];for(j=0;j<4;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);if(j!==2)geometry.faceVertexUvs[i][fi].push(uv);if(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;faceA.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);faceB.normal.copy(faceA.normal);}if(hasFaceVertexNormal){for(i=0;i<4;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);if(i!==2)faceA.vertexNormals.push(normal);if(i!==0)faceB.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];hex=colors[colorIndex];faceA.color.setHex(hex);faceB.color.setHex(hex);}if(hasFaceVertexColor){for(i=0;i<4;i++){colorIndex=faces[offset++];hex=colors[colorIndex];if(i!==2)faceA.vertexColors.push(new Color(hex));if(i!==0)faceB.vertexColors.push(new Color(hex));}}geometry.faces.push(faceA);geometry.faces.push(faceB);}else{face=new Face3();face.a=faces[offset++];face.b=faces[offset++];face.c=faces[offset++];if(hasMaterial){materialIndex=faces[offset++];face.materialIndex=materialIndex;}// to get face <=> uv index correspondence
  fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];for(j=0;j<3;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);geometry.faceVertexUvs[i][fi].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;face.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);}if(hasFaceVertexNormal){for(i=0;i<3;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);face.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];face.color.setHex(colors[colorIndex]);}if(hasFaceVertexColor){for(i=0;i<3;i++){colorIndex=faces[offset++];face.vertexColors.push(new Color(colors[colorIndex]));}}geometry.faces.push(face);}}}function parseSkin(json,geometry){var influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;if(json.skinWeights){for(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){var x=json.skinWeights[i];var y=influencesPerVertex>1?json.skinWeights[i+1]:0;var z=influencesPerVertex>2?json.skinWeights[i+2]:0;var w=influencesPerVertex>3?json.skinWeights[i+3]:0;geometry.skinWeights.push(new Vector4(x,y,z,w));}}if(json.skinIndices){for(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){var a=json.skinIndices[i];var b=influencesPerVertex>1?json.skinIndices[i+1]:0;var c=influencesPerVertex>2?json.skinIndices[i+2]:0;var d=influencesPerVertex>3?json.skinIndices[i+3]:0;geometry.skinIndices.push(new Vector4(a,b,c,d));}}geometry.bones=json.bones;if(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){console.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+geometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');}}function parseMorphing(json,geometry){var scale=json.scale;if(json.morphTargets!==undefined){for(var i=0,l=json.morphTargets.length;i<l;i++){geometry.morphTargets[i]={};geometry.morphTargets[i].name=json.morphTargets[i].name;geometry.morphTargets[i].vertices=[];var dstVertices=geometry.morphTargets[i].vertices;var srcVertices=json.morphTargets[i].vertices;for(var v=0,vl=srcVertices.length;v<vl;v+=3){var vertex=new Vector3();vertex.x=srcVertices[v]*scale;vertex.y=srcVertices[v+1]*scale;vertex.z=srcVertices[v+2]*scale;dstVertices.push(vertex);}}}if(json.morphColors!==undefined&&json.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var faces=geometry.faces;var morphColors=json.morphColors[0].colors;for(var i=0,l=faces.length;i<l;i++){faces[i].color.fromArray(morphColors,i*3);}}}function parseAnimations(json,geometry){var outputAnimations=[];// parse old style Bone/Hierarchy animations
  var animations=[];if(json.animation!==undefined){animations.push(json.animation);}if(json.animations!==undefined){if(json.animations.length){animations=animations.concat(json.animations);}else{animations.push(json.animations);}}for(var i=0;i<animations.length;i++){var clip=AnimationClip.parseAnimation(animations[i],geometry.bones);if(clip)outputAnimations.push(clip);}// parse implicit morph animations
  if(geometry.morphTargets){// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
  var morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);outputAnimations=outputAnimations.concat(morphAnimationClips);}if(outputAnimations.length>0)geometry.animations=outputAnimations;}return function parse(json,texturePath){if(json.data!==undefined){// Geometry 4.0 spec
  json=json.data;}if(json.scale!==undefined){json.scale=1.0/json.scale;}else{json.scale=1.0;}var geometry=new Geometry();parseModel(json,geometry);parseSkin(json,geometry);parseMorphing(json,geometry);parseAnimations(json,geometry);geometry.computeFaceNormals();geometry.computeBoundingSphere();if(json.materials===undefined||json.materials.length===0){return {geometry:geometry};}else{var materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);return {geometry:geometry,materials:materials};}};}()});/**
   * @author mrdoob / http://mrdoob.com/
   */function ObjectLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.texturePath='';}Object.assign(ObjectLoader.prototype,{load:function(url,onLoad,onProgress,onError){if(this.texturePath===''){this.texturePath=url.substring(0,url.lastIndexOf('/')+1);}var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){var json=null;try{json=JSON.parse(text);}catch(error){if(onError!==undefined)onError(error);console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}var metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url+'. Use THREE.JSONLoader instead.');return;}scope.parse(json,onLoad);},onProgress,onError);},setTexturePath:function(value){this.texturePath=value;},setCrossOrigin:function(value){this.crossOrigin=value;},parse:function(json,onLoad){var shapes=this.parseShape(json.shapes);var geometries=this.parseGeometries(json.geometries,shapes);var images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});var textures=this.parseTextures(json.textures,images);var materials=this.parseMaterials(json.materials,textures);var object=this.parseObject(json.object,geometries,materials);if(json.animations){object.animations=this.parseAnimations(json.animations);}if(json.images===undefined||json.images.length===0){if(onLoad!==undefined)onLoad(object);}return object;},parseShape:function(json){var shapes={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var shape=new Shape().fromJSON(json[i]);shapes[shape.uuid]=shape;}}return shapes;},parseGeometries:function(json,shapes){var geometries={};if(json!==undefined){var geometryLoader=new JSONLoader();var bufferGeometryLoader=new BufferGeometryLoader();for(var i=0,l=json.length;i<l;i++){var geometry;var data=json[i];switch(data.type){case'PlaneGeometry':case'PlaneBufferGeometry':geometry=new Geometries[data.type](data.width,data.height,data.widthSegments,data.heightSegments);break;case'BoxGeometry':case'BoxBufferGeometry':case'CubeGeometry':// backwards compatible
  geometry=new Geometries[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);break;case'CircleGeometry':case'CircleBufferGeometry':geometry=new Geometries[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);break;case'CylinderGeometry':case'CylinderBufferGeometry':geometry=new Geometries[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'ConeGeometry':case'ConeBufferGeometry':geometry=new Geometries[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'SphereGeometry':case'SphereBufferGeometry':geometry=new Geometries[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);break;case'DodecahedronGeometry':case'DodecahedronBufferGeometry':case'IcosahedronGeometry':case'IcosahedronBufferGeometry':case'OctahedronGeometry':case'OctahedronBufferGeometry':case'TetrahedronGeometry':case'TetrahedronBufferGeometry':geometry=new Geometries[data.type](data.radius,data.detail);break;case'RingGeometry':case'RingBufferGeometry':geometry=new Geometries[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);break;case'TorusGeometry':case'TorusBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);break;case'TorusKnotGeometry':case'TorusKnotBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);break;case'LatheGeometry':case'LatheBufferGeometry':geometry=new Geometries[data.type](data.points,data.segments,data.phiStart,data.phiLength);break;case'PolyhedronGeometry':case'PolyhedronBufferGeometry':geometry=new Geometries[data.type](data.vertices,data.indices,data.radius,data.details);break;case'ShapeGeometry':case'ShapeBufferGeometry':var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}geometry=new Geometries[data.type](geometryShapes,data.curveSegments);break;case'BufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':geometry=geometryLoader.parse(data,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');continue;}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;geometries[data.uuid]=geometry;}}return geometries;},parseMaterials:function(json,textures){var materials={};if(json!==undefined){var loader=new MaterialLoader();loader.setTextures(textures);for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.type==='MultiMaterial'){// Deprecated
  var array=[];for(var j=0;j<data.materials.length;j++){array.push(loader.parse(data.materials[j]));}materials[data.uuid]=array;}else{materials[data.uuid]=loader.parse(data);}}}return materials;},parseAnimations:function(json){var animations=[];for(var i=0;i<json.length;i++){var clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;},parseImages:function(json,onLoad){var scope=this;var images={};function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemEnd(url);scope.manager.itemError(url);});}if(json!==undefined&&json.length>0){var manager=new LoadingManager(onLoad);var loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(var i=0,l=json.length;i<l;i++){var image=json[i];var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.texturePath+image.url;images[image.uuid]=loadImage(path);}}return images;},parseTextures:function(json,images){function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}var textures={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}var texture=new Texture(images[data.image]);texture.needsUpdate=true;texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.center!==undefined)texture.center.fromArray(data.center);if(data.rotation!==undefined)texture.rotation=data.rotation;if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);}if(data.format!==undefined)texture.format=data.format;if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;textures[data.uuid]=texture;}}return textures;},parseObject:function(data,geometries,materials){var object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if(Array.isArray(name)){var array=[];for(var i=0,l=name.length;i<l;i++){var uuid=name[i];if(materials[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined material',uuid);}array.push(materials[uuid]);}return array;}if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if(Number.isInteger(data.background)){object.background=new Color(data.background);}}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);if(data.zoom!==undefined)object.zoom=data.zoom;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'RectAreaLight':object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'SkinnedMesh':console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');case'Mesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);if(geometry.bones&&geometry.bones.length>0){object=new SkinnedMesh(geometry,material);}else{object=new Mesh(geometry,material);}break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);break;case'LineLoop':object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){object.matrix.fromArray(data.matrix);if(data.matrixAutoUpdate!==undefined)object.matrixAutoUpdate=data.matrixAutoUpdate;if(object.matrixAutoUpdate)object.matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.frustumCulled!==undefined)object.frustumCulled=data.frustumCulled;if(data.renderOrder!==undefined)object.renderOrder=data.renderOrder;if(data.userData!==undefined)object.userData=data.userData;if(data.children!==undefined){var children=data.children;for(var i=0;i<children.length;i++){object.add(this.parseObject(children[i],geometries,materials));}}if(data.type==='LOD'){var levels=data.levels;for(var l=0;l<levels.length;l++){var level=levels[l];var child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;}});var TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,SphericalReflectionMapping:SphericalReflectionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};var TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};var TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipMapNearestFilter:NearestMipMapNearestFilter,NearestMipMapLinearFilter:NearestMipMapLinearFilter,LinearFilter:LinearFilter,LinearMipMapNearestFilter:LinearMipMapNearestFilter,LinearMipMapLinearFilter:LinearMipMapLinearFilter};/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
   **/function ShapePath(){this.type='ShapePath';this.color=new Color();this.subPaths=[];this.currentPath=null;}Object.assign(ShapePath.prototype,{moveTo:function(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);},lineTo:function(x,y){this.currentPath.lineTo(x,y);},quadraticCurveTo:function(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);},bezierCurveTo:function(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);},splineThru:function(pts){this.currentPath.splineThru(pts);},toShapes:function(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
  // toggling of inside/outside at every single! intersection point of an edge
  //  with the horizontal line through inPt, left of inPt
  //  not counting lowerY endpoints of edges and whole edges on that line
  var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){// not parallel
  if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
  // continue;				// no intersection or edgeLowPt => doesn't count !!!
  }else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
  if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
  }}else{// parallel or collinear
  if(inPt.y!==edgeLowPt.y)continue;// parallel
  // edge lies on the same horizontal line as inPt
  if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
  // continue;
  }}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return [];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
  var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
  }else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
  }}// only Holes? -> probably all Shapes with wrong orientation
  if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
  if(toChange.length>0){// console.log("to change: ", toChange);
  if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
  return shapes;}});/**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author mrdoob / http://mrdoob.com/
   */function Font(data){this.type='Font';this.data=data;}Object.assign(Font.prototype,{isFont:true,generateShapes:function(text,size,divisions){if(size===undefined)size=100;if(divisions===undefined)divisions=4;var shapes=[];var paths=createPaths(text,size,divisions,this.data);for(var p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}});function createPaths(text,size,divisions,data){var chars=String(text).split('');var scale=size/data.resolution;var line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;var paths=[];var offsetX=0,offsetY=0;for(var i=0;i<chars.length;i++){var char=chars[i];if(char==='\n'){offsetX=0;offsetY-=line_height;}else{var ret=createPath(char,divisions,scale,offsetX,offsetY,data);offsetX+=ret.offsetX;paths.push(ret.path);}}return paths;}function createPath(char,divisions,scale,offsetX,offsetY,data){var glyph=data.glyphs[char]||data.glyphs['?'];if(!glyph)return;var path=new ShapePath();var x,y,cpx,cpy,cpx1,cpy1,cpx2,cpy2;if(glyph.o){var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(var i=0,l=outline.length;i<l;){var action=outline[i++];switch(action){case'm':// moveTo
  x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.moveTo(x,y);break;case'l':// lineTo
  x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.lineTo(x,y);break;case'q':// quadraticCurveTo
  cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);break;case'b':// bezierCurveTo
  cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;cpx2=outline[i++]*scale+offsetX;cpy2=outline[i++]*scale+offsetY;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);break;}}}return {offsetX:glyph.ha*scale,path:path};}/**
   * @author mrdoob / http://mrdoob.com/
   */function FontLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FontLoader.prototype,{load:function(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.load(url,function(text){var json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}var font=scope.parse(json);if(onLoad)onLoad(font);},onProgress,onError);},parse:function(json){return new Font(json);},setPath:function(value){this.path=value;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */var context;var AudioContext={getContext:function(){if(context===undefined){context=new(window.AudioContext||window.webkitAudioContext)();}return context;},setContext:function(value){context=value;}};/**
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */function AudioLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(AudioLoader.prototype,{load:function(url,onLoad,onProgress,onError){var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var context=AudioContext.getContext();context.decodeAudioData(buffer,function(audioBuffer){onLoad(audioBuffer);});},onProgress,onError);}});/**
   * @author mrdoob / http://mrdoob.com/
   */function StereoCamera(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;}Object.assign(StereoCamera.prototype,{update:function(){var instance,focus,fov,aspect,near,far,zoom,eyeSep;var eyeRight=new Matrix4();var eyeLeft=new Matrix4();return function update(camera){var needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||aspect!==camera.aspect*this.aspect||near!==camera.near||far!==camera.far||zoom!==camera.zoom||eyeSep!==this.eyeSep;if(needsUpdate){instance=this;focus=camera.focus;fov=camera.fov;aspect=camera.aspect*this.aspect;near=camera.near;far=camera.far;zoom=camera.zoom;// Off-axis stereoscopic effect based on
  // http://paulbourke.net/stereographics/stereorender/
  var projectionMatrix=camera.projectionMatrix.clone();eyeSep=this.eyeSep/2;var eyeSepOnProjection=eyeSep*near/focus;var ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;var xmin,xmax;// translate xOffset
  eyeLeft.elements[12]=-eyeSep;eyeRight.elements[12]=eyeSep;// for left eye
  xmin=-ymax*aspect+eyeSepOnProjection;xmax=ymax*aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
  xmin=-ymax*aspect-eyeSepOnProjection;xmax=ymax*aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);};}()});/**
   * Camera for rendering cube maps
   *	- renders scene into axis-aligned cube
   *
   * @author alteredq / http://alteredqualia.com/
   */function CubeCamera(near,far,cubeResolution){Object3D.call(this);this.type='CubeCamera';var fov=90,aspect=1;var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));this.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));this.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));this.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));this.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));this.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));this.add(cameraNZ);var options={format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter};this.renderTarget=new WebGLRenderTargetCube(cubeResolution,cubeResolution,options);this.renderTarget.texture.name="CubeCamera";this.update=function(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var renderTarget=this.renderTarget;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderTarget.activeCubeFace=0;renderer.render(scene,cameraPX,renderTarget);renderTarget.activeCubeFace=1;renderer.render(scene,cameraNX,renderTarget);renderTarget.activeCubeFace=2;renderer.render(scene,cameraPY,renderTarget);renderTarget.activeCubeFace=3;renderer.render(scene,cameraNY,renderTarget);renderTarget.activeCubeFace=4;renderer.render(scene,cameraPZ,renderTarget);renderTarget.texture.generateMipmaps=generateMipmaps;renderTarget.activeCubeFace=5;renderer.render(scene,cameraNZ,renderTarget);renderer.setRenderTarget(null);};this.clear=function(renderer,color,depth,stencil){var renderTarget=this.renderTarget;for(var i=0;i<6;i++){renderTarget.activeCubeFace=i;renderer.setRenderTarget(renderTarget);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(null);};}CubeCamera.prototype=Object.create(Object3D.prototype);CubeCamera.prototype.constructor=CubeCamera;/**
   * @author mrdoob / http://mrdoob.com/
   */function AudioListener(){Object3D.call(this);this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;}AudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:AudioListener,getInput:function(){return this.gain;},removeFilter:function(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}},getFilter:function(){return this.filter;},setFilter:function(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);},getMasterVolume:function(){return this.gain.gain.value;},setMasterVolume:function(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);},updateMatrixWorld:function(){var position=new Vector3();var quaternion=new Quaternion();var scale=new Vector3();var orientation=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);var listener=this.context.listener;var up=this.up;this.matrixWorld.decompose(position,quaternion,scale);orientation.set(0,0,-1).applyQuaternion(quaternion);if(listener.positionX){listener.positionX.setValueAtTime(position.x,this.context.currentTime);listener.positionY.setValueAtTime(position.y,this.context.currentTime);listener.positionZ.setValueAtTime(position.z,this.context.currentTime);listener.forwardX.setValueAtTime(orientation.x,this.context.currentTime);listener.forwardY.setValueAtTime(orientation.y,this.context.currentTime);listener.forwardZ.setValueAtTime(orientation.z,this.context.currentTime);listener.upX.setValueAtTime(up.x,this.context.currentTime);listener.upY.setValueAtTime(up.y,this.context.currentTime);listener.upZ.setValueAtTime(up.z,this.context.currentTime);}else{listener.setPosition(position.x,position.y,position.z);listener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);}};}()});/**
   * @author mrdoob / http://mrdoob.com/
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */function Audio(listener){Object3D.call(this);this.type='Audio';this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.loop=false;this.startTime=0;this.offset=0;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.sourceType='empty';this.filters=[];}Audio.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Audio,getOutput:function(){return this.gain;},setNodeSource:function(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;},setBuffer:function(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;},play:function(){if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.onended=this.onEnded.bind(this);source.playbackRate.setValueAtTime(this.playbackRate,this.startTime);this.startTime=this.context.currentTime;source.start(this.startTime,this.offset);this.isPlaying=true;this.source=source;return this.connect();},pause:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){this.source.stop();this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate;this.isPlaying=false;}return this;},stop:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.offset=0;this.isPlaying=false;return this;},connect:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}return this;},disconnect:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}return this;},getFilters:function(){return this.filters;},setFilters:function(value){if(!value)value=[];if(this.isPlaying===true){this.disconnect();this.filters=value;this.connect();}else{this.filters=value;}return this;},getFilter:function(){return this.getFilters()[0];},setFilter:function(filter){return this.setFilters(filter?[filter]:[]);},setPlaybackRate:function(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime);}return this;},getPlaybackRate:function(){return this.playbackRate;},onEnded:function(){this.isPlaying=false;},getLoop:function(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;},setLoop:function(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;},getVolume:function(){return this.gain.gain.value;},setVolume:function(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   */function PositionalAudio(listener){Audio.call(this,listener);this.panner=this.context.createPanner();this.panner.connect(this.gain);}PositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{constructor:PositionalAudio,getOutput:function(){return this.panner;},getRefDistance:function(){return this.panner.refDistance;},setRefDistance:function(value){this.panner.refDistance=value;},getRolloffFactor:function(){return this.panner.rolloffFactor;},setRolloffFactor:function(value){this.panner.rolloffFactor=value;},getDistanceModel:function(){return this.panner.distanceModel;},setDistanceModel:function(value){this.panner.distanceModel=value;},getMaxDistance:function(){return this.panner.maxDistance;},setMaxDistance:function(value){this.panner.maxDistance=value;},updateMatrixWorld:function(){var position=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);position.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(position.x,position.y,position.z);};}()});/**
   * @author mrdoob / http://mrdoob.com/
   */function AudioAnalyser(audio,fftSize){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize!==undefined?fftSize:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}Object.assign(AudioAnalyser.prototype,{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data;},getAverageFrequency:function(){var value=0,data=this.getFrequencyData();for(var i=0;i<data.length;i++){value+=data[i];}return value/data.length;}});/**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function PropertyMixer(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var bufferType=Float64Array,mixFunction;switch(typeName){case'quaternion':mixFunction=this._slerp;break;case'string':case'bool':bufferType=Array;mixFunction=this._select;break;default:mixFunction=this._lerp;}this.buffer=new bufferType(valueSize*4);// layout: [ incoming | accu0 | accu1 | orig ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property
  this._mixBufferRegion=mixFunction;this.cumulativeWeight=0;this.useCount=0;this.referenceCount=0;}Object.assign(PropertyMixer.prototype,{// accumulate data in the 'incoming' region into 'accu<i>'
  accumulate:function(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
  // the weight and shouldn't have made the call in the first place
  var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride,currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
  for(var i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
  currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;},// apply the state of 'accu<i>' to the binding when accus differ
  apply:function(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,binding=this.binding;this.cumulativeWeight=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
  var originalValueOffset=stride*3;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}for(var i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
  binding.setValue(buffer,offset);break;}}},// remember the state of the bound property and copy it to both accus
  saveOriginalState:function(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*3;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
  for(var i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}this.cumulativeWeight=0;},// apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState:function(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);},// mix functions
  _select:function(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}},_slerp:function(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);},_lerp:function(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var i=0;i!==stride;++i){var j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}});/**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */ // Characters [].:/ are reserved for track binding syntax.
  var RESERVED_CHARS_RE='\\[\\]\\.:\\/';function Composite(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}Object.assign(Composite.prototype,{getValue:function(array,offset){this.bind();// bind all binding
  var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
  if(binding!==undefined)binding.getValue(array,offset);},setValue:function(array,offset){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}},bind:function(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}},unbind:function(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}});function PropertyBinding(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;}Object.assign(PropertyBinding,{Composite:Composite,create:function(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}},/**
  	 * Replaces spaces with underscores and removes unsupported characters from
  	 * node names, to ensure compatibility with parseTrackName().
  	 *
  	 * @param  {string} name Node name to be sanitized.
  	 * @return {string}
  	 */sanitizeNodeName:function(){var reservedRe=new RegExp('['+RESERVED_CHARS_RE+']','g');return function sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(reservedRe,'');};}(),parseTrackName:function(){// Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  var wordChar='[^'+RESERVED_CHARS_RE+']';var wordCharOrDot='[^'+RESERVED_CHARS_RE.replace('\\.','')+']';// Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  var directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',wordChar);// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  var nodeRe=/(WCOD+)?/.source.replace('WCOD',wordCharOrDot);// Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  var objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',wordChar);// Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  var propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',wordChar);var trackRe=new RegExp(''+'^'+directoryRe+nodeRe+objectRe+propertyRe+'$');var supportedObjectNames=['material','materials','bones'];return function parseTrackName(trackName){var matches=trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
  nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
  propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against a whitelist. Otherwise, there
  // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  // 'bar' could be the objectName, or part of a nodeName (which can
  // include '.' characters).
  if(supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;};}(),findNode:function(root,nodeName){if(!nodeName||nodeName===""||nodeName==="root"||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
  if(root.skeleton){var bone=root.skeleton.getBoneByName(nodeName);if(bone!==undefined){return bone;}}// search into node subtree.
  if(root.children){var searchNodeSubtree=function(children){for(var i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}});Object.assign(PropertyBinding.prototype,{// prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];},function getValue_array(buffer,offset){var source=this.resolvedProperty;for(var i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}},function getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];},function getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}],SetterByBindingTypeAndVersioning:[[// Direct
  function setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];},function setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// EntireArray
  function setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}},function setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;},function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}],[// ArrayElement
  function setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];},function setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// HasToFromArray
  function setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);},function setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;},function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}]],getValue:function getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);// Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  },setValue:function getValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);},// create getter / setter pair for a property in the scene graph
  bind:function(){var targetObject=this.node,parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName,propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
  this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
  if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
  switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
  // and convert the integer string to a true integer.
  targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
  for(var i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
  var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
  var versioning=this.Versioning.None;if(targetObject.needsUpdate!==undefined){// material
  versioning=this.Versioning.NeedsUpdate;this.targetObject=targetObject;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
  versioning=this.Versioning.MatrixWorldNeedsUpdate;this.targetObject=targetObject;}// determine how the property gets bound
  var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
  if(propertyName==="morphTargetInfluences"){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
  // support resolving morphTarget names into indices.
  if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}for(var i=0;i<this.node.geometry.morphAttributes.position.length;i++){if(targetObject.geometry.morphAttributes.position[i].name===propertyIndex){propertyIndex=i;break;}}}else{if(!targetObject.geometry.morphTargets){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',this);return;}for(var i=0;i<this.node.geometry.morphTargets.length;i++){if(targetObject.geometry.morphTargets[i].name===propertyIndex){propertyIndex=i;break;}}}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
  bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
  this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];},unbind:function(){this.node=null;// back to the prototype version of getValue / setValue
  // note: avoiding to mutate the shape of 'this' via 'delete'
  this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}});//!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign(PropertyBinding.prototype,{// initial state of these methods that calls 'bind'
  _getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue});/**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   * 	-	Add objects you would otherwise pass as 'root' to the
   * 		constructor or the .clipAction method of AnimationMixer.
   *
   * 	-	Instead pass this object as 'root'.
   *
   * 	-	You can also add and remove objects later when the mixer
   * 		is running.
   *
   * Note:
   *
   *  	Objects of this class appear as one object to the mixer,
   *  	so cache control of the individual objects must be done
   *  	on the group.
   *
   * Limitation:
   *
   * 	- 	The animated properties must be compatible among the
   * 		all objects in the group.
   *
   *  -	A single property can either be controlled through a
   *  	target group or directly, but not both.
   *
   * @author tschw
   */function AnimationObjectGroup(){this.uuid=_Math.generateUUID();// cached objects followed by the active ones
  this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
  // note: read by PropertyBinding.Composite
  var indices={};this._indicesByUUID=indices;// for bookkeeping
  for(var i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
  this._parsedPaths=[];// inside: { we don't care, here }
  this._bindings=[];// inside: Array< PropertyBinding >
  this._bindingsIndicesByPath={};// inside: indices in these arrays
  var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}Object.assign(AnimationObjectGroup.prototype,{isAnimationObjectGroup:true,add:function(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length,knownObject=undefined;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index===undefined){// unknown object -> add it to the ACTIVE region
  index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
  var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
  // for objects that are cached, the binding may
  // or may not exist
  binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+'detected. Clean the caches or recreate your infrastructure when reloading scenes.');}// else the object is already where we want it to be
  }// for arguments
  this.nCachedObjects_=nCachedObjects;},remove:function(){var objects=this._objects,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
  var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
  this.nCachedObjects_=nCachedObjects;},// remove & forget
  uncache:function(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
  var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
  indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
  indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
  var lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastObject.uuid]=index;objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
  for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
  }// if object is known
  }// for arguments
  this.nCachedObjects_=nCachedObjects;},// Internal interface used by befriended PropertyBinding.Composite:
  subscribe_:function(path,parsedPath){// returns an array of bindings for the given path that is changed
  // according to the contained objects in the group
  var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path],bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var i=nCachedObjects,n=objects.length;i!==n;++i){var object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;},unsubscribe_:function(path){// tells the group to forget about a property path and no longer
  // update the array previously obtained with 'subscribe_'
  var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}});/**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */function AnimationAction(mixer,clip,localRoot){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot||null;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var i=0;i!==nTracks;++i){var interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
  // inside: PropertyMixer (managed by the mixer)
  this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
  this._byClipCacheIndex=null;// for the memory manager
  this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action
  this._startTime=null;// scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop
  this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
  this.paused=false;// true -> zero effective time scale
  this.enabled=true;// false -> zero effective weight
  this.clampWhenFinished=false;// keep feeding the last frame?
  this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
  this.zeroSlopeAtEnd=true;// clips for start, loop and end
  }Object.assign(AnimationAction.prototype,{// State & Scheduling
  play:function(){this._mixer._activateAction(this);return this;},stop:function(){this._mixer._deactivateAction(this);return this.reset();},reset:function(){this.paused=false;this.enabled=true;this.time=0;// restart clip
  this._loopCount=-1;// forget previous loops
  this._startTime=null;// forget scheduling
  return this.stopFading().stopWarping();},isRunning:function(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);},// return true when play has been called
  isScheduled:function(){return this._mixer._isActiveAction(this);},startAt:function(time){this._startTime=time;return this;},setLoop:function(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;},// Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight:function(weight){this.weight=weight;// note: same logic as when updated at runtime
  this._effectiveWeight=this.enabled?weight:0;return this.stopFading();},// return the weight considering fading and .enabled
  getEffectiveWeight:function(){return this._effectiveWeight;},fadeIn:function(duration){return this._scheduleFading(duration,0,1);},fadeOut:function(duration){return this._scheduleFading(duration,1,0);},crossFadeFrom:function(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;},crossFadeTo:function(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);},stopFading:function(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;},// Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale:function(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();},// return the time scale considering warping and .paused
  getEffectiveTimeScale:function(){return this._effectiveTimeScale;},setDuration:function(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();},syncWith:function(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();},halt:function(duration){return this.warp(this._effectiveTimeScale,0,duration);},warp:function(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,interpolant=this._timeScaleInterpolant,timeScale=this.timeScale;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;},stopWarping:function(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;},// Object Accessors
  getMixer:function(){return this._mixer;},getClip:function(){return this._clip;},getRoot:function(){return this._localRoot||this._mixer._root;},// Interna
  _update:function(time,deltaTime,timeDirection,accuIndex){// called by the mixer
  if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
  this._updateWeight(time);return;}var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
  var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
  }// start
  this._startTime=null;// unschedule
  deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
  deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
  // an effective weight of 0
  var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}},_updateWeight:function(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
  this.enabled=false;}}}}this._effectiveWeight=weight;return weight;},_updateTimeScale:function(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
  this.paused=true;}else{// warp done - apply final time scale
  this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;},_updateTime:function(deltaTime){var time=this.time+deltaTime;if(deltaTime===0)return time;var duration=this._clip.duration,loop=this.loop,loopCount=this._loopCount;if(loop===LoopOnce){if(loopCount===-1){// just started
  this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else break handle_stop;if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
  var pingPong=loop===LoopPingPong;if(loopCount===-1){// just started
  if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
  // transition through zero counts as a repetition,
  // so leave loopCount at -1
  this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
  var loopDelta=Math.floor(time/duration);// signed
  time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<=0){// have to stop (switch state, clamp time, fire event)
  if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
  if(pending===1){// entering the last round
  var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
  this.time=time;return duration-time;}}this.time=time;return time;},_setEndings:function(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
  if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}},_scheduleFading:function(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time,interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}});/**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */function AnimationMixer(root){this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}AnimationMixer.prototype=Object.assign(Object.create(EventDispatcher.prototype),{constructor:AnimationMixer,_bindAction:function(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName,bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var i=0;i!==nTracks;++i){var track=tracks[i],trackName=track.name,binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
  if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}},_activateAction:function(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
  // appears to be still using it -> rebind
  var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
  for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}},_deactivateAction:function(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
  for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}},// Memory manager
  _initMemoryManager:function(){this._actions=[];// 'nActiveActions' followed by inactive ones
  this._nActiveActions=0;this._actionsByClip={};// inside:
  // {
  // 		knownActions: Array< AnimationAction >	- used as prototypes
  // 		actionByRoot: AnimationAction			- lookup
  // }
  this._bindings=[];// 'nActiveBindings' followed by inactive ones
  this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
  this._controlInterpolants=[];// same game as above
  this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};},// Memory management for AnimationAction objects
  _isActiveAction:function(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;},_addInactiveAction:function(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;},_removeInactiveAction:function(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);},_removeInactiveBindingsForAction:function(action){var bindings=action._propertyBindings;for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}},_lendAction:function(action){// [ active actions |  inactive actions  ]
  // [  active actions >| inactive actions ]
  //                 s        a
  //                  <-swap->
  //                 a        s
  var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;},_takeBackAction:function(action){// [  active actions  | inactive actions ]
  // [ active actions |< inactive actions  ]
  //        a        s
  //         <-swap->
  //        s        a
  var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;},// Memory management for PropertyMixer objects
  _addInactiveBinding:function(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],bindings=this._bindings;if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);},_removeInactiveBinding:function(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];remove_empty_map:{for(var _ in bindingByName)break remove_empty_map;// eslint-disable-line no-unused-vars
  delete bindingsByRoot[rootUuid];}},_lendBinding:function(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;},_takeBackBinding:function(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;},// Memory management of Interpolants for weight and time scale
  _lendControlInterpolant:function(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++,interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;},_takeBackControlInterpolant:function(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;},_controlInterpolantsResultBuffer:new Float32Array(1),// return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction:function(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid],prototypeAction=null;if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined){return existingAction;}// we know the clip, so we don't have to parse all
  // the bindings again but can just copy
  prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
  if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
  if(clipObject===null)return null;// allocate all resources required to run it
  var newAction=new AnimationAction(this,clipObject,optionalRoot);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
  this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;},// get an existing action
  existingAction:function(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;},// deactivates all previously scheduled actions
  stopAllAction:function(){var actions=this._actions,nActions=this._nActiveActions,bindings=this._bindings,nBindings=this._nActiveBindings;this._nActiveActions=0;this._nActiveBindings=0;for(var i=0;i!==nActions;++i){actions[i].reset();}for(var i=0;i!==nBindings;++i){bindings[i].useCount=0;}return this;},// advance the time and update apply the animation
  update:function(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
  for(var i=0;i!==nActions;++i){var action=actions[i];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
  var bindings=this._bindings,nBindings=this._nActiveBindings;for(var i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;},// return this mixer's root target object
  getRoot:function(){return this._root;},// free all resources specific to a particular clip
  uncacheClip:function(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
  // iteration state and also require updating the state we can
  // just throw away
  var actionsToRemove=actionsForClip.knownActions;for(var i=0,n=actionsToRemove.length;i!==n;++i){var action=actionsToRemove[i];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}},// free all resources specific to a particular root target object
  uncacheRoot:function(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}},// remove a targeted clip from the cache
  uncacheAction:function(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}});/**
   * @author mrdoob / http://mrdoob.com/
   */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
   * @author benaadams / https://twitter.com/ben_a_adams
   */function InstancedBufferGeometry(){BufferGeometry.call(this);this.type='InstancedBufferGeometry';this.maxInstancedCount=undefined;}InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:true,copy:function(source){BufferGeometry.prototype.copy.call(this,source);this.maxInstancedCount=source.maxInstancedCount;return this;},clone:function(){return new this.constructor().copy(this);}});/**
   * @author benaadams / https://twitter.com/ben_a_adams
   */function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}Object.defineProperties(InterleavedBufferAttribute.prototype,{count:{get:function(){return this.data.count;}},array:{get:function(){return this.data.array;}}});Object.assign(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:true,setX:function(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;},setY:function(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;},setZ:function(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;},setW:function(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;},getX:function(index){return this.data.array[index*this.data.stride+this.offset];},getY:function(index){return this.data.array[index*this.data.stride+this.offset+1];},getZ:function(index){return this.data.array[index*this.data.stride+this.offset+2];},getW:function(index){return this.data.array[index*this.data.stride+this.offset+3];},setXY:function(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;},setXYZ:function(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;},setXYZW:function(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}});/**
   * @author benaadams / https://twitter.com/ben_a_adams
   */function InterleavedBuffer(array,stride){this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.dynamic=false;this.updateRange={offset:0,count:-1};this.version=0;}Object.defineProperty(InterleavedBuffer.prototype,'needsUpdate',{set:function(value){if(value===true)this.version++;}});Object.assign(InterleavedBuffer.prototype,{isInterleavedBuffer:true,onUploadCallback:function(){},setArray:function(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.stride:0;this.array=array;return this;},setDynamic:function(value){this.dynamic=value;return this;},copy:function(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.dynamic=source.dynamic;return this;},copyAt:function(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},set:function(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},clone:function(){return new this.constructor().copy(this);},onUpload:function(callback){this.onUploadCallback=callback;return this;}});/**
   * @author benaadams / https://twitter.com/ben_a_adams
   */function InstancedInterleavedBuffer(array,stride,meshPerAttribute){InterleavedBuffer.call(this,array,stride);this.meshPerAttribute=meshPerAttribute||1;}InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:true,copy:function(source){InterleavedBuffer.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
   * @author benaadams / https://twitter.com/ben_a_adams
   */function InstancedBufferAttribute(array,itemSize,meshPerAttribute){BufferAttribute.call(this,array,itemSize);this.meshPerAttribute=meshPerAttribute||1;}InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:true,copy:function(source){BufferAttribute.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
   * @author mrdoob / http://mrdoob.com/
   * @author bhouston / http://clara.io/
   * @author stephomi / http://stephaneginier.com/
   */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
  this.near=near||0;this.far=far||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function intersectObject(object,raycaster,intersects,recursive){if(object.visible===false)return;object.raycast(raycaster,intersects);if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){intersectObject(children[i],raycaster,intersects,true);}}}Object.assign(Raycaster.prototype,{linePrecision:1,set:function(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
  this.ray.set(origin,direction);},setFromCamera:function(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
  this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function(object,recursive,optionalTarget){var intersects=optionalTarget||[];intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function(objects,recursive,optionalTarget){var intersects=optionalTarget||[];if(Array.isArray(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}});/**
   * @author alteredq / http://alteredqualia.com/
   */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}Object.assign(Clock.prototype,{start:function(){this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732
  this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function(){this.getElapsedTime();this.running=false;this.autoStart=false;},getElapsedTime:function(){this.getDelta();return this.elapsedTime;},getDelta:function(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=(typeof performance==='undefined'?Date:performance).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}});/**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The poles (phi) are at the positive and negative y axis.
   * The equator starts at positive z.
   */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole
  this.theta=theta!==undefined?theta:0;// around the equator of the sphere
  return this;}Object.assign(Spherical.prototype,{set:function(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function(){return new this.constructor().copy(this);},copy:function(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
  makeSafe:function(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function(vec3){this.radius=vec3.length();if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis
  this.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle
  }return this;}});/**
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   *
   */function Cylindrical(radius,theta,y){this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
  this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  this.y=y!==undefined?y:0;// height above the x-z plane
  return this;}Object.assign(Cylindrical.prototype,{set:function(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;},clone:function(){return new this.constructor().copy(this);},copy:function(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;},setFromVector3:function(vec3){this.radius=Math.sqrt(vec3.x*vec3.x+vec3.z*vec3.z);this.theta=Math.atan2(vec3.x,vec3.z);this.y=vec3.y;return this;}});/**
   * @author bhouston / http://clara.io
   */function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}Object.assign(Box2.prototype,{set:function(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector2();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),clone:function(){return new this.constructor().copy(this);},copy:function(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
  return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function(target){if(target===undefined){console.warn('THREE.Box2: .getCenter() target is now required');target=new Vector2();}return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function(target){if(target===undefined){console.warn('THREE.Box2: .getSize() target is now required');target=new Vector2();}return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min);},expandByPoint:function(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function(point,target){// This can potentially have a divide by zero if the box
  // has a size dimension of 0.
  if(target===undefined){console.warn('THREE.Box2: .getParameter() target is now required');target=new Vector2();}return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function(box){// using 4 splitting planes to rule out intersections
  return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function(point,target){if(target===undefined){console.warn('THREE.Box2: .clampPoint() target is now required');target=new Vector2();}return target.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector2();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),intersect:function(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
   * @author alteredq / http://alteredqualia.com/
   */function ImmediateRenderObject(material){Object3D.call(this);this.material=material;this.render=function()/* renderCallback */{};}ImmediateRenderObject.prototype=Object.create(Object3D.prototype);ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;ImmediateRenderObject.prototype.isImmediateRenderObject=true;/**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */function VertexNormalsHelper(object,size,hex,linewidth){this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xff0000;var width=linewidth!==undefined?linewidth:1;//
  var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length*3;}else if(objGeometry&&objGeometry.isBufferGeometry){nNormals=objGeometry.attributes.normal.count;}//
  var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
  this.matrixAutoUpdate=false;this.update();}VertexNormalsHelper.prototype=Object.create(LineSegments.prototype);VertexNormalsHelper.prototype.constructor=VertexNormalsHelper;VertexNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){var keys=['a','b','c'];this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
  var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0,jl=face.vertexNormals.length;j<jl;j++){var vertex=vertices[face[keys[j]]];var normal=face.vertexNormals[j];v1.copy(vertex).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}}else if(objGeometry&&objGeometry.isBufferGeometry){var objPos=objGeometry.attributes.position;var objNorm=objGeometry.attributes.normal;var idx=0;// for simplicity, ignore index and drawcalls, and render every normal
  for(var j=0,jl=objPos.count;j<jl;j++){v1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);v2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}position.needsUpdate=true;};}();/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */function SpotLightHelper(light,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new BufferGeometry();var positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var i=0,j=1,l=32;i<l;i++,j++){var p1=i/l*Math.PI*2;var p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.addAttribute('position',new Float32BufferAttribute(positions,3));var material=new LineBasicMaterial({fog:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}SpotLightHelper.prototype=Object.create(Object3D.prototype);SpotLightHelper.prototype.constructor=SpotLightHelper;SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose();};SpotLightHelper.prototype.update=function(){var vector=new Vector3();var vector2=new Vector3();return function update(){this.light.updateMatrixWorld();var coneLength=this.light.distance?this.light.distance:1000;var coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);vector.setFromMatrixPosition(this.light.matrixWorld);vector2.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(vector2.sub(vector));if(this.color!==undefined){this.cone.material.color.set(this.color);}else{this.cone.material.color.copy(this.light.color);}};}();/**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */function getBoneList(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var i=0;i<object.children.length;i++){boneList.push.apply(boneList,getBoneList(object.children[i]));}return boneList;}function SkeletonHelper(object){var bones=getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var i=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});LineSegments.call(this,geometry,material);this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;}SkeletonHelper.prototype=Object.create(LineSegments.prototype);SkeletonHelper.prototype.constructor=SkeletonHelper;SkeletonHelper.prototype.updateMatrixWorld=function(){var vector=new Vector3();var boneMatrix=new Matrix4();var matrixWorldInv=new Matrix4();return function updateMatrixWorld(force){var bones=this.bones;var geometry=this.geometry;var position=geometry.getAttribute('position');matrixWorldInv.getInverse(this.root.matrixWorld);for(var i=0,j=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){boneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j,vector.x,vector.y,vector.z);boneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j+1,vector.x,vector.y,vector.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;Object3D.prototype.updateMatrixWorld.call(this,force);};}();/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */function PointLightHelper(light,sphereSize,color){this.light=light;this.light.updateMatrixWorld();this.color=color;var geometry=new SphereBufferGeometry(sphereSize,4,2);var material=new MeshBasicMaterial({wireframe:true,fog:false});Mesh.call(this,geometry,material);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;this.update();/*
  	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  	var d = light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.scale.set( d, d, d );

  	}

  	this.add( this.lightDistance );
  	*/}PointLightHelper.prototype=Object.create(Mesh.prototype);PointLightHelper.prototype.constructor=PointLightHelper;PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose();};PointLightHelper.prototype.update=function(){if(this.color!==undefined){this.material.color.set(this.color);}else{this.material.color.copy(this.light.color);}/*
  	var d = this.light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.visible = true;
  		this.lightDistance.scale.set( d, d, d );

  	}
  	*/};/**
   * @author abelnation / http://github.com/abelnation
   * @author Mugen87 / http://github.com/Mugen87
   * @author WestLangley / http://github.com/WestLangley
   */function RectAreaLightHelper(light,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var material=new LineBasicMaterial({fog:false});var geometry=new BufferGeometry();geometry.addAttribute('position',new BufferAttribute(new Float32Array(5*3),3));this.line=new Line(geometry,material);this.add(this.line);this.update();}RectAreaLightHelper.prototype=Object.create(Object3D.prototype);RectAreaLightHelper.prototype.constructor=RectAreaLightHelper;RectAreaLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};RectAreaLightHelper.prototype.update=function(){// calculate new dimensions of the helper
  var hx=this.light.width*0.5;var hy=this.light.height*0.5;var position=this.line.geometry.attributes.position;var array=position.array;// update vertices
  array[0]=hx;array[1]=-hy;array[2]=0;array[3]=hx;array[4]=hy;array[5]=0;array[6]=-hx;array[7]=hy;array[8]=0;array[9]=-hx;array[10]=-hy;array[11]=0;array[12]=hx;array[13]=-hy;array[14]=0;position.needsUpdate=true;if(this.color!==undefined){this.line.material.color.set(this.color);}else{this.line.material.color.copy(this.light.color);}};/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */function HemisphereLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new OctahedronBufferGeometry(size);geometry.rotateY(Math.PI*0.5);this.material=new MeshBasicMaterial({wireframe:true,fog:false});if(this.color===undefined)this.material.vertexColors=VertexColors;var position=geometry.getAttribute('position');var colors=new Float32Array(position.count*3);geometry.addAttribute('color',new BufferAttribute(colors,3));this.add(new Mesh(geometry,this.material));this.update();}HemisphereLightHelper.prototype=Object.create(Object3D.prototype);HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};HemisphereLightHelper.prototype.update=function(){var vector=new Vector3();var color1=new Color();var color2=new Color();return function update(){var mesh=this.children[0];if(this.color!==undefined){this.material.color.set(this.color);}else{var colors=mesh.geometry.getAttribute('color');color1.copy(this.light.color);color2.copy(this.light.groundColor);for(var i=0,l=colors.count;i<l;i++){var color=i<l/2?color1:color2;colors.setXYZ(i,color.r,color.g,color.b);}colors.needsUpdate=true;}mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());};}();/**
   * @author mrdoob / http://mrdoob.com/
   */function GridHelper(size,divisions,color1,color2){size=size||10;divisions=divisions||10;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}GridHelper.prototype=Object.create(LineSegments.prototype);GridHelper.prototype.constructor=GridHelper;/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   * @author Hectate / http://www.github.com/Hectate
   */function PolarGridHelper(radius,radials,circles,divisions,color1,color2){radius=radius||10;radials=radials||16;circles=circles||8;divisions=divisions||64;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var vertices=[];var colors=[];var x,z;var v,i,j,r,color;// create the radials
  for(i=0;i<=radials;i++){v=i/radials*(Math.PI*2);x=Math.sin(v)*radius;z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
  for(i=0;i<=circles;i++){color=i&1?color1:color2;r=radius-radius/circles*i;for(j=0;j<divisions;j++){// first vertex
  v=j/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
  v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}PolarGridHelper.prototype=Object.create(LineSegments.prototype);PolarGridHelper.prototype.constructor=PolarGridHelper;/**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */function FaceNormalsHelper(object,size,hex,linewidth){// FaceNormalsHelper only supports THREE.Geometry
  this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xffff00;var width=linewidth!==undefined?linewidth:1;//
  var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length;}else{console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');}//
  var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
  this.matrixAutoUpdate=false;this.update();}FaceNormalsHelper.prototype=Object.create(LineSegments.prototype);FaceNormalsHelper.prototype.constructor=FaceNormalsHelper;FaceNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
  var objGeometry=this.object.geometry;var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];var normal=face.normal;v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}position.needsUpdate=true;};}();/**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */function DirectionalLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;if(size===undefined)size=1;var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));var material=new LineBasicMaterial({fog:false});this.lightPlane=new Line(geometry,material);this.add(this.lightPlane);geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(geometry,material);this.add(this.targetLine);this.update();}DirectionalLightHelper.prototype=Object.create(Object3D.prototype);DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose();};DirectionalLightHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var v3=new Vector3();return function update(){v1.setFromMatrixPosition(this.light.matrixWorld);v2.setFromMatrixPosition(this.light.target.matrixWorld);v3.subVectors(v2,v1);this.lightPlane.lookAt(v3);if(this.color!==undefined){this.lightPlane.material.color.set(this.color);this.targetLine.material.color.set(this.color);}else{this.lightPlane.material.color.copy(this.light.color);this.targetLine.material.color.copy(this.light.color);}this.targetLine.lookAt(v3);this.targetLine.scale.z=v3.length();};}();/**
   * @author alteredq / http://alteredqualia.com/
   * @author Mugen87 / https://github.com/Mugen87
   *
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */function CameraHelper(camera){var geometry=new BufferGeometry();var material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});var vertices=[];var colors=[];var pointMap={};// colors
  var colorFrustum=new Color(0xffaa00);var colorCone=new Color(0xff0000);var colorUp=new Color(0x00aaff);var colorTarget=new Color(0xffffff);var colorCross=new Color(0x333333);// near
  addLine('n1','n2',colorFrustum);addLine('n2','n4',colorFrustum);addLine('n4','n3',colorFrustum);addLine('n3','n1',colorFrustum);// far
  addLine('f1','f2',colorFrustum);addLine('f2','f4',colorFrustum);addLine('f4','f3',colorFrustum);addLine('f3','f1',colorFrustum);// sides
  addLine('n1','f1',colorFrustum);addLine('n2','f2',colorFrustum);addLine('n3','f3',colorFrustum);addLine('n4','f4',colorFrustum);// cone
  addLine('p','n1',colorCone);addLine('p','n2',colorCone);addLine('p','n3',colorCone);addLine('p','n4',colorCone);// up
  addLine('u1','u2',colorUp);addLine('u2','u3',colorUp);addLine('u3','u1',colorUp);// target
  addLine('c','t',colorTarget);addLine('p','c',colorCross);// cross
  addLine('cn1','cn2',colorCross);addLine('cn3','cn4',colorCross);addLine('cf1','cf2',colorCross);addLine('cf3','cf4',colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));LineSegments.call(this,geometry,material);this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}CameraHelper.prototype=Object.create(LineSegments.prototype);CameraHelper.prototype.constructor=CameraHelper;CameraHelper.prototype.update=function(){var geometry,pointMap;var vector=new Vector3();var camera=new Camera();function setPoint(point,x,y,z){vector.set(x,y,z).unproject(camera);var points=pointMap[point];if(points!==undefined){var position=geometry.getAttribute('position');for(var i=0,l=points.length;i<l;i++){position.setXYZ(points[i],vector.x,vector.y,vector.z);}}}return function update(){geometry=this.geometry;pointMap=this.pointMap;var w=1,h=1;// we need just camera projection matrix
  // world matrix must be identity
  camera.projectionMatrix.copy(this.camera.projectionMatrix);// center / target
  setPoint('c',0,0,-1);setPoint('t',0,0,1);// near
  setPoint('n1',-w,-h,-1);setPoint('n2',w,-h,-1);setPoint('n3',-w,h,-1);setPoint('n4',w,h,-1);// far
  setPoint('f1',-w,-h,1);setPoint('f2',w,-h,1);setPoint('f3',-w,h,1);setPoint('f4',w,h,1);// up
  setPoint('u1',w*0.7,h*1.1,-1);setPoint('u2',-w*0.7,h*1.1,-1);setPoint('u3',0,h*2,-1);// cross
  setPoint('cf1',-w,0,1);setPoint('cf2',w,0,1);setPoint('cf3',0,-h,1);setPoint('cf4',0,h,1);setPoint('cn1',-w,0,-1);setPoint('cn2',w,0,-1);setPoint('cn3',0,-h,-1);setPoint('cn4',0,h,-1);geometry.getAttribute('position').needsUpdate=true;};}();/**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */function BoxHelper(object,color){this.object=object;if(color===undefined)color=0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=new Float32Array(8*3);var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));this.matrixAutoUpdate=false;this.update();}BoxHelper.prototype=Object.create(LineSegments.prototype);BoxHelper.prototype.constructor=BoxHelper;BoxHelper.prototype.update=function(){var box=new Box3();return function update(object){if(object!==undefined){console.warn('THREE.BoxHelper: .update() has no longer arguments.');}if(this.object!==undefined){box.setFromObject(this.object);}if(box.isEmpty())return;var min=box.min;var max=box.max;/*
  		  5____4
  		1/___0/|
  		| 6__|_7
  		2/___3/

  		0: max.x, max.y, max.z
  		1: min.x, max.y, max.z
  		2: min.x, min.y, max.z
  		3: max.x, min.y, max.z
  		4: max.x, max.y, min.z
  		5: min.x, max.y, min.z
  		6: min.x, min.y, min.z
  		7: max.x, min.y, min.z
  		*/var position=this.geometry.attributes.position;var array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();};}();BoxHelper.prototype.setFromObject=function(object){this.object=object;this.update();return this;};/**
   * @author WestLangley / http://github.com/WestLangley
   */function Box3Helper(box,hex){this.type='Box3Helper';this.box=box;var color=hex!==undefined?hex:0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new Float32BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));this.geometry.computeBoundingSphere();}Box3Helper.prototype=Object.create(LineSegments.prototype);Box3Helper.prototype.constructor=Box3Helper;Box3Helper.prototype.updateMatrixWorld=function(force){var box=this.box;if(box.isEmpty())return;box.getCenter(this.position);box.getSize(this.scale);this.scale.multiplyScalar(0.5);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
   * @author WestLangley / http://github.com/WestLangley
   */function PlaneHelper(plane,size,hex){this.type='PlaneHelper';this.plane=plane;this.size=size===undefined?1:size;var color=hex!==undefined?hex:0xffff00;var positions=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(positions,3));geometry.computeBoundingSphere();Line.call(this,geometry,new LineBasicMaterial({color:color}));//
  var positions2=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];var geometry2=new BufferGeometry();geometry2.addAttribute('position',new Float32BufferAttribute(positions2,3));geometry2.computeBoundingSphere();this.add(new Mesh(geometry2,new MeshBasicMaterial({color:color,opacity:0.2,transparent:true,depthWrite:false})));}PlaneHelper.prototype=Object.create(Line.prototype);PlaneHelper.prototype.constructor=PlaneHelper;PlaneHelper.prototype.updateMatrixWorld=function(force){var scale=-this.plane.constant;if(Math.abs(scale)<1e-8)scale=1e-8;// sign does not matter
  this.scale.set(0.5*this.size,0.5*this.size,scale);this.lookAt(this.plane.normal);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
   * @author WestLangley / http://github.com/WestLangley
   * @author zz85 / http://github.com/zz85
   * @author bhouston / http://clara.io
   *
   * Creates an arrow for visualizing directions
   *
   * Parameters:
   *  dir - Vector3
   *  origin - Vector3
   *  length - Number
   *  color - color in hex value
   *  headLength - Number
   *  headWidth - Number
   */var lineGeometry;var coneGeometry;function ArrowHelper(dir,origin,length,color,headLength,headWidth){// dir is assumed to be normalized
  Object3D.call(this);if(color===undefined)color=0xffff00;if(length===undefined)length=1;if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;if(lineGeometry===undefined){lineGeometry=new BufferGeometry();lineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);coneGeometry.translate(0,-0.5,0);}this.position.copy(origin);this.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}ArrowHelper.prototype=Object.create(Object3D.prototype);ArrowHelper.prototype.constructor=ArrowHelper;ArrowHelper.prototype.setDirection=function(){var axis=new Vector3();var radians;return function setDirection(dir){// dir is assumed to be normalized
  if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{axis.set(dir.z,0,-dir.x).normalize();radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(axis,radians);}};}();ArrowHelper.prototype.setLength=function(length,headLength,headWidth){if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.line.scale.set(1,Math.max(0,length-headLength),1);this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();};ArrowHelper.prototype.setColor=function(color){this.line.material.color.copy(color);this.cone.material.color.copy(color);};/**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */function AxesHelper(size){size=size||1;var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];var colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}AxesHelper.prototype=Object.create(LineSegments.prototype);AxesHelper.prototype.constructor=AxesHelper;//
  Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
  Object.assign(CurvePath.prototype,{createPointsGeometry:function(divisions){console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from path points (for Line or Points objects)
  var pts=this.getPoints(divisions);return this.createGeometry(pts);},createSpacedPointsGeometry:function(divisions){console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from equidistant sampling along the path
  var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function(points){console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});//
  Object.assign(Path.prototype,{fromPoints:function(points){console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');this.setFromPoints(points);}});//
  function Spline(points){console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}Spline.prototype=Object.create(CatmullRomCurve3.prototype);Object.assign(Spline.prototype,{initFromArray:function()/* a */{console.error('THREE.Spline: .initFromArray() has been removed.');},getControlPointsArray:function()/* optionalTarget */{console.error('THREE.Spline: .getControlPointsArray() has been removed.');},reparametrizeByArcLength:function()/* samplingCoef */{console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');}});GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};SkeletonHelper.prototype.update=function(){console.error('THREE.SkeletonHelper: update() no longer needs to be called.');};//
  Object.assign(Loader.prototype,{extractUrlBase:function(url){console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');return LoaderUtils.extractUrlBase(url);}});//
  Object.assign(Box2.prototype,{center:function(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},size:function(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Object.assign(Box3.prototype,{center:function(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionSphere:function(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);},size:function(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Object.assign(_Math,{random16:function(){console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');return Math.random();},nearestPowerOfTwo:function(value){console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');return _Math.floorPowerOfTwo(value);},nextPowerOfTwo:function(value){console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');return _Math.ceilPowerOfTwo(value);}});Object.assign(Matrix3.prototype,{flattenToArrayOffset:function(array,offset){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},multiplyVector3:function(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);},multiplyVector3Array:function()/* a */{console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');},applyToBuffer:function(buffer/*, offset, length */){console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function()/* array, offset, length */{console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');}});Object.assign(Matrix4.prototype,{extractPosition:function(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);},flattenToArrayOffset:function(array,offset){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},getPosition:function(){var v1;return function getPosition(){if(v1===undefined)v1=new Vector3();console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return v1.setFromMatrixColumn(this,3);};}(),setRotationFromQuaternion:function(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);},multiplyToArray:function(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');},multiplyVector3:function(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector4:function(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector3Array:function()/* a */{console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');},rotateAxis:function(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);},crossVector:function(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},translate:function(){console.error('THREE.Matrix4: .translate() has been removed.');},rotateX:function(){console.error('THREE.Matrix4: .rotateX() has been removed.');},rotateY:function(){console.error('THREE.Matrix4: .rotateY() has been removed.');},rotateZ:function(){console.error('THREE.Matrix4: .rotateZ() has been removed.');},rotateByAxis:function(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');},applyToBuffer:function(buffer/*, offset, length */){console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function()/* array, offset, length */{console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');},makeFrustum:function(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);}});Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Object.assign(Ray.prototype,{isIntersectionBox:function(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionPlane:function(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);},isIntersectionSphere:function(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);}});Object.assign(Triangle.prototype,{area:function(){console.warn('THREE.Triangle: .area() has been renamed to .getArea().');return this.getArea();},barycoordFromPoint:function(point,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return this.getBarycoord(point,target);},midpoint:function(target){console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');return this.getMidpoint(target);},normal:function(target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return this.getNormal(target);},plane:function(target){console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');return this.getPlane(target);}});Object.assign(Triangle,{barycoordFromPoint:function(point,a,b,c,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return Triangle.getBarycoord(point,a,b,c,target);},normal:function(a,b,c,target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return Triangle.getNormal(a,b,c,target);}});Object.assign(Shape.prototype,{extractAllPoints:function(divisions){console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');return this.extractPoints(divisions);},extrude:function(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);},makeGeometry:function(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);}});Object.assign(Vector2.prototype,{fromAttribute:function(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});Object.assign(Vector3.prototype,{setEulerFromRotationMatrix:function(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');},setEulerFromQuaternion:function(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');},getPositionFromMatrix:function(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);},getScaleFromMatrix:function(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);},getColumnFromMatrix:function(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);},applyProjection:function(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);},fromAttribute:function(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});Object.assign(Vector4.prototype,{fromAttribute:function(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},lengthManhattan:function(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});//
  Object.assign(Geometry.prototype,{computeTangents:function(){console.error('THREE.Geometry: .computeTangents() has been removed.');},computeLineDistances:function(){console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');}});Object.assign(Object3D.prototype,{getChildByName:function(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);},renderDepth:function(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');},translate:function(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);},getWorldRotation:function(){console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');}});Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});Object.defineProperties(LOD.prototype,{objects:{get:function(){console.warn('THREE.LOD: .objects has been renamed to .levels.');return this.levels;}}});Object.defineProperty(Skeleton.prototype,'useVertexTexture',{get:function(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');},set:function(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');}});Object.defineProperty(Curve.prototype,'__arcLengthDivisions',{get:function(){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');return this.arcLengthDivisions;},set:function(value){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');this.arcLengthDivisions=value;}});//
  PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+"Use .setFocalLength and .filmGauge for a photographic setup.");if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
  Object.defineProperties(Light.prototype,{onlyShadow:{set:function(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
  Object.defineProperties(BufferAttribute.prototype,{length:{get:function(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}},copyIndicesArray:function()/* indices */{console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');}});Object.assign(BufferGeometry.prototype,{addIndex:function(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);},addDrawCall:function(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);},clearDrawCalls:function(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();},computeTangents:function(){console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');},computeOffsets:function(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');}});Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});//
  Object.assign(ExtrudeBufferGeometry.prototype,{getArrays:function(){console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');},addShapeList:function(){console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');},addShape:function(){console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');}});//
  Object.defineProperties(Uniform.prototype,{dynamic:{set:function(){console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');}},onUpdate:{value:function(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;}}});//
  Object.defineProperties(Material.prototype,{wrapAround:{get:function(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function(){console.warn('THREE.Material: .wrapAround has been removed.');}},wrapRGB:{get:function(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}},shading:{get:function(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}}});Object.defineProperties(MeshPhongMaterial.prototype,{metal:{get:function(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');return false;},set:function(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
  Object.assign(WebGLRenderer.prototype,{getCurrentRenderTarget:function(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();},getMaxAnisotropy:function(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();},getPrecision:function(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;},resetGLState:function(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();},supportsFloatTextures:function(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');},supportsHalfFloatTextures:function(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');},supportsStandardDerivatives:function(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');},supportsCompressedTextureS3TC:function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');},supportsCompressedTexturePVRTC:function(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');},supportsBlendMinMax:function(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');},supportsVertexTextures:function(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;},supportsInstancedArrays:function(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');},enableScissorTest:function(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);},initMaterial:function(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');},addPrePlugin:function(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');},addPostPlugin:function(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');},updateShadowMap:function(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');},setFaceCulling:function(){console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');}});Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function(){return this.shadowMap.type;},set:function(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function()/* value */{console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function()/* cullFace */{console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');}},renderReverseSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');}},renderSingleSided:{get:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');}}});//
  Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
  Object.defineProperties(WebVRManager.prototype,{standing:{set:function()/* value */{console.warn('THREE.WebVRManager: .standing has been removed.');}}});//
  Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
  CubeCamera.prototype.updateCubeMap=function(renderer,scene){console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');return this.update(renderer,scene);};var minivents_commonjs=function Events(target){var events={},empty=[];target=target||this;/**
     *  On: listen to events
     */target.on=function(type,func,ctx){(events[type]=events[type]||[]).push([func,ctx]);return target;};/**
     *  Off: stop listening to event / specific callback
     */target.off=function(type,func){type||(events={});var list=events[type]||empty,i=list.length=func?list.length:0;while(i--)func==list[i][0]&&list.splice(i,1);return target;};/** 
     * Emit: send event, callbacks will be triggered
     */target.emit=function(type){var e=events[type]||empty,list=e.length>0?e.slice(0,e.length):e,i=0,j;while(j=list[i++])j[0].apply(j[1],empty.slice.call(arguments,1));return target;};};// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
  _export(_export.S,'Object',{create:_objectCreate});var $Object$2=_core.Object;var create=function create(P,D){return $Object$2.create(P,D);};var create$1=create;var _validateCollection=function(it,TYPE){if(!_isObject(it)||it._t!==TYPE)throw TypeError('Incompatible receiver, '+TYPE+' required!');return it;};var dP$2=_objectDp.f;var fastKey=_meta.fastKey;var SIZE=_descriptors?'_s':'size';var getEntry=function(that,key){// fast case
  var index=fastKey(key);var entry;if(index!=='F')return that._i[index];// frozen object case
  for(entry=that._f;entry;entry=entry.n){if(entry.k==key)return entry;}};var _collectionStrong={getConstructor:function(wrapper,NAME,IS_MAP,ADDER){var C=wrapper(function(that,iterable){_anInstance(that,C,NAME,'_i');that._t=NAME;// collection type
  that._i=_objectCreate(null);// index
  that._f=undefined;// first entry
  that._l=undefined;// last entry
  that[SIZE]=0;// size
  if(iterable!=undefined)_forOf(iterable,IS_MAP,that[ADDER],that);});_redefineAll(C.prototype,{// 23.1.3.1 Map.prototype.clear()
  // 23.2.3.2 Set.prototype.clear()
  clear:function clear(){for(var that=_validateCollection(this,NAME),data=that._i,entry=that._f;entry;entry=entry.n){entry.r=true;if(entry.p)entry.p=entry.p.n=undefined;delete data[entry.i];}that._f=that._l=undefined;that[SIZE]=0;},// 23.1.3.3 Map.prototype.delete(key)
  // 23.2.3.4 Set.prototype.delete(value)
  'delete':function(key){var that=_validateCollection(this,NAME);var entry=getEntry(that,key);if(entry){var next=entry.n;var prev=entry.p;delete that._i[entry.i];entry.r=true;if(prev)prev.n=next;if(next)next.p=prev;if(that._f==entry)that._f=next;if(that._l==entry)that._l=prev;that[SIZE]--;}return !!entry;},// 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
  // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
  forEach:function forEach(callbackfn/* , that = undefined */){_validateCollection(this,NAME);var f=_ctx(callbackfn,arguments.length>1?arguments[1]:undefined,3);var entry;while(entry=entry?entry.n:this._f){f(entry.v,entry.k,this);// revert to the last existing entry
  while(entry&&entry.r)entry=entry.p;}},// 23.1.3.7 Map.prototype.has(key)
  // 23.2.3.7 Set.prototype.has(value)
  has:function has(key){return !!getEntry(_validateCollection(this,NAME),key);}});if(_descriptors)dP$2(C.prototype,'size',{get:function(){return _validateCollection(this,NAME)[SIZE];}});return C;},def:function(that,key,value){var entry=getEntry(that,key);var prev,index;// change existing entry
  if(entry){entry.v=value;// create new entry
  }else{that._l=entry={i:index=fastKey(key,true),// <- index
  k:key,// <- key
  v:value,// <- value
  p:prev=that._l,// <- previous entry
  n:undefined,// <- next entry
  r:false// <- removed
  };if(!that._f)that._f=entry;if(prev)prev.n=entry;that[SIZE]++;// add to index
  if(index!=='F')that._i[index]=entry;}return that;},getEntry:getEntry,setStrong:function(C,NAME,IS_MAP){// add .keys, .values, .entries, [@@iterator]
  // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
  _iterDefine(C,NAME,function(iterated,kind){this._t=_validateCollection(iterated,NAME);// target
  this._k=kind;// kind
  this._l=undefined;// previous
  },function(){var that=this;var kind=that._k;var entry=that._l;// revert to the last existing entry
  while(entry&&entry.r)entry=entry.p;// get next entry
  if(!that._t||!(that._l=entry=entry?entry.n:that._t._f)){// or finish the iteration
  that._t=undefined;return _iterStep(1);}// return step by kind
  if(kind=='keys')return _iterStep(0,entry.k);if(kind=='values')return _iterStep(0,entry.v);return _iterStep(0,[entry.k,entry.v]);},IS_MAP?'entries':'values',!IS_MAP,true);// add [@@species], 23.1.2.2, 23.2.2.2
  _setSpecies(NAME);}};var SPECIES$2=_wks('species');var _arraySpeciesConstructor=function(original){var C;if(_isArray(original)){C=original.constructor;// cross-realm fallback
  if(typeof C=='function'&&(C===Array||_isArray(C.prototype)))C=undefined;if(_isObject(C)){C=C[SPECIES$2];if(C===null)C=undefined;}}return C===undefined?Array:C;};// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
  var _arraySpeciesCreate=function(original,length){return new(_arraySpeciesConstructor(original))(length);};// 0 -> Array#forEach
  // 1 -> Array#map
  // 2 -> Array#filter
  // 3 -> Array#some
  // 4 -> Array#every
  // 5 -> Array#find
  // 6 -> Array#findIndex
  var _arrayMethods=function(TYPE,$create){var IS_MAP=TYPE==1;var IS_FILTER=TYPE==2;var IS_SOME=TYPE==3;var IS_EVERY=TYPE==4;var IS_FIND_INDEX=TYPE==6;var NO_HOLES=TYPE==5||IS_FIND_INDEX;var create=$create||_arraySpeciesCreate;return function($this,callbackfn,that){var O=_toObject($this);var self=_iobject(O);var f=_ctx(callbackfn,that,3);var length=_toLength(self.length);var index=0;var result=IS_MAP?create($this,length):IS_FILTER?create($this,0):undefined;var val,res;for(;length>index;index++)if(NO_HOLES||index in self){val=self[index];res=f(val,index,O);if(TYPE){if(IS_MAP)result[index]=res;// map
  else if(res)switch(TYPE){case 3:return true;// some
  case 5:return val;// find
  case 6:return index;// findIndex
  case 2:result.push(val);// filter
  }else if(IS_EVERY)return false;// every
  }}return IS_FIND_INDEX?-1:IS_SOME||IS_EVERY?IS_EVERY:result;};};var dP$3=_objectDp.f;var each=_arrayMethods(0);var _collection=function(NAME,wrapper,methods,common,IS_MAP,IS_WEAK){var Base=_global[NAME];var C=Base;var ADDER=IS_MAP?'set':'add';var proto=C&&C.prototype;var O={};if(!_descriptors||typeof C!='function'||!(IS_WEAK||proto.forEach&&!_fails(function(){new C().entries().next();}))){// create collection constructor
  C=common.getConstructor(wrapper,NAME,IS_MAP,ADDER);_redefineAll(C.prototype,methods);_meta.NEED=true;}else{C=wrapper(function(target,iterable){_anInstance(target,C,NAME,'_c');target._c=new Base();if(iterable!=undefined)_forOf(iterable,IS_MAP,target[ADDER],target);});each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){var IS_ADDER=KEY=='add'||KEY=='set';if(KEY in proto&&!(IS_WEAK&&KEY=='clear'))_hide(C.prototype,KEY,function(a,b){_anInstance(this,C,KEY);if(!IS_ADDER&&IS_WEAK&&!_isObject(a))return KEY=='get'?undefined:false;var result=this._c[KEY](a===0?0:a,b);return IS_ADDER?this:result;});});IS_WEAK||dP$3(C.prototype,'size',{get:function(){return this._c.size;}});}_setToStringTag(C,NAME);O[NAME]=C;_export(_export.G+_export.W+_export.F,O);if(!IS_WEAK)common.setStrong(C,NAME,IS_MAP);return C;};var MAP='Map';// 23.1 Map Objects
  var es6_map=_collection(MAP,function(get){return function Map(){return get(this,arguments.length>0?arguments[0]:undefined);};},{// 23.1.3.6 Map.prototype.get(key)
  get:function get(key){var entry=_collectionStrong.getEntry(_validateCollection(this,MAP),key);return entry&&entry.v;},// 23.1.3.9 Map.prototype.set(key, value)
  set:function set(key,value){return _collectionStrong.def(_validateCollection(this,MAP),key===0?0:key,value);}},_collectionStrong,true);var _arrayFromIterable=function(iter,ITERATOR){var result=[];_forOf(iter,false,result.push,result,ITERATOR);return result;};// https://github.com/DavidBruant/Map-Set.prototype.toJSON
  var _collectionToJson=function(NAME){return function toJSON(){if(_classof(this)!=NAME)throw TypeError(NAME+"#toJSON isn't generic");return _arrayFromIterable(this);};};// https://github.com/DavidBruant/Map-Set.prototype.toJSON
  _export(_export.P+_export.R,'Map',{toJSON:_collectionToJson('Map')});// https://tc39.github.io/proposal-setmap-offrom/
  var _setCollectionOf=function(COLLECTION){_export(_export.S,COLLECTION,{of:function of(){var length=arguments.length;var A=new Array(length);while(length--)A[length]=arguments[length];return new this(A);}});};// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
  _setCollectionOf('Map');// https://tc39.github.io/proposal-setmap-offrom/
  var _setCollectionFrom=function(COLLECTION){_export(_export.S,COLLECTION,{from:function from(source/* , mapFn, thisArg */){var mapFn=arguments[1];var mapping,A,n,cb;_aFunction(this);mapping=mapFn!==undefined;if(mapping)_aFunction(mapFn);if(source==undefined)return new this();A=[];if(mapping){n=0;cb=_ctx(mapFn,arguments[2],2);_forOf(source,false,function(nextItem){A.push(cb(nextItem,n++));});}else{_forOf(source,false,A.push,A);}return new this(A);}});};// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
  _setCollectionFrom('Map');var map=_core.Map;var map$1=map;var arraySlice=[].slice;var factories={};var construct=function(F,len,args){if(!(len in factories)){for(var n=[],i=0;i<len;i++)n[i]='a['+i+']';// eslint-disable-next-line no-new-func
  factories[len]=Function('F,a','return new F('+n.join(',')+')');}return factories[len](F,args);};var _bind=Function.bind||function bind(that/* , ...args */){var fn=_aFunction(this);var partArgs=arraySlice.call(arguments,1);var bound=function()/* args... */{var args=partArgs.concat(arraySlice.call(arguments));return this instanceof bound?construct(fn,args.length,args):_invoke(fn,args,that);};if(_isObject(fn.prototype))bound.prototype=fn.prototype;return bound;};// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
  var rConstruct=(_global.Reflect||{}).construct;// MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it
  var NEW_TARGET_BUG=_fails(function(){function F(){/* empty */}return !(rConstruct(function(){/* empty */},[],F)instanceof F);});var ARGS_BUG=!_fails(function(){rConstruct(function(){/* empty */});});_export(_export.S+_export.F*(NEW_TARGET_BUG||ARGS_BUG),'Reflect',{construct:function construct(Target,args/* , newTarget */){_aFunction(Target);_anObject(args);var newTarget=arguments.length<3?Target:_aFunction(arguments[2]);if(ARGS_BUG&&!NEW_TARGET_BUG)return rConstruct(Target,args,newTarget);if(Target==newTarget){// w/o altered newTarget, optimization for 0-4 arguments
  switch(args.length){case 0:return new Target();case 1:return new Target(args[0]);case 2:return new Target(args[0],args[1]);case 3:return new Target(args[0],args[1],args[2]);case 4:return new Target(args[0],args[1],args[2],args[3]);}// w/o altered newTarget, lot of arguments case
  var $args=[null];$args.push.apply($args,args);return new(_bind.apply(Target,$args))();}// with altered newTarget, not support built-in constructors
  var proto=newTarget.prototype;var instance=_objectCreate(_isObject(proto)?proto:Object.prototype);var result=Function.apply.call(Target,instance,args);return _isObject(result)?result:instance;}});var construct$1=_core.Reflect.construct;var construct$2=construct$1;var construct$3=createCommonjsModule(function(module){function _construct$$1(Parent,args,Class){if(typeof Reflect!=="undefined"&&construct$2){module.exports=_construct$$1=construct$2;}else{module.exports=_construct$$1=function _construct$$1(Parent,args,Class){var a=[null];a.push.apply(a,args);var Constructor=Parent.bind.apply(Parent,a);var instance=new Constructor();if(Class)setPrototypeOf$2(instance,Class.prototype);return instance;};}return _construct$$1.apply(null,arguments);}module.exports=_construct$$1;});var wrapNativeSuper=createCommonjsModule(function(module){function _wrapNativeSuper$$1(Class){var _cache=typeof map$1==="function"?new map$1():undefined;module.exports=_wrapNativeSuper$$1=function _wrapNativeSuper$$1(Class){if(typeof Class!=="function"){throw new TypeError("Super expression must either be null or a function");}if(typeof _cache!=="undefined"){if(_cache.has(Class))return _cache.get(Class);_cache.set(Class,Wrapper);}function Wrapper(){}Wrapper.prototype=create$1(Class.prototype,{constructor:{value:Wrapper,enumerable:false,writable:true,configurable:true}});return setPrototypeOf$2(Wrapper,setPrototypeOf$2(function Super(){return construct$3(Class,arguments,getPrototypeOf$2(this).constructor);},Class));};return _wrapNativeSuper$$1(Class);}module.exports=_wrapNativeSuper$$1;});var CompositionError$1=/*#__PURE__*/function(_Error){function CompositionError(classInstance,message,component){var _this;classCallCheck(this,CompositionError);_this=possibleConstructorReturn(this,getPrototypeOf$2(CompositionError).call(this,"@".concat(classInstance,": ").concat(message)));var stackArray=_this.stack.split('\n');stackArray.splice(1,2);_this.stack=stackArray.join('\n');if(console)console.error('Component:',component);_this.name='CompositionError';return _this;}inherits(CompositionError,_Error);return CompositionError;}(wrapNativeSuper(Error));var DependencyError=/*#__PURE__*/function(_Error2){function DependencyError(classInstance,message,activeModule){var _this2;var dependencyModule=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;classCallCheck(this,DependencyError);_this2=possibleConstructorReturn(this,getPrototypeOf$2(DependencyError).call(this,"@".concat(classInstance,": ").concat(message)));var stackArray=_this2.stack.split('\n');stackArray.splice(1,2);_this2.stack=stackArray.join('\n');if(console)console.error('Active module:',activeModule);if(console&&dependencyModule)console.error('Dependency published by module:',dependencyModule);_this2.name='DependencyError';return _this2;}inherits(DependencyError,_Error2);return DependencyError;}(wrapNativeSuper(Error));var ManagerError=/*#__PURE__*/function(_Error3){function ManagerError(classInstance,message,component){var _this3;var activeModule=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;classCallCheck(this,ManagerError);_this3=possibleConstructorReturn(this,getPrototypeOf$2(ManagerError).call(this,"@".concat(classInstance,": ").concat(message)));var stackArray=_this3.stack.split('\n');stackArray.splice(1,2);_this3.stack=stackArray.join('\n');if(console)console.error('Component:',component);if(console&&activeModule)console.error('Active module:',activeModule);_this3.name='ManagerError';return _this3;}inherits(ManagerError,_Error3);return ManagerError;}(wrapNativeSuper(Error));var warnDeps=function warnDeps(){throw new Error('WhitestormJS Framework requ ires Three.js r92. https://threejs.org/');};try{}catch(err){warnDeps();}/**
   * @class ModuleSystem
   * @category core
   * @description  Provides API for classes that will use Modules.<br/>
   * This class includes basic event system with those supported methods:
   * <pre>.on()</pre><pre>.off()</pre><pre>.emit()</pre>
   * @extends Events
   * @memberof module:core
   */var ModuleSystem=/*#__PURE__*/function(_Events){function ModuleSystem(){classCallCheck(this,ModuleSystem);return possibleConstructorReturn(this,getPrototypeOf$2(ModuleSystem).apply(this,arguments));}createClass(ModuleSystem,[{key:"integrateModules",// INTEGRATING
  /**
       * @method integrateModules
       * @instance
       * @description This method applies all modules from .modules collection.
       * @param {Object} [source] If source (should be a component) is provided, will replace .modules with source's one before executing modules.
       * @memberof module:core.ModuleSystem
       */value:function integrateModules(source){if(!this.modules&&!source)return;if(source&&source.modules)this.modules=source.modules.slice(0);if(this.modules){for(var i=0,max=this.modules.length;i<max;i++){this.applyModule(this.modules[i],false);}}if(source)this.applyBridge({onCopy:source});}// APPLYING MODULE (...and a "bridge" for module)
  /**
       * @method applyBridge
       * @instance
       * @description Makes component-specific API to work with modules.
       * @param {Object} bridgeMap
       * @return {Object} Returns object with modified values.
       * @memberof module:core.ModuleSystem
       */},{key:"applyBridge",value:function applyBridge(){var bridgeMap=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var modules=this.modules;if(!modules)return bridgeMap;for(var i=0,max=modules.length;i<max;i++){for(var key in bridgeMap){if(bridgeMap[key]){var module=modules[i];if(module&&module.bridge&&module.bridge[key])bridgeMap[key]=module.bridge[key].apply(this,[bridgeMap[key],module]);}}}return bridgeMap;}/**
       * @method applyCommand
       * @instance
       * @description .applyCommand runs a method called `name` on all modules.
       * @param {String} name the method name.
       * @param {Function} [cb=(func, moduleScope) => func.apply(this, [moduleScope])] How the function is wrapped/
       * @memberof module:core.ModuleSystem
       */},{key:"applyCommand",value:function applyCommand(name){var _this=this;var cb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:function(func,moduleScope){return func.apply(_this,[moduleScope]);};var modules=this.modules;if(!modules)return;for(var i=0,max=modules.length;i<max;i++){var module=modules[i];if(name in module)cb(module[name],module);}}/**
       * @method applyModule
       * @instance
       * @description .applyModule is also used in .integrateModules() function.
       * It does exactly what its name says (applies module to component or app).
       * @param {Object} module the module to apply
       * @param {Boolean} [push=true]
       * @return {Object} Returns module that was applied.
       * @throws {ManagerError}
       * @memberof module:core.ModuleSystem
       */},{key:"applyModule",value:function applyModule(module){var push=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(!module)return;if(push&&this.modules)this.modules.push(module);else if(push)this.modules=[module];if(this.manager)this.manager.active(module);if(module.manager&&this.manager)module.manager(this.manager);else if(module.manager){throw new ManagerError('Component',"Module requires ModuleManager that is turned off for this component",this,module);}if(module.integrate)module.integrate.bind(this)(module);return module;}/**
       * @method disposeModules
       * @instance
       * @description Disposes of all modules
       * @memberof module:core.ModuleSystem
       */},{key:"disposeModules",value:function disposeModules(){while(this.modules.length){this.disposeModule(this.modules[0]);}}/**
       * @method disposeModule
       * @instance
       * @description Disposes of the given module
       * @param {Object} module the module to dispose
       * @return {Module} Returns module that was removed.
       * @memberof module:core.ModuleSystem
       */},{key:"disposeModule",value:function disposeModule(module){if(!module)return;this.modules.splice(this.modules.indexOf(module),1);if(module.dispose)module.dispose.bind(this)(module);return module;}// PIPED METHOD
  /**
       * @method module
       * @instance
       * @description piped version of .applyModule().
       * @param {Object} module the module to apply
       * @return {this} returns this - app/component
       * @throws {ManagerError}
       * @memberof module:core.ModuleSystem
       * @example <caption>Piped modules</caption>
       * component
       *   .module(new Module1())
       *   .module(new Module2())
       *   .module(new Module3())
       */},{key:"module",value:function module(_module){this.applyModule(_module);return this;}}]);inherits(ModuleSystem,_Events);return ModuleSystem;}(minivents_commonjs);function _arrayWithHoles$1(arr){if(Array.isArray(arr))return arr;}var arrayWithHoles=_arrayWithHoles$1;var core_getIterator=_core.getIterator=function(it){var iterFn=core_getIteratorMethod(it);if(typeof iterFn!='function')throw TypeError(it+' is not iterable!');return _anObject(iterFn.call(it));};var getIterator=core_getIterator;var getIterator$1=getIterator;function _iterableToArrayLimit$1(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=getIterator$1(arr),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}var iterableToArrayLimit=_iterableToArrayLimit$1;function _nonIterableRest$1(){throw new TypeError("Invalid attempt to destructure non-iterable instance");}var nonIterableRest=_nonIterableRest$1;function _slicedToArray$1(arr,i){return arrayWithHoles(arr)||iterableToArrayLimit(arr,i)||nonIterableRest();}var slicedToArray=_slicedToArray$1;function symbolObservablePonyfill(root){var result;var Symbol=root.Symbol;if(typeof Symbol==='function'){if(Symbol.observable){result=Symbol.observable;}else{result=Symbol('observable');Symbol.observable=result;}}else{result='@@observable';}return result;}/* global window */var root;if(typeof self!=='undefined'){root=self;}else if(typeof window!=='undefined'){root=window;}else if(typeof global!=='undefined'){root=global;}else if(typeof module!=='undefined'){root=module;}else{root=Function('return this')();}var result=symbolObservablePonyfill(root);/**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */var ActionTypes={INIT:'@@redux/INIT'+Math.random().toString(36).substring(7).split('').join('.'),REPLACE:'@@redux/REPLACE'+Math.random().toString(36).substring(7).split('').join('.')};var _typeof$1=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};/**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */function isPlainObject(obj){if((typeof obj==='undefined'?'undefined':_typeof$1(obj))!=='object'||obj===null)return false;var proto=obj;while(Object.getPrototypeOf(proto)!==null){proto=Object.getPrototypeOf(proto);}return Object.getPrototypeOf(obj)===proto;}/**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */function createStore(reducer,preloadedState,enhancer){var _ref2;if(typeof preloadedState==='function'&&typeof enhancer==='undefined'){enhancer=preloadedState;preloadedState=undefined;}if(typeof enhancer!=='undefined'){if(typeof enhancer!=='function'){throw new Error('Expected the enhancer to be a function.');}return enhancer(createStore)(reducer,preloadedState);}if(typeof reducer!=='function'){throw new Error('Expected the reducer to be a function.');}var currentReducer=reducer;var currentState=preloadedState;var currentListeners=[];var nextListeners=currentListeners;var isDispatching=false;function ensureCanMutateNextListeners(){if(nextListeners===currentListeners){nextListeners=currentListeners.slice();}}/**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */function getState(){if(isDispatching){throw new Error('You may not call store.getState() while the reducer is executing. '+'The reducer has already received the state as an argument. '+'Pass it down from the top reducer instead of reading it from the store.');}return currentState;}/**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */function subscribe(listener){if(typeof listener!=='function'){throw new Error('Expected the listener to be a function.');}if(isDispatching){throw new Error('You may not call store.subscribe() while the reducer is executing. '+'If you would like to be notified after the store has been updated, subscribe from a '+'component and invoke store.getState() in the callback to access the latest state. '+'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');}var isSubscribed=true;ensureCanMutateNextListeners();nextListeners.push(listener);return function unsubscribe(){if(!isSubscribed){return;}if(isDispatching){throw new Error('You may not unsubscribe from a store listener while the reducer is executing. '+'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');}isSubscribed=false;ensureCanMutateNextListeners();var index=nextListeners.indexOf(listener);nextListeners.splice(index,1);};}/**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing âwhat changedâ. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */function dispatch(action){if(!isPlainObject(action)){throw new Error('Actions must be plain objects. '+'Use custom middleware for async actions.');}if(typeof action.type==='undefined'){throw new Error('Actions may not have an undefined "type" property. '+'Have you misspelled a constant?');}if(isDispatching){throw new Error('Reducers may not dispatch actions.');}try{isDispatching=true;currentState=currentReducer(currentState,action);}finally{isDispatching=false;}var listeners=currentListeners=nextListeners;for(var i=0;i<listeners.length;i++){var listener=listeners[i];listener();}return action;}/**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */function replaceReducer(nextReducer){if(typeof nextReducer!=='function'){throw new Error('Expected the nextReducer to be a function.');}currentReducer=nextReducer;dispatch({type:ActionTypes.REPLACE});}/**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */function observable(){var _ref;var outerSubscribe=subscribe;return _ref={/**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */subscribe:function subscribe(observer){if((typeof observer==='undefined'?'undefined':_typeof$1(observer))!=='object'||observer===null){throw new TypeError('Expected the observer to be an object.');}function observeState(){if(observer.next){observer.next(getState());}}observeState();var unsubscribe=outerSubscribe(observeState);return {unsubscribe:unsubscribe};}},_ref[result]=function(){return this;},_ref;}// When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({type:ActionTypes.INIT});return _ref2={dispatch:dispatch,subscribe:subscribe,getState:getState,replaceReducer:replaceReducer},_ref2[result]=observable,_ref2;}/**
   * @class ModuleManager
   * @category core
   * @param {Object} object handler
   * @description  Solves modules dependencies
   * @memberof module:core
   */var ModuleManager=/*#__PURE__*/function(){function ModuleManager(object){classCallCheck(this,ModuleManager);this.handler=object;this.currentModule=null;this.store=createStore(function(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[{},''];var action=arguments.length>1?arguments[1]:undefined;state[0][action.key]=action.data;state[1]=action.key;return state;});this.modules={};}/**
     * @method active
     * @instance
     * @description Sets .currentModule to provided module.
     * @param {Object} module the module to make current
     * @memberof module:core.ModuleManager
     */createClass(ModuleManager,[{key:"active",value:function active(module){this.currentModule=module;}/**
       * @method reset
       * @instance
       * @description Set's .currentModule to null.
       * @memberof module:core.ModuleManager
       */},{key:"reset",value:function reset(){this.currentModule=null;}/**
       * @method define
       * @instance
       * @description Define the module in manager
       * @param name The module name
       * @memberof module:core.ModuleManager
       */},{key:"define",value:function define(name){this.modules[name]=this.currentModule;}/**
       * @method use
       * @instance
       * @description Get the defined module from manager
       * @param name The module name
       * @memberof module:core.ModuleManager
       */},{key:"use",value:function use(name){return this.modules[name];}/**
       * @method set
       * @instance
       * @description An alias for .add() <br/><br/>
       * Use this method if you know that you will overwrite existing dependency.<br/>
       * Use it in your app, but not in module that you provide to other people.
       * @param {String} key the key of the dependency
       * @param {Object} data the value of the dependency
       * @memberof module:core.ModuleManager
       */},{key:"set",value:function set(key,data){this.store.dispatch({type:'ADD',key:key,data:data});}/**
       * @method get
       * @instance
       * @description Returns dependency in store object, by key.
       * @param {String} key the key of the dependency
       * @memberof module:core.ModuleManager
       * @return {Object|Module}
       * @throws {DependencyError} if dependency is not in the store
       * @example <caption>Get the 'hello' dependency</caption>
       * manager.get('hello'); // -> {world: true}
       */},{key:"get",value:function get(key){if(!this.store.getState()[0][key]){throw new DependencyError('ModuleManager',"Module requires '".concat(key,"' dependency"),this.currentModule);}return this.store.getState()[0][key];}/**
       * @method has
       * @instance
       * @description Returns whether manager has a dependency with the given key
       * @param {String} key the key of the dependency
       * @memberof module:core.ModuleManager
       * @return {Boolean} Promise that is resolved when all promises completed.
       * @example <caption>Check whether the store has the 'hello' dependency</caption>
       * manager.has('hello'); // -> true
       */},{key:"has",value:function has(key){return Boolean(this.store.getState()[0][key]);}/**
       * @method update
       * @instance
       * @description Updates deps
       * @param {Object} [depsMap={}]
       * @memberof module:core.ModuleManager
       */},{key:"update",value:function update(){var _this=this;var depsMap=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.store.subscribe(function(){var _this$store$getState=_this.store.getState(),_this$store$getState2=slicedToArray(_this$store$getState,2),data=_this$store$getState2[0],changedKey=_this$store$getState2[1];var callback=depsMap[changedKey];if(callback)callback(data[changedKey]);});}/**
       * @method add
       * @alias module:core.ModuleManager#set
       * @memberof module:core.ModuleManager
       */},{key:"add",value:function add(){console.warn('.add() method is deprecated. Use .set() instead');return this.set.apply(this,arguments);}/**
       * @method require
       * @instance
       * @description Require module
       * @param {String} name Defined name
       * @param {Function} moduleExecutor Function that returns applied module
       * @memberof module:core.ModuleManager
       */},{key:"require",value:function require(name,moduleExecutor){if(this.use(name)===undefined)this.handler.applyModule(moduleExecutor());}}]);return ModuleManager;}();/**
   * @class Component
   * @category core
   * @param {Object} [params] - The parameters object.
   * @param {Object} [instructions] - The instructions object.
   * @extends ModuleSystem
   * @memberof module:core
   */var Component=/*#__PURE__*/function(_ModuleSystem){/**
     * Default values for parameters
     * @member {Object} module:core.Component#defaults
     * @static
     * @default {
     *   modules: [],
     *   manager: true
     * }
     */ /**
     * Static instructions
     * @member {Object} module:core.Component#instructions
     * @static
     * @default {}
     */ /**
     * Array of promises that should be resolved before Component is ready.
     * @member {Array} module:core.Component#_wait
     * @private
     */ // Collection of promises;
  /**
     * Collection of `modules`.
     * @member {Array} module:core.Component#modules
     * @public
     */ // Collection of modules;
  /**
     * Collection of `child` Components.
     * @member {Array} module:core.Component#children
     * @public
     */ // For keeping children components;
  function Component(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var defaults=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Component.defaults;var instructions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:Component.instructions;classCallCheck(this,Component);_this=possibleConstructorReturn(this,getPrototypeOf$2(Component).call(this));// Apply polyfilled parameters to .params;
  defineProperty$3(defineProperty$3(defineProperty$3(assertThisInitialized(assertThisInitialized(_this)),"_wait",[]),"modules",[]),"children",[]);_this.params=extend(transformData(params,instructions),defaults);if(_this.params.manager)_this.manager=new ModuleManager(assertThisInitialized(assertThisInitialized(_this)));_this.modules=_this.params.modules;_this.integrateModules();return _this;}/**
     * @method wait
     * @instance
     * @description Wait for a promise.
     * @param {Promise} [promise] - The promise that should be added to a queue.
     * @return {Promise} Promise that is resolved when all promises completed.
     * @memberof module:core.Component
     */createClass(Component,[{key:"wait",value:function wait(promise){if(promise)this._wait.push(promise);return Promise.all(this._wait);}/**
       * @method defer
       * @instance
       * @description Execute `func` (Callback) when Component is ready.
       * @param {Function} func - Callback.
       * @memberof module:core.Component
       */},{key:"defer",value:function defer(func){var _this2=this;if(this.isDeffered)this.wait().then(function(){return func(_this2);});else func(this);}// PARAMETERS
  /**
       * @method updateParams
       * @instance
       * @description Updates parameters of the Component.
       * @return {Object} Params of this Component
       * @memberof module:core.Component
       */},{key:"updateParams",value:function updateParams(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.params=extend(params,this.params);return this.params;}// COPYING & CLONING
  /**
       * @method clone
       * @instance
       * @description Clone this component
       * @return {object} a cloned component with all its source component' params copied.
       * @memberof module:core.Component
       */},{key:"clone",value:function clone(){return new this.constructor(this.params).copy(this);}/**
       * @method copy
       * @instance
       * @description Copy source native and integrate `modules` to it.
       * @param {Component} source - Source component that is used for `copy()` action.
       * @param {Function} [customize] - Callback executed before modules integration process.
       * @return {this} Component
       * @memberof module:core.Component
       */},{key:"copy",value:function copy(source,customize){this.params=objectSpread({},source.params);if(source.native)this.native=source.native.clone(source.params);if(customize)customize();this.integrateModules(source);return this;}/**
       * @method add
       * @instance
       * @description Add a child `Component`.
       * @param {Component} object - Component that should be added as a `child`.
       * @return {Promise} Resolved when action is done.
       * @memberof module:core.Component
       */},{key:"add",value:function(){var _add=asyncToGenerator(/*#__PURE__*/regenerator.mark(function _callee(object){return regenerator.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!object.parent){_context.next=3;break;}_context.next=3;return object.parent.remove(object);case 3:_context.next=5;return this.wait();case 5:_context.next=7;return object.wait();case 7:if(object.native){_context.next=9;break;}throw new CompositionError$1('Component','there is no object.native',this);case 9:object.parent=this;_context.next=12;return this.applyBridge({onAdd:object}).onAdd;case 12:this.native.add(object.native);this.children.push(object);return _context.abrupt("return",object);case 15:case"end":return _context.stop();}}},_callee,this);}));return function add(_x){return _add.apply(this,arguments);};}()/**
       * @method remove
       * @instance
       * @description Remove a child `Component`.
       * @param {Component} object - Component that should be a **child** of this Component.
       * @return {Promise} Resolved when action is done.
       * @memberof module:core.Component
       */},{key:"remove",value:function(){var _remove=asyncToGenerator(/*#__PURE__*/regenerator.mark(function _callee2(object){return regenerator.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(object.parent!==this)){_context2.next=2;break;}return _context2.abrupt("return");case 2:_context2.next=4;return this.wait();case 4:_context2.next=6;return object.wait();case 6:object.parent=null;this.native.remove(object.native);this.children.splice(this.children.indexOf(object),1);case 9:case"end":return _context2.stop();}}},_callee2,this);}));return function remove(_x2){return _remove.apply(this,arguments);};}()/**
       * @method addTo
       * @instance
       * @description Adds `this` Component to specified `App`/`Component`.
       * @param {Component} object - Component that will be a parent of `this`.
       * @memberof module:core.Component
       */},{key:"addTo",value:function addTo(object){return object.add(this);}},{key:"get",value:function get(key){return this.manager.get(key);}},{key:"use",value:function use(key){return this.manager.use(key);}/**
       * Returns whether the object is `async` (`wait` promises are more than `0`).
       * @member {Boolean} module:core.Component#isDeffered
       */},{key:"isDeffered",get:function get(){return this._wait.length>0;}/**
       * Returns the `ModuleManager` used for this component.
       * @member {ModuleManager} module:core.Component#manager
       * @throws {ManagerError}
       */},{key:"manager",get:function get(){if(this._manager)return this._manager;throw new ManagerError('Component',"ModuleManager is not used in this component. 'manager' parameter should be set as 'true'",this);},set:function set(manager){this._manager=manager;}/**
       * Returns the `native` object used for this component.
       * @member {Object} module:core.Component#native
       */},{key:"native",get:function get(){return this._native;},set:function set(mesh){this._native=mesh;this._native.component=this;return this._native;}}]);inherits(Component,_ModuleSystem);return Component;}(ModuleSystem);defineProperty$3(defineProperty$3(Component,"defaults",{modules:null,manager:true}),"instructions",{});// 26.1.6 Reflect.get(target, propertyKey [, receiver])
  function get(target,propertyKey/* , receiver */){var receiver=arguments.length<3?target:arguments[2];var desc,proto;if(_anObject(target)===receiver)return target[propertyKey];if(desc=_objectGopd.f(target,propertyKey))return _has(desc,'value')?desc.value:desc.get!==undefined?desc.get.call(receiver):undefined;if(_isObject(proto=_objectGpo(target)))return get(proto,propertyKey,receiver);}_export(_export.S,'Reflect',{get:get});var get$1=_core.Reflect.get;var get$2=get$1;function _superPropBase$1(object,property){while(!Object.prototype.hasOwnProperty.call(object,property)){object=getPrototypeOf$2(object);if(object===null)break;}return object;}var superPropBase=_superPropBase$1;var get$3=createCommonjsModule(function(module){function _get$$1(target,property,receiver){if(typeof Reflect!=="undefined"&&get$2){module.exports=_get$$1=get$2;}else{module.exports=_get$$1=function _get$$1(target,property,receiver){var base=superPropBase(target,property);if(!base)return;var desc=getOwnPropertyDescriptor$1(base,property);if(desc.get){return desc.get.call(receiver);}return desc.value;};}return _get$$1(target,property,receiver||target);}module.exports=_get$$1;});function attributes(){for(var _len=arguments.length,mappers=new Array(_len),_key=0;_key<_len;_key++){mappers[_key]=arguments[_key];}return function(target){for(var i=0;i<mappers.length;i++){var mapper=mappers[i];for(var k=0;k<mapper.map.length;k++){var attribute=mapper.map[k];Object.defineProperty(target.prototype,attribute,{get:mapper.getter(attribute),set:mapper.setter(attribute),configurable:mapper.configurable,enumerable:mapper.enumerable});}}};}function copy(){for(var _len2=arguments.length,map=new Array(_len2),_key2=0;_key2<_len2;_key2++){map[_key2]=arguments[_key2];}return {map:map,getter:function getter(name){return function(){return this.native[name];};},setter:function setter(name){return function(value){this.native[name].copy(value);};},configurable:true,enumerable:true};}function mirror(){for(var _len3=arguments.length,map=new Array(_len3),_key3=0;_key3<_len3;_key3++){map[_key3]=arguments[_key3];}return {map:map,getter:function getter(name){return function(){return this.native[name];};},setter:function setter(name){return function(value){this.native[name]=value;};},configurable:true,enumerable:true};}var _dec,_class;var/**
   * @class MeshComponent
   * @category core
   * @param {Object} [params] - The parameters object.
   * @param {Object} [instructions] - The instructions object.
   * @extends module:core.Component
   * @memberof module:core
   */MeshComponent=(_dec=attributes(copy('position','rotation','quaternion','scale'),mirror('material','geometry')),_dec(_class=/*#__PURE__*/function(_Component){createClass(MeshComponent,null,[{key:"custom",/**
       * Default values for parameters
       * @member {Object} module:core.MeshComponent#defaults
       * @static
       * @default
       * {
       *   build: true,
       *   geometry: {},
       *   material: false,
       *
       *   shadow: {
       *     cast: true,
       *     receive: true
       *   },
       *
       *   position: {x: 0, y: 0, z: 0},
       *   rotation: {x: 0, y: 0, z: 0},
       *   scale: {x: 1, y: 1, z: 1}
       * }
       */ /**
       * Static instructions
       * @member {Object} module:core.MeshComponent#instructions
       * @static
       * @default
       * {
       *   position: ['x', 'y', 'z'],
       *   rotation: ['x', 'y', 'z'],
       *   scale: ['x', 'y', 'z']
       * }
       */ // CUSTOM GEOMETRY HANDLING
  value:function custom(geom){var constructor=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Mesh;return(/*#__PURE__*/function(_MeshComponent){function _class2(){classCallCheck(this,_class2);return possibleConstructorReturn(this,getPrototypeOf$2(_class2).apply(this,arguments));}createClass(_class2,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:geom,material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new constructor(geometry,material)}).mesh;}}]);inherits(_class2,_MeshComponent);return _class2;}(MeshComponent));}},{key:"create",value:function create(geom,params,constructor){return new(MeshComponent.custom(geom,constructor))(params);}},{key:"from",value:function from(mesh){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};params.build=false;var component=new MeshComponent(params);component.native=mesh;component.wrap();return component;}}]);function MeshComponent(params){var _this;var defaults=arguments.length>1&&arguments[1]!==undefined?arguments[1]:MeshComponent.defaults;var instructions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:MeshComponent.instructions;classCallCheck(this,MeshComponent);_this=possibleConstructorReturn(this,getPrototypeOf$2(MeshComponent).call(this,params,defaults,instructions));if(_this.params.build){var build=_this.build(_this.params);if(!build){throw new CompositionError$1('MeshComponent','.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.',assertThisInitialized(assertThisInitialized(_this)));}if(build instanceof Promise){_this.wait(build);_this.wait(new Promise(function(resolve){build.then(function(native){_this.native=native;_this.wrap().then(resolve);});}));}else{_this.native=build;_this.wait(_this.wrap());}}_this.applyCommand('postIntegrate');return _this;}// BUILDING & WRAPPING
  /**
     * @method build
     * @description Build livecycle should return a native object.
     * @throws {CompositionError}
     * @memberof module:core.MeshComponent
     */createClass(MeshComponent,[{key:"build",value:function build(){throw new CompositionError$1('MeshComponent','Instance should have it\'s own .build().',this);}/**
       * @method wrap
       * @instance
       * @description Wraps transforms (`position` & `rotation`)
       * @return {Promise} Resolved when action is completed
       * @memberof module:core.MeshComponent
       */},{key:"wrap",value:function wrap(){var _this2=this;return new Promise(function(resolve){// TODO: Fix defer with physics
  // this.defer(() => {
  var _this2$params=_this2.params,position=_this2$params.position,rotation=_this2$params.rotation,scale=_this2$params.scale,shadow=_this2$params.shadow;_this2.position.set(position.x,position.y,position.z);_this2.rotation.set(rotation.x,rotation.y,rotation.z);_this2.scale.set(scale.x,scale.y,scale.z);_this2.native.castShadow=shadow.cast;_this2.native.receiveShadow=shadow.receive;_this2.applyBridge({onWrap:1});resolve(_this2);// });
  });}// COPYING & CLONING
  /**
       * @method copy
       * @instance
       * @description Copy source transforms & execute `Component.copy()`
       * @return {this} MeshComponent
       * @memberof module:core.MeshComponent
       */},{key:"copy",value:function copy$$1(source){var _this3=this;return get$3(getPrototypeOf$2(MeshComponent.prototype),"copy",this).call(this,source,function(){_this3.position.copy(source.position);_this3.rotation.copy(source.rotation);_this3.quaternion.copy(source.quaternion);});}/**
       * @method clone
       * @instance
       * @description Make a clone of this MeshComponent using `.copy()`
       * @return {MeshComponent} clone of this object
       * @memberof module:core.MeshComponent
       */},{key:"clone",value:function clone(geometry,material){var dest=new this.constructor({build:false}).copy(this);if(geometry)dest.geometry=dest.geometry.clone();if(material)dest.material=dest.material.clone();return dest;}}]);inherits(MeshComponent,_Component);return MeshComponent;}(Component))||_class);defineProperty$3(defineProperty$3(MeshComponent,"defaults",objectSpread({},Component.defaults,{build:true,geometry:{},material:false,shadow:{cast:true,receive:true},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scale:{x:1,y:1,z:1}})),"instructions",{position:['x','y','z'],rotation:['x','y','z'],scale:['x','y','z']});var _dec$1,_class$1;var/**
   * @class LightComponent
   * @category core
   * @param {Object} [params] - The parameters object.
   * @param {Object} [instructions] - The instructions object.
   * @extends module:core.Component
   * @memberof module:core
   */LightComponent=(_dec$1=attributes(copy('position','rotation','quaternion','target')),_dec$1(_class$1=/*#__PURE__*/function(_Component){createClass(LightComponent,null,[{key:"from",/**
       * Default values for parameters
       * @member {Object} module:core.LightComponent#defaults
       * @static
       * @default
       * {
       *   build: true,
       *
       *   shadow: {
       *     cast: true,
       *
       *     bias: 0,
       *     radius: 1,
       *
       *     mapSize: {
       *       width: 1024,
       *       height: 1024
       *     },
       *
       *     camera: {
       *       near: true,
       *       far: 400,
       *       fov: 90,
       *
       *       top: 200,
       *       bottom: -200,
       *       left: -200,
       *       right: 200
       *     }
       *   },
       *
       *   position: {x: 0, y: 0, z: 0},
       *   rotation: {x: 0, y: 0, z: 0}
       * }
       */ /**
       * Static instructions
       * @member {Object} module:core.LightComponent#instructions
       * @static
       * @default
       * {
       *   position: ['x', 'y', 'z'],
       *   rotation: ['x', 'y', 'z']
       * }
       */value:function from(light){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var wrapShadow=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;params.build=false;var component=new LightComponent(params);component.native=light;component.wrap();if(wrapShadow)component.wrapShadow();return component;}}]);function LightComponent(params){var _this;var defaults=arguments.length>1&&arguments[1]!==undefined?arguments[1]:LightComponent.defaults;var instructions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:LightComponent.instructions;classCallCheck(this,LightComponent);_this=possibleConstructorReturn(this,getPrototypeOf$2(LightComponent).call(this,params,defaults,instructions));if(_this.params.build){var build=_this.build(_this.params);if(!build){throw new CompositionError$1('LightComponent','.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.',assertThisInitialized(assertThisInitialized(_this)));}if(build instanceof Promise){build.then(function(native){_this.native=native;});}else _this.native=build;_this.wait(_this.wrap());}_this.applyCommand('postIntegrate');return _this;}// BUILDING & WRAPPING
  /**
     * @method build
     * @instance
     * @description Build livecycle should return a native object.
     * @throws {CompositionError}
     * @memberof module:core.LightComponent
     */createClass(LightComponent,[{key:"build",value:function build(){throw new CompositionError$1('MeshComponent','Instance should have it\'s own .build().',this);}/**
       * @method wrap
       * @instance
       * @description Wraps transforms (`position` & `rotation`)
       * @return {Promise} Resolved when action is completed
       * @memberof module:core.LightComponent
       */},{key:"wrap",value:function wrap(){var _this2=this;return new Promise(function(resolve){_this2.defer(function(){var _this2$params=_this2.params,position=_this2$params.position,rotation=_this2$params.rotation;_this2.position.set(position.x,position.y,position.z);_this2.rotation.set(rotation.x,rotation.y,rotation.z);_this2.applyBridge({onWrap:1});resolve(_this2);});});}/**
       * @method wrapShadow
       * @instance
       * @description Wraps shadow properties
       * @memberof module:core.LightComponent
       */},{key:"wrapShadow",value:function wrapShadow(){var native=this.native,shadow=this.params.shadow;native.castShadow=shadow.cast;native.shadow.mapSize.width=shadow.mapSize.width;native.shadow.mapSize.height=shadow.mapSize.height;native.shadow.bias=shadow.bias;native.shadow.radius=shadow.radius;var shadowCamera=native.shadow.camera;var camera=shadow.camera;shadowCamera.near=camera.near;shadowCamera.far=camera.far;shadowCamera.fov=camera.fov;shadowCamera.left=camera.left;shadowCamera.right=camera.right;shadowCamera.top=camera.top;shadowCamera.bottom=camera.bottom;}// COPYING & CLONING
  /**
       * @method copy
       * @instance
       * @description Copy source transforms & execute `Component.copy()`
       * @return {this} LightComponent
       * @memberof module:core.LightComponent
       */},{key:"copy",value:function copy$$1(source){var _this3=this;return get$3(getPrototypeOf$2(LightComponent.prototype),"copy",this).call(this,source,function(){if(_this3.target)_this3.target.copy(source.target());_this3.position.copy(source.position);_this3.rotation.copy(source.rotation);_this3.quaternion.copy(source.quaternion);});}/**
       * @method clone
       * @instance
       * @description Make a clone of this LightComponent using `.copy()`
       * @return {LightComponent} clone of this object
       * @memberof module:core.LightComponent
       */},{key:"clone",value:function clone(){return new this.constructor({build:false}).copy(this);}}]);inherits(LightComponent,_Component);return LightComponent;}(Component))||_class$1);defineProperty$3(defineProperty$3(LightComponent,"defaults",objectSpread({},Component.defaults,{build:true,shadow:{cast:true,bias:0,radius:1,mapSize:{width:1024,height:1024},camera:{near:true,far:400,fov:90,top:200,bottom:-200,left:-200,right:200}},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0}})),"instructions",{position:['x','y','z'],rotation:['x','y','z']});var _dec$2,_class$2;var/**
   * @class CameraComponent
   * @category core
   * @param {Object} [params] - The parameters object.
   * @param {Object} [instructions] - The instructions object.
   * @extends module:core.Component
   * @memberof module:core
   */CameraComponent=(_dec$2=attributes(copy('position','rotation','quaternion','target')),_dec$2(_class$2=/*#__PURE__*/function(_Component){createClass(CameraComponent,null,[{key:"from",/**
       * Default values for parameters
       * @member {Object} module:core.CameraComponent#defaults
       * @static
       * @default
       * {
       *   build: true,
       *
       *   position: {x: 0, y: 0, z: 0},
       *   rotation: {x: 0, y: 0, z: 0}
       * }
       */ /**
       * Static instructions
       * @member {Object} module:core.CameraComponent#instructions
       * @static
       * @default
       * {
       *   position: ['x', 'y', 'z'],
       *   rotation: ['x', 'y', 'z'],
       *   scale: ['x', 'y', 'z']
       * }
       */value:function from(camera){var params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};params.build=false;var component=new CameraComponent(params);component.native=camera;component.wrap();return component;}}]);function CameraComponent(params){var _this;var defaults=arguments.length>1&&arguments[1]!==undefined?arguments[1]:CameraComponent.defaults;var instructions=arguments.length>2&&arguments[2]!==undefined?arguments[2]:CameraComponent.instructions;classCallCheck(this,CameraComponent);_this=possibleConstructorReturn(this,getPrototypeOf$2(CameraComponent).call(this,params,defaults,instructions));if(_this.params.build){var build=_this.build(_this.params);if(!build){throw new CompositionError$1('CameraComponent','.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.',assertThisInitialized(assertThisInitialized(_this)));}if(build instanceof Promise){build.then(function(native){_this.native=native;});}else _this.native=build;_this.wait(_this.wrap());}_this.applyCommand('postIntegrate');return _this;}// BUILDING & WRAPPING
  /**
     * @method build
     * @instance
     * @description Build livecycle should return a native object.
     * @throws {CompositionError}
     * @memberof module:core.CameraComponent
     */createClass(CameraComponent,[{key:"build",value:function build(){throw new CompositionError$1('CameraComponent','Instance should have it\'s own .build().',this);}/**
       * @method wrap
       * @instance
       * @description Wraps transforms (`position` & `rotation`)
       * @return {Promise} Resolved when action is completed
       * @memberof module:core.CameraComponent
       */},{key:"wrap",value:function wrap(){var _this2=this;return new Promise(function(resolve){_this2.defer(function(){_this2.position.set(_this2.params.position.x,_this2.params.position.y,_this2.params.position.z);_this2.rotation.set(_this2.params.rotation.x,_this2.params.rotation.y,_this2.params.rotation.z);_this2.applyBridge({onWrap:1});resolve(_this2);});});}/**
       * @method copy
       * @instance
       * @description Copy source transforms & execute `Component.copy()`
       * @return {this} CameraComponent
       * @memberof module:core.CameraComponent
       */},{key:"copy",value:function copy$$1(source){var _this3=this;return get$3(getPrototypeOf$2(CameraComponent.prototype),"copy",this).call(this,source,function(){if(_this3.target)_this3.target.copy(source.target());_this3.position.copy(source.position);_this3.rotation.copy(source.rotation);_this3.quaternion.copy(source.quaternion);});}/**
       * @method clone
       * @instance
       * @description Make a clone of this CameraComponent using `.copy()`
       * @return {CameraComponent} clone of this object
       * @memberof module:core.CameraComponent
       */},{key:"clone",value:function clone(){return new this.constructor({build:false}).copy(this);}}]);inherits(CameraComponent,_Component);return CameraComponent;}(Component))||_class$2);defineProperty$3(defineProperty$3(CameraComponent,"defaults",objectSpread({},Component.defaults,{build:true,position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0}})),"instructions",{position:['x','y','z'],rotation:['x','y','z'],scale:['x','y','z']});const version="2.2.0-alpha.0";var system={window:typeof window==='undefined'?global:window};/**
   * @class App
   * @category core
   * @description This component is used to prepare a world scene, setup physics, camera, renderer and all other things that you usually do before making meshes.
   * @param {Array} [modules=[]] - Array of Modules
   * @extends ModuleSystem
   * @memberof module:core
   */var App=/*#__PURE__*/function(_ModuleSystem){/**
     * @description Defines whether the scene should render or not
     * @member {Boolean} module:core.App#enabled
     * @public
     */ /**
     * Loops in this app
     * @description Array of loops that are executed by this app.
     * @member {Array} module:core.App#loops
     * @public
     */function App(){var _this;var modules=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];classCallCheck(this,App);console.log("WHS.App ".concat(version));_this=possibleConstructorReturn(this,getPrototypeOf$2(App).call(this));defineProperty$3(defineProperty$3(assertThisInitialized(assertThisInitialized(_this)),"enabled",true),"loops",[]);_this.manager=new ModuleManager(assertThisInitialized(assertThisInitialized(_this)));_this.modules=modules;_this.integrateModules();return _this;}// CONTROLS & UPDATING
  /**
     * @method start
     * @description Start rendering loop and physics simulation (if you use version with physics).
     * @memberof module:core.App
     */createClass(App,[{key:"start",value:function start(){var requestAnimFrame=function(){return system.window.requestAnimationFrame||system.window.webkitRequestAnimationFrame||system.window.mozRequestAnimationFrame||function(callback){system.window.setTimeout(callback,1000/60);};}();var loops=this.loops,enabled=this.enabled;function process(){requestAnimFrame(process);if(!enabled)return;for(var i=0,ll=loops.length;i<ll;i++){var e=loops[i];if(e.enabled)e.execute(e.clock);}}this.enabled=true;process();}/**
       * @method stop
       * @description Stops rendering loops
       * @memberof module:core.App
       */},{key:"stop",value:function stop(){this.enabled=false;}/**
       * @method addLoop
       * @description Adds loop to this app.
       * @param {Object} loop - the loop to add
       * @return {Promise} Promise that is resolved when promises completed.
       * @memberof module:core.App
       * @example <caption>Adding a loop to an app</caption>
       * const loop = new Loop(() => {
       *  // ...
       * });
       *
       * const app = new App();
       *
       * app.addLoop(loop);
       * loop.start();
       */},{key:"addLoop",value:function addLoop(loop){var _this2=this;return new Promise(function(resolve){_this2.loops.push(loop);resolve(loop);});}/**
       * @method removeLoop
       * @description Removes loop from this app.
       * @param {Object} loop - the loop to remove
       * @return {Promise} Promise that is resolved when promises completed.
       * @memberof module:core.App
       */},{key:"removeLoop",value:function removeLoop(loop){var _this3=this;return new Promise(function(resolve){var index=_this3.loops.indexOf(loop);if(index!==-1)_this3.loops.splice(index,1);resolve(loop);});}},{key:"get",value:function get(key){return this.manager.get(key);}},{key:"use",value:function use(key){return this.manager.use(key);}}]);inherits(App,_ModuleSystem);return App;}(ModuleSystem);/**
   * @class Loop
   * @category core
   * @param {Function} func function to execute on each animation frame
   * @param {Boolean} [useClock=true] passes a Clock to the function when called, if true
   * @memberof module:core
   */var Loop=/*#__PURE__*/function(){function Loop(func){var useClock=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;classCallCheck(this,Loop);this.func=func;this.clock=useClock?new Clock():null;this.enabled=false;}// CONTROLS
  /**
     * @method start
     * @instance
     * @description Starts this loop, clock if it has one. Won't do anything if loop enabled already.
     * @param {Component} [world] app to add this loop to, if provided.
     * @memberof module:core.Loop
     */createClass(Loop,[{key:"start",value:function start(world){if(this.enabled)return;if(world)world.addLoop(this);if(this.clock)this.clock.start();this.enabled=true;}/**
       * @method stop
       * @instance
       * @description Stops this loop and its clock if it has one, won't do anything if this loop is not enabled)
       * @param {Component} [world] app to remove this loop from, if provided.
       * @memberof module:core.Loop
       */},{key:"stop",value:function stop(world){if(!this.enabled)return;if(this.clock)this.clock.stop();this.enabled=false;if(world)world.removeLoop(this);}// EXECUTION
  /**
       * @method execute
       * @instance
       * @description Executes the function of this loop
       * @memberof module:core.Loop
       * @returns {*} whatever the function of this loop returns
       */},{key:"execute",value:function execute(){return this.func(this.clock);}}]);return Loop;}();/** @module core */ /**
   * @class AmbientLight
   * @category components/lights
   * @description AmbientLight is a simple class, it extends Light and inherits all its methods.
   * AmbientLight creates basic light around all scene, so it doesn't need properties like pos or target.
   * It supports only color and intensity as parameters, which defines the color of the surrounded light and intensity of light.
   * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
   * @extends module:core.LightComponent
   * @memberof module:components/lights
   * @example <caption>Creating an AmbientLight </caption>
   * new AmbientLight({
   *   color: 0xffffff,
   *   intensity: 0.2
   * }).addTo(world);
   */var AmbientLight$1=/*#__PURE__*/function(_LightComponent){function AmbientLight$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,AmbientLight$$1);return possibleConstructorReturn(this,getPrototypeOf$2(AmbientLight$$1).call(this,params,AmbientLight$$1.defaults));}createClass(AmbientLight$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new AmbientLight(params.color,params.intensity)}).light;}}]);inherits(AmbientLight$$1,_LightComponent);return AmbientLight$$1;}(LightComponent);defineProperty$3(AmbientLight$1,"defaults",objectSpread({},LightComponent.defaults,{color:0xffffff,intensity:1}));/**
   * @class DirectionalLight
   * @category components/lights
   * @description DirectinalLight creates a light that shines from a specific direction not from a specific position.<br/><br/>
   * This light will behave as though it is infinitely far away and the rays produced from it are all parallel. <br/><br/>
   * The best analogy would be a light source that acts like the sun: the sun is so far away that all sunlight hitting objects comes from the same angle.<br/><br/>
   * It has the same options as AmbientLight in light paramater, but it also supports pos and target paramaters.
   * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
   * @extends module:core.LightComponent
   * @memberof module:components/lights
   * @example <caption>Creating a DirectionalLight to fall down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
   * new DirectionalLight({
   *   color: 0xffffff,
   *   intensity: 0.2,
   *
   *   position: [10, 20, 10]
   * }).addTo(app);
   */var DirectionalLight$1=/*#__PURE__*/function(_LightComponent){function DirectionalLight$$1(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,DirectionalLight$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(DirectionalLight$$1).call(this,params,DirectionalLight$$1.defaults));_this.wrapShadow();return _this;}createClass(DirectionalLight$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new DirectionalLight(params.color,params.intensity)}).light;}}]);inherits(DirectionalLight$$1,_LightComponent);return DirectionalLight$$1;}(LightComponent);defineProperty$3(DirectionalLight$1,"defaults",objectSpread({},LightComponent.defaults,{color:0xffffff,intensity:1}));/**
   * @class HemisphereLight
   * @category components/lights
   * @description HemisphereLight is a light source positioned directly above the scene.<br/>
   * It also doesn't need position and target properties.
   * @classDesc
   * <iframe src="https://threejs.org/examples/webgl_lights_hemisphere.html"></iframe>
   * @param {Object} [params={light: {skyColor: 0xffffff, groundColor: 0xffffff, intensity: 1}}] - The params.
   * @extends module:core.LightComponent
   * @memberof module:components/lights
   * @example <caption>Creating a HemisphereLight</caption>
   * new HemisphereLight({
   *   skyColor: 0xff0000,
   *   groundColor: 0x0000ff,
   *   intensity: 0.2
   * }).addTo(app);
   */var HemisphereLight$1=/*#__PURE__*/function(_LightComponent){function HemisphereLight$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,HemisphereLight$$1);return possibleConstructorReturn(this,getPrototypeOf$2(HemisphereLight$$1).call(this,params,HemisphereLight$$1.defaults));}createClass(HemisphereLight$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new HemisphereLight(params.skyColor,params.groundColor,params.intensity)}).light;}}]);inherits(HemisphereLight$$1,_LightComponent);return HemisphereLight$$1;}(LightComponent);defineProperty$3(HemisphereLight$1,"defaults",objectSpread({},LightComponent.defaults,{skyColor:0xffffff,groundColor:0xffffff,intensity:1}));/**
   * @class PointLight
   * @category components/lights
   * @description PointLight creates a light at a specific position in the scene. The light shines in all directions (roughly similar to a light bulb.)<br/><br/>
   * It has the same options as AmbientLight in light paramater, but it also supports position, distance and decay.<br/>
   * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, decay: 1}}] - The params.
   * @extends LightComponent
   * @memberof module:components/lights
   * @example <caption>Creating a PointLight</caption>
   * new PointLight( {
   *   color: 0xff0000,
   *   intensity: 2,
   *   distance: 300
   *
   *   position: [10, 20, 10]
   * }).addTo(app);
   */var PointLight$1=/*#__PURE__*/function(_LightComponent){function PointLight$$1(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,PointLight$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(PointLight$$1).call(this,params,PointLight$$1.defaults));_this.wrapShadow();return _this;}createClass(PointLight$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new PointLight(params.color,params.intensity,params.distance,params.decay)}).light;}}]);inherits(PointLight$$1,_LightComponent);return PointLight$$1;}(LightComponent);defineProperty$3(PointLight$1,"defaults",objectSpread({},LightComponent.defaults,{color:0xffffff,intensity:1,distance:100,decay:1}));/**
   * @class SpotLight
   * @category components/lights
   * @description SpotLight creates spot light that can cast shadow in one direction. <br/><br/>
   * It has the same parameters as AmbientLight in light, but it also supports pos and target. <br/><br/>
   * SpotLight affects meshes with lambert and phong material.
   * @classDesc
   * <iframe src="https://threejs.org/examples/webgl_lights_spotlight.html"></iframe>
   * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, angle: Math.PI / 3, exponent: 0, decay: 1}}] - The params.
   * @extends module:core.LightComponent
   * @memberof module:components/lights
   * @example <caption>Creating a SpotLight that falls down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
   * new SpotLight({
   *   color: 0x00ff00,
   *   intensity: 3,
   *   distance: 1000
   *
   *   position: [10, 20, 10]
   * }).addTo(app);
   */var SpotLight$1=/*#__PURE__*/function(_LightComponent){function SpotLight$$1(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,SpotLight$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(SpotLight$$1).call(this,params,SpotLight$$1.defaults));_this.wrapShadow();return _this;}createClass(SpotLight$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new SpotLight(params.color,params.intensity,params.distance,params.angle,params.exponent,params.decay)}).light;}}]);inherits(SpotLight$$1,_LightComponent);return SpotLight$$1;}(LightComponent);defineProperty$3(SpotLight$1,"defaults",objectSpread({},LightComponent.defaults,{color:0xffffff,intensity:1,distance:100,angle:Math.PI/3,exponent:0,decay:1}));var AreaLight=/*#__PURE__*/function(_LightComponent){function AreaLight(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,AreaLight);return possibleConstructorReturn(this,getPrototypeOf$2(AreaLight).call(this,params,AreaLight.defaults));}createClass(AreaLight,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({light:new RectAreaLight(params.color,params.intensity,params.width,params.height)}).light;}}]);inherits(AreaLight,_LightComponent);return AreaLight;}(LightComponent);defineProperty$3(AreaLight,"defaults",objectSpread({},LightComponent.defaults,{color:0xffffff,intensity:1,width:10,height:10}));/** @module components/lights */ /**
   * @class CubeCamera
   * @category components/cameras
   * @description Creates 6 cameras that render to a WebGLRenderTargetCube
   * @param {Object} [params] - The parameters object.
   * @memberof module:components/cameras
   * @extends module:core.CameraComponent
   * @example <caption>Creates a CubeCamera and set it as app's camera</caption>
   * const camera = new CubeCamera({
   *   camera: {
   *     cubeResolution: 256
   *   },
   *
   *   position: {
   *     x: 0,
   *     y: 100,
   *     z: 0
   *   }
   * });
   *
   * app.camera = camera;
   */var CubeCamera$1=/*#__PURE__*/function(_CameraComponent){/**
     * Default values for parameters
     * @member {Object} module:components/cameras.CubeCamera#defaults
     * @static
     * @default <pre>
     * {
     *   camera: {
     *     near: 1,
     *     far: 1000,
     *     cubeResolution: 128
     *   }
     * }</pre>
     */function CubeCamera$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,CubeCamera$$1);return possibleConstructorReturn(this,getPrototypeOf$2(CubeCamera$$1).call(this,params,CubeCamera$$1.defaults));}createClass(CubeCamera$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({camera:new CubeCamera(params.near,params.far,params.cubeResolution)}).camera;}}]);inherits(CubeCamera$$1,_CameraComponent);return CubeCamera$$1;}(CameraComponent);defineProperty$3(CubeCamera$1,"defaults",objectSpread({},CameraComponent.defaults,{near:1,far:1000,cubeResolution:128}));/**
   * @class OrthographicCamera
   * @category components/cameras
   * @description Camera with orthographic projection.
   * @param {Object} [params] - The parameters object.
   * @memberof module:components/cameras
   * @extends module:core.CameraComponent
   * @example <caption>Create an OrthographicCamera and set it as app's camera</caption>
   * const camera = new OrthographicCamera({
   *   camera: {
   *     far: 10000
   *   },
   *
   *   position: {
   *     y: 50
   *   }
   * });
   *
   * app.camera = camera;
   */var OrthographicCamera$1=/*#__PURE__*/function(_CameraComponent){/**
     * Default values for parameters
     * @member {Object} module:components/cameras.OrthographicCamera#defaults
     * @static
     * @default <pre>
     * {
     *   near: 1,
     *   far: 1000,
     *   left: system.window.innerWidth / -2,
     *   right: system.window.innerWidth / 2,
     *   top: system.window.innerHeight / 2,
     *   bottom: system.window.innerHeight / -2
     * }</pre>
     */function OrthographicCamera$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,OrthographicCamera$$1);return possibleConstructorReturn(this,getPrototypeOf$2(OrthographicCamera$$1).call(this,params,OrthographicCamera$$1.defaults));}createClass(OrthographicCamera$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({camera:new OrthographicCamera(params.left,params.right,params.top,params.bottom,params.near,params.far)}).camera;}}]);inherits(OrthographicCamera$$1,_CameraComponent);return OrthographicCamera$$1;}(CameraComponent);defineProperty$3(OrthographicCamera$1,"defaults",objectSpread({},CameraComponent.defaults,{near:1,far:1000,left:system.window.innerWidth/-2,right:system.window.innerWidth/2,top:system.window.innerHeight/2,bottom:system.window.innerHeight/-2}));/**
   * @class PerspectiveCamera
   * @description Camera with perspective projection.
   * @category components/cameras
   * @param {Object} [params] - The parameters object.
   * @memberof module:components/cameras
   * @extends module:core.CameraComponent
   * @example <caption>Create an PerspectiveCamera and set it as app's camera</caption>
   * const camera = new PerspectiveCamera({
   *   fov: 75,
   *   aspect: window.innerWidth / window.innerHeight,
   *
   *   position: {
   *     x: 0,
   *     y: 100,
   *     z: 0
   *   }
   * });
   *
   * app.camera = camera;
   */var PerspectiveCamera$1=/*#__PURE__*/function(_CameraComponent){/**
     * Default values for parameters
     * @member {Object} module:components/cameras.PerspectiveCamera#defaults
     * @static
     * @default <pre>
     * {
     *   near: 1,
     *   far: 1000,
     *   fov: 75,
     *   aspect: system.window.innerWidth / system.window.innerHeight
     * }</pre>
     */function PerspectiveCamera$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,PerspectiveCamera$$1);return possibleConstructorReturn(this,getPrototypeOf$2(PerspectiveCamera$$1).call(this,params,PerspectiveCamera$$1.defaults));}createClass(PerspectiveCamera$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return this.applyBridge({camera:new PerspectiveCamera(params.fov,params.aspect,params.near,params.far)}).camera;}}]);inherits(PerspectiveCamera$$1,_CameraComponent);return PerspectiveCamera$$1;}(CameraComponent);defineProperty$3(PerspectiveCamera$1,"defaults",objectSpread({},CameraComponent.defaults,{near:1,far:1000,fov:75,aspect:system.window.innerWidth/system.window.innerHeight}));/** @module components/cameras */ /**
   * @class Box
   * @category components/meshes
   * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
   * pass specific parameters to build this mesh as a geometry object.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Box, and adding to app</caption>
   *  new Box({
   *    geometry: {
   *      width: 2,
   *      height: 2,
   *      depth: 2
   *    },
   *
   *    material: new THREE.MeshBasicMaterial({
   *      color: 0xffffff
   *    }),
   *
   *    position: [50, 60, 70]
   * }).addTo(app);
   */var Box=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Box#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     width: 1,
     *     height: 1,
     *     depth: 1,
     *     widthSegments: 1,
     *     heightSegments: 1,
     *     depthSegments: 1
     *   }
     * }</pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Box#instructions
     * @static
     * @default geometry: ['width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegements']
     */function Box(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Box);return possibleConstructorReturn(this,getPrototypeOf$2(Box).call(this,params,Box.defaults,Box.instructions));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Box
     */createClass(Box,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?BoxBufferGeometry:BoxGeometry)(params.geometry.width,params.geometry.height,params.geometry.depth,params.geometry.widthSegments,params.geometry.heightSegments,params.geometry.depthSegments);return geometry;}}]);inherits(Box,_MeshComponent);return Box;}(MeshComponent);defineProperty$3(defineProperty$3(Box,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{width:1,height:1,depth:1,widthSegments:1,heightSegments:1,depthSegments:1}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['width','height','depth','widthSegments','heightSegments','depthSegements']}));/**
   * @class Circle
   * @category components/meshes
   * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
   * pass specific parameters to build this mesh as a geometry object.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Circle, and adding to app</caption>
   *  new Circle({
   *    geometry: {
   *      radius: 4,
   *      segments: 16
   *    },
   *
   *    material: new THREE.MeshBasicMaterial({
   *      color: 0xffffff
   *    }),
   *
   *    position: [50, 60, 70]
   * }).addTo(app);
   */var Circle=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Circle#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 50,
     *     segments: 8,
     *     thetaStart: 0,
     *     thetaLength: Math.PI * 2
     *   }
     * }</pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Circle#instructions
     * @static
     * @default geometry: ['radius', 'segments', 'thetaStart', 'thetaLength']
     */function Circle(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Circle);return possibleConstructorReturn(this,getPrototypeOf$2(Circle).call(this,params,Circle.defaults,Circle.instructions));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Circle
     */createClass(Circle,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?CircleBufferGeometry:CircleGeometry)(params.geometry.radius,params.geometry.segments,params.geometry.thetaStart,params.geometry.thetaLength);return geometry;}}]);inherits(Circle,_MeshComponent);return Circle;}(MeshComponent);defineProperty$3(defineProperty$3(Circle,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:50,segments:8,thetaStart:0,thetaLength:Math.PI*2}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','segments','thetaStart','thetaLength']}));/**
   * @class Cone
   * @category components/meshes
   * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
   * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
   * The surface area and the volume of a cylinder have been known since deep antiquity.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ConeGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Cone, and adding to app</caption>
   * new Cone({
   *   geometry: {
   *     radiusTop: 2,
   *     radiusBottom: 4,
   *     height: 5
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   pos: [0, 100, 0]
   * }).addTo(app);
   */var Cone=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Cone#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 20,
     *     height: 100,
     *     radiusSegments: 32,
     *     heightSegments: 1,
     *     openEnded: false,
     *     thetaStart: 0,
     *     thetaLength: Math.PI * 2
     *   }
     * }</pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Cone#instructions
     * @static
     * @default <pre>
     * geometry: [
     *   'radius',
     *   'height',
     *   'radiusSegments',
     *   'heightSegments',
     *   'openEnded',
     *   'thetaStart',
     *   'thetaLength'
     * ]
     * </pre>
     */function Cone(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Cone);_this=possibleConstructorReturn(this,getPrototypeOf$2(Cone).call(this,params,Cone.defaults,Cone.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Cone.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Cone
     */createClass(Cone,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?ConeBufferGeometry:ConeGeometry)(params.geometry.radius,params.geometry.height,params.geometry.radiusSegments,params.geometry.heightSegments,params.geometry.openEnded,params.geometry.thetaStart,params.geometry.thetaLength);return geometry;}}]);inherits(Cone,_MeshComponent);return Cone;}(MeshComponent);defineProperty$3(defineProperty$3(Cone,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:20,height:100,radiusSegments:32,heightSegments:1,openEnded:false,thetaStart:0,thetaLength:Math.PI*2}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','height','radiusSegments','heightSegments','openEnded','thetaStart','thetaLength']}));/**
   * @class Cylinder
   * @category components/meshes
   * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
   * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
   * The surface area and the volume of a cylinder have been known since deep antiquity.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CylinderGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Cylinder, and adding to app</caption>
   * new Cylinder({
   *   geometry: {
   *     radiusTop: 2,
   *     radiusBottom: 4,
   *     height: 5
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   pos: [0, 100, 0]
   * }).addTo(app);
   */var Cylinder=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Cylinder#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radiusTop: 20,
     *     radiusBottom: 20,
     *     height: 100,
     *     radiusSegments: 32,
     *     heightSegments: 1,
     *     openEnded: false,
     *     thetaStart: 0,
     *     thetaLength: Math.PI * 2
     *   }
     * }</pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Cylinder#instructions
     * @static
     * @default <pre>
     * geometry: [
     *   'radiusTop',
     *   'radiusBottom',
     *   'height',
     *   'radiusSegments',
     *   'heightSegments',
     *   'openEnded',
     *   'thetaStart',
     *   'thetaLength'
     * ]
     * </pre>
     */function Cylinder(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Cylinder);_this=possibleConstructorReturn(this,getPrototypeOf$2(Cylinder).call(this,params,Cylinder.defaults,Cylinder.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Cylinder.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Cylinder
     */createClass(Cylinder,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?CylinderBufferGeometry:CylinderGeometry)(params.geometry.radiusTop,params.geometry.radiusBottom,params.geometry.height,params.geometry.radiusSegments,params.geometry.heightSegments,params.geometry.openEnded,params.geometry.thetaStart,params.geometry.thetaLength);return geometry;}}]);inherits(Cylinder,_MeshComponent);return Cylinder;}(MeshComponent);defineProperty$3(defineProperty$3(Cylinder,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radiusTop:0,radiusBottom:1,height:1,radiusSegments:32,heightSegments:1,openEnded:false,thetaStart:0,thetaLength:Math.PI*2}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radiusTop','radiusBottom','height','radiusSegments','heightSegments','openEnded','thetaStart','thetaLength']}));/**
   * @class Dodecahedron
   * @category components/meshes
   * @description In geometry, a dodecahedron is any polyhedron with twelve flat faces. <br/><br/>
   * The most familiar dodecahedron is the regular dodecahedron, which is a Platonic solid. <br/>
   * There are also three regular star dodecahedra, which are constructed as stellations of the convex form. <br/>
   * All of these have icosahedral symmetry, order 120.
   * Dodecahedron creates Dodecahedron object by it's radius and detail.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#DodecahedronGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Dodecahedron, and adding to app</caption>
   * new Dodecahedron({
   *   geometry: {
   *     radius: 2
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: {
   *     y: 10
   *   }
    * }).addTo(app);
   */var Dodecahedron=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Dodecahedron#defaults
     * @static
     * @default <pre>
     * geometry: {
     *   radius: 1,
     *   detail: 0
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Dodecahedron#instructions
     * @static
     * @default <pre>
     * geometry: ['radius', 'detail']
     * </pre>
     */function Dodecahedron(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Dodecahedron);_this=possibleConstructorReturn(this,getPrototypeOf$2(Dodecahedron).call(this,params,Dodecahedron.defaults,Dodecahedron.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Dodecahedron.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Dodecahedron
     */createClass(Dodecahedron,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?DodecahedronBufferGeometry:DodecahedronGeometry)(params.geometry.radius,params.geometry.detail);}}]);inherits(Dodecahedron,_MeshComponent);return Dodecahedron;}(MeshComponent);defineProperty$3(defineProperty$3(Dodecahedron,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:1,detail:0}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','detail']}));/**
   * @class Extrude
   * @category components/meshes
   * @description Extrude geometry means that you can create a 3D mesh from any 2D shape using three.js geometry based on <a href='https://threejs.org/docs/#api/math/Vector2'>THREE.Vector2.</a> <br/>
   * Such implementation will help you to make volumed shapes that have their own depth and can be seen from all angels.<br/><br/>
   * You can also find some interesting examples made using <a href='threejs.org'>three.js</a> which is a core of whs.js, such as:
   * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes.html'>Webgl geometry extrude</a>
   * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes2.html'>Extrude shapes from geodata</a>
   * - <a href='http://threejs.org/examples/webgl_geometry_extrude_splines.html'>Extrude splines</a>
   *
   * Such examples can be easily implemented using whitestorm.js or it's plugins. Use `Extrude` class with <a href='https://threejs.org/docs/#api/extras/core/Shape'>THREE.Shape</a> to get extrude effect of shape defined by 2D vectors.
   * This class is similar to <a href='https://threejs.org/docs/#api/geometries/ExtrudeGeometry'>THREE.ExtrudeGeometry</a>,
   * but it also contains all properties, applied by `Shape`, such as material, mass and vectors like position (pos) and rotation (rot).
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ExtrudeGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a shape, then an Extrude from it</caption>
   * const shape = new THREE.Shape([
   *   new THREE.Vector2(-4,-4),
   *   new THREE.Vector2(-2,0),
   *   new THREE.Vector2(-4,4),
   *   new THREE.Vector2(0,2),
   *   new THREE.Vector2(4,4),
   *   new THREE.Vector2(2,0),
   *   new THREE.Vector2(4,-4),
   *   new THREE.Vector2(0,-2)
   * ]);
   *
   * const extrude = new Extrude({
   *   geometry: {
   *     shapes: shape,
   *     options: {
   *       bevelEnabled: false,
   *       bevelSize: 0,
   *       amount: 2
   *     }
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: [0, 100, 0]
   * });
   *
   * extrude.addTo(app);
   */var Extrude=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Extrude#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     shapes: [],
     *     options: {}
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Extrude#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['shapes', 'options']
     * }
     * </pre>
     */function Extrude(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Extrude);_this=possibleConstructorReturn(this,getPrototypeOf$2(Extrude).call(this,params,Extrude.defaults,Extrude.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Extrude.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Extrude
     */createClass(Extrude,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new ExtrudeGeometry(params.geometry.shapes,params.geometry.options);return params.buffer?new BufferGeometry().fromGeometry(geometry):geometry;}}]);inherits(Extrude,_MeshComponent);return Extrude;}(MeshComponent);defineProperty$3(defineProperty$3(Extrude,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{shapes:[],options:{}}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['shapes','options']}));/**
   * @class Icosahedron
   * @category components/meshes
   * @description In geometry, an icosahedron is a polyhedron with 20 faces.<br/>
   * There are many kinds of icosahedra, with some being more symmetrical than others. The most well known is the Platonic, convex regular icosahedron.<br/>
   * `Icosahedron` creates an Icosahedron object by its radius and detail.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#IcosahedronGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Icosahedron, and adding to app</caption>
   * new Icosahedron({
   *   geometry: {
   *     radius: 2,
   *     detail: 1
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: [0, 100, 0]
   * }).addTo(app);
   */var Icosahedron=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Icosahedron#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 1,
     *     detail: 0
     *   }
     * }</pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Icosahedron#instructions
     * @static
     * @default {geometry: ['radius', 'detail']}
     */function Icosahedron(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Icosahedron);_this=possibleConstructorReturn(this,getPrototypeOf$2(Icosahedron).call(this,params,Icosahedron.defaults,Icosahedron.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Icosahedron.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Icosahedron
     */createClass(Icosahedron,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?IcosahedronBufferGeometry:IcosahedronGeometry)(params.geometry.radius,params.geometry.detail);}}]);inherits(Icosahedron,_MeshComponent);return Icosahedron;}(MeshComponent);defineProperty$3(defineProperty$3(Icosahedron,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:1,detail:0}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','detail']}));/**
   * @class Lathe
   * @category components/meshes
   * @description A `LatheGeometry` allows you to create shapes from a smooth curve.
   * This curve is defined by a number of points (also called knots) and is most often called a spline. This spline is rotated around a fixed point and results in vase- and bell-like shapes.<br/><br/>
   * In 3D computer graphics, a lathed object is a 3D model whose vertex geometry is produced by rotating the points of a spline or other point set around a fixed axis.
   * The lathing may be partial; the amount of rotation is not necessarily a full 360 degrees.
   * The point set providing the initial source data can be thought of as a cross section through the object along a plane containing its axis of radial symmetry. <br/><br/>
   * The <a href='http://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry'>following example</a> shows a geometry which can be generated using `Lathe` class.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Lath, and adding to app</caption>
   * const points = [];
   *
   * for (let i = 0; i < 10; i++) {
   *   points.push(
   *     new THREE.Vector2(
   *       (Math.sin(i * 0.7) * 15 + 50) / 10,
   *       (i - 5) * 0.2
   *     )
   *   );
   * }
   *
   * const lathe = new Lathe({
   *   geometry: {
   *     points: points
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: [0, 50, 10]
   * }).addTo(app);
   */var Lathe=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Lathe#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     points: []
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Lathe#instructions
     * @static
     * @default <pre>{
     *   geometry: ['points']
     * }
     * </pre>
     */function Lathe(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Lathe);_this=possibleConstructorReturn(this,getPrototypeOf$2(Lathe).call(this,params,Lathe.defaults,Lathe.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Lathe.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Lathe
     */createClass(Lathe,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?LatheBufferGeometry:LatheGeometry)(params.geometry.points);}}]);inherits(Lathe,_MeshComponent);return Lathe;}(MeshComponent);defineProperty$3(defineProperty$3(Lathe,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{points:[]}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['points']}));/**
   * @class Line
   * @category components/meshes
   * @description Line component is generated from a curve/line and amount of vectors that should be used (points).
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Line, and adding to app</caption>
   * new Line({
   *   geometry: {
   *     curve: new THREE.LineCurve3(new THREE.Vector3(10, 10, 0), new THREE.Vector3(10, 30, 0))
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   })
   * }).addTo(app);
   */var Line$1=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Line#defaults
     * @static
     * @default <pre>
     * {
     *   curve: new LineCurve3(new Vector3(0, 0, 0), new Vector3(10, 0, 0)),
     *   points: 50
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Line#instructions
     * @static
     * @default <pre>{
     *   geometry: ['curve', 'points']
     * }
     * </pre>
     */function Line$$1(params){classCallCheck(this,Line$$1);return possibleConstructorReturn(this,getPrototypeOf$2(Line$$1).call(this,params,Line$$1.defaults,Line$$1.instructions));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Line
     */createClass(Line$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Line(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=params.buffer?new BufferGeometry():new Geometry();if(params.buffer){var pp=params.curve.getPoints(params.points);var verts=new Float32Array(pp.length*3);for(var i=0,max=pp.length;i<max;i++){var i3=i*3;verts[i3]=pp[i].x;verts[i3+1]=pp[i].y;verts[i3+2]=pp[i].z;}geometry.addAttribute('position',new BufferAttribute(verts,3));}else geometry.vertices=params.curve.getPoints(params.points);return geometry;}}]);inherits(Line$$1,_MeshComponent);return Line$$1;}(MeshComponent);defineProperty$3(defineProperty$3(Line$1,"defaults",objectSpread({},MeshComponent.defaults,{curve:null,points:50})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['curve','points']}));/**
   * @class Importer
   * @category components/meshes
   * @description Importer is a loader for meshes and any other data to your scene
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Importer, and adding to app</caption>
   * new Importer({
   *   loader: new THREE.OBJLoader(),
   *
   *   parser(geometry, material) { // data from loader
   *     return new THREE.Mesh(geometry, material); // should return your .native (mesh in this case)
   *   },
   *
   *   position: [0, 100, 0]
   * }).addTo(app);
   */var Importer=/*#__PURE__*/function(_MeshComponent){createClass(Importer,null,[{key:"filter",/**
       * Default values for parameters
       * @member {Object} module:components/meshes.Importer#defaults
       * @static
       * @default <pre>
       * {
       *   url: '',
       *   loader: new JSONLoader(),
       *
       *   onLoad() {},
       *   onProgress() {},
       *   onError() {},
       *
       *   texturePath: null,
       *   useCustomMaterial: false,
       *
       *   parser(geometry, materials) {
       *     return new Mesh(geometry, materials);
       *   }
       * }</pre>
       */ /**
       * @method filter
       * @description Default values for filter
       * @static
       * @param {THREE.Mesh} object Instance for iterating through it's children.
       * @param {Function} filter Function with child as argument, should return a boolean whether include the child or not.
       * @return {THREE.Mesh} object with children
       * @memberof module:components/meshes.Importer
       * @example <caption>Removing unnecessary lights from children</caption>
       * new Importer({
       *   loader: new THREE.OBJLoader(),
       *
       *   parse(group) { // data from loader
       *     return Importer.filter(group, child => !child.isLight); // remove lights
       *   },
       *
       *   position: [0, 100, 0]
       * }).addTo(app);
       */value:function filter(object,_filter){var processFilter=function processFilter(object){object.children.forEach(function(el,index){if(el.children)processFilter(el);if(!_filter(el))object.children.splice(index,1);});return object;};return processFilter(object);}}]);function Importer(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Importer);return possibleConstructorReturn(this,getPrototypeOf$2(Importer).call(this,params,Importer.defaults,Importer.instructions,false));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Importer
     */createClass(Importer,[{key:"build",value:function build(){var _this=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new Promise(function(resolve){if(params.texturePath)params.loader.setTexturePath(params.texturePath);params.loader.load(params.url,function(){for(var _len=arguments.length,data=new Array(_len),_key=0;_key<_len;_key++){data[_key]=arguments[_key];}// geometry, materials
  params.onLoad.apply(params,data);var object=params.parser.apply(_this,data);if(params.material)object.material=_this.applyBridge({material:params.material}).material;resolve(object);},params.onProgress,params.onError);});}}]);inherits(Importer,_MeshComponent);return Importer;}(MeshComponent);defineProperty$3(defineProperty$3(Importer,"defaults",objectSpread({},MeshComponent.defaults,{url:'',loader:new JSONLoader(),onLoad:function onLoad(){},onProgress:function onProgress(){},// TODO add onComplete?
  onError:function onError(){},texturePath:null,useCustomMaterial:false,parser:function parser(geometry,material){var _this$applyBridge=this.applyBridge({geometry:geometry,material:material}),geom=_this$applyBridge.geometry,mat=_this$applyBridge.material;return this.applyBridge({mesh:geom.bones?new SkinnedMesh(geom,mat):new Mesh(geom,mat)}).mesh;}})),"instructions",objectSpread({},MeshComponent.instructions));/**
   * @class Octahedron
   * @category components/meshes
   * @description In geometry, an octahedron is a polyhedron with eight faces.
   * A regular octahedron is a Platonic solid composed of eight equilateral triangles, four of which meet at each vertex.
   * <br/><br/>
   * `Octahedron` creates an Octahedron object by its `radius` and `detail`.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#OctahedronGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating an Octahedron, and adding to app</caption>
   * new Octahedron({
   *   geometry: {
   *     radius: 2,
   *     detail: 1
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: [0, 100, 0]
   * }).addTo(app);
   */var Octahedron=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Octahedron#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 1,
     *     detail: 0
     *   }
     * }
     * </pre>
     */function Octahedron(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Octahedron);_this=possibleConstructorReturn(this,getPrototypeOf$2(Octahedron).call(this,params,Octahedron.defaults,Octahedron.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Octahedron.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Octahedron
     */createClass(Octahedron,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?OctahedronBufferGeometry:OctahedronGeometry)(params.geometry.radius,params.geometry.detail);}}]);inherits(Octahedron,_MeshComponent);return Octahedron;}(MeshComponent);defineProperty$3(Octahedron,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:1,detail:0}}));/**
   * @class Parametric
   * @category components/meshes
   * @description `Parametric` generates a geometry representing a <a href='https://en.wikipedia.org/wiki/Parametric_surface'>Parametric surface</a>
   * <br/><br/>
   * It is usually used to develop different kinds of highfields or visualize a <a href='https://stemkoski.github.io/Three.js/Graphulus-Function.html'>math function</a>.
   * <br/>
   * - <a href='http://math.hws.edu/graphicsbook/source/threejs/curves-and-surfaces.html'>Parametric surface</a>
   * - <a href='https://stemkoski.github.io/Three.js/Graphulus-Surface.html'>"Graphulus"</a>
   * <br/><br/>
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ParametricGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Example creating an heightfield-like geometry. `u` and `v` are like `x` and `y` in shape, but their values are always from `0` to `1`.
   * We use them in `THREE.Vector3` like `x` and `z` and `Math.random() * 5` for `y`.</caption>
   * const createParametric = (u, v) => {
   *   return new THREE.Vector3(u * 30, Math.random() * 5, v * 30);
   * }
   *
   * new Parametric({
   *   geometry: {
   *     func: createParametric
   *   },
   *
   *   material: new THREE.MeshLambertMaterial({
   *     color: 0xffffff,
   *     side: THREE.DoubleSide
   *   }),
   *
   *   position: [0, 100, -100]
   * }).addTo(app);
   */var Parametric=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Parametric#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     func: (u, v) => new Vector3(u, v, 0),
     *     slices: 10,
     *     tacks: 10
     *   }
     * }
     * </pre>
     */function Parametric(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Parametric);return possibleConstructorReturn(this,getPrototypeOf$2(Parametric).call(this,params,Parametric.defaults,Parametric.instructions));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Parametric
     */createClass(Parametric,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?ParametricBufferGeometry:ParametricGeometry)(params.geometry.func,params.geometry.slices,params.geometry.stacks);}}]);inherits(Parametric,_MeshComponent);return Parametric;}(MeshComponent);defineProperty$3(Parametric,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{func:function func(u,v){return new Vector3(u,v,0);},slices:10,stacks:10}}));/**
   * @class Plane
   * @category components/meshes
   * @description `Plane` is used for creating planes given some `width` and `height`.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Plane, and adding to app</caption>
   * new Plane({
   *   geometry: {
   *     width: 20,
   *     height: 30
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   })
   * }).addTo(app);
   */var Plane$1=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Plane#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     width: 10,
     *     height: 10,
     *     wSegments: 1,
     *     hSegments: 1
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Plane#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['width', 'height', 'wSegments', 'hSegments']
     * }
     * </pre>
     */function Plane$$1(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Plane$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(Plane$$1).call(this,params,Plane$$1.defaults,Plane$$1.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Plane$$1.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Plane
     */createClass(Plane$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?PlaneBufferGeometry:PlaneGeometry)(params.geometry.width,params.geometry.height,params.geometry.wSegments,params.geometry.hSegments);return geometry;}}]);inherits(Plane$$1,_MeshComponent);return Plane$$1;}(MeshComponent);defineProperty$3(defineProperty$3(Plane$1,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{width:10,height:10,wSegments:1,hSegments:1}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['width','height','wSegments','hSegments']}));var verticesOfCube=[-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1],indicesOfFaces=[2,1,0,0,3,2,0,4,7,7,3,0,0,1,5,5,4,0,1,2,6,6,5,1,2,3,7,7,6,2,4,5,6,6,7,4];/**
   * @class Polyhedron
   * @category components/meshes
   * @description In elementary geometry, a polyhedron is a solid in three dimensions with flat polygonal faces, straight edges and sharp corners or vertices.
   * <br/><br/>
   * `Polyhedron` creates a Polyhedron by its `radius` and `detail`.
   * <br/><br/>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating an Polyhedron, and adding to app</caption>
   * new Polyhedron({
   *   geometry: {
   *     radius: 2,
   *     detail: 1
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: [0, 100, 0]
   * }).addTo(app);
   */var Polyhedron=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Polyhedron#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     verticesOfCube: [
     *       -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,
     *       -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1
     *     ],
     *
     *     indicesOfFaces: [
     *       2, 1, 0, 0, 3, 2,
     *       0, 4, 7, 7, 3, 0,
     *       0, 1, 5, 5, 4, 0,
     *       1, 2, 6, 6, 5, 1,
     *       2, 3, 7, 7, 6, 2,
     *       4, 5, 6, 6, 7, 4
     *     ],
     *
     *     radius: 6,
     *     detail: 2
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Polyhedron#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['verticesOfCube', 'indicesOfFaces', 'radius', 'detail']
     * }
     * </pre>
     */function Polyhedron(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Polyhedron);_this=possibleConstructorReturn(this,getPrototypeOf$2(Polyhedron).call(this,params,Polyhedron.defaults,Polyhedron.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Polyhedron.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Polyhedron
     */createClass(Polyhedron,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?PolyhedronBufferGeometry:PolyhedronGeometry)(params.geometry.verticesOfCube,params.geometry.indicesOfFaces,params.geometry.radius,params.geometry.detail);}}]);inherits(Polyhedron,_MeshComponent);return Polyhedron;}(MeshComponent);defineProperty$3(defineProperty$3(defineProperty$3(defineProperty$3(Polyhedron,"verticesOfCube",verticesOfCube),"indicesOfFaces",indicesOfFaces),"defaults",objectSpread({},MeshComponent.defaults,{geometry:{verticesOfCube:verticesOfCube,indicesOfFaces:indicesOfFaces,radius:6,detail:2}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['verticesOfCube','indicesOfFaces','radius','detail']}));/**
   * @class Ring
   * @category components/meshes
   * @description Ring class creates a circle or just 2D Torus. Does not support physics.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#RingGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Ring, and adding to app</caption>
   * new Ring({
   *   geometry: {
   *     innerRadius: 5,
   *     outerRadius: 2
   *   },
   *
   *   material: new THREE.MeshLambertMaterial({
   *     color: 0xffffff,
   *     side THREE.DoubleSide
   *   }),
   *
   *   position: [0, 8, 0],
   *
   *   rotation: {
   *     x: Math.PI/4
   *   }
   * }).addTo(app);
   */var Ring=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Ring#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     innerRadius: 0,
     *     outerRadius: 50,
     *     thetaSegments: 8,
     *     phiSegments: 8,
     *     thetaStart: 0,
     *     thetaLength: Math.PI * 2
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Ring#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: [
     *     'innerRadius',
     *     'outerRadius',
     *     'thetaSegments',
     *     'phiSegments',
     *     'thetaStart',
     *     'thetaLength'
     *   ]
     * }
     * </pre>
     */function Ring(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Ring);_this=possibleConstructorReturn(this,getPrototypeOf$2(Ring).call(this,params,Ring.defaults,Ring.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Ring.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Ring
     */createClass(Ring,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?RingBufferGeometry:RingGeometry)(params.geometry.innerRadius,params.geometry.outerRadius,params.geometry.thetaSegments,params.geometry.phiSegments,params.geometry.thetaStart,params.geometry.thetaLength);}}]);inherits(Ring,_MeshComponent);return Ring;}(MeshComponent);defineProperty$3(defineProperty$3(Ring,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{innerRadius:0,outerRadius:50,thetaSegments:8,phiSegments:8,thetaStart:0,thetaLength:Math.PI*2}})),"instructions",objectSpread({},MeshComponent.defaults,{geometry:['innerRadius','outerRadius','thetaSegments','phiSegments','thetaStart','thetaLength']}));/**
   * @class Shape
   * @category components/meshes
   * @description Shape is a universal class. It allows you to create different 2D shapes in 3D scene.<br/>
   * Unfortunately, not all of them support physics, an alternative is to make a similar 3D object and scale its width down to near zero.
   * <br/><br/>
   * `Shape` consists of shapes that are in its shapes parameter.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ShapeGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a plane looking Shape from a THREE.Shape, and adding it to app</caption>
   * const rectWidth = 10,
   * rectLength = 5;
   *
   * const rectShape = new THREE.Shape();
   * rectShape.moveTo(0,0);
   * rectShape.lineTo(0, rectWidth);
   * rectShape.lineTo(rectLength, rectWidth);
   * rectShape.lineTo(rectLength, 0);
   * rectShape.lineTo(0, 0);
   *
   * const plane = new Shape({
   *   geometry: {
   *     shape: rectShape
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   })
   * }).addTo(app);
   */var Shape$1=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Shape#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     shapes: []
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Shape#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['shapes']
     * }
     * </pre>
     */function Shape$$1(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Shape$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(Shape$$1).call(this,params,Shape$$1.defaults,Shape$$1.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Shape$$1.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Shape
     */createClass(Shape$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?ShapeBufferGeometry:ShapeGeometry)(params.geometry.shapes);}}]);inherits(Shape$$1,_MeshComponent);return Shape$$1;}(MeshComponent);defineProperty$3(defineProperty$3(Shape$1,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{shapes:[]}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['shapes']}));/**
   * @class Sphere
   * @category components/meshes
   * @description Sphere class is used to create sphere objects by its radius property and other values that determines its detality.
   * <br/><br/>
   * It is similar to THREE.SphereGeometry, but it also contains all `Shape` properties, such as material, mass and vectors like position (pos) and rotation (rot).
   * <br/><br/>
   * Then it creates an `Three.js mesh` or a `Physijs mesh`, that is similar to `Three.js mesh`, but it also take into consideration collision calculations.
   * This mesh is a combination of `Three.js geometry` and `Physijs material` (The same as in three.js, but with friction and restitution).
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#SphereGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Sphere, and adding it to app</caption>
   * new Sphere({
   *   geometry: {
   *     radius: 2
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: {
   *     y: 100
   *   }
   * }).addTo(app);
   */var Sphere$1=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Sphere#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 1,
     *     widthSegments: 8,
     *     heightSegments: 6
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Sphere#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['radius', 'widthSegments', 'heightSegments']
     * }
     * </pre>
     */function Sphere$$1(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Sphere$$1);return possibleConstructorReturn(this,getPrototypeOf$2(Sphere$$1).call(this,params,Sphere$$1.defaults,Sphere$$1.instructions));}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Sphere
     */createClass(Sphere$$1,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?SphereBufferGeometry:SphereGeometry)(params.geometry.radius,params.geometry.widthSegments,params.geometry.heightSegments);return geometry;}}]);inherits(Sphere$$1,_MeshComponent);return Sphere$$1;}(MeshComponent);defineProperty$3(defineProperty$3(Sphere$1,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:1,widthSegments:8,heightSegments:6}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','widthSegments','heightSegments']}));/**
   * @class Tetrahedron
   * @category components/meshes
   * @description In geometry, a tetrahedron is a polyhedron composed of four triangular faces, six straight edges, and four vertex corners.
   * The tetrahedron is the simplest of all the ordinary convex polyhedra and the only one that has fewer than 5 faces.
   * <br/><br/>
   * `Tetrahedron` creates a Tetrahedron object by its `radius` and `detail`
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TetrahedronGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Tetrahedron, and adding it to app</caption>
   * new Tetrahedron({
   *   geometry: {
   *     radius: 2,
   *     detail: 1
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: {
   *     x: 0,
   *     y: 100,
   *     z: 0
   *   }
   * }).addTo(app);
   */var Tetrahedron=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Tetrahedron#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 1,
     *     detail: 0
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Tetrahedron#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: ['radius', 'detail']
     * }
     * </pre>
     */function Tetrahedron(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Tetrahedron);_this=possibleConstructorReturn(this,getPrototypeOf$2(Tetrahedron).call(this,params,Tetrahedron.defaults,Tetrahedron.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Tetrahedron.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Tetrahedron
     */createClass(Tetrahedron,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new(params.buffer?TetrahedronBufferGeometry:TetrahedronGeometry)(params.geometry.radius,params.geometry.detail);}}]);inherits(Tetrahedron,_MeshComponent);return Tetrahedron;}(MeshComponent);defineProperty$3(defineProperty$3(Tetrahedron,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:1,detail:0}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','detail']}));/**
   * @class Text
   * @category components/meshes
   * @description Text class is made for creating 3D text objects.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TextGeometry"></iframe>
   * <br/><br/>
   * Physics text object can be convex or concave. By default it's convex but you can also switch to concave.
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Text, and adding it to app</caption>
   * new Text({
   *     text: 'Some text',
   *     parameters: {
   *       font: 'path/to/font.typeface.js',
   *       size: 20,
   *       height: 5,
   *       curveSegments: 6
   *     }
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: {
   *     x: -40,
   *     y: 20,
   *     z: 0
   *   }
   * }).addTo(app);
   */var Text=/*#__PURE__*/function(_MeshComponent){createClass(Text,null,[{key:"load",/**
       * Default values for parameters
       * @member {Object} module:components/meshes.Text#defaults
       * @static
       * @default <pre>
       * {
       *   text: 'Hello World!',
       *   font: null,
       *
       *   geometry: {
       *     size: 12,
       *     height: 50,
       *     curveSegments: 12,
       *     font: new Font(),
       *     bevelEnabled: false,
       *     bevelThickness: 10,
       *     bevelSize: 8
       *   }
       * }
       * </pre>
       */ /**
       * Default FontLoader
       * @member {Object} module:components/meshes.Text#loader
       * @static
       * @default new FontLoader()
       */ /**
       * @method load
       * @static
       * @description load() preloads a Font object and returns a Promise with it.
       * @param {String} path Path to the font
       * @return {Promise} A promise resolved with a font
       * @memberof module:components/meshes.Text
       */value:function load(path){var loader=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Text.loader;return new Promise(function(resolve){loader.load(path,resolve);});}}]);function Text(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Text);return possibleConstructorReturn(this,getPrototypeOf$2(Text).call(this,params,Text.defaults,Text.instructions));}/**
     * @method build
     * @description Build is called as part of the lifecycle to create a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Text
     */createClass(Text,[{key:"build",value:function build(){var _this=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var promise=new Promise(function(resolve){(params.font instanceof Promise?params.font:Promise.resolve(params.font)).then(function(font){var _this$applyBridge=_this.applyBridge({geometry:new TextGeometry(params.text,Object.assign(params.geometry,{font:font})),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;resolve(_this.applyBridge({mesh:new Mesh(geometry,material)}).mesh);});});get$3(getPrototypeOf$2(Text.prototype),"wait",this).call(this,promise);return promise;}}]);inherits(Text,_MeshComponent);return Text;}(MeshComponent);defineProperty$3(defineProperty$3(defineProperty$3(Text,"defaults",objectSpread({},MeshComponent.defaults,{text:'Hello World!',font:null,geometry:{size:12,height:50,curveSegments:12,font:new Font(),bevelEnabled:false,bevelThickness:10,bevelSize:8}})),"instructions",objectSpread({},MeshComponent.instructions)),"loader",new FontLoader());/**
   * @class Torus
   * @category components/meshes
   * @description Torus class makes a torus figure. A donut is a torus.
   * @classDesc
   * <iframe src="https://threejs.org/docs/index.html#api/geometries/TorusGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Torus, and adding it to app</caption>
   * new Torus({
   *   geometry: {
   *     radius: 5,
   *     tube: 2
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   position: {
   *     y: 35
   *   }
   * }).addTo(app);
   */var Torus=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Torus#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 100,
     *     tube: 40,
     *     radialSegments: 8,
     *     tubularSegments: 6,
     *     arc: Math.PI * 2
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Torus#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: [
     *     'radius',
     *     'tube',
     *     'radialSegments',
     *     'tubularSegments',
     *     'arc'
     *   ]
     * }
     * </pre>
     */function Torus(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Torus);_this=possibleConstructorReturn(this,getPrototypeOf$2(Torus).call(this,params,Torus.defaults,Torus.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Torus.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Torus
     */createClass(Torus,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return new TorusGeometry(params.geometry.radius,params.geometry.tube,params.geometry.radialSegments,params.geometry.tubularSegments,params.geometry.arc);}}]);inherits(Torus,_MeshComponent);return Torus;}(MeshComponent);defineProperty$3(defineProperty$3(Torus,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:100,tube:40,radialSegments:8,tubularSegments:6,arc:Math.PI*2}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','tube','radialSegments','tubularSegments','arc']}));/**
   * @class Torusknot
   * @category components/meshes
   * @description Torusknot class makes a torusknot figure. It's like a crooked donut, very crooked.
   * @classDesc
   * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TorusKnotGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Torusknot, and adding it to app</caption>
   * new Torusknot({
   *   geometry: {
   *     radius:5,
   *     tube: 2
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *
   *   pos: {
   *     y: 100
   *   }
   * }).addTo(app);
   */var Torusknot=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Torusknot#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     radius: 100,
     *     tube: 40,
     *     radialSegments: 64,
     *     tubularSegments: 8,
     *     p: 2,
     *     q: 3
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Torusknot#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: [
     *     'radius',
     *     'tube',
     *     'radialSegments',
     *     'tubularSegments',
     *     'p',
     *     'q'
     *   ]
     * }
     * </pre>
     */function Torusknot(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Torusknot);_this=possibleConstructorReturn(this,getPrototypeOf$2(Torusknot).call(this,params,Torusknot.defaults,Torusknot.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Torusknot.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Torusknot
     */createClass(Torusknot,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var GConstruct=params.buffer?TorusKnotBufferGeometry:TorusKnotGeometry;return new GConstruct(params.geometry.radius,params.geometry.tube,params.geometry.radialSegments,params.geometry.tubularSegments,params.geometry.p,params.geometry.q);}}]);inherits(Torusknot,_MeshComponent);return Torusknot;}(MeshComponent);defineProperty$3(defineProperty$3(Torusknot,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{radius:100,tube:40,radialSegments:64,tubularSegments:8,p:2,q:3}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['radius','tube','radialSegments','tubularSegments','p','q']}));/**
   * @class Tube
   * @category components/meshes
   * @description Tube class makes a tube that extrudes along a 3d curve.
   * @classDesc
   * <iframe src="https://threejs.org/docs/index.html#api/geometries/TubeGeometry"></iframe>
   * @param {Object} [params] - The params.
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Creating a Tube from a three.js Curve, and adding it to app</caption>
   * const CustomSinCurve = THREE.Curve.create(
   *   function (scale) { // custom curve constructor
   *     this.scale = (scale === undefined) ? 1 : scale;
   *   },
   *
   *   function (t) { // getPoint: t is between 0-1
   *     const tx = t * 3 - 1.5,
   *     ty = Math.sin( 2 * Math.PI * t ),
   *     tz = 0;
   *
   *     return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
   *   }
   * );
   *
   * const path = new CustomSinCurve(10);
   *
   * new Tube({
   *   geometry: {
   *     path: path
   *   },
   *
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   })
   * }).addTo(app);
   */var Tube=/*#__PURE__*/function(_MeshComponent){/**
     * Default values for parameters
     * @member {Object} module:components/meshes.Tube#defaults
     * @static
     * @default <pre>
     * {
     *   geometry: {
     *     path: new THREE.LineCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, 1)),
     *     segments: 20,
     *     radius: 2,
     *     radiusSegments: 8,
     *     closed: false
     *   }
     * }
     * </pre>
     */ /**
     * Instructions
     * @member {Object} module:components/meshes.Tube#instructions
     * @static
     * @default <pre>
     * {
     *   geometry: [
     *     'path',
     *     'segments',
     *     'radius',
     *     'radiusSegments',
     *     'closed'
     *   ]
     * }
     * </pre>
     */function Tube(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,Tube);_this=possibleConstructorReturn(this,getPrototypeOf$2(Tube).call(this,params,Tube.defaults,Tube.instructions));if(params.build){_this.build(params);get$3(getPrototypeOf$2(Tube.prototype),"wrap",assertThisInitialized(_this)).call(assertThisInitialized(_this));}return _this;}/**
     * @method build
     * @description Build lifecycle creates a mesh using input params.
     * @param {Object} params Component parameters.
     * @return {THREE.Mesh} Built mesh
     * @memberof module:components/meshes.Tube
     */createClass(Tube,[{key:"build",value:function build(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.params;var _this$applyBridge=this.applyBridge({geometry:this.buildGeometry(params),material:params.material}),geometry=_this$applyBridge.geometry,material=_this$applyBridge.material;return this.applyBridge({mesh:new Mesh(geometry,material)}).mesh;}},{key:"buildGeometry",value:function buildGeometry(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var geometry=new(params.buffer?TubeBufferGeometry:TubeGeometry)(params.geometry.path,params.geometry.segments,params.geometry.radius,params.geometry.radiusSegments,params.geometry.closed);return geometry;}}]);inherits(Tube,_MeshComponent);return Tube;}(MeshComponent);defineProperty$3(defineProperty$3(Tube,"defaults",objectSpread({},MeshComponent.defaults,{geometry:{path:new LineCurve3(new Vector3(0,0,0),new Vector3(0,0,1)),segments:20,radius:2,radiusSegments:8,closed:false}})),"instructions",objectSpread({},MeshComponent.instructions,{geometry:['path','segments','radius','radiusSegments','closed']}));/**
   * @class Group
   * @category components/meshes
   * @description Sometimes you need to make groups of objects (it's not conveniently to apply transforms to each object when can make just one to a group).<br/>
   * In Three.js you make it using `THREE.Object3D` and it's children. <br/><br/>
   * In whs.js we have `Group`
   * @extends module:core.MeshComponent
   * @memberof module:components/meshes
   * @example <caption>Approach 2 - Adding objects to an empty group</caption>
   * const sphere = new Sphere();
   * const box = new Box();
   * const group = new Group();
   *
   * sphere.addTo(group);
   * box.addTo(group);
  * @example <caption>Approach 2 - Making a group from objects</caption>
   * const sphere = new Sphere();
   * const box = new Box();
   * const group = new Group(box, sphere);
   * // OR: const group = new Group([box, sphere]);
   */var Group$1=/*#__PURE__*/function(_MeshComponent){function Group$$1(){var _this;classCallCheck(this,Group$$1);_this=possibleConstructorReturn(this,getPrototypeOf$2(Group$$1).call(this,{}));for(var i=0;i<arguments.length;i++){var obj=i<0||arguments.length<=i?undefined:arguments[i];if(obj instanceof Component)obj.addTo(assertThisInitialized(assertThisInitialized(_this)));else if(obj instanceof Object3D)_this.native.add(obj);}return _this;}createClass(Group$$1,[{key:"build",value:function build(){return new Object3D();}}]);inherits(Group$$1,_MeshComponent);return Group$$1;}(MeshComponent);/** @module components/meshes */ /**
   * @class ElementModule
   * @category modules/app
   * @param {Object} [container=document.body] container is the DOM object to which application's canvas will be added to.
   * @memberof module:modules/app
   * @example <caption>Creating an element module, passing it to the App</caption>
   * new App([
   *   new ElementModule(document.getElementById('app'))
   * ]);
   */var ElementModule=/*#__PURE__*/function(){function ElementModule(){var container=arguments.length>0&&arguments[0]!==undefined?arguments[0]:document.body;classCallCheck(this,ElementModule);if(container.container){console.warn('ElementModule now accepts only argument which is a DOM object, not a params object.');this.container=container.container;}else this.container=container;this.createElement();}/**
     * @method createElement
     * @instance
     * @description Creates a canvas element.
     * @memberof module:modules/app.ElementModule
     */createClass(ElementModule,[{key:"createElement",value:function createElement(){this.element=window.document.createElement('div');this.element.className='whs-app';this.element.style.width='inherit';this.element.style.height='inherit';this.element.style.position='relative';}},{key:"manager",value:function manager(_manager){_manager.set('element',this.element);_manager.set('container',this.container);}},{key:"integrate",value:function integrate(self){self.container.appendChild(self.element);}}]);return ElementModule;}();/**
   * @class RenderingModule
   * @category modules/app
   * @param {Object} [params]
   * @memberof module:modules/app
   * @example <caption> Creating a rendering module and passing it to App's modules</caption>
   * new App([
   *   new ElementModule(),
   *   new SceneModule(),
   *   new DefineModule('camera', new PerspectiveCamera({
   *     position: new THREE.Vector3(0, 6, 18),
   *     far: 10000
   *   })),
   *   new RenderingModule({
   *     bgColor: 0x162129,
   *
   *     renderer: {
   *       antialias: true
   *     }
   *   }, {shadow: true})
   * ]);
   */var RenderingModule=/*#__PURE__*/function(){/**
     * additional
     * @description collection of additional scripts
     * @static
     * @member {Object} module:core.App#additional
     * @public
     */ /**
     * enabled
     * @static
     * @member {Boolean} module:core.App#enabled
     * @public
     */function RenderingModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var additional=arguments.length>1?arguments[1]:undefined;classCallCheck(this,RenderingModule);defineProperty$3(this,"enabled",true);this.params=Object.assign({width:window.innerWidth,height:window.innerHeight,resolution:new Vector2(1,1),pixelRatio:window.devicePixelRatio,bgColor:0x000000,bgOpacity:1,renderer:{},fix:function fix(){}},params);var _this$params=this.params,bgColor=_this$params.bgColor,bgOpacity=_this$params.bgOpacity,_renderer=_this$params.renderer,pixelRatio=_this$params.pixelRatio,width=_this$params.width,height=_this$params.height,resolution=_this$params.resolution,fix=_this$params.fix;this.renderer=new WebGLRenderer(_renderer);this.effects=[];this.renderer.setClearColor(bgColor,bgOpacity);if(pixelRatio)this.renderer.setPixelRatio(pixelRatio);this.setSize(Number(width*resolution.x).toFixed(),Number(height*resolution.y).toFixed());for(var key in additional){if(additional[key])this.applyAdditional(key);}fix(this.renderer);}/**
     * @method applyAdditional
     * @description Apply additional script from RenderingModule.additional
     * @param {Stirng} name Script name
     * @return {this}
     * @memberof module:modules/app.RenderingModule
     */createClass(RenderingModule,[{key:"applyAdditional",value:function applyAdditional(name){RenderingModule.additional[name].apply(this,[this.renderer]);}/**
       * @method integrateRenderer
       * @description Integrate renderer
       * @param {NodeElement} element DOM object
       * @param {THREE.Scene} scene used scene
       * @param {THREE.Camera} camera used camera
       * @return {Loop} renderLoop
       * @memberof module:modules/app.RenderingModule
       */},{key:"integrateRenderer",value:function integrateRenderer(element,scene,camera){var _this=this;this.scene=scene;this.camera=camera;this.attachToCanvas(element);return new Loop(function(){return _this.renderer.render(_this.scene,_this.camera);});}/**
       * @method effect
       * @description Add three.js effect
       * @param {Object} effect three.js effect
       * @param {function} effectLoop update function for effect
       * @return {this}
       * @memberof module:modules/app.RenderingModule
       */},{key:"effect",value:function effect(_effect){var _this2=this;var effectLoop=arguments.length>1&&arguments[1]!==undefined?arguments[1]:function(){_effect.render(_this2.scene,_this2.camera);};this.renderLoop.stop();var size=this.renderer.getSize();_effect.setSize(size.width,size.height);var loop=new Loop(effectLoop);this.effects.push(loop);if(this.enabled)loop.start(this.app);return this;}/**
       * @method setSize
       * @description Update render target width and height.
       * @param {Number} width
       * @param {Number} height
       * @memberof module:modules/app.RenderingModule
       */},{key:"setSize",value:function setSize(width,height){if(this.renderer)this.renderer.setSize(width,height);}/**
       * @method attachToCanvas
       * @description Attach renderer.domElement to element
       * @param {NodeElement} element DOM object
       * @memberof module:modules/app.RenderingModule
       */},{key:"attachToCanvas",value:function attachToCanvas(element){var canvas=this.renderer.domElement;// attach to new parent world dom
  element.appendChild(canvas);canvas.style.width='100%';canvas.style.height='100%';}/**
       * @method stop
       * @description Stops renderLoop and effect loops
       * @memberof module:modules/app.RenderingModule
       */},{key:"stop",value:function stop(){this.enabled=false;this.renderLoop.stop();this.effects.forEach(function(loop){return loop.stop();});}/**
       * @method play
       * @description Resumes renderLoop and effect loops
       * @memberof module:modules/app.RenderingModule
       */},{key:"play",value:function play(){this.enabled=true;this.renderLoop.start();this.effects.forEach(function(loop){return loop.start();});}},{key:"manager",value:function manager(_manager){var _this3=this;_manager.define('rendering');_manager.set('renderer',this.renderer);this.app=_manager.handler;this.renderLoop=this.integrateRenderer(_manager.get('element'),_manager.get('scene'),_manager.get('camera').native);_manager.update({element:function element(_element){_this3.attachToCanvas(_element);},scene:function scene(_scene){_this3.scene=_scene;},camera:function camera(_camera){_this3.camera=_camera.native;}});}},{key:"integrate",value:function integrate(self){var _this4=this;self.renderLoop.start(this);self.effects.forEach(function(loop){return loop.start(_this4);});}/**
       * @method dispose
       * @description Dispose rendering context
       * @memberof module:modules/app.RenderingModule
       */},{key:"dispose",value:function dispose(){this.stop();this.renderer.forceContextLoss();}}]);return RenderingModule;}();defineProperty$3(RenderingModule,"additional",{shadow:function shadow(renderer){renderer.shadowMap.enabled=true;}});var SYMBOL_CHILDREN_FOR_SCENE=Symbol('SYMBOL_CHILDREN_FOR_SCENE');/**
   * @class SceneModule
   * @category modules/app
   * @param {Boolean} [willSceneBeReplaced=false] willSceneBeReplaced should be true only if you are going to overwrite scene dependency even without the use of default one.
   * @memberof module:modules/app
   */var SceneModule=/*#__PURE__*/function(){function SceneModule(){var willSceneBeReplaced=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;classCallCheck(this,SceneModule);this.scene=willSceneBeReplaced?null:new Scene();}createClass(SceneModule,[{key:"manager",value:function manager(_manager){_manager.set('scene',this.scene);}},{key:"integrate",value:function integrate(self){Object.assign(this,{add:function add(object){var _this=this;return asyncToGenerator(/*#__PURE__*/regenerator.mark(function _callee(){return regenerator.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!object.parent){_context.next=3;break;}_context.next=3;return object.parent.remove(object);case 3:_context.next=5;return object.wait();case 5:if(object.native){_context.next=7;break;}throw new CompositionError('SceneModule','there is no object.native',_this);case 7:object.parent=_this;_context.next=10;return _this.applyBridge({onAdd:object}).onAdd;case 10:self.scene.add(object.native);_this.children.push(object);return _context.abrupt("return",object);case 13:case"end":return _context.stop();}}},_callee,this);}))();},remove:function remove(object){var _this2=this;return asyncToGenerator(/*#__PURE__*/regenerator.mark(function _callee2(){return regenerator.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(object.parent!==_this2)){_context2.next=2;break;}return _context2.abrupt("return");case 2:_context2.next=4;return object.wait();case 4:object.parent=null;self.scene.remove(object.native);_this2.children.splice(_this2.children.indexOf(object),1);case 7:case"end":return _context2.stop();}}},_callee2,this);}))();},_setScene:function _setScene(scene){this.children=scene[SYMBOL_CHILDREN_FOR_SCENE]=scene[SYMBOL_CHILDREN_FOR_SCENE]||[];self.scene=scene;},setScene:function setScene(scene){this._setScene(scene);this.manager.set('scene',scene);},getScene:function getScene(){return self.scene;}});if(self.scene)this._setScene(self.scene);}}]);return SceneModule;}();// import {addResizeListener} from 'detect-element-resize';
  /**
   * @class ResizeModule
   * @category modules/app
   * @param {Object} [params={auto: true}] - If auto is set to true - resize will be triggered when container resizes
   * @memberof module:modules/app
   */var ResizeModule=/*#__PURE__*/function(){function ResizeModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,ResizeModule);this.params=Object.assign({auto:true},params);this.callbacks=[this.setSize.bind(this)];}/**
     * @function setSize
     * @instance
     * @description This function sets the provided width & height to the renderer object.
     * @param {Number} [width=1] - The promise that should be added to a queue.
     * @param {Number} [height=1] - that is resolved when all promises completed.
     * @memberof module:modules/app.ResizeModule
     */createClass(ResizeModule,[{key:"setSize",value:function setSize(){var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;this.camera.native.aspect=width/height;this.camera.native.updateProjectionMatrix();if(this.rendering)this.rendering.setSize(width,height);}/**
       * @method trigger
       * @instance
       * @description Triggers resize when called. width & height are determined automatically
       * This invokes each callbacks with the new width and height as params
       * @memberof module:modules/app.ResizeModule
       */},{key:"trigger",value:function trigger(){var _this$container=this.container,offsetWidth=_this$container.offsetWidth,offsetHeight=_this$container.offsetHeight,resolution=this.resolution;var width=Number(offsetWidth*resolution.x).toFixed();var height=Number(offsetHeight*resolution.y).toFixed();this.callbacks.forEach(function(cb){cb(width,height);});}/**
       * @method addAutoresize
       * @instance
       * @description Sets module to autoresize, this adds an event listene on window resize to trigger the resize
       * @memberof module:modules/app.ResizeModule
       */},{key:"addAutoresize",value:function addAutoresize(){this.container=this.getContainer();this.resolution=this.getResolution();if(this.params.auto)window.addEventListener('resize',this.trigger.bind(this));}/**
       * @method addCallback
       * @instance
       * @description Adds a call back function to the existing callbacks list.
       * @param {Function} func - The callback function to add
       * @memberof module:modules/app.ResizeModule
       */},{key:"addCallback",value:function addCallback(func){this.callbacks.push(func);}},{key:"manager",value:function manager(_manager){var _this=this;_manager.define('resize');this.rendering=_manager.get('renderer');this.camera=_manager.get('camera');this.getResolution=function(){return _manager.use('rendering').params.resolution;};this.getContainer=function(){return _manager.get('container');};_manager.update({container:function container(_container){_this.container=_container;}});this.addAutoresize();}}]);return ResizeModule;}();var fragment="uniform sampler2D tPreviousLum;\r\nuniform sampler2D tCurrentLum;\r\nuniform float minLuminance;\r\nuniform float delta;\r\nuniform float tau;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tfloat previousLum = texture2D(tPreviousLum, vUv, MIP_LEVEL_1X1).r;\r\n\tfloat currentLum = texture2D(tCurrentLum, vUv, MIP_LEVEL_1X1).r;\r\n\r\n\tpreviousLum = max(minLuminance, previousLum);\r\n\tcurrentLum = max(minLuminance, currentLum);\r\n\r\n\t// Adapt the luminance using Pattanaik's technique.\r\n\tfloat adaptedLum = previousLum + (currentLum - previousLum) * (1.0 - exp(-delta * tau));\r\n\r\n\tgl_FragColor.r = adaptedLum;\r\n\r\n}\r\n";var vertex="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * An adaptive luminosity shader material.
   */var AdaptiveLuminosityMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new adaptive luminosity material.
     */function AdaptiveLuminosityMaterial(){classCallCheck(this,AdaptiveLuminosityMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(AdaptiveLuminosityMaterial).call(this,{type:"AdaptiveLuminosityMaterial",defines:{MIP_LEVEL_1X1:"0.0"},uniforms:{tPreviousLum:new Uniform(null),tCurrentLum:new Uniform(null),minLuminance:new Uniform(0.01),delta:new Uniform(0.0),tau:new Uniform(1.0)},fragmentShader:fragment,vertexShader:vertex,depthWrite:false,depthTest:false}));}inherits(AdaptiveLuminosityMaterial,_ShaderMaterial);return AdaptiveLuminosityMaterial;}(ShaderMaterial);var fragment$1="uniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform float focus;\r\nuniform float dof;\r\nuniform float aspect;\r\nuniform float aperture;\r\nuniform float maxBlur;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tuniform float cameraNear;\r\n\tuniform float cameraFar;\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(1.0, aspect);\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = texture2D(tDepth, vUv).x;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = readDepth(tDepth, vUv);\r\n\r\n\t#endif\r\n\r\n\tfloat focusNear = clamp(focus - dof, 0.0, 1.0);\r\n\tfloat focusFar = clamp(focus + dof, 0.0, 1.0);\r\n\r\n\t// Calculate a DoF mask.\r\n\tfloat low = step(depth, focusNear);\r\n\tfloat high = step(focusFar, depth);\r\n\r\n\tfloat factor = (depth - focusNear) * low + (depth - focusFar) * high;\r\n\r\n\tvec2 dofBlur = vec2(clamp(factor * aperture, -maxBlur, maxBlur));\r\n\r\n\tvec2 dofblur9 = dofBlur * 0.9;\r\n\tvec2 dofblur7 = dofBlur * 0.7;\r\n\tvec2 dofblur4 = dofBlur * 0.4;\r\n\r\n\tvec4 color = vec4(0.0);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur7);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur4);\r\n\r\n\tgl_FragColor = color / 41.0;\r\n\r\n}\r\n";var vertex$1="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * Depth of Field shader (Bokeh).
   *
   * Original shader code by Martins Upitis:
   *  http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
   */var BokehMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new bokeh material.
     *
     * @param {PerspectiveCamera} [camera] - A camera.
     * @param {Object} [options] - The options.
     * @param {Number} [options.focus=1.0] - The focus distance, corresponds directly with the scene depth.
     * @param {Number} [options.dof=0.02] - Depth of field. An area in front of and behind the focus point that still appears sharp.
     * @param {Number} [options.aperture=0.025] - Camera aperture scale. Bigger values for stronger blur and shallower depth of field.
     * @param {Number} [options.maxBlur=1.0] - Maximum blur strength.
     */function BokehMaterial(camera){var _this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,BokehMaterial);var settings=Object.assign({focus:1.0,dof:0.02,aperture:0.025,maxBlur:1.0},options);_this=possibleConstructorReturn(this,getPrototypeOf$2(BokehMaterial).call(this,{type:"BokehMaterial",uniforms:{cameraNear:new Uniform(0.1),cameraFar:new Uniform(2000),aspect:new Uniform(1.0),tDiffuse:new Uniform(null),tDepth:new Uniform(null),focus:new Uniform(settings.focus),dof:new Uniform(settings.dof),aperture:new Uniform(settings.aperture),maxBlur:new Uniform(settings.maxBlur)},fragmentShader:fragment$1,vertexShader:vertex$1,depthWrite:false,depthTest:false}));_this.adoptCameraSettings(camera);return _this;}/**
     * Adopts the settings of the given camera.
     *
     * @param {PerspectiveCamera} [camera=null] - A camera.
     */createClass(BokehMaterial,[{key:"adoptCameraSettings",value:function adoptCameraSettings(){var camera=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(camera!==null){this.uniforms.cameraNear.value=camera.near;this.uniforms.cameraFar.value=camera.far;this.uniforms.aspect.value=camera.aspect;}}}]);inherits(BokehMaterial,_ShaderMaterial);return BokehMaterial;}(ShaderMaterial);var fragment$2="uniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tconst vec2 threshold = vec2(EDGE_THRESHOLD);\r\n\r\n\t// Calculate color deltas.\r\n\tvec4 delta;\r\n\tvec3 c = texture2D(tDiffuse, vUv).rgb;\r\n\r\n\tvec3 cLeft = texture2D(tDiffuse, vOffset[0].xy).rgb;\r\n\tvec3 t = abs(c - cLeft);\r\n\tdelta.x = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTop = texture2D(tDiffuse, vOffset[0].zw).rgb;\r\n\tt = abs(c - cTop);\r\n\tdelta.y = max(max(t.r, t.g), t.b);\r\n\r\n\t// We do the usual threshold.\r\n\tvec2 edges = step(threshold, delta.xy);\r\n\r\n\t// Then discard if there is no edge.\r\n\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\t// Calculate right and bottom deltas.\r\n\tvec3 cRight = texture2D(tDiffuse, vOffset[1].xy).rgb;\r\n\tt = abs(c - cRight);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cBottom = texture2D(tDiffuse, vOffset[1].zw).rgb;\r\n\tt = abs(c - cBottom);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the maximum delta in the direct neighborhood.\r\n\tfloat maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\r\n\r\n\t// Calculate left-left and top-top deltas.\r\n\tvec3 cLeftLeft = texture2D(tDiffuse, vOffset[2].xy).rgb;\r\n\tt = abs(c - cLeftLeft);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTopTop = texture2D(tDiffuse, vOffset[2].zw).rgb;\r\n\tt = abs(c - cTopTop);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the final maximum delta.\r\n\tmaxDelta = max(max(maxDelta, delta.z), delta.w);\r\n\r\n\t// Local contrast adaptation in action.\r\n\tedges.xy *= step(0.5 * maxDelta, delta.xy);\r\n\r\n\tgl_FragColor = vec4(edges, 0.0, 0.0);\r\n\r\n}\r\n";var vertex$2="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-1.0, 0.0, 0.0, 1.0); // Changed sign in W component.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\tvOffset[2] = uv.xyxy + texelSize.xyxy * vec4(-2.0, 0.0, 0.0, 2.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A material that detects edges in a color texture.
   *
   * Mainly used for Subpixel Morphological Antialiasing.
   */var ColorEdgesMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new color edges material.
     *
     * @param {Vector2} [texelSize] - The absolute screen texel size.
     */function ColorEdgesMaterial(){var texelSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();classCallCheck(this,ColorEdgesMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(ColorEdgesMaterial).call(this,{type:"ColorEdgesMaterial",defines:{EDGE_THRESHOLD:"0.1"},uniforms:{tDiffuse:new Uniform(null),texelSize:new Uniform(texelSize)},fragmentShader:fragment$2,vertexShader:vertex$2,depthWrite:false,depthTest:false}));}/**
     * Sets the edge detection sensitivity.
     *
     * A lower value results in more edges being detected at the expense of
     * performance.
     *
     * 0.1 is a reasonable value, and allows to catch most visible edges.
     * 0.05 is a rather overkill value, that allows to catch 'em all.
     *
     * If temporal supersampling is used, 0.2 could be a reasonable value,
     * as low contrast edges are properly filtered by just 2x.
     *
     * @param {Number} threshold - The edge detection sensitivity. Range: [0, 0.5].
     */createClass(ColorEdgesMaterial,[{key:"setEdgeDetectionThreshold",value:function setEdgeDetectionThreshold(threshold){this.defines.EDGE_THRESHOLD=threshold.toFixed("2");this.needsUpdate=true;}}]);inherits(ColorEdgesMaterial,_ShaderMaterial);return ColorEdgesMaterial;}(ShaderMaterial);var fragment$3="uniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\n\r\nuniform float opacity1;\r\nuniform float opacity2;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel1 = opacity1 * texture2D(texture1, vUv);\r\n\tvec4 texel2 = opacity2 * texture2D(texture2, vUv);\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invTexel1 = vec3(1.0) - texel1.rgb;\r\n\t\tvec3 invTexel2 = vec3(1.0) - texel2.rgb;\r\n\r\n\t\tvec4 color = vec4(\r\n\t\t\tvec3(1.0) - invTexel1 * invTexel2,\r\n\t\t\ttexel1.a + texel2.a\r\n\t\t);\r\n\r\n\t#else\r\n\r\n\t\tvec4 color = texel1 + texel2;\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";var vertex$3="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A material for combining two textures.
   *
   * This material supports the two blend modes Add and Screen.
   *
   * In Screen mode, the two textures are effectively projected on a white screen
   * simultaneously. In Add mode, the textures are simply added together which
   * often produces undesired, washed out results.
   */var CombineMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new combine material.
     *
     * @param {Boolean} [screenMode=false] - Whether the screen blend mode should be used.
     */function CombineMaterial(){var _this;var screenMode=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;classCallCheck(this,CombineMaterial);_this=possibleConstructorReturn(this,getPrototypeOf$2(CombineMaterial).call(this,{type:"CombineMaterial",uniforms:{texture1:new Uniform(null),texture2:new Uniform(null),opacity1:new Uniform(1.0),opacity2:new Uniform(1.0)},fragmentShader:fragment$3,vertexShader:vertex$3,depthWrite:false,depthTest:false}));_this.setScreenModeEnabled(screenMode);return _this;}/**
     * Enables or disables the Screen blend mode.
     *
     * @param {Boolean} enabled - Whether the Screen blend mode should be enabled.
     */createClass(CombineMaterial,[{key:"setScreenModeEnabled",value:function setScreenModeEnabled(enabled){if(enabled){this.defines.SCREEN_MODE="1";}else{delete this.defines.SCREEN_MODE;}this.needsUpdate=true;}}]);inherits(CombineMaterial,_ShaderMaterial);return CombineMaterial;}(ShaderMaterial);var fragment$4="#include <common>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\t// Sample top left texel.\r\n\tvec4 sum = texture2D(tDiffuse, vUv0);\r\n\r\n\t// Sample top right texel.\r\n\tsum += texture2D(tDiffuse, vUv1);\r\n\r\n\t// Sample bottom right texel.\r\n\tsum += texture2D(tDiffuse, vUv2);\r\n\r\n\t// Sample bottom left texel.\r\n\tsum += texture2D(tDiffuse, vUv3);\r\n\r\n\t// Compute the average.\r\n\tgl_FragColor = sum * 0.25;\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";var vertex$4="uniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\nuniform float kernel;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 dUv = (texelSize * vec2(kernel)) + halfTexelSize;\r\n\r\n\tvUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\r\n\tvUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\r\n\tvUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\r\n\tvUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * An optimised convolution shader material.
   *
   * This material supports dithering.
   *
   * Based on the GDC2003 Presentation by Masaki Kawase, Bunkasha Games:
   *  Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)
   * and an article by Filip Strugar, Intel:
   *  An investigation of fast real-time GPU-based image blur algorithms
   *
   * Further modified according to Apple's
   * [Best Practices for Shaders](https://goo.gl/lmRoM5).
   */var ConvolutionMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new convolution material.
     *
     * @param {Vector2} [texelSize] - The absolute screen texel size.
     */function ConvolutionMaterial(){var _this;var texelSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();classCallCheck(this,ConvolutionMaterial);_this=possibleConstructorReturn(this,getPrototypeOf$2(ConvolutionMaterial).call(this,{type:"ConvolutionMaterial",uniforms:{tDiffuse:new Uniform(null),texelSize:new Uniform(new Vector2()),halfTexelSize:new Uniform(new Vector2()),kernel:new Uniform(0.0)},fragmentShader:fragment$4,vertexShader:vertex$4,depthWrite:false,depthTest:false}));_this.setTexelSize(texelSize.x,texelSize.y);/**
       * The current kernel size.
       *
       * @type {KernelSize}
       * @default KernelSize.LARGE
       */_this.kernelSize=KernelSize.LARGE;return _this;}/**
     * Returns the kernel.
     *
     * @return {Float32Array} The kernel.
     */createClass(ConvolutionMaterial,[{key:"getKernel",value:function getKernel(){return kernelPresets[this.kernelSize];}/**
       * Sets the texel size.
       *
       * @param {Number} x - The texel width.
       * @param {Number} y - The texel height.
       */},{key:"setTexelSize",value:function setTexelSize(x,y){this.uniforms.texelSize.value.set(x,y);this.uniforms.halfTexelSize.value.set(x,y).multiplyScalar(0.5);}}]);inherits(ConvolutionMaterial,_ShaderMaterial);return ConvolutionMaterial;}(ShaderMaterial);/**
   * The Kawase blur kernel presets.
   *
   * @type {Float32Array[]}
   * @private
   */var kernelPresets=[new Float32Array([0.0,0.0]),new Float32Array([0.0,1.0,1.0]),new Float32Array([0.0,1.0,1.0,2.0]),new Float32Array([0.0,1.0,2.0,2.0,3.0]),new Float32Array([0.0,1.0,2.0,3.0,4.0,4.0,5.0]),new Float32Array([0.0,1.0,2.0,3.0,4.0,5.0,7.0,8.0,9.0,10.0])];/**
   * A kernel size enumeration.
   *
   * @type {Object}
   * @property {Number} VERY_SMALL - A very small kernel that matches a 7x7 Gauss blur kernel.
   * @property {Number} SMALL - A small kernel that matches a 15x15 Gauss blur kernel.
   * @property {Number} MEDIUM - A medium sized kernel that matches a 23x23 Gauss blur kernel.
   * @property {Number} LARGE - A large kernel that matches a 35x35 Gauss blur kernel.
   * @property {Number} VERY_LARGE - A very large kernel that matches a 63x63 Gauss blur kernel.
   * @property {Number} HUGE - A huge kernel that matches a 127x127 Gauss blur kernel.
   */var KernelSize={VERY_SMALL:0,SMALL:1,MEDIUM:2,LARGE:3,VERY_LARGE:4,HUGE:5};var fragment$5="uniform sampler2D tDiffuse;\r\nuniform float opacity;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = opacity * texel;\r\n\r\n}\r\n";var vertex$5="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A simple copy shader material.
   */var CopyMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new copy material.
     */function CopyMaterial(){classCallCheck(this,CopyMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(CopyMaterial).call(this,{type:"CopyMaterial",uniforms:{tDiffuse:new Uniform(null),opacity:new Uniform(1.0)},fragmentShader:fragment$5,vertexShader:vertex$5,depthWrite:false,depthTest:false}));}inherits(CopyMaterial,_ShaderMaterial);return CopyMaterial;}(ShaderMaterial);var fragment$6="#include <packing>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nuniform sampler2D tDepth;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nvarying float vViewZ;\r\nvarying vec4 vProjTexCoord;\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\t// Transform into Cartesian coordinate (not mirrored).\r\n\tvec2 projTexCoord = (vProjTexCoord.xy / vProjTexCoord.w) * 0.5 + 0.5;\r\n\tprojTexCoord = clamp(projTexCoord, 0.002, 0.998);\r\n\r\n\tfloat fragCoordZ = unpackRGBAToDepth(texture2D(tDepth, projTexCoord));\r\n\r\n\t#ifdef PERSPECTIVE_CAMERA\r\n\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t#else\r\n\r\n\t\tfloat viewZ = orthographicDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t#endif\r\n\r\n\tfloat depthTest = (-vViewZ > -viewZ) ? 1.0 : 0.0;\r\n\r\n\tgl_FragColor.rgb = vec3(0.0, depthTest, 1.0);\r\n\r\n}\r\n";var vertex$6="#include <common>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvarying float vViewZ;\r\nvarying vec4 vProjTexCoord;\r\n\r\nvoid main() {\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tvViewZ = mvPosition.z;\r\n\tvProjTexCoord = gl_Position;\r\n\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n";/**
   * A depth comparison shader material.
   */var DepthComparisonMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new depth comparison material.
     *
     * @param {Texture} [depthTexture=null] - A depth texture.
     * @param {PerspectiveCamera} [camera] - A camera.
     */function DepthComparisonMaterial(){var _this;var depthTexture=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var camera=arguments.length>1?arguments[1]:undefined;classCallCheck(this,DepthComparisonMaterial);_this=possibleConstructorReturn(this,getPrototypeOf$2(DepthComparisonMaterial).call(this,{type:"DepthComparisonMaterial",uniforms:{tDepth:new Uniform(depthTexture),cameraNear:new Uniform(0.1),cameraFar:new Uniform(2000)},fragmentShader:fragment$6,vertexShader:vertex$6,depthWrite:false,depthTest:false,morphTargets:true,skinning:true}));_this.adoptCameraSettings(camera);return _this;}/**
     * Adopts the settings of the given camera.
     *
     * @param {Camera} [camera=null] - A camera.
     */createClass(DepthComparisonMaterial,[{key:"adoptCameraSettings",value:function adoptCameraSettings(){var camera=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(camera!==null){this.uniforms.cameraNear.value=camera.near;this.uniforms.cameraFar.value=camera.far;if(camera instanceof PerspectiveCamera){this.defines.PERSPECTIVE_CAMERA="1";}else{delete this.defines.PERSPECTIVE_CAMERA;}}}}]);inherits(DepthComparisonMaterial,_ShaderMaterial);return DepthComparisonMaterial;}(ShaderMaterial);var fragment$7="uniform sampler2D tDiffuse;\r\n\r\nuniform float angle;\r\nuniform float scale;\r\nuniform float intensity;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nfloat pattern() {\r\n\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\r\n\tvec2 point = vec2(c * vUvPattern.x - s * vUvPattern.y, s * vUvPattern.x + c * vUvPattern.y) * scale;\r\n\r\n\treturn (sin(point.x) * sin(point.y)) * 4.0;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef AVERAGE\r\n\r\n\t\tcolor = vec3((color.r + color.g + color.b) / 3.0);\r\n\r\n\t#endif\r\n\r\n\tcolor = vec3(color * 10.0 - 5.0 + pattern());\r\n\tcolor = texel.rgb + (color - texel.rgb) * intensity;\r\n\r\n\tgl_FragColor = vec4(color, texel.a);\r\n\r\n}\r\n";var vertex$7="uniform vec4 offsetRepeat;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvUvPattern = uv * offsetRepeat.zw + offsetRepeat.xy;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A dot screen shader material.
   */var DotScreenMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new dot screen material.
     *
     * @param {Boolean} [options] - The options.
     * @param {Boolean} [options.average=false] - Whether the shader should output the colour average (black and white).
     * @param {Boolean} [options.angle=1.57] - The angle of the dot pattern.
     * @param {Boolean} [options.scale=1.0] - The scale of the dot pattern.
     * @param {Boolean} [options.intensity=1.0] - The intensity of the effect.
     */function DotScreenMaterial(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,DotScreenMaterial);var settings=Object.assign({average:false,angle:1.57,scale:1.0,intensity:1.0},options);_this=possibleConstructorReturn(this,getPrototypeOf$2(DotScreenMaterial).call(this,{type:"DotScreenMaterial",uniforms:{tDiffuse:new Uniform(null),angle:new Uniform(settings.angle),scale:new Uniform(settings.scale),intensity:new Uniform(settings.intensity),offsetRepeat:new Uniform(new Vector4(0.5,0.5,1.0,1.0))},fragmentShader:fragment$7,vertexShader:vertex$7,depthWrite:false,depthTest:false}));_this.setAverageEnabled(settings.average);return _this;}/**
     * Enables or disables the Screen blend mode.
     *
     * @param {Boolean} enabled - Whether the Screen blend mode should be enabled.
     */createClass(DotScreenMaterial,[{key:"setAverageEnabled",value:function setAverageEnabled(enabled){if(enabled){this.defines.AVERAGE="1";}else{delete this.defines.AVERAGE;}this.needsUpdate=true;}}]);inherits(DotScreenMaterial,_ShaderMaterial);return DotScreenMaterial;}(ShaderMaterial);var fragment$8="uniform sampler2D tDiffuse;\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifdef NOISE\r\n\r\n\tuniform float noiseIntensity;\r\n\r\n#endif\r\n\r\n#ifdef SCANLINES\r\n\r\n\tuniform float scanlineIntensity;\r\n\tuniform float scanlineCount;\r\n\r\n#endif\r\n\r\n#ifdef GRID\r\n\r\n\tuniform float gridIntensity;\r\n\tuniform vec2 gridScale;\r\n\tuniform float gridLineWidth;\r\n\r\n#endif\r\n\r\n#ifdef GREYSCALE\r\n\r\n\t#include <common>\r\n\r\n\tuniform float greyscaleIntensity;\r\n\r\n#elif defined(SEPIA)\r\n\r\n\tuniform float sepiaIntensity;\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tuniform float vignetteOffset;\r\n\tuniform float vignetteDarkness;\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invColor;\r\n\r\n\t#endif\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tfloat x = vUv.x * vUv.y * time * 1000.0;\r\n\t\tx = mod(x, 13.0) * mod(x, 123.0);\r\n\t\tx = mod(x, 0.01);\r\n\r\n\t\tvec3 noise = texel.rgb * clamp(0.1 + x * 100.0, 0.0, 1.0) * noiseIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invNoise = vec3(1.0) - noise;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invNoise;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += noise;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef SCANLINES\r\n\r\n\t\tvec2 sl = vec2(sin(vUv.y * scanlineCount), cos(vUv.y * scanlineCount));\r\n\t\tvec3 scanlines = texel.rgb * vec3(sl.x, sl.y, sl.x) * scanlineIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invScanlines = vec3(1.0) - scanlines;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invScanlines;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += scanlines;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef GRID\r\n\r\n\t\tfloat grid = 0.5 - max(abs(mod(vUv.x * gridScale.x, 1.0) - 0.5), abs(mod(vUv.y * gridScale.y, 1.0) - 0.5));\r\n\t\tcolor *= (1.0 - gridIntensity) + vec3(smoothstep(0.0, gridLineWidth, grid)) * gridIntensity;\r\n\r\n\t#endif\r\n\r\n\t#ifdef GREYSCALE\r\n\r\n\t\tcolor = mix(color, vec3(linearToRelativeLuminance(color)), greyscaleIntensity);\r\n\r\n\t#elif defined(SEPIA)\r\n\r\n\t\tvec3 c = color.rgb;\r\n\r\n\t\tcolor.r = dot(c, vec3(1.0 - 0.607 * sepiaIntensity, 0.769 * sepiaIntensity, 0.189 * sepiaIntensity));\r\n\t\tcolor.g = dot(c, vec3(0.349 * sepiaIntensity, 1.0 - 0.314 * sepiaIntensity, 0.168 * sepiaIntensity));\r\n\t\tcolor.b = dot(c, vec3(0.272 * sepiaIntensity, 0.534 * sepiaIntensity, 1.0 - 0.869 * sepiaIntensity));\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tconst vec2 center = vec2(0.5);\r\n\r\n\t\t#ifdef ESKIL\r\n\r\n\t\t\tvec2 uv = (vUv - center) * vec2(vignetteOffset);\r\n\t\t\tcolor = mix(color.rgb, vec3(1.0 - vignetteDarkness), dot(uv, uv));\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat dist = distance(vUv, center);\r\n\t\t\tcolor *= smoothstep(0.8, vignetteOffset * 0.799, dist * (vignetteDarkness + vignetteOffset));\r\n\r\n\t\t#endif\t\t\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);\r\n\r\n}\r\n";var vertex$8="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A cinematic shader that provides the following effects:
   *  - Film Grain
   *  - Scanlines
   *  - Vignette
   *  - Greyscale
   *  - Sepia
   *
   * Original scanlines algorithm by Pat "Hawthorne" Shearon.
   *  http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
   *
   * Optimised scanlines and noise with intensity scaling by Georg "Leviathan"
   * Steinrohder. This version was provided under a Creative Commons Attribution
   * 3.0 License: http://creativecommons.org/licenses/by/3.0.
   *
   * The sepia effect is based on:
   *  https://github.com/evanw/glfx.js
   *
   * The vignette code is based on PaintEffect postprocess from ro.me:
   *  http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
   */var FilmMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new film material.
     *
     * @param {Object} [options] - The options. Disabled effects will not be included in the final shader and have no negative impact on performance.
     * @param {Boolean} [options.greyscale=false] - Enable greyscale effect. Greyscale and sepia are mutually exclusive.
     * @param {Boolean} [options.sepia=false] - Enable sepia effect. Greyscale and sepia are mutually exclusive.
     * @param {Boolean} [options.vignette=false] - Apply vignette effect.
     * @param {Boolean} [options.eskil=false] - Use Eskil's vignette approach. The default looks dusty while Eskil looks burned out.
     * @param {Boolean} [options.screenMode=true] - Whether the screen blend mode should be used for noise and scanlines. Both of these effects are computed independently.
     * @param {Boolean} [options.noise=true] - Show noise-based film grain.
     * @param {Boolean} [options.scanlines=true] - Show scanlines.
     * @param {Boolean} [options.grid=true] - Show a grid.
     * @param {Number} [options.noiseIntensity=0.5] - The noise intensity.
     * @param {Number} [options.scanlineIntensity=0.05] - The scanline intensity.
     * @param {Number} [options.gridIntensity=1.0] - The grid strength. 0.0 to 1.0.
     * @param {Number} [options.greyscaleIntensity=1.0] - The intensity of the greyscale effect. 0.0 to 1.0.
     * @param {Number} [options.sepiaIntensity=1.0] - The intensity of the sepia effect. 0.0 to 1.0.
     * @param {Number} [options.vignetteOffset=1.0] - The offset of the vignette effect. 0.0 to 1.0.
     * @param {Number} [options.vignetteDarkness=1.0] - The darkness of the vignette effect. 0.0 to 1.0.
     */function FilmMaterial(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,FilmMaterial);var settings=Object.assign({screenMode:true,noise:true,scanlines:true,grid:false,greyscale:false,sepia:false,vignette:false,eskil:false,noiseIntensity:0.5,scanlineIntensity:0.05,gridIntensity:1.0,greyscaleIntensity:1.0,sepiaIntensity:1.0,vignetteOffset:1.0,vignetteDarkness:1.0},options);_this=possibleConstructorReturn(this,getPrototypeOf$2(FilmMaterial).call(this,{type:"FilmMaterial",uniforms:{tDiffuse:new Uniform(null),time:new Uniform(0.0),noiseIntensity:new Uniform(settings.noiseIntensity),scanlineIntensity:new Uniform(settings.scanlineIntensity),gridIntensity:new Uniform(settings.gridIntensity),scanlineCount:new Uniform(0.0),gridScale:new Uniform(new Vector2()),gridLineWidth:new Uniform(0.0),greyscaleIntensity:new Uniform(settings.greyscaleIntensity),sepiaIntensity:new Uniform(settings.sepiaIntensity),vignetteOffset:new Uniform(settings.vignetteOffset),vignetteDarkness:new Uniform(settings.vignetteDarkness)},fragmentShader:fragment$8,vertexShader:vertex$8,depthWrite:false,depthTest:false}));_this.setScreenModeEnabled(settings.screenMode);_this.setNoiseEnabled(settings.noise);_this.setScanlinesEnabled(settings.scanlines);_this.setGridEnabled(settings.grid);_this.setGreyscaleEnabled(settings.greyscale);_this.setSepiaEnabled(settings.sepia);_this.setVignetteEnabled(settings.vignette);_this.setEskilEnabled(settings.eskil);return _this;}/**
     * Enables or disables the Screen blend mode.
     *
     * @param {Boolean} enabled - Whether the Screen blend mode should be enabled.
     */createClass(FilmMaterial,[{key:"setScreenModeEnabled",value:function setScreenModeEnabled(enabled){if(enabled){this.defines.SCREEN_MODE="1";}else{delete this.defines.SCREEN_MODE;}this.needsUpdate=true;}/**
       * Enables or disables the noise effect.
       *
       * @param {Boolean} enabled - Whether the noise effect should be enabled.
       */},{key:"setNoiseEnabled",value:function setNoiseEnabled(enabled){if(enabled){this.defines.NOISE="1";}else{delete this.defines.NOISE;}this.needsUpdate=true;}/**
       * Enables or disables the scanlines effect.
       *
       * @param {Boolean} enabled - Whether the scanlines effect should be enabled.
       */},{key:"setScanlinesEnabled",value:function setScanlinesEnabled(enabled){if(enabled){this.defines.SCANLINES="1";}else{delete this.defines.SCANLINES;}this.needsUpdate=true;}/**
       * Enables or disables the grid effect.
       *
       * @param {Boolean} enabled - Whether the grid effect should be enabled.
       */},{key:"setGridEnabled",value:function setGridEnabled(enabled){if(enabled){this.defines.GRID="1";}else{delete this.defines.GRID;}this.needsUpdate=true;}/**
       * Enables or disables the greyscale effect.
       *
       * @param {Boolean} enabled - Whether the greyscale effect should be enabled.
       */},{key:"setGreyscaleEnabled",value:function setGreyscaleEnabled(enabled){if(enabled){this.defines.GREYSCALE="1";}else{delete this.defines.GREYSCALE;}this.needsUpdate=true;}/**
       * Enables or disables the sepia effect.
       *
       * @param {Boolean} enabled - Whether the sepia effect should be enabled.
       */},{key:"setSepiaEnabled",value:function setSepiaEnabled(enabled){if(enabled){this.defines.SEPIA="1";}else{delete this.defines.SEPIA;}this.needsUpdate=true;}/**
       * Enables or disables the Vignette effect.
       *
       * @param {Boolean} enabled - Whether the Vignette effect should be enabled.
       */},{key:"setVignetteEnabled",value:function setVignetteEnabled(enabled){if(enabled){this.defines.VIGNETTE="1";}else{delete this.defines.VIGNETTE;}this.needsUpdate=true;}/**
       * Enables or disables the Eskil Vignette effect.
       *
       * Has no effect if Vignette is disabled.
       *
       * @param {Boolean} enabled - Whether the Eskil Vignette effect should be enabled.
       */},{key:"setEskilEnabled",value:function setEskilEnabled(enabled){if(enabled){this.defines.ESKIL="1";}else{delete this.defines.ESKIL;}this.needsUpdate=true;}}]);inherits(FilmMaterial,_ShaderMaterial);return FilmMaterial;}(ShaderMaterial);var fragment$9="uniform sampler2D tDiffuse;\r\nuniform sampler2D tPerturb;\r\n\r\nuniform bool active;\r\n\r\nuniform float amount;\r\nuniform float angle;\r\nuniform float seed;\r\nuniform float seedX;\r\nuniform float seedY;\r\nuniform float distortionX;\r\nuniform float distortionY;\r\nuniform float colS;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat rand(vec2 tc) {\r\n\r\n\tconst float a = 12.9898;\r\n\tconst float b = 78.233;\r\n\tconst float c = 43758.5453;\r\n\r\n\tfloat dt = dot(tc, vec2(a, b));\r\n\tfloat sn = mod(dt, 3.14);\r\n\r\n\treturn fract(sin(sn) * c);\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec2 coord = vUv;\r\n\r\n\tfloat xs, ys;\r\n\tvec4 normal;\r\n\r\n\tvec2 offset;\r\n\tvec4 cr, cga, cb;\r\n\tvec4 snow, color;\r\n\r\n\tfloat sx, sy;\r\n\r\n\tif(active) {\r\n\r\n\t\txs = floor(gl_FragCoord.x / 0.5);\r\n\t\tys = floor(gl_FragCoord.y / 0.5);\r\n\r\n\t\tnormal = texture2D(tPerturb, coord * seed * seed);\r\n\r\n\t\tif(coord.y < distortionX + colS && coord.y > distortionX - colS * seed) {\r\n\r\n\t\t\tsx = clamp(ceil(seedX), 0.0, 1.0);\r\n\t\t\tcoord.y = sx * (1.0 - (coord.y + distortionY)) + (1.0 - sx) * distortionY;\r\n\r\n\t\t}\r\n\r\n\t\tif(coord.x < distortionY + colS && coord.x > distortionY - colS * seed) {\r\n\r\n\t\t\tsy = clamp(ceil(seedY), 0.0, 1.0);\r\n\t\t\tcoord.x = sy * distortionX + (1.0 - sy) * (1.0 - (coord.x + distortionX));\r\n\r\n\t\t}\r\n\r\n\t\tcoord.x += normal.x * seedX * (seed / 5.0);\r\n\t\tcoord.y += normal.y * seedY * (seed / 5.0);\r\n\r\n\t\toffset = amount * vec2(cos(angle), sin(angle));\r\n\r\n\t\tcr = texture2D(tDiffuse, coord + offset);\r\n\t\tcga = texture2D(tDiffuse, coord);\r\n\t\tcb = texture2D(tDiffuse, coord - offset);\r\n\r\n\t\tcolor = vec4(cr.r, cga.g, cb.b, cga.a);\r\n\t\tsnow = 200.0 * amount * vec4(rand(vec2(xs * seed, ys * seed * 50.0)) * 0.2);\r\n\t\tcolor += snow;\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";var vertex$9="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A glitch shader material.
   *
   * Reference:
   *  https://github.com/staffantan/unityglitch
   */var GlitchMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new glitch material.
     */function GlitchMaterial(){classCallCheck(this,GlitchMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(GlitchMaterial).call(this,{type:"GlitchMaterial",uniforms:{tDiffuse:new Uniform(null),tPerturb:new Uniform(null),active:new Uniform(1),amount:new Uniform(0.8),angle:new Uniform(0.02),seed:new Uniform(0.02),seedX:new Uniform(0.02),seedY:new Uniform(0.02),distortionX:new Uniform(0.5),distortionY:new Uniform(0.6),colS:new Uniform(0.05)},fragmentShader:fragment$9,vertexShader:vertex$9,depthWrite:false,depthTest:false}));}inherits(GlitchMaterial,_ShaderMaterial);return GlitchMaterial;}(ShaderMaterial);var fragment$10="#include <common>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform vec3 lightPosition;\r\n\r\nuniform float exposure;\r\nuniform float decay;\r\nuniform float density;\r\nuniform float weight;\r\nuniform float clampMax;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec2 texCoord = vUv;\r\n\r\n\t// Calculate vector from pixel to light source in screen space.\r\n\tvec2 deltaTexCoord = texCoord - lightPosition.st;\r\n\tdeltaTexCoord *= 1.0 / NUM_SAMPLES_FLOAT * density;\r\n\r\n\t// A decreasing illumination factor.\r\n\tfloat illuminationDecay = 1.0;\r\n\r\n\tvec4 sample;\r\n\tvec4 color = vec4(0.0);\r\n\r\n\t// Estimate the probability of occlusion at each pixel by summing samples along a ray to the light source.\r\n\tfor(int i = 0; i < NUM_SAMPLES_INT; ++i) {\r\n\r\n\t\ttexCoord -= deltaTexCoord;\r\n\t\tsample = texture2D(tDiffuse, texCoord);\r\n\r\n\t\t// Apply sample attenuation scale/decay factors.\r\n\t\tsample *= illuminationDecay * weight;\r\n\r\n\t\tcolor += sample;\r\n\r\n\t\t// Update exponential decay factor.\r\n\t\tilluminationDecay *= decay;\r\n\r\n\t}\r\n\r\n\tgl_FragColor = clamp(color * exposure, 0.0, clampMax);\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";var vertex$10="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A crepuscular rays shader material.
   *
   * This material supports dithering.
   *
   * References:
   *
   * Thibaut Despoulain, 2012:
   *  [(WebGL) Volumetric Light Approximation in Three.js](
   *  http://bkcore.com/blog/3d/webgl-three-js-volumetric-light-godrays.html)
   *
   * Nvidia, GPU Gems 3, 2008:
   *  [Chapter 13. Volumetric Light Scattering as a Post-Process](
   *  https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch13.html)
   */var GodRaysMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new god rays material.
     *
     * @param {Object} [options] - The options.
     * @param {Number} [options.density=0.96] - The density of the light rays.
     * @param {Number} [options.decay=0.93] - An illumination decay factor.
     * @param {Number} [options.weight=0.4] - A light ray weight factor.
     * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
     * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
     */function GodRaysMaterial(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,GodRaysMaterial);var settings=Object.assign({exposure:0.6,density:0.93,decay:0.96,weight:0.4,clampMax:1.0},options);return possibleConstructorReturn(this,getPrototypeOf$2(GodRaysMaterial).call(this,{type:"GodRaysMaterial",defines:{NUM_SAMPLES_FLOAT:"60.0",NUM_SAMPLES_INT:"60"},uniforms:{tDiffuse:new Uniform(null),lightPosition:new Uniform(null),exposure:new Uniform(settings.exposure),decay:new Uniform(settings.decay),density:new Uniform(settings.density),weight:new Uniform(settings.weight),clampMax:new Uniform(settings.clampMax)},fragmentShader:fragment$10,vertexShader:vertex$10,depthWrite:false,depthTest:false}));}inherits(GodRaysMaterial,_ShaderMaterial);return GodRaysMaterial;}(ShaderMaterial);var fragment$11="#include <common>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform float distinction;\r\nuniform vec2 range;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tfloat l = linearToRelativeLuminance(texel.rgb);\r\n\r\n\t#ifdef RANGE\r\n\r\n\t\tfloat low = step(range.x, l);\r\n\t\tfloat high = step(l, range.y);\r\n\r\n\t\t// Apply the mask.\r\n\t\tl *= low * high;\r\n\r\n\t#endif\r\n\r\n\tl = pow(abs(l), distinction);\r\n\r\n\t#ifdef COLOR\r\n\r\n\t\tgl_FragColor = vec4(texel.rgb * l, texel.a);\r\n\r\n\t#else\r\n\r\n\t\tgl_FragColor = vec4(l, l, l, texel.a);\r\n\r\n\t#endif\r\n\r\n}\r\n";var vertex$11="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A luminosity shader material.
   *
   * This shader produces a greyscale luminance map that describes the absolute
   * amount of light emitted by a scene. It can also be configured to output
   * colours that are scaled with their respective luminance value. Additionally,
   * a range may be provided to mask out undesired texels.
   *
   * The alpha channel will remain unaffected in all cases.
   *
   * On luminance coefficients:
   *  http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9
   *
   * Coefficients for different colour spaces:
   *  https://hsto.org/getpro/habr/post_images/2ab/69d/084/2ab69d084f9a597e032624bcd74d57a7.png
   *
   * Luminance range reference:
   *  https://cycling74.com/2007/05/23/your-first-shader/#.Vty9FfkrL4Z
   */var LuminosityMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new luminosity material.
     *
     * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colours scaled with their luminance value.
     * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
     */function LuminosityMaterial(){var _this;var colorOutput=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var luminanceRange=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;classCallCheck(this,LuminosityMaterial);var maskLuminance=luminanceRange!==null;_this=possibleConstructorReturn(this,getPrototypeOf$2(LuminosityMaterial).call(this,{type:"LuminosityMaterial",uniforms:{tDiffuse:new Uniform(null),distinction:new Uniform(1.0),range:new Uniform(maskLuminance?luminanceRange:new Vector2())},fragmentShader:fragment$11,vertexShader:vertex$11}));_this.setColorOutputEnabled(colorOutput);_this.setLuminanceRangeEnabled(maskLuminance);return _this;}/**
     * Enables or disables color output.
     *
     * @param {Boolean} enabled - Whether color output should be enabled.
     */createClass(LuminosityMaterial,[{key:"setColorOutputEnabled",value:function setColorOutputEnabled(enabled){if(enabled){this.defines.COLOR="1";}else{delete this.defines.COLOR;}this.needsUpdate=true;}/**
       * Enables or disables the luminance mask.
       *
       * @param {Boolean} enabled - Whether the luminance mask should be enabled.
       */},{key:"setLuminanceRangeEnabled",value:function setLuminanceRangeEnabled(enabled){if(enabled){this.defines.RANGE="1";}else{delete this.defines.RANGE;}this.needsUpdate=true;}}]);inherits(LuminosityMaterial,_ShaderMaterial);return LuminosityMaterial;}(ShaderMaterial);var fragment$12="uniform sampler2D tDiffuse;\r\nuniform sampler2D tMask;\r\nuniform sampler2D tEdges;\r\n\r\nuniform vec3 visibleEdgeColor;\r\nuniform vec3 hiddenEdgeColor;\r\nuniform float pulse;\r\nuniform float edgeStrength;\r\n\r\n#ifdef USE_PATTERN\r\n\r\n\tuniform sampler2D tPattern;\r\n\tvarying vec2 vPatternCoord;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 color = texture2D(tDiffuse, vUv);\r\n\tvec2 edge = texture2D(tEdges, vUv).rg;\r\n\tvec2 mask = texture2D(tMask, vUv).rg;\r\n\r\n\t#ifndef X_RAY\r\n\r\n\t\tedge.y = 0.0;\r\n\r\n\t#endif\r\n\r\n\tedge *= (edgeStrength * mask.x * pulse);\r\n\tvec3 outlineColor = edge.x * visibleEdgeColor + edge.y * hiddenEdgeColor;\r\n\r\n\t#ifdef ALPHA_BLENDING\r\n\r\n\t\tcolor.rgb = mix(color.rgb, outlineColor, max(edge.x, edge.y));\r\n\r\n\t#else\r\n\r\n\t\tcolor.rgb += outlineColor;\r\n\r\n\t#endif\r\n\r\n\t#ifdef USE_PATTERN\r\n\r\n\t\tvec3 patternColor = texture2D(tPattern, vPatternCoord).rgb;\r\n\r\n\t\t#ifdef X_RAY\r\n\r\n\t\t\tfloat hiddenFactor = 0.5;\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat hiddenFactor = 0.0;\r\n\r\n\t\t#endif\r\n\r\n\t\tfloat visibilityFactor = (1.0 - mask.y > 0.0) ? 1.0 : hiddenFactor;\r\n\r\n\t\tcolor.rgb += visibilityFactor * (1.0 - mask.x) * (1.0 - patternColor);\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";var vertex$12="#ifdef USE_PATTERN\r\n\r\n\tuniform float aspect;\r\n\tuniform float patternScale;\r\n\tvarying vec2 vPatternCoord;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_PATTERN\r\n\r\n\t\tvec2 aspectCorrection = vec2(aspect, 1.0);\r\n\t\tvPatternCoord = uv * aspectCorrection * patternScale;\r\n\r\n\t#endif\r\n\r\n\tvUv = uv;\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * An outline blend shader material.
   */var OutlineBlendMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new outline blend material.
     *
     * @param {Object} [options] - The options.
     * @param {Number} [options.edgeStrength=1.0] - The edge strength.
     * @param {Number} [options.patternScale=1.0] - The scale of the pattern texture.
     * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.
     * @param {Number} [options.hiddenEdgeColor=0x22090A] - The color of hidden edges.
     * @param {Boolean} [alphaBlending=false] - Whether the outline should be blended using alpha.
     * @param {Boolean} [xRay=true] - Whether hidden parts of selected objects should be visible.
     */function OutlineBlendMaterial(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,OutlineBlendMaterial);var settings=Object.assign({edgeStrength:1.0,patternScale:1.0,visibleEdgeColor:0xffffff,hiddenEdgeColor:0x22090A,alphaBlending:false,xRay:true},options);_this=possibleConstructorReturn(this,getPrototypeOf$2(OutlineBlendMaterial).call(this,{type:"OutlineBlendMaterial",uniforms:{pulse:new Uniform(1.0),aspect:new Uniform(1.0),tDiffuse:new Uniform(null),tMask:new Uniform(null),tEdges:new Uniform(null),tPattern:new Uniform(null),edgeStrength:new Uniform(settings.edgeStrength),patternScale:new Uniform(settings.patternScale),visibleEdgeColor:new Uniform(new Color(settings.visibleEdgeColor)),hiddenEdgeColor:new Uniform(new Color(settings.hiddenEdgeColor))},fragmentShader:fragment$12,vertexShader:vertex$12,depthWrite:false,depthTest:false}));_this.setAlphaBlendingEnabled(settings.alphaBlending);_this.setXRayEnabled(settings.xRay);return _this;}/**
     * Enables or disables the alpha blending.
     *
     * @param {Boolean} enabled - Whether the alpha blending should be enabled.
     */createClass(OutlineBlendMaterial,[{key:"setAlphaBlendingEnabled",value:function setAlphaBlendingEnabled(enabled){if(enabled){this.defines.ALPHA_BLENDING="1";}else{delete this.defines.ALPHA_BLENDING;}this.needsUpdate=true;}/**
       * Defines whether hidden parts of selected objects should be visible.
       *
       * @param {Boolean} enabled - Whether hidden parts of selected objects should be visible.
       */},{key:"setXRayEnabled",value:function setXRayEnabled(enabled){if(enabled){this.defines.X_RAY="1";}else{delete this.defines.X_RAY;}this.needsUpdate=true;}/**
       * Sets a pattern texture to use as overlay.
       *
       * @param {Texture} [texture=null] - A pattern texture. Set to null to disable the pattern.
       */},{key:"setPatternTexture",value:function setPatternTexture(){var texture=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;if(texture!==null){this.defines.USE_PATTERN="1";}else{delete this.defines.USE_PATTERN;}this.uniforms.tPattern.value=texture;this.needsUpdate=true;}}]);inherits(OutlineBlendMaterial,_ShaderMaterial);return OutlineBlendMaterial;}(ShaderMaterial);var fragment$13="uniform sampler2D tMask;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 c0 = texture2D(tMask, vUv0).rg;\r\n\tvec2 c1 = texture2D(tMask, vUv1).rg;\r\n\tvec2 c2 = texture2D(tMask, vUv2).rg;\r\n\tvec2 c3 = texture2D(tMask, vUv3).rg;\r\n\r\n\tfloat d0 = (c0.x - c1.x) * 0.5;\r\n\tfloat d1 = (c2.x - c3.x) * 0.5;\r\n\tfloat d = length(vec2(d0, d1));\r\n\r\n\tfloat a0 = min(c0.y, c1.y);\r\n\tfloat a1 = min(c2.y, c3.y);\r\n\tfloat visibilityFactor = min(a0, a1);\r\n\r\n\tgl_FragColor.rg = (1.0 - visibilityFactor > 0.001) ? vec2(d, 0.0) : vec2(0.0, d);\r\n\r\n}\r\n";var vertex$13="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvUv0 = vec2(uv.x + texelSize.x, uv.y);\r\n\tvUv1 = vec2(uv.x - texelSize.x, uv.y);\r\n\tvUv2 = vec2(uv.x, uv.y + texelSize.y);\r\n\tvUv3 = vec2(uv.x, uv.y - texelSize.y);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * An outline edge detection shader material.
   */var OutlineEdgesMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new outline edge detection material.
     *
     * @param {Vector2} [texelSize] - The absolute screen texel size.
     */function OutlineEdgesMaterial(){var _this;var texelSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();classCallCheck(this,OutlineEdgesMaterial);_this=possibleConstructorReturn(this,getPrototypeOf$2(OutlineEdgesMaterial).call(this,{type:"OutlineEdgesMaterial",uniforms:{tMask:new Uniform(null),texelSize:new Uniform(new Vector2())},fragmentShader:fragment$13,vertexShader:vertex$13,depthWrite:false,depthTest:false}));_this.setTexelSize(texelSize.x,texelSize.y);return _this;}/**
     * Sets the texel size.
     *
     * @param {Number} x - The texel width.
     * @param {Number} y - The texel height.
     */createClass(OutlineEdgesMaterial,[{key:"setTexelSize",value:function setTexelSize(x,y){this.uniforms.texelSize.value.set(x,y);}}]);inherits(OutlineEdgesMaterial,_ShaderMaterial);return OutlineEdgesMaterial;}(ShaderMaterial);var fragment$14="uniform sampler2D tDiffuse;\r\nuniform float granularity;\r\nuniform float dx;\r\nuniform float dy;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel;\r\n\r\n\tif(granularity > 0.0) {\r\n\r\n\t\tvec2 coord = vec2(\r\n\t\t\tdx * (floor(vUv.x / dx) + 0.5),\r\n\t\t\tdy * (floor(vUv.y / dy) + 0.5)\r\n\t\t);\r\n\r\n\t\ttexel = texture2D(tDiffuse, coord);\r\n\r\n\t} else {\r\n\r\n\t\ttexel = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texel;\r\n\r\n}\r\n";var vertex$14="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A pixelation shader material.
   *
   * Original shader code by Robert Casanova:
   *  https://github.com/robertcasanova/pixelate-shader
   */var PixelationMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new pixelation material.
     */function PixelationMaterial(){classCallCheck(this,PixelationMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(PixelationMaterial).call(this,{type:"PixelationMaterial",uniforms:{tDiffuse:new Uniform(null),granularity:new Uniform(1.0),resolution:new Uniform(new Vector2(1.0,1.0)),dx:new Uniform(1.0),dy:new Uniform(1.0)},fragmentShader:fragment$14,vertexShader:vertex$14,depthWrite:false,depthTest:false}));}/**
     * The pixel granularity.
     *
     * @type {Number}
     */createClass(PixelationMaterial,[{key:"setResolution",/**
       * Sets the resolution.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */value:function setResolution(width,height){this.uniforms.resolution.value.set(width,height);this.granularity=this.granularity;}},{key:"granularity",get:function get(){return this.uniforms.granularity.value;}/**
       * A higher value yields coarser visuals.
       *
       * @type {Number}
       */,set:function set(x){var uniforms=this.uniforms;var resolution=uniforms.resolution.value;uniforms.granularity.value=x;uniforms.dx.value=x/resolution.x;uniforms.dy.value=x/resolution.y;}}]);inherits(PixelationMaterial,_ShaderMaterial);return PixelationMaterial;}(ShaderMaterial);var fragment$15="#include <common>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nuniform float focalLength;\r\nuniform float focalStop;\r\n\r\nuniform float maxBlur;\r\nuniform float luminanceThreshold;\r\nuniform float luminanceGain;\r\nuniform float bias;\r\nuniform float fringe;\r\nuniform float ditherStrength;\r\n\r\n#ifdef SHADER_FOCUS\r\n\r\n\tuniform vec2 focusCoords;\r\n\r\n#else\r\n\r\n\tuniform float focalDepth;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef PENTAGON\r\n\r\n\tfloat penta(vec2 coords) {\r\n\r\n\t\tconst vec4 HS0 = vec4( 1.0,          0.0,         0.0, 1.0);\r\n\t\tconst vec4 HS1 = vec4( 0.309016994,  0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS2 = vec4(-0.809016994,  0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS3 = vec4(-0.809016994, -0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS4 = vec4( 0.309016994, -0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS5 = vec4( 0.0,          0.0,         1.0, 1.0);\r\n\r\n\t\tconst vec4 ONE = vec4(1.0);\r\n\r\n\t\tconst float P_FEATHER = 0.4;\r\n\t\tconst float N_FEATHER = -P_FEATHER;\r\n\r\n\t\tfloat inOrOut = -4.0;\r\n\r\n\t\tvec4 P = vec4(coords, vec2(RINGS_FLOAT - 1.3));\r\n\r\n\t\tvec4 dist = vec4(\r\n\t\t\tdot(P, HS0),\r\n\t\t\tdot(P, HS1),\r\n\t\t\tdot(P, HS2),\r\n\t\t\tdot(P, HS3)\r\n\t\t);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\r\n\t\tinOrOut += dot(dist, ONE);\r\n\r\n\t\tdist.x = dot(P, HS4);\r\n\t\tdist.y = HS5.w - abs(P.z);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\t\tinOrOut += dist.x;\r\n\r\n\t\treturn clamp(inOrOut, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef SHOW_FOCUS\r\n\r\n\tvec3 debugFocus(vec3 c, float blur, float depth) {\r\n\r\n\t\tfloat edge = 0.002 * depth;\r\n\t\tfloat m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\r\n\t\tfloat e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\r\n\r\n\t\tc = mix(c, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\r\n\t\tc = mix(c, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\r\n\r\n\t\treturn c;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tfloat vignette() {\r\n\r\n\t\tconst vec2 CENTER = vec2(0.5);\r\n\r\n\t\tconst float VIGNETTE_OUT = 1.3;\r\n\t\tconst float VIGNETTE_IN = 0.0;\r\n\t\tconst float VIGNETTE_FADE = 22.0; \r\n\r\n\t\tfloat d = distance(vUv, CENTER);\r\n\t\td = smoothstep(VIGNETTE_OUT + (focalStop / VIGNETTE_FADE), VIGNETTE_IN + (focalStop / VIGNETTE_FADE), d);\r\n\r\n\t\treturn clamp(d, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvec2 rand2(vec2 coord) {\r\n\r\n\tvec2 noise;\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tconst float a = 12.9898;\r\n\t\tconst float b = 78.233;\r\n\t\tconst float c = 43758.5453;\r\n\r\n\t\tnoise.x = clamp(fract(sin(mod(dot(coord, vec2(a, b)), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\t\tnoise.y = clamp(fract(sin(mod(dot(coord, vec2(a, b) * 2.0), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\r\n\t#else\r\n\r\n\t\tnoise.x = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.25) + (fract(coord.t * halfTexelSize.y) * 0.75)) * 2.0 - 1.0;\r\n\t\tnoise.y = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.75) + (fract(coord.t * halfTexelSize.y) * 0.25)) * 2.0 - 1.0;\r\n\r\n\t#endif\r\n\r\n\treturn noise;\r\n\r\n}\r\n\r\nvec3 processTexel(vec2 coords, float blur) {\r\n\r\n\tvec3 c;\r\n\tc.r = texture2D(tDiffuse, coords + vec2(0.0, 1.0) * texelSize * fringe * blur).r;\r\n\tc.g = texture2D(tDiffuse, coords + vec2(-0.866, -0.5) * texelSize * fringe * blur).g;\r\n\tc.b = texture2D(tDiffuse, coords + vec2(0.866, -0.5) * texelSize * fringe * blur).b;\r\n\r\n\t// Calculate the luminance of the constructed colour.\r\n\tfloat luminance = linearToRelativeLuminance(c);\r\n\tfloat threshold = max((luminance - luminanceThreshold) * luminanceGain, 0.0);\r\n\r\n\treturn c + mix(vec3(0.0), c, threshold * blur);\r\n\r\n}\r\n\r\nfloat linearize(float depth) {\r\n\r\n\treturn -cameraFar * cameraNear / (depth * (cameraFar - cameraNear) - cameraFar);\r\n\r\n}\r\n\r\nfloat gather(float i, float j, float ringSamples, inout vec3 color, float w, float h, float blur) {\r\n\r\n\tconst float TWO_PI = 6.28318531;\r\n\r\n\tfloat step = TWO_PI / ringSamples;\r\n\tfloat pw = cos(j * step) * i;\r\n\tfloat ph = sin(j * step) * i;\r\n\r\n\t#ifdef PENTAGON\r\n\r\n\t\tfloat p = penta(vec2(pw, ph));\r\n\r\n\t#else\r\n\r\n\t\tfloat p = 1.0;\r\n\r\n\t#endif\r\n\r\n\tcolor += processTexel(vUv + vec2(pw * w, ph * h), blur) * mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n\treturn mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = linearize(texture2D(tDepth, vUv).x);\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = linearize(readDepth(tDepth, vUv));\r\n\r\n\t#endif\r\n\r\n\t#ifdef SHADER_FOCUS\r\n\r\n\t\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\t\tfloat fDepth = linearize(texture2D(tDepth, focusCoords).x);\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat fDepth = linearize(readDepth(tDepth, focusCoords));\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tfloat fDepth = focalDepth;\r\n\r\n\t#endif\r\n\r\n\t#ifdef MANUAL_DOF\r\n\r\n\t\tconst float nDoFStart = 1.0; \r\n\t\tconst float nDoFDist = 2.0;\r\n\t\tconst float fDoFStart = 1.0;\r\n\t\tconst float fDoFDist = 3.0;\r\n\r\n\t\tfloat focalPlane = depth - fDepth;\r\n\t\tfloat farDoF = (focalPlane - fDoFStart) / fDoFDist;\r\n\t\tfloat nearDoF = (-focalPlane - nDoFStart) / nDoFDist;\r\n\r\n\t\tfloat blur = (focalPlane > 0.0) ? farDoF : nearDoF;\r\n\r\n\t#else\r\n\r\n\t\tconst float CIRCLE_OF_CONFUSION = 0.03; // 35mm film = 0.03mm CoC.\r\n\r\n\t\tfloat focalPlaneMM = fDepth * 1000.0;\r\n\t\tfloat depthMM = depth * 1000.0;\r\n\r\n\t\tfloat focalPlane = (depthMM * focalLength) / (depthMM - focalLength);\r\n\t\tfloat farDoF = (focalPlaneMM * focalLength) / (focalPlaneMM - focalLength);\r\n\t\tfloat nearDoF = (focalPlaneMM - focalLength) / (focalPlaneMM * focalStop * CIRCLE_OF_CONFUSION);\r\n\r\n\t\tfloat blur = abs(focalPlane - farDoF) * nearDoF;\r\n\r\n\t#endif\r\n\r\n\tblur = clamp(blur, 0.0, 1.0);\r\n\r\n\t// Dithering.\r\n\tvec2 noise = rand2(vUv) * ditherStrength * blur;\r\n\r\n\tfloat blurFactorX = texelSize.x * blur * maxBlur + noise.x;\r\n\tfloat blurFactorY = texelSize.y * blur * maxBlur + noise.y;\r\n\r\n\tconst int MAX_RING_SAMPLES = RINGS_INT * SAMPLES_INT;\r\n\r\n\t// Calculation of final color.\r\n\tvec4 color;\r\n\r\n\tif(blur < 0.05) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t\tfloat s = 1.0;\r\n\t\tint ringSamples;\r\n\r\n\t\tfor(int i = 1; i <= RINGS_INT; ++i) {\r\n\r\n\t\t\tringSamples = i * SAMPLES_INT;\r\n\r\n\t\t\t// Constant loop.\r\n\t\t\tfor(int j = 0; j < MAX_RING_SAMPLES; ++j) {\r\n\r\n\t\t\t\t// Break earlier.\r\n\t\t\t\tif(j >= ringSamples) { break; }\r\n\r\n\t\t\t\ts += gather(float(i), float(j), float(ringSamples), color.rgb, blurFactorX, blurFactorY, blur);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcolor.rgb /= s; // Divide by sample count.\r\n\r\n\t}\r\n\r\n\t#ifdef SHOW_FOCUS\r\n\r\n\t\tcolor.rgb = debugFocus(color.rgb, blur, depth);\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tcolor.rgb *= vignette();\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";var vertex$15="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * Depth of Field shader v2.4.
   *
   * Original shader code by Martins Upitis:
   *  http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
   */var RealisticBokehMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new bokeh2 material.
     *
     * @param {PerspectiveCamera} [camera] - The main camera.
     * @param {Object} [options] - Additional options.
     * @param {Vector2} [options.texelSize] - The absolute screen texel size.
     * @param {Boolean} [options.rings=3] - The number of blurring iterations.
     * @param {Boolean} [options.samples=2] - The amount of samples taken per ring.
     * @param {Boolean} [options.showFocus=false] - Whether the focus point should be highlighted.
     * @param {Boolean} [options.manualDoF=false] - Enables manual depth of field blur.
     * @param {Boolean} [options.vignette=false] - Enables a vignette effect.
     * @param {Boolean} [options.pentagon=false] - Enable to use a pentagonal shape to scale gathered texels.
     * @param {Boolean} [options.shaderFocus=true] - Disable if you compute your own focalDepth (in metres!).
     * @param {Boolean} [options.noise=true] - Disable if you don't want noise patterns for dithering.
     * @param {Number} [options.maxBlur=1.0] - The maximum blur strength.
     * @param {Number} [options.luminanceThreshold=0.5] - A luminance threshold.
     * @param {Number} [options.luminanceGain=2.0] - A luminance gain factor.
     * @param {Number} [options.bias=0.5] - A blur bias.
     * @param {Number} [options.fringe=0.7] - A blur offset.
     * @param {Number} [options.ditherStrength=0.0001] - The dither strength.
     */function RealisticBokehMaterial(){var _this;var camera=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,RealisticBokehMaterial);var settings=Object.assign({texelSize:null,rings:3,samples:2,showFocus:false,manualDoF:false,vignette:false,pentagon:false,shaderFocus:true,noise:true,maxBlur:1.0,luminanceThreshold:0.5,luminanceGain:2.0,bias:0.5,fringe:0.7,ditherStrength:0.0001},options);_this=possibleConstructorReturn(this,getPrototypeOf$2(RealisticBokehMaterial).call(this,{type:"RealisticBokehMaterial",defines:{RINGS_INT:settings.rings.toFixed(0),RINGS_FLOAT:settings.rings.toFixed(1),SAMPLES_INT:settings.samples.toFixed(0),SAMPLES_FLOAT:settings.samples.toFixed(1)},uniforms:{tDiffuse:new Uniform(null),tDepth:new Uniform(null),texelSize:new Uniform(new Vector2()),halfTexelSize:new Uniform(new Vector2()),cameraNear:new Uniform(0.1),cameraFar:new Uniform(2000),focalLength:new Uniform(24.0),focalStop:new Uniform(0.9),maxBlur:new Uniform(settings.maxBlur),luminanceThreshold:new Uniform(settings.luminanceThreshold),luminanceGain:new Uniform(settings.luminanceGain),bias:new Uniform(settings.bias),fringe:new Uniform(settings.fringe),ditherStrength:new Uniform(settings.ditherStrength),focusCoords:new Uniform(new Vector2(0.5,0.5)),focalDepth:new Uniform(1.0)},fragmentShader:fragment$15,vertexShader:vertex$15,depthWrite:false,depthTest:false}));_this.setShowFocusEnabled(settings.showFocus);_this.setManualDepthOfFieldEnabled(settings.manualDoF);_this.setVignetteEnabled(settings.vignette);_this.setPentagonEnabled(settings.pentagon);_this.setShaderFocusEnabled(settings.shaderFocus);_this.setNoiseEnabled(settings.noise);if(settings.texelSize!==null){_this.setTexelSize(settings.texelSize.x,settings.texelSize.y);}_this.adoptCameraSettings(camera);return _this;}/**
     * Defines whether the focus should be shown.
     *
     * @param {Boolean} enabled - True if the focus should be shown, false otherwise.
     */createClass(RealisticBokehMaterial,[{key:"setShowFocusEnabled",value:function setShowFocusEnabled(enabled){if(enabled){this.defines.SHOW_FOCUS="1";}else{delete this.defines.SHOW_FOCUS;}this.needsUpdate=true;}/**
       * Defines whether manual Depth of Field should be enabled.
       *
       * @param {Boolean} enabled - Whether manual DoF should be enabled.
       */},{key:"setManualDepthOfFieldEnabled",value:function setManualDepthOfFieldEnabled(enabled){if(enabled){this.defines.MANUAL_DOF="1";}else{delete this.defines.MANUAL_DOF;}this.needsUpdate=true;}/**
       * Defines whether the Vignette effect should be enabled.
       *
       * @param {Boolean} enabled - Whether the Vignette effect should be enabled.
       */},{key:"setVignetteEnabled",value:function setVignetteEnabled(enabled){if(enabled){this.defines.VIGNETTE="1";}else{delete this.defines.VIGNETTE;}this.needsUpdate=true;}/**
       * Defines whether the pentagonal blur effect should be enabled.
       *
       * @param {Boolean} enabled - Whether the pentagonal blur effect should be enabled.
       */},{key:"setPentagonEnabled",value:function setPentagonEnabled(enabled){if(enabled){this.defines.PENTAGON="1";}else{delete this.defines.PENTAGON;}this.needsUpdate=true;}/**
       * Enables or disables the automatic shader focus.
       *
       * @param {Boolean} enabled - Whether the shader focus should be enabled.
       */},{key:"setShaderFocusEnabled",value:function setShaderFocusEnabled(enabled){if(enabled){this.defines.SHADER_FOCUS="1";}else{delete this.defines.SHADER_FOCUS;}this.needsUpdate=true;}/**
       * Defines whether the dithering should compute noise.
       *
       * @param {Boolean} enabled - Whether noise-based dithering should be enabled.
       */},{key:"setNoiseEnabled",value:function setNoiseEnabled(enabled){if(enabled){this.defines.NOISE="1";}else{delete this.defines.NOISE;}this.needsUpdate=true;}/**
       * Sets the texel size.
       *
       * @param {Number} x - The texel width.
       * @param {Number} y - The texel height.
       */},{key:"setTexelSize",value:function setTexelSize(x,y){this.uniforms.texelSize.value.set(x,y);this.uniforms.halfTexelSize.value.set(x,y).multiplyScalar(0.5);}/**
       * Adopts the near and far plane and the focal length of the given camera.
       *
       * @param {PerspectiveCamera} camera - The main camera.
       */},{key:"adoptCameraSettings",value:function adoptCameraSettings(camera){if(camera!==null){this.uniforms.cameraNear.value=camera.near;this.uniforms.cameraFar.value=camera.far;this.uniforms.focalLength.value=camera.getFocalLength();// unit: mm.
  }}}]);inherits(RealisticBokehMaterial,_ShaderMaterial);return RealisticBokehMaterial;}(ShaderMaterial);var fragment$16="#include <common>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform vec2 center;\r\nuniform float aspect;\r\nuniform float waveSize;\r\nuniform float radius;\r\nuniform float maxRadius;\r\nuniform float amplitude;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(aspect, 1.0);\r\n\r\n\tvec2 difference = vUv * aspectCorrection - center * aspectCorrection;\r\n\tfloat distance = sqrt(dot(difference, difference)) * vSize;\r\n\r\n\tvec2 displacement = vec2(0.0);\r\n\r\n\tif(distance > radius) {\r\n\r\n\t\tif(distance < radius + waveSize) {\r\n\r\n\t\t\tfloat angle = (distance - radius) * PI2 / waveSize;\r\n\t\t\tfloat cosSin = (1.0 - cos(angle)) * 0.5;\r\n\r\n\t\t\tfloat extent = maxRadius + waveSize;\r\n\t\t\tfloat decay = max(extent - distance * distance, 0.0) / extent;\r\n\r\n\t\t\tdisplacement = ((cosSin * amplitude * difference) / distance) * decay;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texture2D(tDiffuse, vUv - displacement);\r\n\r\n}\r\n";var vertex$16="uniform float size;\r\nuniform float scale;\r\nuniform float cameraDistance;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvSize = (0.1 * cameraDistance) / size;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * A shock wave shader material.
   *
   * Based on a Gist by Jean-Philippe Sarda:
   *  https://gist.github.com/jpsarda/33cea67a9f2ecb0a0eda
   */var ShockWaveMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new shock wave material.
     *
     * @param {Object} [options] - The options.
     * @param {Number} [options.waveSize=0.2] - The wave size.
     * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
     */function ShockWaveMaterial(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,ShockWaveMaterial);var settings=Object.assign({maxRadius:1.0,waveSize:0.2,amplitude:0.05},options);return possibleConstructorReturn(this,getPrototypeOf$2(ShockWaveMaterial).call(this,{type:"ShockWaveMaterial",uniforms:{tDiffuse:new Uniform(null),center:new Uniform(new Vector2(0.5,0.5)),aspect:new Uniform(1.0),cameraDistance:new Uniform(1.0),size:new Uniform(1.0),radius:new Uniform(-settings.waveSize),maxRadius:new Uniform(settings.maxRadius),waveSize:new Uniform(settings.waveSize),amplitude:new Uniform(settings.amplitude)},fragmentShader:fragment$16,vertexShader:vertex$16,depthWrite:false,depthTest:false}));}inherits(ShockWaveMaterial,_ShaderMaterial);return ShockWaveMaterial;}(ShaderMaterial);var fragment$17="uniform sampler2D tDiffuse;\r\nuniform sampler2D tWeights;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\t// Fetch the blending weights for current pixel.\r\n\tvec4 a;\r\n\ta.xz = texture2D(tWeights, vUv).xz;\r\n\ta.y = texture2D(tWeights, vOffset.zw).g;\r\n\ta.w = texture2D(tWeights, vOffset.xy).a;\r\n\r\n\tvec4 color;\r\n\r\n\t// Check if there is any blending weight with a value greater than 0.0.\r\n\tif(dot(a, vec4(1.0)) < 1e-5) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\r\n\t} else {\r\n\r\n\t\t/* Up to four lines can be crossing a pixel (one through each edge).\r\n\t\t * The line with the maximum weight for each direction is favoured.\r\n\t\t */\r\n\r\n\t\tvec2 offset;\r\n\t\toffset.x = a.a > a.b ? a.a : -a.b; // Left vs. right.\r\n\t\toffset.y = a.g > a.r ? -a.g : a.r; // Top vs. bottom (changed signs).\r\n\r\n\t\t// Go in the direction with the maximum weight (horizontal vs. vertical).\r\n\t\tif(abs(offset.x) > abs(offset.y)) {\r\n\r\n\t\t\toffset.y = 0.0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\toffset.x = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\t// Fetch the opposite color and lerp by hand.\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\t\tvec2 coord = vUv + sign(offset) * texelSize;\r\n\t\tvec4 oppositeColor = texture2D(tDiffuse, coord, 0.0);\r\n\t\tfloat s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\r\n\r\n\t\t// Gamma correction.\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(2.2));\r\n\t\toppositeColor.rgb = pow(abs(oppositeColor.rgb), vec3(2.2));\r\n\t\tcolor = mix(color, oppositeColor, s);\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(1.0 / 2.2));\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";var vertex$17="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * Subpixel Morphological Antialiasing.
   *
   * This material is used to render the final antialiasing.
   */var SMAABlendMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new SMAA blend material.
     *
     * @param {Vector2} [texelSize] - The absolute screen texel size.
     */function SMAABlendMaterial(){var texelSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();classCallCheck(this,SMAABlendMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(SMAABlendMaterial).call(this,{type:"SMAABlendMaterial",uniforms:{tDiffuse:new Uniform(null),tWeights:new Uniform(null),texelSize:new Uniform(texelSize)},fragmentShader:fragment$17,vertexShader:vertex$17,depthWrite:false,depthTest:false}));}inherits(SMAABlendMaterial,_ShaderMaterial);return SMAABlendMaterial;}(ShaderMaterial);var fragment$18="#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + float(offset) * texelSize, 0.0)\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tArea;\r\nuniform sampler2D tSearch;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvec2 round(vec2 x) {\r\n\r\n\treturn sign(x) * floor(abs(x) + 0.5);\r\n\r\n}\r\n\r\nfloat searchLength(vec2 e, float bias, float scale) {\r\n\r\n\t// Not required if tSearch accesses are set to point.\r\n\t// const vec2 SEARCH_TEX_PIXEL_SIZE = 1.0 / vec2(66.0, 33.0);\r\n\t// e = vec2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE + e * vec2(scale, 1.0) * vec2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\r\n\r\n\te.r = bias + e.r * scale;\r\n\r\n\treturn 255.0 * texture2D(tSearch, e, 0.0).r;\r\n\r\n}\r\n\r\nfloat searchXLeft(vec2 texCoord, float end) {\r\n\r\n\t/* @PSEUDO_GATHER4\r\n\t * This texCoord has been offset by (-0.25, -0.125) in the vertex shader to\r\n\t * sample between edge, thus fetching four edges in a row.\r\n\t * Sampling with different offsets in each direction allows to disambiguate\r\n\t * which edges are active from the four fetched ones.\r\n\t */\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\t// Correct the previously applied offset (-0.25, -0.125).\r\n\ttexCoord.x += 0.25 * texelSize.x;\r\n\r\n\t// The searches are biased by 1, so adjust the coords accordingly.\r\n\ttexCoord.x += texelSize.x;\r\n\r\n\t// Disambiguate the length added by the last step.\r\n\ttexCoord.x += 2.0 * texelSize.x; // Undo last step.\r\n\ttexCoord.x -= texelSize.x * searchLength(e, 0.0, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchXRight(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.x -= 0.25 * texelSize.x;\r\n\ttexCoord.x -= texelSize.x;\r\n\ttexCoord.x -= 2.0 * texelSize.x;\r\n\ttexCoord.x += texelSize.x * searchLength(e, 0.5, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchYUp(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y -= 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y; // Changed sign.\r\n\ttexCoord.y -= 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y * searchLength(e.gr, 0.0, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nfloat searchYDown(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < MAX_SEARCH_STEPS_INT; ++i ) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y += 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y; // Changed sign.\r\n\ttexCoord.y += 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y * searchLength(e.gr, 0.5, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nvec2 area(vec2 dist, float e1, float e2, float offset) {\r\n\r\n\t// Rounding prevents precision errors of bilinear filtering.\r\n\tvec2 texCoord = AREATEX_MAX_DISTANCE * round(4.0 * vec2(e1, e2)) + dist;\r\n\r\n\t// Scale and bias for texel space translation.\r\n\ttexCoord = AREATEX_PIXEL_SIZE * texCoord + (0.5 * AREATEX_PIXEL_SIZE);\r\n\r\n\t// Move to proper place, according to the subpixel offset.\r\n\ttexCoord.y += AREATEX_SUBTEX_SIZE * offset;\r\n\r\n\treturn texture2D(tArea, texCoord, 0.0).rg;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 weights = vec4(0.0);\r\n\tvec4 subsampleIndices = vec4(0.0);\r\n\tvec2 e = texture2D(tDiffuse, vUv).rg;\r\n\r\n\tif(e.g > 0.0) {\r\n\r\n\t\t// Edge at north.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the left.\r\n\t\tvec2 coords;\r\n\t\tcoords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);\r\n\t\tcoords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)\r\n\t\td.x = coords.x;\r\n\r\n\t\t/* Now fetch the left crossing edges, two at a time using bilinear\r\n\t\tfiltering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to discern what\r\n\t\tvalue each edge has. */\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).r;\r\n\r\n\t\t// Find the distance to the right.\r\n\t\tcoords.x = searchXRight(vOffset[0].zw, vOffset[2].y);\r\n\t\td.y = coords.x;\r\n\r\n\t\t/* Translate distances to pixel units for better interleave arithmetic and\r\n\t\tmemory accesses. */\r\n\t\td = d / texelSize.x - vPixCoord.x;\r\n\r\n\t\t// The area texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the right crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(1, 0)).r;\r\n\r\n\t\t// Pattern recognised, now get the actual area.\r\n\t\tweights.rg = area(sqrtD, e1, e2, subsampleIndices.y);\r\n\r\n\t}\r\n\r\n\tif(e.r > 0.0) {\r\n\r\n\t\t// Edge at west.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the top.\r\n\t\tvec2 coords;\r\n\t\tcoords.y = searchYUp(vOffset[1].xy, vOffset[2].z);\r\n\t\tcoords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;\r\n\t\td.x = coords.y;\r\n\r\n\t\t// Fetch the top crossing edges.\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).g;\r\n\r\n\t\t// Find the distance to the bottom.\r\n\t\tcoords.y = searchYDown(vOffset[1].zw, vOffset[2].w);\r\n\t\td.y = coords.y;\r\n\r\n\t\t// Distances in pixel units.\r\n\t\td = d / texelSize.y - vPixCoord.y;\r\n\r\n\t\t// The area texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the bottom crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(0, 1)).g;\r\n\r\n\t\t// Get the area for this direction.\r\n\t\tweights.ba = area(sqrtD, e1, e2, subsampleIndices.x);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = weights;\r\n\r\n}\r\n";var vertex$18="uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvPixCoord = uv / texelSize;\r\n\r\n\t// Offsets for the searches (see @PSEUDO_GATHER4).\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-0.25, 0.125, 1.25, 0.125); // Changed sign in Y and W components.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(-0.125, 0.25, -0.125, -1.25); //Changed sign in Y and W components.\r\n\r\n\t// This indicates the ends of the loops.\r\n\tvOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * MAX_SEARCH_STEPS_FLOAT;\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * Subpixel Morphological Antialiasing.
   *
   * This material computes weights for detected edges.
   */var SMAAWeightsMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new SMAA weights material.
     *
     * @param {Vector2} [texelSize] - The absolute screen texel size.
     */function SMAAWeightsMaterial(){var texelSize=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Vector2();classCallCheck(this,SMAAWeightsMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(SMAAWeightsMaterial).call(this,{type:"SMAAWeightsMaterial",defines:{// Configurable settings:
  MAX_SEARCH_STEPS_INT:"8",MAX_SEARCH_STEPS_FLOAT:"8.0",// Non-configurable settings:
  AREATEX_MAX_DISTANCE:"16.0",AREATEX_PIXEL_SIZE:"(1.0 / vec2(160.0, 560.0))",AREATEX_SUBTEX_SIZE:"(1.0 / 7.0)",SEARCHTEX_SIZE:"vec2(66.0, 33.0)",SEARCHTEX_PACKED_SIZE:"vec2(64.0, 16.0)"},uniforms:{tDiffuse:new Uniform(null),tArea:new Uniform(null),tSearch:new Uniform(null),texelSize:new Uniform(texelSize)},fragmentShader:fragment$18,vertexShader:vertex$18,depthWrite:false,depthTest:false}));}/**
     * Sets the maximum amount of steps performed in the horizontal/vertical
     * pattern searches, at each side of the pixel.
     *
     * In number of pixels, it's actually the double. So the maximum line length
     * perfectly handled by, for example 16, is 64 (perfectly means that longer
     * lines won't look as good, but are still antialiased).
     *
     * @param {Number} steps - The search steps. Range: [0, 112].
     */createClass(SMAAWeightsMaterial,[{key:"setOrthogonalSearchSteps",value:function setOrthogonalSearchSteps(steps){this.defines.MAX_SEARCH_STEPS_INT=steps.toFixed("0");this.defines.MAX_SEARCH_STEPS_FLOAT=steps.toFixed("1");this.needsUpdate=true;}}]);inherits(SMAAWeightsMaterial,_ShaderMaterial);return SMAAWeightsMaterial;}(ShaderMaterial);var fragment$19="#include <common>\r\n#include <dithering_pars_fragment>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform float middleGrey;\r\nuniform float maxLuminance;\r\n\r\n#ifdef ADAPTED_LUMINANCE\r\n\r\n\tuniform sampler2D luminanceMap;\r\n\r\n#else\r\n\r\n\tuniform float averageLuminance;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvec3 toneMap(vec3 c) {\r\n\r\n\t#ifdef ADAPTED_LUMINANCE\r\n\r\n\t\t// Get the calculated average luminance by sampling the center.\r\n\t\tfloat lumAvg = texture2D(luminanceMap, vec2(0.5)).r;\r\n\r\n\t#else\r\n\r\n\t\tfloat lumAvg = averageLuminance;\r\n\r\n\t#endif\r\n\r\n\t// Calculate the luminance of the current pixel.\r\n\tfloat lumPixel = linearToRelativeLuminance(c);\r\n\r\n\t// Apply the modified operator (Reinhard Eq. 4).\r\n\tfloat lumScaled = (lumPixel * middleGrey) / lumAvg;\r\n\r\n\tfloat lumCompressed = (lumScaled * (1.0 + (lumScaled / (maxLuminance * maxLuminance)))) / (1.0 + lumScaled);\r\n\r\n\treturn lumCompressed * c;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = vec4(toneMap(texel.rgb), texel.a);\r\n\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n";var vertex$19="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";/**
   * Full-screen tone-mapping shader material.
   *
   * This material supports dithering.
   *
   * Reference:
   *  http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf
   */var ToneMappingMaterial=/*#__PURE__*/function(_ShaderMaterial){/**
     * Constructs a new tone mapping material.
     */function ToneMappingMaterial(){classCallCheck(this,ToneMappingMaterial);return possibleConstructorReturn(this,getPrototypeOf$2(ToneMappingMaterial).call(this,{type:"ToneMappingMaterial",uniforms:{tDiffuse:new Uniform(null),luminanceMap:new Uniform(null),averageLuminance:new Uniform(1.0),maxLuminance:new Uniform(16.0),middleGrey:new Uniform(0.6)},fragmentShader:fragment$19,vertexShader:vertex$19,depthWrite:false,depthTest:false}));}inherits(ToneMappingMaterial,_ShaderMaterial);return ToneMappingMaterial;}(ShaderMaterial);/**
   * A collection of shader materials that are used in the post processing passes.
   *
   * @module postprocessing/materials
   */ /**
   * An abstract pass.
   *
   * Passes that do not rely on the depth buffer should explicitly disable the
   * depth test and depth write in their respective shader materials.
   *
   * @implements {Resizable}
   * @implements {Disposable}
   */var Pass=/*#__PURE__*/function(){/**
     * Constructs a new pass.
     *
     * @param {String} [name] - The name of this pass.
     * @param {Scene} [scene] - The scene to render.
     * @param {Camera} [camera] - The camera.
     * @param {Mesh} [quad] - A quad that fills the screen to render 2D filter effects. Set this to null, if you don't need it (see {@link RenderPass}).
     */function Pass(){var name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:"Pass";var scene=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Scene();var camera=arguments.length>2&&arguments[2]!==undefined?arguments[2]:new OrthographicCamera(-1,1,1,-1,0,1);var quad=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new Mesh(new PlaneBufferGeometry(2,2),null);classCallCheck(this,Pass);/**
       * The name of this pass.
       *
       * @type {String}
       */this.name=name;/**
       * The scene to render.
       *
       * @type {Scene}
       * @protected
       */this.scene=scene;/**
       * The camera.
       *
       * @type {Camera}
       * @protected
       */this.camera=camera;/**
       * A quad mesh that fills the screen.
       *
       * @type {Mesh}
       * @private
       */this.quad=quad;if(this.quad!==null){this.quad.frustumCulled=false;if(this.scene!==null){this.scene.add(this.quad);}}/**
       * Indicates whether this pass should render to screen.
       *
       * @type {Boolean}
       */this.renderToScreen=false;/**
       * Indicates whether this pass should be executed.
       *
       * @type {Boolean}
       */this.enabled=true;/**
       * Indicates whether the {@link EffectComposer} should swap the frame
       * buffers after this pass has finished rendering.
       *
       * Set this to `false` if this pass doesn't render to the output buffer or
       * the screen. Otherwise, the contents of the input buffer will be lost.
       *
       * @type {Boolean}
       */this.needsSwap=true;}/**
     * The fullscreen material.
     *
     * @type {Material}
     */createClass(Pass,[{key:"render",/**
       * Renders the effect.
       *
       * This is an abstract method that must be overridden.
       *
       * @abstract
       * @throws {Error} An error is thrown if the method is not overridden.
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){throw new Error("Render method not implemented!");}/**
       * Updates this pass with the renderer's size.
       *
       * You may override this method in case you want to be informed about the main
       * render size.
       *
       * The {@link EffectComposer} calls this method before this pass is
       * initialized and every time its own size is updated.
       *
       * @param {Number} width - The renderer's width.
       * @param {Number} height - The renderer's height.
       * @example this.myRenderTarget.setSize(width, height);
       */},{key:"setSize",value:function setSize(width,height){}/**
       * Performs initialization tasks.
       *
       * By overriding this method you gain access to the renderer. You'll also be
       * able to configure your custom render targets to use the appropriate format
       * (RGB or RGBA).
       *
       * The provided renderer can be used to warm up special off-screen render
       * targets by performing a preliminary render operation.
       *
       * The {@link EffectComposer} calls this method when this pass is added to its
       * queue, but not before its size has been set.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       * @example if(!alpha) { this.myRenderTarget.texture.format = RGBFormat; }
       */},{key:"initialize",value:function initialize(renderer,alpha){}/**
       * Performs a shallow search for properties that define a dispose method and
       * deletes them. The pass will be inoperative after this method was called!
       *
       * Disposable objects:
       *  - render targets
       *  - materials
       *  - textures
       *
       * The {@link EffectComposer} calls this method when it is being destroyed.
       * You may, however, use it independently to free memory when you are certain
       * that you don't need this pass anymore.
       */},{key:"dispose",value:function dispose(){var key;var _arr=Object.keys(this);for(var _i=0;_i<_arr.length;_i++){key=_arr[_i];if(this[key]!==null&&typeof this[key].dispose==="function"){this[key].dispose();this[key]=null;}}if(this.material!==null){this.material.dispose();}}},{key:"material",get:function get(){return this.quad!==null?this.quad.material:null;}/**
       * Sets the fullscreen material.
       *
       * The material will be assigned to the quad mesh that fills the screen.
       *
       * @type {Material}
       */,set:function set(value){if(this.quad!==null){this.quad.material=value;}}}]);return Pass;}();/**
   * An efficient, incremental blur pass.
   *
   * Note: This pass allows the input and output buffer to be the same.
   */var BlurPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new blur pass.
     *
     * @param {Object} [options] - The options.
     * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
     * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
     */function BlurPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,BlurPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(BlurPass).call(this,"BlurPass"));/**
       * A render target.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetX=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter,stencilBuffer:false,depthBuffer:false});_this.renderTargetX.texture.name="Blur.TargetX";_this.renderTargetX.texture.generateMipmaps=false;/**
       * A second render target.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetY=_this.renderTargetX.clone();_this.renderTargetY.texture.name="Blur.TargetY";/**
       * The resolution scale.
       *
       * You need to call {@link EffectComposer#setSize} after changing this
       * value.
       *
       * @type {Number}
       */_this.resolutionScale=options.resolutionScale!==undefined?options.resolutionScale:0.5;/**
       * A convolution shader material.
       *
       * @type {ConvolutionMaterial}
       * @private
       */_this.convolutionMaterial=new ConvolutionMaterial();/**
       * A convolution shader material that uses dithering.
       *
       * @type {ConvolutionMaterial}
       * @private
       */_this.ditheredConvolutionMaterial=new ConvolutionMaterial();_this.ditheredConvolutionMaterial.dithering=true;/**
       * Whether the blurred result should also be dithered using noise.
       *
       * @type {Boolean}
       */_this.dithering=false;_this.kernelSize=options.kernelSize;return _this;}/**
     * The absolute width of the internal render targets.
     *
     * @type {Number}
     */createClass(BlurPass,[{key:"render",/**
       * Blurs the input buffer and writes the result to the output buffer. The
       * input buffer remains intact, unless its also the output buffer.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var scene=this.scene;var camera=this.camera;var renderTargetX=this.renderTargetX;var renderTargetY=this.renderTargetY;var material=this.convolutionMaterial;var uniforms=material.uniforms;var kernel=material.getKernel();var lastRT=inputBuffer;var destRT;var i,l;this.material=material;// Apply the multi-pass blur.
  for(i=0,l=kernel.length-1;i<l;++i){// Alternate between targets.
  destRT=i%2===0?renderTargetX:renderTargetY;uniforms.kernel.value=kernel[i];uniforms.tDiffuse.value=lastRT.texture;renderer.render(scene,camera,destRT);lastRT=destRT;}if(this.dithering){material=this.ditheredConvolutionMaterial;uniforms=material.uniforms;this.material=material;}uniforms.kernel.value=kernel[i];uniforms.tDiffuse.value=lastRT.texture;renderer.render(scene,camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){width=Math.max(1,Math.floor(width*this.resolutionScale));height=Math.max(1,Math.floor(height*this.resolutionScale));this.renderTargetX.setSize(width,height);this.renderTargetY.setSize(width,height);this.convolutionMaterial.setTexelSize(1.0/width,1.0/height);this.ditheredConvolutionMaterial.setTexelSize(1.0/width,1.0/height);}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){if(!alpha){this.renderTargetX.texture.format=RGBFormat;this.renderTargetY.texture.format=RGBFormat;}}},{key:"width",get:function get(){return this.renderTargetX.width;}/**
       * The absolute height of the internal render targets.
       *
       * @type {Number}
       */},{key:"height",get:function get(){return this.renderTargetX.height;}/**
       * The kernel size.
       *
       * @type {KernelSize}
       */},{key:"kernelSize",get:function get(){return this.convolutionMaterial.kernelSize;}/**
       * @type {KernelSize}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:KernelSize.LARGE;this.convolutionMaterial.kernelSize=value;this.ditheredConvolutionMaterial.kernelSize=value;}}]);inherits(BlurPass,_Pass);return BlurPass;}(Pass);/**
   * A bloom pass.
   *
   * This pass renders a scene with superimposed blur by utilizing the fast Kawase
   * convolution approach.
   */var BloomPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new bloom pass.
     *
     * @param {Object} [options] - The options.
     * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
     * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
     * @param {Number} [options.intensity=1.0] - The strength of the bloom effect.
     * @param {Number} [options.distinction=1.0] - The luminance distinction factor. Raise this value to bring out the brighter elements in the scene.
     * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the bloom texture with the scene colors.
     */function BloomPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,BloomPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(BloomPass).call(this,"BloomPass"));/**
       * A render target.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTarget=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter,stencilBuffer:false,depthBuffer:false});_this.renderTarget.texture.name="Bloom.Target";_this.renderTarget.texture.generateMipmaps=false;/**
       * A blur pass.
       *
       * @type {BlurPass}
       * @private
       */_this.blurPass=new BlurPass(options);/**
       * A combine shader material.
       *
       * @type {CombineMaterial}
       * @private
       */_this.combineMaterial=new CombineMaterial(options.screenMode!==undefined?options.screenMode:true);_this.intensity=options.intensity;/**
       * A luminosity shader material.
       *
       * @type {LuminosityMaterial}
       * @private
       */_this.luminosityMaterial=new LuminosityMaterial(true);_this.distinction=options.distinction;return _this;}/**
     * The resolution scale.
     *
     * @type {Number}
     */createClass(BloomPass,[{key:"render",/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var scene=this.scene;var camera=this.camera;var blurPass=this.blurPass;var luminosityMaterial=this.luminosityMaterial;var combineMaterial=this.combineMaterial;var renderTarget=this.renderTarget;// Luminance filter.
  this.material=luminosityMaterial;luminosityMaterial.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(scene,camera,renderTarget);// Convolution phase.
  blurPass.render(renderer,renderTarget,renderTarget);if(this.blend){// Render the original scene with superimposed blur.
  this.material=combineMaterial;combineMaterial.uniforms.texture1.value=inputBuffer.texture;combineMaterial.uniforms.texture2.value=renderTarget.texture;renderer.render(scene,camera,this.renderToScreen?null:outputBuffer);}}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.blurPass.setSize(width,height);width=this.blurPass.width;height=this.blurPass.height;this.renderTarget.setSize(width,height);}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){this.blurPass.initialize(renderer,alpha);if(!alpha){this.renderTarget.texture.format=RGBFormat;}}},{key:"resolutionScale",get:function get(){return this.blurPass.resolutionScale;}/**
       * You need to call {@link EffectComposer#setSize} after changing this value.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0.5;this.blurPass.resolutionScale=value;}/**
       * The blur kernel size.
       *
       * @type {KernelSize}
       */},{key:"kernelSize",get:function get(){return this.blurPass.kernelSize;}/**
       * @type {KernelSize}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:KernelSize.LARGE;this.blurPass.kernelSize=value;}/**
       * The overall intensity of the effect.
       *
       * @type {Number}
       */},{key:"intensity",get:function get(){return this.combineMaterial.uniforms.opacity2.value;}/**
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this.combineMaterial.uniforms.opacity2.value=value;}/**
       * The luminance distinction factor.
       *
       * @type {Number}
       */},{key:"distinction",get:function get(){return this.luminosityMaterial.uniforms.distinction.value;}/**
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this.luminosityMaterial.uniforms.distinction.value=value;}/**
       * Indicates whether dithering is enabled.
       *
       * @type {Boolean}
       */},{key:"dithering",get:function get(){return this.blurPass.dithering;}/**
       * If enabled, the result will be dithered to remove banding artifacts.
       *
       * @type {Boolean}
       */,set:function set(value){this.blurPass.dithering=value;}/**
       * Indicates whether the effect should be applied to the input buffer.
       *
       * @type {Boolean}
       */},{key:"blend",get:function get(){return this.needsSwap;}/**
       * If disabled, the input buffer will remain unaffected.
       *
       * You may use the {@link BloomPass#overlay} texture to apply the effect to
       * your scene.
       *
       * @type {Boolean}
       */,set:function set(value){this.needsSwap=value;}/**
       * The effect overlay texture.
       *
       * @type {Texture}
       */},{key:"overlay",get:function get(){return this.renderTarget.texture;}}]);inherits(BloomPass,_Pass);return BloomPass;}(Pass);/**
   * A Depth of Field (DoF) pass using a bokeh shader.
   *
   * This pass requires a {@link EffectComposer#depthTexture}.
   */var BokehPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new bokeh pass.
     *
     * @param {PerspectiveCamera} camera - The main camera. Used to obtain the aspect ratio and the near and far plane settings.
     * @param {Object} [options] - Additional parameters. See {@link BokehMaterial} for details.
     */function BokehPass(camera){var _this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,BokehPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(BokehPass).call(this,"BokehPass"));_this.material=new BokehMaterial(camera,options);return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(BokehPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;this.material.uniforms.tDepth.value=inputBuffer.depthTexture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.material.uniforms.aspect.value=width/height;}}]);inherits(BokehPass,_Pass);return BokehPass;}(Pass);/**
   * A pass that disables the stencil test.
   */var ClearMaskPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new clear mask pass.
     */function ClearMaskPass(){var _this;classCallCheck(this,ClearMaskPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(ClearMaskPass).call(this,"ClearMaskPass",null,null,null));_this.needsSwap=false;return _this;}/**
     * Disables the global stencil test.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(ClearMaskPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){renderer.state.buffers.stencil.setTest(false);}}]);inherits(ClearMaskPass,_Pass);return ClearMaskPass;}(Pass);/**
   * Used for saving the original clear color of the renderer.
   *
   * @type {Color}
   * @private
   */var color=new Color();/**
   * A pass that clears the input buffer or the screen.
   *
   * You can prevent specific bits from being cleared by setting either the
   * autoClearColor, autoClearStencil or autoClearDepth properties of the renderer
   * to false.
   */var ClearPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new clear pass.
     *
     * @param {Object} [options] - Additional options.
     * @param {Color} [options.clearColor=null] - An override clear color.
     * @param {Number} [options.clearAlpha=0.0] - An override clear alpha.
     */function ClearPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,ClearPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(ClearPass).call(this,"ClearPass",null,null,null));_this.needsSwap=false;/**
       * The clear color.
       *
       * @type {Color}
       */_this.clearColor=options.clearColor!==undefined?options.clearColor:null;/**
       * The clear alpha.
       *
       * @type {Number}
       */_this.clearAlpha=options.clearAlpha!==undefined?options.clearAlpha:0.0;return _this;}/**
     * Clears the input buffer or the screen.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(ClearPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var clearColor=this.clearColor;var clearAlpha;if(clearColor!==null){color.copy(renderer.getClearColor());clearAlpha=renderer.getClearAlpha();renderer.setClearColor(clearColor,this.clearAlpha);}renderer.setRenderTarget(this.renderToScreen?null:inputBuffer);renderer.clear();if(clearColor!==null){renderer.setClearColor(color,clearAlpha);}}}]);inherits(ClearPass,_Pass);return ClearPass;}(Pass);/**
   * A dot screen pass.
   */var DotScreenPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new dot screen pass.
     *
     * @param {Object} [options] - The options.
     * @param {Boolean} [options.average=false] - Whether the shader should output a colour average (black and white).
     * @param {Number} [options.angle=1.57] - The angle of the pattern.
     * @param {Number} [options.scale=1.0] - The scale of the overall effect.
     * @param {Number} [options.intensity=1.0] - The intensity of the effect.
     */function DotScreenPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,DotScreenPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(DotScreenPass).call(this,"DotScreenPass"));_this.material=new DotScreenMaterial(options);return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(DotScreenPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){width=Math.max(1,width);height=Math.max(1,height);this.material.uniforms.offsetRepeat.value.z=width;this.material.uniforms.offsetRepeat.value.w=height;}}]);inherits(DotScreenPass,_Pass);return DotScreenPass;}(Pass);/**
   * A film pass.
   *
   * Provides various cinematic effects.
   */var FilmPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new film pass.
     *
     * @param {Object} [options] - The options. See {@link FilmMaterial} for more options.
     * @param {Number} [options.scanlineDensity=1.25] - The scanline density, relative to the screen height.
     * @param {Number} [options.gridScale=1.0] - The grid scale, relative to the screen height.
     * @param {Number} [options.gridLineWidth=0.0] - The grid line width. This value will be added to the base line width.
     */function FilmPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,FilmPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(FilmPass).call(this,"FilmPass"));_this.material=new FilmMaterial(options);/**
       * The amount of scanlines, relative to the screen height.
       *
       * You need to call {@link EffectComposer#setSize} after changing this
       * value.
       *
       * @type {Number}
       */_this.scanlineDensity=options.scanlineDensity===undefined?1.25:options.scanlineDensity;/**
       * The grid scale, relative to the screen height.
       *
       * You need to call {@link EffectComposer#setSize} after changing this
       * value.
       *
       * @type {Number}
       */_this.gridScale=options.gridScale===undefined?1.0:Math.max(options.gridScale,1e-6);/**
       * The grid line width.
       *
       * You need to call {@link EffectComposer#setSize} after changing this
       * value.
       *
       * @type {Number}
       */_this.gridLineWidth=options.gridLineWidth===undefined?0.0:Math.max(options.gridLineWidth,0.0);return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(FilmPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;this.material.uniforms.time.value+=delta;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){var aspect=width/height;var gridScale=this.gridScale*(height*0.125);this.material.uniforms.scanlineCount.value=Math.round(height*this.scanlineDensity);this.material.uniforms.gridScale.value.set(aspect*gridScale,gridScale);this.material.uniforms.gridLineWidth.value=gridScale/height+this.gridLineWidth;}}]);inherits(FilmPass,_Pass);return FilmPass;}(Pass);/**
   * Returns a random integer in the specified range.
   *
   * @private
   * @param {Number} low - The lowest possible value.
   * @param {Number} high - The highest possible value.
   * @return {Number} The random value.
   */function randomInt(low,high){return low+Math.floor(Math.random()*(high-low+1));}/**
   * Returns a random float in the specified range.
   *
   * @private
   * @param {Number} low - The lowest possible value.
   * @param {Number} high - The highest possible value.
   * @return {Number} The random value.
   */function randomFloat(low,high){return low+Math.random()*(high-low);}/**
   * A glitch pass.
   */var GlitchPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new glitch pass.
     *
     * @param {Object} [options] - The options.
     * @param {Texture} [options.perturbMap] - A perturbation map. If none is provided, a noise texture will be created.
     * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.
     */function GlitchPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,GlitchPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(GlitchPass).call(this,"GlitchPass"));_this.material=new GlitchMaterial();/**
       * A perturbation map.
       *
       * @type {Texture}
       * @private
       */_this.texture=null;_this.perturbMap=options.perturbMap!==undefined?options.perturbMap:_this.generatePerturbMap(options.dtSize);_this.perturbMap.name="Glitch.Perturbation";_this.perturbMap.generateMipmaps=false;/**
       * The effect mode.
       *
       * @type {GlitchMode}
       */_this.mode=GlitchMode.SPORADIC;/**
       * A counter for the glitch activation and deactivation.
       *
       * @type {Number}
       * @private
       */_this.counter=0;/**
       * A random break point for the sporadic glitch activation.
       *
       * @type {Number}
       * @private
       */_this.breakPoint=randomInt(120,240);return _this;}/**
     * The current perturbation map.
     *
     * @type {Texture}
     */createClass(GlitchPass,[{key:"generatePerturbMap",/**
       * Destroys the current perturbation map and replaces it with a new one.
       *
       * @param {Number} [size=64] - The texture size.
       * @return {DataTexture} The perturbation texture.
       */value:function generatePerturbMap(){var size=arguments.length>0&&arguments[0]!==undefined?arguments[0]:64;var pixels=size*size;var data=new Float32Array(pixels*3);var dt=this.perturbMap;var i,x;for(i=0;i<pixels;++i){x=Math.random();data[i*3]=x;data[i*3+1]=x;data[i*3+2]=x;}if(dt!==null){dt.dispose();}dt=new DataTexture(data,size,size,RGBFormat,FloatType);dt.needsUpdate=true;this.perturbMap=dt;return dt;}/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */},{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var mode=this.mode;var counter=this.counter;var breakPoint=this.breakPoint;var uniforms=this.material.uniforms;uniforms.tDiffuse.value=inputBuffer.texture;uniforms.seed.value=Math.random();uniforms.active.value=true;if(counter%breakPoint===0||mode===GlitchMode.CONSTANT_WILD){uniforms.amount.value=Math.random()/30.0;uniforms.angle.value=randomFloat(-Math.PI,Math.PI);uniforms.seedX.value=randomFloat(-1.0,1.0);uniforms.seedY.value=randomFloat(-1.0,1.0);uniforms.distortionX.value=randomFloat(0.0,1.0);uniforms.distortionY.value=randomFloat(0.0,1.0);this.breakPoint=randomInt(120,240);this.counter=0;}else{if(counter%breakPoint<breakPoint/5||mode===GlitchMode.CONSTANT_MILD){uniforms.amount.value=Math.random()/90.0;uniforms.angle.value=randomFloat(-Math.PI,Math.PI);uniforms.distortionX.value=randomFloat(0.0,1.0);uniforms.distortionY.value=randomFloat(0.0,1.0);uniforms.seedX.value=randomFloat(-0.3,0.3);uniforms.seedY.value=randomFloat(-0.3,0.3);}else{// Sporadic.
  uniforms.active.value=false;}}++this.counter;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}},{key:"perturbMap",get:function get(){return this.texture;}/**
       * Assigning a new perturbation map does not destroy the current one!
       *
       * @type {Texture}
       */,set:function set(value){this.texture=value;this.material.uniforms.tPerturb.value=value;}}]);inherits(GlitchPass,_Pass);return GlitchPass;}(Pass);/**
   * A glitch mode enumeration.
   *
   * @type {Object}
   * @property {Number} SPORADIC - Sporadic glitches.
   * @property {Number} CONSTANT_MILD - Constant mild glitches.
   * @property {Number} CONSTANT_WILD - Constant wild glitches.
   */var GlitchMode={SPORADIC:0,CONSTANT_MILD:1,CONSTANT_WILD:2};/**
   * A pass that renders a given scene directly on screen or into the read buffer
   * for further processing.
   */var RenderPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new render pass.
     *
     * @param {Scene} scene - The scene to render.
     * @param {Camera} camera - The camera to use to render the scene.
     * @param {Object} [options] - Additional options.
     * @param {Material} [options.overrideMaterial=null] - An override material for the scene.
     * @param {Color} [options.clearColor=null] - An override clear color.
     * @param {Number} [options.clearAlpha=1.0] - An override clear alpha.
     * @param {Boolean} [options.clearDepth=false] - Whether depth should be cleared explicitly.
     * @param {Boolean} [options.clear=true] - Whether all buffers should be cleared.
     */function RenderPass(scene,camera){var _this;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,RenderPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(RenderPass).call(this,"RenderPass",scene,camera,null));_this.needsSwap=false;/**
       * A clear pass.
       *
       * @type {ClearPass}
       */_this.clearPass=new ClearPass(options);/**
       * An override material.
       *
       * @type {Material}
       */_this.overrideMaterial=options.overrideMaterial!==undefined?options.overrideMaterial:null;/**
       * Indicates whether the depth buffer should be cleared explicitly.
       *
       * @type {Boolean}
       */_this.clearDepth=options.clearDepth!==undefined?options.clearDepth:false;/**
       * Indicates whether the color, depth and stencil buffers should be cleared.
       *
       * Even with clear set to true you can prevent specific buffers from being
       * cleared by setting either the autoClearColor, autoClearStencil or
       * autoClearDepth properties of the renderer to false.
       *
       * @type {Boolean}
       */_this.clear=options.clear!==undefined?options.clear:true;return _this;}/**
     * Renders the scene.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(RenderPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var scene=this.scene;var renderTarget=this.renderToScreen?null:inputBuffer;var overrideMaterial=scene.overrideMaterial;if(this.clear){this.clearPass.renderToScreen=this.renderToScreen;this.clearPass.render(renderer,inputBuffer);}else if(this.clearDepth){renderer.setRenderTarget(renderTarget);renderer.clearDepth();}scene.overrideMaterial=this.overrideMaterial;renderer.render(scene,this.camera,renderTarget);scene.overrideMaterial=overrideMaterial;}}]);inherits(RenderPass,_Pass);return RenderPass;}(Pass);/**
   * Clamps a given value.
   *
   * @private
   * @param {Number} value - The value to clamp.
   * @param {Number} min - The lowest possible value.
   * @param {Number} max - The highest possible value.
   * @return {Number} The clamped value.
   */function clamp(value,min,max){return Math.max(min,Math.min(max,value));}/**
   * A crepuscular rays pass.
   */var GodRaysPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new god rays pass.
     *
     * @param {Scene} scene - The main scene.
     * @param {Camera} camera - The main camera.
     * @param {Object3D} lightSource - The main light source.
     * @param {Object} [options] - The options.
     * @param {Number} [options.density=0.96] - The density of the light rays.
     * @param {Number} [options.decay=0.93] - An illumination decay factor.
     * @param {Number} [options.weight=0.4] - A light ray weight factor.
     * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
     * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
     * @param {Number} [options.intensity=1.0] - A constant factor for additive blending.
     * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
     * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
     * @param {Number} [options.samples=60] - The number of samples per pixel.
     * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the god rays texture with the scene colors.
     */function GodRaysPass(scene,camera,lightSource){var _this;var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};classCallCheck(this,GodRaysPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(GodRaysPass).call(this,"GodRaysPass"));/**
       * A scene that only contains the light source.
       *
       * @type {Scene}
       * @private
       */_this.lightScene=new Scene();/**
       * The main scene.
       *
       * @type {Scene}
       * @private
       */_this.mainScene=scene;/**
       * The main camera.
       *
       * @type {Camera}
       * @private
       */_this.mainCamera=camera;/**
       * A render target.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetX=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter,stencilBuffer:false,depthBuffer:false});_this.renderTargetX.texture.name="GodRays.TargetX";_this.renderTargetX.texture.generateMipmaps=false;/**
       * A second render target.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetY=_this.renderTargetX.clone();_this.renderTargetY.texture.name="GodRays.TargetY";/**
       * A render target for the masked light scene.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetMask=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter});_this.renderTargetMask.texture.name="GodRays.Mask";_this.renderTargetMask.texture.generateMipmaps=false;/**
       * A pass that only renders the light source.
       *
       * @type {RenderPass}
       * @private
       */_this.renderPassLight=new RenderPass(_this.lightScene,_this.mainCamera,{clearColor:new Color(0x000000)});/**
       * A pass that renders the masked scene over the light.
       *
       * @type {RenderPass}
       * @private
       */_this.renderPassMask=new RenderPass(_this.mainScene,_this.mainCamera,{overrideMaterial:new MeshBasicMaterial({color:0x000000})});_this.renderPassMask.clear=false;/**
       * A blur pass.
       *
       * @type {BlurPass}
       * @private
       */_this.blurPass=new BlurPass(options);/**
       * The light source.
       *
       * @type {Object3D}
       */_this.lightSource=lightSource;/**
       * The light position in screen space.
       *
       * @type {Vector3}
       * @private
       */_this.screenPosition=new Vector3();/**
       * A god rays shader material.
       *
       * @type {GodRaysMaterial}
       * @private
       */_this.godRaysMaterial=new GodRaysMaterial(options);_this.godRaysMaterial.uniforms.lightPosition.value=_this.screenPosition;_this.samples=options.samples;/**
       * A combine shader material.
       *
       * @type {CombineMaterial}
       * @private
       */_this.combineMaterial=new CombineMaterial(options.screenMode!==undefined?options.screenMode:true);_this.intensity=options.intensity;return _this;}/**
     * The resolution scale.
     *
     * @type {Number}
     */createClass(GodRaysPass,[{key:"render",/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var scene=this.scene;var camera=this.camera;var mainScene=this.mainScene;var lightSource=this.lightSource;var screenPosition=this.screenPosition;var godRaysMaterial=this.godRaysMaterial;var combineMaterial=this.combineMaterial;var renderTargetMask=this.renderTargetMask;var renderTargetX=this.renderTargetX;var renderTargetY=this.renderTargetY;var background,parent;// Compute the screen light position and translate it to [0.0, 1.0].
  screenPosition.copy(lightSource.position).project(this.mainCamera);screenPosition.x=clamp((screenPosition.x+1.0)*0.5,0.0,1.0);screenPosition.y=clamp((screenPosition.y+1.0)*0.5,0.0,1.0);parent=lightSource.parent;background=mainScene.background;mainScene.background=null;this.lightScene.add(lightSource);/* First, render the light source. Then render the scene into the same
        buffer using a mask override material with depth test enabled. */this.renderPassLight.render(renderer,renderTargetMask);this.renderPassMask.render(renderer,renderTargetMask);if(parent!==null){parent.add(lightSource);}mainScene.background=background;// Blur the masked scene to reduce artifacts.
  this.blurPass.render(renderer,this.renderTargetMask,renderTargetX);// Blur the masked scene along radial lines towards the light source.
  this.material=godRaysMaterial;godRaysMaterial.uniforms.tDiffuse.value=renderTargetX.texture;renderer.render(scene,camera,renderTargetY);if(this.blend){// Combine the god rays with the scene colors.
  this.material=combineMaterial;combineMaterial.uniforms.texture1.value=inputBuffer.texture;combineMaterial.uniforms.texture2.value=renderTargetY.texture;renderer.render(scene,camera,this.renderToScreen?null:outputBuffer);}}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.renderPassLight.setSize(width,height);this.renderPassMask.setSize(width,height);this.blurPass.setSize(width,height);width=this.blurPass.width;height=this.blurPass.height;this.renderTargetMask.setSize(width,height);this.renderTargetX.setSize(width,height);this.renderTargetY.setSize(width,height);}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){this.renderPassLight.initialize(renderer,alpha);this.renderPassMask.initialize(renderer,alpha);this.blurPass.initialize(renderer,alpha);if(!alpha){this.renderTargetMask.texture.format=RGBFormat;this.renderTargetX.texture.format=RGBFormat;this.renderTargetY.texture.format=RGBFormat;}}},{key:"resolutionScale",get:function get(){return this.blurPass.resolutionScale;}/**
       * You need to call {@link EffectComposer#setSize} after changing this value.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0.5;this.blurPass.resolutionScale=value;}/**
       * The blur kernel size.
       *
       * @type {KernelSize}
       */},{key:"kernelSize",get:function get(){return this.blurPass.kernelSize;}/**
       * @type {KernelSize}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:KernelSize.LARGE;this.blurPass.kernelSize=value;}/**
       * The overall intensity of the effect.
       *
       * @type {Number}
       */},{key:"intensity",get:function get(){return this.combineMaterial.uniforms.opacity2.value;}/**
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this.combineMaterial.uniforms.opacity2.value=value;}/**
       * The number of samples per pixel.
       *
       * @type {Number}
       */},{key:"samples",get:function get(){return Number.parseInt(this.godRaysMaterial.defines.NUM_SAMPLES_INT);}/**
       * This value must be carefully chosen. A higher value directly increases the
       * GPU load.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:60;value=Math.floor(value);this.godRaysMaterial.defines.NUM_SAMPLES_FLOAT=value.toFixed(1);this.godRaysMaterial.defines.NUM_SAMPLES_INT=value.toFixed(0);this.godRaysMaterial.needsUpdate=true;}/**
       * Indicates whether dithering is enabled.
       *
       * @type {Boolean}
       */},{key:"dithering",get:function get(){return this.godRaysMaterial.dithering;}/**
       * If enabled, the result will be dithered to remove banding artifacts.
       *
       * @type {Boolean}
       */,set:function set(value){if(this.dithering!==value){this.godRaysMaterial.dithering=value;this.godRaysMaterial.needsUpdate=true;}}/**
       * Indicates whether the effect should be applied to the input buffer.
       *
       * @type {Boolean}
       */},{key:"blend",get:function get(){return this.needsSwap;}/**
       * If disabled, the input buffer will remain unaffected.
       *
       * You may use the {@link BloomPass#overlay} texture to apply the effect to
       * your scene.
       *
       * @type {Boolean}
       */,set:function set(value){this.needsSwap=value;}/**
       * The effect overlay texture.
       *
       * @type {Texture}
       */},{key:"overlay",get:function get(){return this.renderTargetY.texture;}}]);inherits(GodRaysPass,_Pass);return GodRaysPass;}(Pass);/**
   * A mask pass.
   */var MaskPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new mask pass.
     *
     * @param {Scene} scene - The scene to render.
     * @param {Camera} camera - The camera to use.
     */function MaskPass(scene,camera){var _this;classCallCheck(this,MaskPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(MaskPass).call(this,"MaskPass",scene,camera,null));_this.needsSwap=false;/**
       * Inverse flag.
       *
       * @type {Boolean}
       */_this.inverse=false;/**
       * Stencil buffer clear flag.
       *
       * @type {Boolean}
       */_this.clearStencil=true;return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(MaskPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var context=renderer.context;var state=renderer.state;var scene=this.scene;var camera=this.camera;var writeValue=this.inverse?0:1;var clearValue=1-writeValue;// Don't update color or depth.
  state.buffers.color.setMask(false);state.buffers.depth.setMask(false);// Lock the buffers.
  state.buffers.color.setLocked(true);state.buffers.depth.setLocked(true);// Configure the stencil.
  state.buffers.stencil.setTest(true);state.buffers.stencil.setOp(context.REPLACE,context.REPLACE,context.REPLACE);state.buffers.stencil.setFunc(context.ALWAYS,writeValue,0xffffffff);state.buffers.stencil.setClear(clearValue);// Clear the stencil.
  if(this.clearStencil){if(this.renderToScreen){renderer.setRenderTarget(null);renderer.clearStencil();}else{renderer.setRenderTarget(inputBuffer);renderer.clearStencil();renderer.setRenderTarget(outputBuffer);renderer.clearStencil();}}// Draw the mask.
  if(this.renderToScreen){renderer.render(scene,camera,null);}else{renderer.render(scene,camera,inputBuffer);renderer.render(scene,camera,outputBuffer);}// Unlock the buffers.
  state.buffers.color.setLocked(false);state.buffers.depth.setLocked(false);// Only render where the stencil is set to 1.
  state.buffers.stencil.setFunc(context.EQUAL,1,0xffffffff);state.buffers.stencil.setOp(context.KEEP,context.KEEP,context.KEEP);}}]);inherits(MaskPass,_Pass);return MaskPass;}(Pass);/**
   * A shader pass.
   *
   * Used to render any shader material as a 2D filter.
   */var ShaderPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new shader pass.
     *
     * @param {ShaderMaterial} material - The shader material to use.
     * @param {String} [textureID="tDiffuse"] - The texture uniform identifier.
     */function ShaderPass(material){var _this;var textureID=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"tDiffuse";classCallCheck(this,ShaderPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(ShaderPass).call(this,"ShaderPass"));_this.material=material;/**
       * The name of the color sampler uniform of the given material.
       *
       * @type {String}
       */_this.textureID=textureID;return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(ShaderPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){if(this.material.uniforms[this.textureID]!==undefined){this.material.uniforms[this.textureID].value=inputBuffer.texture;}renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}}]);inherits(ShaderPass,_Pass);return ShaderPass;}(Pass);/**
   * An outline pass.
   */var OutlinePass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new outline pass.
     *
     * @param {Scene} scene - The main scene.
     * @param {Camera} camera - The main camera.
     * @param {Object} [options] - Additional parameters. See {@link BlurPass}, {@link OutlineBlendMaterial} and {@link OutlineEdgesMaterial} for details.
     * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.
     * @param {Boolean} [options.blur=true] - Whether the outline should be blurred.
     */function OutlinePass(scene,camera){var _this;var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,OutlinePass);_this=possibleConstructorReturn(this,getPrototypeOf$2(OutlinePass).call(this,"OutlinePass"));/**
       * The main scene.
       *
       * @type {Scene}
       * @private
       */_this.mainScene=scene;/**
       * The main camera.
       *
       * @type {Camera}
       * @private
       */_this.mainCamera=camera;/**
       * A render target for depth information.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetDepth=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter});_this.renderTargetDepth.texture.name="Outline.Depth";_this.renderTargetDepth.texture.generateMipmaps=false;/**
       * A render target for the outline mask.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetMask=_this.renderTargetDepth.clone();_this.renderTargetMask.texture.format=RGBFormat;_this.renderTargetMask.texture.name="Outline.Mask";/**
       * A render target for the edge detection.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetEdges=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter,stencilBuffer:false,depthBuffer:false,format:RGBFormat});_this.renderTargetEdges.texture.name="Outline.Edges";_this.renderTargetEdges.texture.generateMipmaps=false;/**
       * A render target for the blurred outline overlay.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetBlurredEdges=_this.renderTargetEdges.clone();_this.renderTargetBlurredEdges.texture.name="Outline.BlurredEdges";/**
       * A depth pass.
       *
       * @type {RenderPass}
       * @private
       */_this.renderPassDepth=new RenderPass(_this.mainScene,_this.mainCamera,{overrideMaterial:new MeshDepthMaterial({depthPacking:RGBADepthPacking,morphTargets:true,skinning:true}),clearColor:new Color(0xffffff),clearAlpha:1.0});/**
       * A depth comparison mask pass.
       *
       * @type {RenderPass}
       * @private
       */_this.renderPassMask=new RenderPass(_this.mainScene,_this.mainCamera,{overrideMaterial:new DepthComparisonMaterial(_this.renderTargetDepth.texture,_this.mainCamera),clearColor:new Color(0xffffff),clearAlpha:1.0});/**
       * A blur pass.
       *
       * @type {BlurPass}
       * @private
       */_this.blurPass=new BlurPass(options);_this.kernelSize=options.kernelSize;/**
       * A copy pass that renders the read buffer to screen if needed.
       *
       * @type {ShaderPass}
       * @private
       */_this.copyPass=new ShaderPass(new CopyMaterial());_this.copyPass.renderToScreen=true;/**
       * An outline edge detection material.
       *
       * @type {OutlineEdgesMaterial}
       * @private
       */_this.outlineEdgesMaterial=new OutlineEdgesMaterial(options);_this.outlineEdgesMaterial.uniforms.tMask.value=_this.renderTargetMask.texture;/**
       * An outline blend material.
       *
       * @type {OutlineBlendMaterial}
       * @private
       */_this.outlineBlendMaterial=new OutlineBlendMaterial(options);_this.outlineBlendMaterial.uniforms.tMask.value=_this.renderTargetMask.texture;_this.blur=options.blur!==undefined?options.blur:true;/**
       * A list of objects to outline.
       *
       * @type {Object3D[]}
       * @private
       */_this.selection=[];/**
       * The current animation time.
       *
       * @type {Number}
       * @private
       */_this.time=0.0;/**
       * The pulse speed. A value of zero disables the pulse effect.
       *
       * @type {Number}
       */_this.pulseSpeed=options.pulseSpeed!==undefined?options.pulseSpeed:0.0;/**
       * A dedicated render layer for selected objects.
       *
       * This layer is set to 10 by default. If this collides with your own custom
       * layers, please change it to a free layer before rendering!
       *
       * @type {Number}
       */_this.selectionLayer=10;return _this;}/**
     * The resolution scale.
     *
     * @type {Number}
     */createClass(OutlinePass,[{key:"setPatternTexture",/**
       * Sets a pattern texture to use as an overlay for selected objects.
       *
       * @param {Texture} [texture=null] - A pattern texture. Set to null to disable the pattern.
       */value:function setPatternTexture(){var texture=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;this.outlineBlendMaterial.setPatternTexture(texture);}/**
       * Clears the current selection and selects a list of objects.
       *
       * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.
       * @return {OutlinePass} This pass.
       */},{key:"setSelection",value:function setSelection(objects){var selection=objects.slice(0);var selectionLayer=this.selectionLayer;var i,l;this.clearSelection();for(i=0,l=selection.length;i<l;++i){selection[i].layers.enable(selectionLayer);}this.selection=selection;return this;}/**
       * Clears the list of selected objects.
       *
       * @return {OutlinePass} This pass.
       */},{key:"clearSelection",value:function clearSelection(){var selection=this.selection;var selectionLayer=this.selectionLayer;var i,l;for(i=0,l=selection.length;i<l;++i){selection[i].layers.disable(selectionLayer);}this.selection=[];this.time=0.0;return this;}/**
       * Selects an object.
       *
       * @param {Object3D} object - The object that should be outlined.
       * @return {OutlinePass} This pass.
       */},{key:"selectObject",value:function selectObject(object){object.layers.enable(this.selectionLayer);this.selection.push(object);return this;}/**
       * Deselects an object.
       *
       * @param {Object3D} object - The object that should no longer be outlined.
       * @return {OutlinePass} This pass.
       */},{key:"deselectObject",value:function deselectObject(object){var selection=this.selection;var index=selection.indexOf(object);if(index>=0){selection[index].layers.disable(this.selectionLayer);selection.splice(index,1);if(selection.length===0){this.time=0.0;}}return this;}/**
       * Sets the visibility of all selected objects.
       *
       * @private
       * @param {Boolean} visible - Whether the selected objects should be visible.
       */},{key:"setSelectionVisible",value:function setSelectionVisible(visible){var selection=this.selection;var i,l;for(i=0,l=selection.length;i<l;++i){if(visible){selection[i].layers.enable(0);}else{selection[i].layers.disable(0);}}}/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */},{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var mainScene=this.mainScene;var mainCamera=this.mainCamera;var pulse=this.outlineBlendMaterial.uniforms.pulse;var background,mask;if(this.selection.length>0){background=mainScene.background;mask=mainCamera.layers.mask;mainScene.background=null;pulse.value=1.0;if(this.pulseSpeed>0.0){pulse.value=0.625+Math.cos(this.time*this.pulseSpeed*10.0)*0.375;this.time+=delta;}// Render a custom depth texture and ignore selected objects.
  this.setSelectionVisible(false);this.renderPassDepth.render(renderer,this.renderTargetDepth);this.setSelectionVisible(true);// Create a mask for the selected objects using the depth information.
  mainCamera.layers.mask=1<<this.selectionLayer;this.renderPassMask.render(renderer,this.renderTargetMask);// Restore the camera layer mask and the scene background.
  mainCamera.layers.mask=mask;mainScene.background=background;// Detect the outline.
  this.material=this.outlineEdgesMaterial;renderer.render(this.scene,this.camera,this.renderTargetEdges);if(this.blurPass.enabled){// Blur the edges.
  this.blurPass.render(renderer,this.renderTargetEdges,this.renderTargetBlurredEdges);}if(this.blend){// Draw the final overlay onto the scene colours.
  this.material=this.outlineBlendMaterial;this.outlineBlendMaterial.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:this.outputBuffer);}}else if(this.renderToScreen){// Draw the read buffer to screen.
  this.copyPass.render(renderer,inputBuffer);}}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.renderTargetDepth.setSize(width,height);this.renderTargetMask.setSize(width,height);this.renderPassDepth.setSize(width,height);this.renderPassMask.setSize(width,height);this.blurPass.setSize(width,height);width=this.blurPass.width;height=this.blurPass.height;this.renderTargetEdges.setSize(width,height);this.renderTargetBlurredEdges.setSize(width,height);this.outlineBlendMaterial.uniforms.aspect.value=width/height;this.outlineEdgesMaterial.setTexelSize(1.0/width,1.0/height);}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){this.renderPassDepth.initialize(renderer,alpha);this.renderPassMask.initialize(renderer,alpha);this.blurPass.initialize(renderer,alpha);}},{key:"resolutionScale",get:function get(){return this.blurPass.resolutionScale;}/**
       * You need to call {@link EffectComposer#setSize} after changing this value.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0.5;this.blurPass.resolutionScale=value;}/**
       * The blur kernel size.
       *
       * @type {KernelSize}
       */},{key:"kernelSize",get:function get(){return this.blurPass.kernelSize;}/**
       * @type {KernelSize}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:KernelSize.VERY_SMALL;this.blurPass.kernelSize=value;}/**
       * Indicates whether the outline overlay should be blurred.
       *
       * @type {Boolean}
       */},{key:"blur",get:function get(){return this.blurPass.enabled;}/**
       * @type {Boolean}
       */,set:function set(value){this.blurPass.enabled=value;this.outlineBlendMaterial.uniforms.tEdges.value=value?this.renderTargetBlurredEdges.texture:this.renderTargetEdges.texture;}/**
       * Indicates whether dithering is enabled.
       *
       * @type {Boolean}
       */},{key:"dithering",get:function get(){return this.blurPass.dithering;}/**
       * If enabled, the result will be dithered to remove banding artifacts.
       *
       * @type {Boolean}
       */,set:function set(value){this.blurPass.dithering=value;}/**
       * Indicates whether the effect should be applied to the input buffer.
       *
       * @type {Boolean}
       */},{key:"blend",get:function get(){return this.needsSwap;}/**
       * If disabled, the input buffer will remain unaffected.
       *
       * You may use the {@link BloomPass#overlay} texture to apply the effect to
       * your scene.
       *
       * @type {Boolean}
       */,set:function set(value){this.needsSwap=value;}/**
       * The effect overlay texture.
       *
       * @type {Texture}
       */},{key:"overlay",get:function get(){return this.outlineBlendMaterial.uniforms.tEdges.value;}}]);inherits(OutlinePass,_Pass);return OutlinePass;}(Pass);/**
   * A pixelation pass.
   */var PixelationPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new pixelation pass.
     *
     * @param {Number} [granularity=30.0] - The intensity of the effect.
     */function PixelationPass(){var _this;var granularity=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30.0;classCallCheck(this,PixelationPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(PixelationPass).call(this,"PixelationPass"));_this.material=new PixelationMaterial();_this.granularity=granularity;return _this;}/**
     * The pixel granularity.
     *
     * @type {Number}
     */createClass(PixelationPass,[{key:"render",/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.material.setResolution(width,height);}},{key:"granularity",get:function get(){return this.material.granularity;}/**
       * A higher value yields coarser visuals.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30;value=Math.floor(value);if(value%2>0){value+=1;}this.material.granularity=value;}}]);inherits(PixelationPass,_Pass);return PixelationPass;}(Pass);/**
   * An advanced Depth of Field (DoF) pass.
   *
   * Yields more realistic results but is also more demanding.
   *
   * This pass requires a {@link EffectComposer#depthTexture}.
   */var RealisticBokehPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new bokeh pass.
     *
     * @param {PerspectiveCamera} camera - The main camera. Used to obtain the focal length and the near and far plane settings.
     * @param {Object} [options] - Additional parameters. See {@link RealisticBokehMaterial} for details.
     */function RealisticBokehPass(camera){var _this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,RealisticBokehPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(RealisticBokehPass).call(this,"RealisticBokehPass"));_this.material=new RealisticBokehMaterial(camera,options);return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(RealisticBokehPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;this.material.uniforms.tDepth.value=inputBuffer.depthTexture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.material.setTexelSize(1.0/width,1.0/height);}}]);inherits(RealisticBokehPass,_Pass);return RealisticBokehPass;}(Pass);/**
   * A pass that renders the result from a previous pass to another render target.
   */var SavePass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new save pass.
     *
     * @param {WebGLRenderTarget} [renderTarget] - The render target to use for saving the input buffer.
     * @param {Boolean} [resize=true] - Whether the render target should adjust to the size of the input buffer.
     */function SavePass(renderTarget){var _this;var resize=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;classCallCheck(this,SavePass);_this=possibleConstructorReturn(this,getPrototypeOf$2(SavePass).call(this,"SavePass"));_this.material=new CopyMaterial();_this.needsSwap=false;/**
       * The render target.
       *
       * @type {WebGLRenderTarget}
       */_this.renderTarget=renderTarget!==undefined?renderTarget:new WebGLRenderTarget(1,1,{minFilter:LinearFilter,magFilter:LinearFilter,stencilBuffer:false,depthBuffer:false});_this.renderTarget.texture.name="Save.Target";_this.renderTarget.texture.generateMipmaps=false;/**
       * Indicates whether the render target should be resized when the size of
       * the composer's frame buffer changes.
       *
       * @type {Boolean}
       */_this.resize=resize;return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(SavePass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderTarget);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){if(this.resize){width=Math.max(1,width);height=Math.max(1,height);this.renderTarget.setSize(width,height);}}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){if(!alpha){this.renderTarget.texture.format=RGBFormat;}}}]);inherits(SavePass,_Pass);return SavePass;}(Pass);/**
   * Half PI.
   *
   * @type {Number}
   * @private
   */var HALF_PI=Math.PI*0.5;/**
   * A vector.
   *
   * @type {Vector3}
   * @private
   */var v=new Vector3();/**
   * A vector.
   *
   * @type {Vector3}
   * @private
   */var ab=new Vector3();/**
   * A shock wave pass.
   */var ShockWavePass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new shock wave pass.
     *
     * @param {Camera} camera - The main camera.
     * @param {Vector3} [epicenter] - The world position of the shock wave epicenter.
     * @param {Object} [options] - The options.
     * @param {Number} [options.speed=1.0] - The animation speed.
     * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.
     * @param {Number} [options.waveSize=0.2] - The wave size.
     * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
     */function ShockWavePass(camera){var _this;var epicenter=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Vector3();var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,ShockWavePass);_this=possibleConstructorReturn(this,getPrototypeOf$2(ShockWavePass).call(this,"ShockWavePass"));/**
       * The main camera.
       *
       * @type {Object3D}
       */_this.mainCamera=camera;/**
       * The epicenter.
       *
       * @type {Vector3}
       * @example shockWavePass.epicenter = myMesh.position;
       */_this.epicenter=epicenter;/**
       * The object position in screen space.
       *
       * @type {Vector3}
       * @private
       */_this.screenPosition=new Vector3();/**
       * The speed of the shock wave animation.
       *
       * @type {Number}
       */_this.speed=options.speed!==undefined?options.speed:2.0;/**
       * A time accumulator.
       *
       * @type {Number}
       * @private
       */_this.time=0.0;/**
       * Indicates whether the shock wave animation is active.
       *
       * @type {Boolean}
       * @private
       */_this.active=false;/**
       * A shock wave shader material.
       *
       * @type {ShockWaveMaterial}
       * @private
       */_this.shockWaveMaterial=new ShockWaveMaterial(options);_this.shockWaveMaterial.uniforms.center.value=_this.screenPosition;/**
       * A copy shader material.
       *
       * @type {CopyMaterial}
       * @private
       */_this.copyMaterial=new CopyMaterial();return _this;}/**
     * Emits the shock wave.
     */createClass(ShockWavePass,[{key:"explode",value:function explode(){this.time=0.0;this.active=true;}/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */},{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var epicenter=this.epicenter;var mainCamera=this.mainCamera;var screenPosition=this.screenPosition;var shockWaveMaterial=this.shockWaveMaterial;var uniforms=shockWaveMaterial.uniforms;var center=uniforms.center;var radius=uniforms.radius;var maxRadius=uniforms.maxRadius;var waveSize=uniforms.waveSize;this.copyMaterial.uniforms.tDiffuse.value=inputBuffer.texture;this.material=this.copyMaterial;if(this.active){// Calculate direction vectors.
  mainCamera.getWorldDirection(v);ab.copy(mainCamera.position).sub(epicenter);// Don't render the effect if the object is behind the camera.
  if(v.angleTo(ab)>HALF_PI){// Scale the effect based on distance to the object.
  uniforms.cameraDistance.value=mainCamera.position.distanceTo(epicenter);// Calculate the screen position of the epicenter.
  screenPosition.copy(epicenter).project(mainCamera);center.value.x=(screenPosition.x+1.0)*0.5;center.value.y=(screenPosition.y+1.0)*0.5;uniforms.tDiffuse.value=inputBuffer.texture;this.material=shockWaveMaterial;}// Update the shock wave radius based on time.
  this.time+=delta*this.speed;radius.value=this.time-waveSize.value;if(radius.value>=(maxRadius.value+waveSize.value)*2){this.active=false;}}renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.shockWaveMaterial.uniforms.aspect.value=width/height;}}]);inherits(ShockWavePass,_Pass);return ShockWavePass;}(Pass);// Generated with SMAASearchImageData.generate().toCanvas().toDataURL(), not cropped, low dynamic range.
  var searchImageDataURL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII";// Generated with SMAAAreaImageData.generate().toCanvas().toDataURL().
  var areaImageDataURL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC";/**
   * Subpixel Morphological Antialiasing (SMAA) v2.8.
   *
   * Preset: SMAA 1x Medium (with color edge detection).
   *  https://github.com/iryoku/smaa/releases/tag/v2.8
   */var SMAAPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new SMAA pass.
     *
     * @param {Image} searchImage - The SMAA search image. Preload this image using the {@link searchImageDataURL}.
     * @param {Image} areaImage - The SMAA area image. Preload this image using the {@link areaImageDataURL}.
     */function SMAAPass(searchImage,areaImage){var _this;classCallCheck(this,SMAAPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(SMAAPass).call(this,"SMAAPass"));/**
       * A clear pass for the color edges buffer.
       *
       * @type {ClearPass}
       * @private
       */_this.clearPass=new ClearPass({clearColor:new Color(0x000000),clearAlpha:1.0});/**
       * A render target for the color edge detection.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetColorEdges=new WebGLRenderTarget(1,1,{minFilter:LinearFilter,format:RGBFormat,stencilBuffer:false,depthBuffer:false});_this.renderTargetColorEdges.texture.name="SMAA.ColorEdges";_this.renderTargetColorEdges.texture.generateMipmaps=false;/**
       * A render target for the SMAA weights.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetWeights=_this.renderTargetColorEdges.clone();_this.renderTargetWeights.texture.name="SMAA.Weights";_this.renderTargetWeights.texture.format=RGBAFormat;/**
       * Color edge detection shader material.
       *
       * @type {ColorEdgesMaterial}
       * @private
       */_this.colorEdgesMaterial=new ColorEdgesMaterial();/**
       * SMAA weights shader material.
       *
       * @type {SMAAWeightsMaterial}
       * @private
       */_this.weightsMaterial=new SMAAWeightsMaterial();_this.weightsMaterial.uniforms.tDiffuse.value=_this.renderTargetColorEdges.texture;/**
       * The SMAA search texture.
       *
       * @type {Texture}
       * @private
       */_this.searchTexture=new Texture(searchImage);_this.searchTexture.name="SMAA.Search";_this.searchTexture.magFilter=NearestFilter;_this.searchTexture.minFilter=NearestFilter;_this.searchTexture.format=RGBAFormat;_this.searchTexture.generateMipmaps=false;_this.searchTexture.needsUpdate=true;_this.searchTexture.flipY=false;_this.weightsMaterial.uniforms.tSearch.value=_this.searchTexture;/**
       * The SMAA area texture.
       *
       * @type {Texture}
       * @private
       */_this.areaTexture=new Texture(areaImage);_this.areaTexture.name="SMAA.Area";_this.areaTexture.minFilter=LinearFilter;_this.areaTexture.format=RGBAFormat;_this.areaTexture.generateMipmaps=false;_this.areaTexture.needsUpdate=true;_this.areaTexture.flipY=false;_this.weightsMaterial.uniforms.tArea.value=_this.areaTexture;/**
       * SMAA blend shader material.
       *
       * @type {SMAABlendMaterial}
       * @private
       */_this.blendMaterial=new SMAABlendMaterial();_this.blendMaterial.uniforms.tWeights.value=_this.renderTargetWeights.texture;return _this;}/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
     * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
     * @param {Number} [delta] - The time between the last frame and the current one in seconds.
     * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
     */createClass(SMAAPass,[{key:"render",value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){// Detect color edges.
  this.material=this.colorEdgesMaterial;this.colorEdgesMaterial.uniforms.tDiffuse.value=inputBuffer.texture;this.clearPass.render(renderer,this.renderTargetColorEdges);renderer.render(this.scene,this.camera,this.renderTargetColorEdges);// Compute edge weights.
  this.material=this.weightsMaterial;renderer.render(this.scene,this.camera,this.renderTargetWeights);// Apply the antialiasing filter to the colors.
  this.material=this.blendMaterial;this.blendMaterial.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Updates the size of this pass.
       *
       * @param {Number} width - The width.
       * @param {Number} height - The height.
       */},{key:"setSize",value:function setSize(width,height){this.renderTargetColorEdges.setSize(width,height);this.renderTargetWeights.setSize(width,height);this.colorEdgesMaterial.uniforms.texelSize.value.copy(this.weightsMaterial.uniforms.texelSize.value.copy(this.blendMaterial.uniforms.texelSize.value.set(1.0/width,1.0/height)));}/**
       * The SMAA search image, encoded as a base64 data URL.
       *
       * Use this image data to create an Image instance and use it together with
       * the area image to create an SMAAPass.
       *
       * @type {String}
       * @example
       * const searchImage = new Image();
       * searchImage.addEventListener("load", progress);
       * searchImage.src = SMAAPass.searchImageDataURL;
       */}],[{key:"searchImageDataURL",get:function get(){return searchImageDataURL;}/**
       * The SMAA area image, encoded as a base64 data URL.
       *
       * Use this image data to create an Image instance and use it together with
       * the search image to create an SMAAPass.
       *
       * @type {String}
       * @example
       * const areaImage = new Image();
       * areaImage.addEventListener("load", progress);
       * areaImage.src = SMAAPass.areaImageDataURL;
       */},{key:"areaImageDataURL",get:function get(){return areaImageDataURL;}}]);inherits(SMAAPass,_Pass);return SMAAPass;}(Pass);/**
   * A pass that renders a given texture.
   */var TexturePass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new texture pass.
     *
     * @param {Texture} texture - The texture.
     * @param {Number} [opacity=1.0] - The texture opacity.
     * @param {Boolean} [screenMode=true] - Whether the screen blend mode should be used for combining the texture with the scene colors.
     */function TexturePass(texture){var _this;var opacity=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1.0;var screenMode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;classCallCheck(this,TexturePass);_this=possibleConstructorReturn(this,getPrototypeOf$2(TexturePass).call(this,"TexturePass"));_this.material=new CombineMaterial(screenMode);_this.texture=texture;_this.opacitySource=opacity;return _this;}/**
     * The texture.
     *
     * @type {Texture}
     */createClass(TexturePass,[{key:"render",/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){this.material.uniforms.texture1.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}},{key:"texture",get:function get(){return this.material.uniforms.texture2.value;}/**
       * @type {Texture}
       */,set:function set(value){this.material.uniforms.texture2.value=value;}/**
       * The opacity of the input buffer.
       *
       * The destination color is the color from the image in the input buffer.
       *
       * @type {Number}
       */},{key:"opacityDestination",get:function get(){return this.material.uniforms.opacity1.value;}/**
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this.material.uniforms.opacity1.value=value;}/**
       * The opacity of the texture.
       *
       * The source color is the color from the texture.
       *
       * @type {Number}
       */},{key:"opacitySource",get:function get(){return this.material.uniforms.opacity2.value;}/**
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1.0;this.material.uniforms.opacity2.value=value;}}]);inherits(TexturePass,_Pass);return TexturePass;}(Pass);/**
   * A tone mapping pass that supports adaptive luminosity.
   *
   * If adaptivity is enabled, this pass generates a texture that represents the
   * luminosity of the current scene and adjusts it over time to simulate the
   * optic nerve responding to the amount of light it is receiving.
   *
   * Reference:
   *  GDC2007 - Wolfgang Engel, Post-Processing Pipeline
   *  http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/GAMA/2007/gdc07/Post-Processing_Pipeline.pdf
   */var ToneMappingPass=/*#__PURE__*/function(_Pass){/**
     * Constructs a new tone mapping pass.
     *
     * @param {Object} [options] - The options.
     * @param {Boolean} [options.adaptive=true] - Whether the tone mapping should use an adaptive luminance map.
     * @param {Number} [options.resolution=256] - The render texture resolution.
     * @param {Number} [options.distinction=1.0] - A luminance distinction factor.
     */function ToneMappingPass(){var _this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,ToneMappingPass);_this=possibleConstructorReturn(this,getPrototypeOf$2(ToneMappingPass).call(this,"ToneMappingPass"));/**
       * The render target for the current luminosity.
       *
       * @type {WebGLRenderTarget}
       * @private
       * @todo Use RED format in WebGL 2.0.
       */_this.renderTargetLuminosity=new WebGLRenderTarget(1,1,{minFilter:LinearMipMapLinearFilter,magFilter:LinearFilter,format:RGBFormat,stencilBuffer:false,depthBuffer:false});_this.renderTargetLuminosity.texture.name="ToneMapping.Luminosity";/**
       * The render target for adapted luminosity.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetAdapted=_this.renderTargetLuminosity.clone();_this.renderTargetAdapted.texture.name="ToneMapping.AdaptedLuminosity";_this.renderTargetAdapted.texture.generateMipmaps=false;_this.renderTargetAdapted.texture.minFilter=LinearFilter;/**
       * A render target that holds a copy of the adapted limonosity.
       *
       * @type {WebGLRenderTarget}
       * @private
       */_this.renderTargetPrevious=_this.renderTargetAdapted.clone();_this.renderTargetPrevious.texture.name="ToneMapping.PreviousLuminosity";/**
       * Copy shader material used for saving the luminance map.
       *
       * @type {CopyMaterial}
       * @private
       */_this.copyMaterial=new CopyMaterial();/**
       * A luminosity shader material.
       *
       * @type {LuminosityMaterial}
       * @private
       */_this.luminosityMaterial=new LuminosityMaterial();_this.luminosityMaterial.uniforms.distinction.value=options.distinction!==undefined?options.distinction:1.0;/**
       * An adaptive luminance shader material.
       *
       * @type {AdaptiveLuminosityMaterial}
       * @private
       */_this.adaptiveLuminosityMaterial=new AdaptiveLuminosityMaterial();_this.resolution=options.resolution;/**
       * A tone mapping shader material.
       *
       * @type {ToneMappingMaterial}
       * @private
       */_this.toneMappingMaterial=new ToneMappingMaterial();_this.adaptive=options.adaptive;return _this;}/**
     * The resolution of the render targets.
     *
     * @type {Number}
     */createClass(ToneMappingPass,[{key:"render",/**
       * Renders the effect.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
       * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
       * @param {Number} [delta] - The time between the last frame and the current one in seconds.
       * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
       */value:function render(renderer,inputBuffer,outputBuffer,delta,stencilTest){var scene=this.scene;var camera=this.camera;var adaptiveLuminosityMaterial=this.adaptiveLuminosityMaterial;var luminosityMaterial=this.luminosityMaterial;var toneMappingMaterial=this.toneMappingMaterial;var copyMaterial=this.copyMaterial;var renderTargetPrevious=this.renderTargetPrevious;var renderTargetLuminosity=this.renderTargetLuminosity;var renderTargetAdapted=this.renderTargetAdapted;if(this.adaptive){// Render the luminance of the current scene into a render target with mipmapping enabled.
  this.material=luminosityMaterial;luminosityMaterial.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(scene,camera,renderTargetLuminosity);// Use the new luminance values, the previous luminance and the frame delta to adapt the luminance over time.
  this.material=adaptiveLuminosityMaterial;adaptiveLuminosityMaterial.uniforms.delta.value=delta;adaptiveLuminosityMaterial.uniforms.tPreviousLum.value=renderTargetPrevious.texture;adaptiveLuminosityMaterial.uniforms.tCurrentLum.value=renderTargetLuminosity.texture;renderer.render(scene,camera,renderTargetAdapted);// Copy the new adapted luminance value so that it can be used by the next frame.
  this.material=copyMaterial;copyMaterial.uniforms.tDiffuse.value=renderTargetAdapted.texture;renderer.render(scene,camera,renderTargetPrevious);}// Apply the tone mapping to the colours.
  this.material=toneMappingMaterial;toneMappingMaterial.uniforms.tDiffuse.value=inputBuffer.texture;renderer.render(this.scene,this.camera,this.renderToScreen?null:outputBuffer);}/**
       * Performs initialization tasks.
       *
       * @param {WebGLRenderer} renderer - The renderer.
       * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
       */},{key:"initialize",value:function initialize(renderer,alpha){this.material=new MeshBasicMaterial({color:0x7fffff});renderer.render(this.scene,this.camera,this.renderTargetPrevious);this.material.dispose();}},{key:"resolution",get:function get(){return this.renderTargetLuminosity.width;}/**
       * The resolution of the render targets. Must be a power of two for mipmaps.
       *
       * @type {Number}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:256;// Round the given value to the next power of two.
  var exponent=Math.max(0,Math.ceil(Math.log2(value)));value=Math.pow(2,exponent);this.renderTargetLuminosity.setSize(value,value);this.renderTargetPrevious.setSize(value,value);this.renderTargetAdapted.setSize(value,value);this.adaptiveLuminosityMaterial.defines.MIP_LEVEL_1X1=exponent.toFixed(1);this.adaptiveLuminosityMaterial.needsUpdate=true;}/**
       * Whether this pass uses adaptive luminosity.
       *
       * @type {Boolean}
       * @default true
       */},{key:"adaptive",get:function get(){return this.toneMappingMaterial.defines.ADAPTED_LUMINANCE!==undefined;}/**
       * Whether this pass should use adaptive luminosity.
       *
       * @type {Boolean}
       */,set:function set(){var value=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;if(value){this.toneMappingMaterial.defines.ADAPTED_LUMINANCE="1";this.toneMappingMaterial.uniforms.luminanceMap.value=this.renderTargetAdapted.texture;}else{delete this.toneMappingMaterial.defines.ADAPTED_LUMINANCE;this.toneMappingMaterial.uniforms.luminanceMap.value=null;}this.toneMappingMaterial.needsUpdate=true;}/**
       * Indicates whether dithering is enabled.
       *
       * @type {Boolean}
       */},{key:"dithering",get:function get(){return this.toneMappingMaterial.dithering;}/**
       * If enabled, the result will be dithered to remove banding artifacts.
       *
       * @type {Boolean}
       */,set:function set(value){if(this.dithering!==value){this.toneMappingMaterial.dithering=value;this.toneMappingMaterial.needsUpdate=true;}}}]);inherits(ToneMappingPass,_Pass);return ToneMappingPass;}(Pass);/**
   * A compilation of the post processing passes.
   *
   * @module postprocessing/passes
   */ /**
   * The EffectComposer may be used in place of a normal WebGLRenderer.
   *
   * The auto clear behaviour of the provided renderer will be disabled to prevent
   * unnecessary clear operations.
   *
   * It is common practice to use a {@link RenderPass} as the first pass to
   * automatically clear the screen and render the scene to a texture for further
   * processing.
   *
   * @implements {Resizable}
   * @implements {Disposable}
   */var EffectComposer=/*#__PURE__*/function(){/**
     * Constructs a new effect composer.
     *
     * @param {WebGLRenderer} [renderer] - The renderer that should be used.
     * @param {Object} [options] - The options.
     * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
     * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
     * @param {Boolean} [options.depthTexture=false] - Set to true if one of your passes relies on a depth texture.
     */function EffectComposer(){var renderer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};classCallCheck(this,EffectComposer);/**
       * The renderer.
       *
       * You may replace the renderer at any time by using
       * {@link EffectComposer#replaceRenderer}.
       *
       * @type {WebGLRenderer}
       */this.renderer=renderer;/**
       * The input buffer.
       *
       * Reading from and writing to the same render target should be avoided.
       * Therefore, two seperate yet identical buffers are used.
       *
       * @type {WebGLRenderTarget}
       * @private
       */this.inputBuffer=null;/**
       * The output buffer.
       *
       * @type {WebGLRenderTarget}
       * @private
       */this.outputBuffer=null;if(this.renderer!==null){this.renderer.autoClear=false;this.inputBuffer=this.createBuffer(options.depthBuffer!==undefined?options.depthBuffer:true,options.stencilBuffer!==undefined?options.stencilBuffer:false,options.depthTexture!==undefined?options.depthTexture:false);this.outputBuffer=this.inputBuffer.clone();}/**
       * A copy pass used for copying masked scenes.
       *
       * @type {ShaderPass}
       * @private
       */this.copyPass=new ShaderPass(new CopyMaterial());/**
       * The passes.
       *
       * @type {Pass[]}
       * @private
       */this.passes=[];}/**
     * The depth texture of the input and output buffers.
     *
     * @type {DepthTexture}
     */createClass(EffectComposer,[{key:"replaceRenderer",/**
       * Replaces the current renderer with the given one. The DOM element of the
       * current renderer will automatically be removed from its parent node and the
       * DOM element of the new renderer will take its place.
       *
       * The auto clear mechanism of the provided renderer will be disabled.
       *
       * Switching between renderers allows you to dynamically enable or disable
       * antialiasing.
       *
       * @param {WebGLRenderer} renderer - The new renderer.
       * @return {WebGLRenderer} The old renderer.
       */value:function replaceRenderer(renderer){var oldRenderer=this.renderer;var parent,oldSize,newSize;if(oldRenderer!==null&&oldRenderer!==renderer){this.renderer=renderer;this.renderer.autoClear=false;parent=oldRenderer.domElement.parentNode;oldSize=oldRenderer.getSize();newSize=renderer.getSize();if(parent!==null){parent.removeChild(oldRenderer.domElement);parent.appendChild(renderer.domElement);}if(oldSize.width!==newSize.width||oldSize.height!==newSize.height){this.setSize();}}return oldRenderer;}/**
       * Creates a new render target by replicating the renderer's canvas.
       *
       * The created render target uses a linear filter for texel minification and
       * magnification. Its render texture format depends on whether the renderer
       * uses the alpha channel. Mipmaps are disabled.
       *
       * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
       * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
       * @param {Boolean} depthTexture - Whether the render target should have a depth texture.
       * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
       */},{key:"createBuffer",value:function createBuffer(depthBuffer,stencilBuffer,depthTexture){var drawingBufferSize=this.renderer.getDrawingBufferSize();var alpha=this.renderer.context.getContextAttributes().alpha;var renderTarget=new WebGLRenderTarget(drawingBufferSize.width,drawingBufferSize.height,{minFilter:LinearFilter,magFilter:LinearFilter,format:alpha?RGBAFormat:RGBFormat,depthBuffer:depthBuffer,stencilBuffer:stencilBuffer,depthTexture:depthTexture?new DepthTexture():null});if(depthTexture&&stencilBuffer){renderTarget.depthTexture.format=DepthStencilFormat;renderTarget.depthTexture.type=UnsignedInt248Type;}renderTarget.texture.name="EffectComposer.Buffer";renderTarget.texture.generateMipmaps=false;return renderTarget;}/**
       * Adds a pass, optionally at a specific index.
       *
       * @param {Pass} pass - A new pass.
       * @param {Number} [index] - An index at which the pass should be inserted.
       */},{key:"addPass",value:function addPass(pass,index){var renderer=this.renderer;var drawingBufferSize=renderer.getDrawingBufferSize();pass.setSize(drawingBufferSize.width,drawingBufferSize.height);pass.initialize(renderer,renderer.context.getContextAttributes().alpha);if(index!==undefined){this.passes.splice(index,0,pass);}else{this.passes.push(pass);}}/**
       * Removes a pass.
       *
       * @param {Pass} pass - The pass.
       */},{key:"removePass",value:function removePass(pass){this.passes.splice(this.passes.indexOf(pass),1);}/**
       * Renders all enabled passes in the order in which they were added.
       *
       * @param {Number} delta - The time between the last frame and the current one in seconds.
       */},{key:"render",value:function render(delta){var passes=this.passes;var copyPass=this.copyPass;var renderer=this.renderer;var inputBuffer=this.inputBuffer;var outputBuffer=this.outputBuffer;var stencilTest=false;var pass,context,state,buffer;var i,l;for(i=0,l=passes.length;i<l;++i){pass=passes[i];if(pass.enabled){pass.render(renderer,inputBuffer,outputBuffer,delta,stencilTest);if(pass.needsSwap){if(stencilTest){copyPass.renderToScreen=pass.renderToScreen;context=renderer.context;state=renderer.state;// Preserve the unaffected pixels.
  state.buffers.stencil.setFunc(context.NOTEQUAL,1,0xffffffff);copyPass.render(renderer,inputBuffer,outputBuffer,delta,stencilTest);state.buffers.stencil.setFunc(context.EQUAL,1,0xffffffff);}buffer=inputBuffer;inputBuffer=outputBuffer;outputBuffer=buffer;}if(pass instanceof MaskPass){stencilTest=true;}else if(pass instanceof ClearMaskPass){stencilTest=false;}}}}/**
       * Sets the size of the buffers and the renderer's output canvas.
       *
       * Every pass will be informed of the new size. It's up to each pass how that
       * information is used.
       *
       * If no width or height is specified, the render targets and passes will be
       * updated with the current size of the renderer.
       *
       * @param {Number} [width] - The width.
       * @param {Number} [height] - The height.
       */},{key:"setSize",value:function setSize(width,height){var passes=this.passes;var renderer=this.renderer;var size,drawingBufferSize;var i,l;if(width===undefined||height===undefined){size=renderer.getSize();width=size.width;height=size.height;}// Update the logical render size.
  renderer.setSize(width,height);// The drawing buffer size takes the device pixel ratio into account.
  drawingBufferSize=renderer.getDrawingBufferSize();this.inputBuffer.setSize(drawingBufferSize.width,drawingBufferSize.height);this.outputBuffer.setSize(drawingBufferSize.width,drawingBufferSize.height);for(i=0,l=passes.length;i<l;++i){passes[i].setSize(drawingBufferSize.width,drawingBufferSize.height);}}/**
       * Resets this composer by deleting all passes and creating new buffers.
       */},{key:"reset",value:function reset(){var renderTarget=this.createBuffer(this.inputBuffer.depthBuffer,this.inputBuffer.stencilBuffer,this.inputBuffer.depthTexture!==null);this.dispose();// Reanimate.
  this.inputBuffer=renderTarget;this.outputBuffer=renderTarget.clone();this.copyPass=new ShaderPass(new CopyMaterial());}/**
       * Destroys this composer and all passes.
       *
       * This method deallocates all disposable objects created by the passes. It
       * also deletes the main frame buffers of this composer.
       */},{key:"dispose",value:function dispose(){var passes=this.passes;var i,l;for(i=0,l=passes.length;i<l;++i){passes[i].dispose();}this.passes=[];if(this.inputBuffer!==null){this.inputBuffer.dispose();this.inputBuffer=null;}if(this.outputBuffer!==null){this.outputBuffer.dispose();this.outputBuffer=null;}this.copyPass.dispose();}},{key:"depthTexture",get:function get(){return this.inputBuffer.depthTexture;}/**
       * The input and output buffers share a single depth texture. Depth will be
       * written to this texture when something is rendered into one of the buffers
       * and the involved materials have depth write enabled.
       *
       * You may enable this mechanism during the instantiation of the composer or
       * by assigning a DepthTexture instance later on. You may also disable it by
       * assigning null.
       *
       * @type {DepthTexture}
       */,set:function set(x){this.inputBuffer.depthTexture=x;this.outputBuffer.depthTexture=x;}}]);return EffectComposer;}();var polyfill=function polyfill(object,method){var showWarn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;if(object[method])return;if(showWarn)console.warn("@PostProcessorModule: pass.".concat(method,"() was not found."),object);object[method]=function(){};};/**
   * @class PostProcessorModule
   * @category modules/app
   * @param {Object} [params]
   * @memberof module:modules/app
   * @example <caption> Creating a rendering module and passing it to App's modules</caption>
   * new App([
   *   new ElementModule(),
   *   new SceneModule(),
   *   new DefineModule('camera', new WHS.PerspectiveCamera({
   *     position: new THREE.Vector3(0, 6, 18),
   *     far: 10000
   *   })),
   *   new RenderingModule(),
   *   new PostProcessorModule()
   * ]);
   *
   * const processor = app.use('postprocessor');
   *
   * processor
   *   .render()
   *   .pass(new GlitchPass())
   *   .renderToScreen()
   */var PostProcessorModule=/*#__PURE__*/function(){function PostProcessorModule(){var _this=this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:PostProcessorModule.defaults;classCallCheck(this,PostProcessorModule);defineProperty$3(defineProperty$3(this,"currentPass",null),"defer",new Promise(function(resolve){_this.resolve=resolve;}));this.debug=params.debug;this.params=params;}createClass(PostProcessorModule,[{key:"manager",value:function manager(_manager){var _this2=this;_manager.define('postprocessor');this.effects=_manager.use('rendering').effects;this.renderer=_manager.get('renderer');this.scene=_manager.get('scene');this.camera=_manager.get('camera');this.composer=new EffectComposer(this.renderer,this.params);_manager.use('rendering').stop();var composer=this.composer;this.renderLoop=new Loop(function(clock){return composer.render(clock.getDelta());}).start(_manager.handler);_manager.update({renderer:function renderer(_renderer){_this2.composer.replaceRenderer(_renderer);},scene:function scene(_scene){_this2.scene=_scene;},camera:function camera(_camera){_this2.camera=_camera;}});this.resolve();}/**
       * @method render
       * @description Adds RenderPass
       * @return {this}
       * @memberof module:modules/app.PostProcessorModule
       */},{key:"render",value:function render(){var _this3=this;this.defer.then(function(){var pass=new RenderPass(_this3.scene,_this3.camera.native);// TODO: Support for effects.
  _this3.composer.addPass(pass);_this3.currentPass=pass;});return this;}/**
       * @method pass
       * @description Adds your custom pass
       * @param {Pass} pass A custom pass
       * @return {this}
       * @memberof module:modules/app.PostProcessorModule
       */},{key:"pass",value:function pass(_pass){var _this4=this;this.defer.then(function(){polyfill(_pass,'setSize',_this4.debug);polyfill(_pass,'initialise',_this4.debug);_this4.composer.addPass(_pass);_this4.currentPass=_pass;});return this;}/**
       * @method shader
       * @description Adds a pass made from shader material
       * @param {Material} material A ShaderMaterial
       * @param {String} textureID Name of the readBuffer uniform
       * @return {this}
       * @memberof module:modules/app.PostProcessorModule
       */},{key:"shader",value:function shader(material){var _this5=this;var textureID=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'readBuffer';this.defer.then(function(){if(!material.uniforms[textureID])material.uniforms[textureID]={value:null};var pass=new ShaderPass(material,textureID);_this5.composer.addPass(pass);_this5.currentPass=pass;});return this;}/**
       * @method get
       * @description Returns a pass by the given name
       * @param {String} name The name of the pass
       * @return {this}
       * @memberof module:modules/app.PostProcessorModule
       */},{key:"get",value:function get(name){return name?this.composer.passes.filter(function(pass){return pass.name===name;})[0]:this.currentPass;}/**
       * @method renderToScreen
       * @description Sets the renderToScreen property of currentPass
       * @param {String} [name=true] The name of the pass
       * @return {this}
       * @memberof module:modules/app.PostProcessorModule
       */},{key:"renderToScreen",value:function renderToScreen(){var _this6=this;var bool=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.defer.then(function(){_this6.currentPass.renderToScreen=bool;});return this;}}]);return PostProcessorModule;}();defineProperty$3(PostProcessorModule,"defaults",{debug:true});/**
   * @class EventsPatchModule
   * @description This one is used in the core to handle events used by modules. If you want to make custom events - please make a similar one.
   * @category modules/app
   * @memberof module:modules/app
   */var EventsPatchModule=/*#__PURE__*/function(){function EventsPatchModule(){classCallCheck(this,EventsPatchModule);}createClass(EventsPatchModule,[{key:"manager",value:function manager(_manager){_manager.define('events');this.element=_manager.get('renderer').domElement;}/**
       * @function patchEvents
       * @description This methods patches the list of events on specific object.
       * @param {Number} originObject - The object that gives events.
       * @param {Number} [destObject=this] - The object that takes events.
       * @param {Array[Strings]} [events=[]] - The list of events by names.
       * @memberof module:modules/app.EventsPatchModule
       */},{key:"patchEvents",value:function patchEvents(originObject){var destObject=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this;var events=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];events.forEach(function(event){return originObject.addEventListener(event,function(e){return destObject.emit(event,e);});});}},{key:"integrate",value:function integrate(self){var element=self.element,patchEvents=self.patchEvents;patchEvents(element,this,['mousemove','mouseup','contextmenu','mousedown','click','wheel','touchstart','touchend','touchmove','keydown','keyup','keypress']);}}]);return EventsPatchModule;}();/**
   * @class VirtualMouseModule
   * @category modules/app
   * @param {Boolean} [globalMovement=false]
   * @memberof module:modules/app
   * @extends Events
   */var VirtualMouseModule=/*#__PURE__*/function(_Events){function VirtualMouseModule(){var _this;var globalMovement=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;classCallCheck(this,VirtualMouseModule);_this=possibleConstructorReturn(this,getPrototypeOf$2(VirtualMouseModule).call(this));defineProperty$3(defineProperty$3(defineProperty$3(defineProperty$3(defineProperty$3(assertThisInitialized(assertThisInitialized(_this)),"mouse",new Vector2()),"raycaster",new Raycaster()),"world",null),"canvas",null),"projectionPlane",new Plane(new Vector3(0,0,1),0));_this.globalMovement=globalMovement;return _this;}createClass(VirtualMouseModule,[{key:"update",value:function update(e,customX,customY){var rect=this.canvas.getBoundingClientRect();var x=customX||e.clientX;var y=customY||e.clientY;this.mouse.x=(x-rect.left)/(rect.right-rect.left)*2-1;this.mouse.y=-((y-rect.top)/(rect.bottom-rect.top))*2+1;this.projectionPlane.normal.copy(this.camera.getWorldDirection());this.raycaster.setFromCamera(this.mouse,this.camera);this.emit('move');}},{key:"manager",value:function manager(_manager){_manager.define('mouse');_manager.require('events',function(){return new EventsPatchModule();});this.canvas=_manager.get('renderer').domElement;this.camera=_manager.get('camera').native;}},{key:"integrate",value:function integrate(self){var _this2=this;['click','mousedown','mouseup','mousemove'].forEach(function(ev){return _this2.on(ev,function(e){return self.emit(ev,e);});});self.globalX=0;self.globalY=0;this.on('mousemove',function(e){if(document.pointerLockElement!==null){self.globalX+=e.movementX;self.globalY+=e.movementY;self.update(e,self.globalX,self.globalY);}else self.update(e);});}/**
       * @method track
       * @description Starts tracking events on a component
       * @param {Component} component A component, that should be tracked by the mouse
       * @param {Boolean} nested Whether component's children should be tracked or not
       * @memberof module:modules/app.VirtualMouseModule
       */},{key:"track",value:function track(component){var _this3=this;var nested=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var isHovered=false;this.on('move',function(){if(_this3.hovers(component,nested)){if(isHovered)component.emit('mousemove');else{component.emit('mouseover');isHovered=true;}}else if(isHovered){component.emit('mouseout');isHovered=false;}});this.on('click',function(){if(isHovered)component.emit('click');else component.emit('offClick');});this.on('mousedown',function(){if(isHovered)component.emit('mousedown');});this.on('mouseup',function(){if(isHovered)component.emit('mouseup');});}/**
       * @method intersection
       * @description Returns an intersection data
       * @param {Component} component A component that intersects with mouse ray (or doesn't)
       * @param {Boolean} nested Whether component's children should be tracked or not
       * @return {Array} intersection data.
       * @memberof module:modules/app.VirtualMouseModule
       */},{key:"intersection",value:function intersection(_ref){var native=_ref.native;var nested=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(native.children.length>0&&nested){var objects=[];native.traverse(function(child){return objects.push(child);});return this.raycaster.intersectObjects(objects);}return this.raycaster.intersectObject(native);}/**
       * @method project
       * @description Returns a vector based on mouse ray intersection with plane
       * @param {THREE.Plane} [plane=this.projectionPlane] Math plane that is used
       * @param {Vector3} [target] Optional target
       * @return {Vector3} An intersection point.
       * @memberof module:modules/app.VirtualMouseModule
       */},{key:"project",value:function project(){var plane=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.projectionPlane;var target=arguments.length>1?arguments[1]:undefined;return this.raycaster.ray.intersectPlane(plane,target);}/**
       * @method hovers
       * @description Returns a boolean based on intersection data (Whether mouse hovers the component)
       * @param {Component} component A component that intersects with mouse ray (or doesn't)
       * @param {Boolean} nested Whether component's children should be tracked or not
       * @return {Boolean} Whether the component is hovered.
       * @memberof module:modules/app.VirtualMouseModule
       */},{key:"hovers",value:function hovers(component){var nested=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.intersection(component,nested).length>0;}/**
       * Mouse ray
       * @member {THREE.Ray} module:modules/app.VirtualMouseModule#ray
       * @public
       */},{key:"ray",get:function get(){return this.raycaster.ray;}/**
       * Mouse x [-1; 1]
       * @member {Number} module:modules/app.VirtualMouseModule#x
       * @public
       */},{key:"x",get:function get(){return this.mouse.x;}/**
       * Mouse y [-1; 1]
       * @member {Number} module:modules/app.VirtualMouseModule#y
       * @public
       */},{key:"y",get:function get(){return this.mouse.y;}}]);inherits(VirtualMouseModule,_Events);return VirtualMouseModule;}(minivents_commonjs);/**
   * @class ControlsModule
   * @category modules/app
   * @param {Object} [params]
   * @memberof module:modules/app
   * @example <caption> Creating a rendering module and passing it to App's modules</caption>
   * new App([
   *   new ElementModule(),
   *   new SceneModule(),
   *   new DefineModule('camera', new WHS.PerspectiveCamera({
   *     position: new THREE.Vector3(0, 6, 18),
   *     far: 10000
   *   })),
   *   new RenderingModule(),
   *   new ControlsModule.from(new THREE.TrackballControls())
   * ]);
   */var ControlsModule=/*#__PURE__*/function(){createClass(ControlsModule,null,[{key:"from",value:function from(controls){return new ControlsModule({controls:controls});}}]);function ControlsModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,ControlsModule);this.params=Object.assign({controls:false,fix:function fix(controls){return controls;},update:function update(c){this.controls.update(c.getDelta());}},params);this.controls=this.params.controls;this.update=this.params.update;}createClass(ControlsModule,[{key:"manager",value:function manager(_manager){_manager.define('controls');_manager.require('events',function(){return new EventsPatchModule();});}/**
       * @method setControls
       * @description Set working controls
       * @param {Object} controls Working three.js controls object.
       * @return {this}
       * @memberof module:modules/app.ControlsModule
       */},{key:"setControls",value:function setControls(controls){this.controls=controls;return this;}/**
       * @method setUpdate
       * @description Set controls update function
       * @param {Function} update Update function
       * @return {this}
       * @memberof module:modules/app.ControlsModule
       */},{key:"setUpdate",value:function setUpdate(update){this.update=update;return this;}},{key:"integrate",value:function integrate(self){self.updateLoop=new Loop(self.update.bind(self));self.updateLoop.start(this);}}]);return ControlsModule;}();/**
   * @class FogModule
   * @category modules/app
   * @param {Object} [params={color: 0xefd1b5, density: 0.020, near: 10, far: 1000}] - The parameters object.
   * @param {String} [type=exp2] - The type of fog - exp2 or linear
   * @memberof module:modules/app
   * @example <caption>How to create and apply a FogModule</caption>
   * const fogModule = new FogModule({
   *    color: 0xffffff,
   *    density: 0.03,
   *    near: 20,
   *    far: 200
   *  }, 'exp2');
   *
   * new App([
   *  ...,
   *  fogModule
   * ]);
   */var FogModule=/*#__PURE__*/function(){function FogModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var type=arguments.length>1?arguments[1]:undefined;classCallCheck(this,FogModule);this.params=Object.assign({color:0xefd1b5,density:0.020,near:10,far:1000},params);if(!type||type==='exp2')this.fog=new FogExp2(this.params.color,this.params.density);else if(type==='linear')this.fog=new Fog(this.params.color,this.params.near,this.params.far);}createClass(FogModule,[{key:"manager",value:function manager(_manager){_manager.set('fog',this.fog);_manager.get('scene').fog=this.fog;}}]);return FogModule;}();var isEqualDefault=function isEqualDefault(a,b){if(a===b)return true;else if(a&&a.equals&&a.equals(b))return true;return false;};/**
   * @class StateModule
   * @description `StateModule` is useful for apps, where you need state manipulation.
   * This can be: _transitions between screens, games, development moments_.
   * You can check [basic/state](https://whs-dev.surge.sh/examples/?basic/state) example.
   * @category modules/app
   * @param {Object} [params]
   * @memberof module:modules/app
   * @example <caption> Creating a state module</caption>
   * new App([
   *   // ...
   *   new StateModule().default({
   *     sphereColor: 0xff0000
   *   })
   * ]);
   */var StateModule=/*#__PURE__*/function(){createClass(StateModule,null,[{key:"actionGenerate",value:function actionGenerate(isEqual){return function(){var state=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[{},''];var _ref=arguments.length>1?arguments[1]:undefined,key=_ref.key,data=_ref.data;if(isEqual(state[0][key],data))return state;state[0][key]=data;state[1]=key;return state;};}}]);function StateModule(){var equalCheck=arguments.length>0&&arguments[0]!==undefined?arguments[0]:isEqualDefault;classCallCheck(this,StateModule);this.store=createStore(StateModule.actionGenerate(equalCheck));this.configuration={};this.currentConfig='default';this.prevConfig='default';}/**
     * @method default
     * @description Add default configuration.
     * @param {Object} data Configuration setup
     * @memberof module:modules/app.StateModule
     * @example
     * new WHS.StateModule().default({
     *   sphereColor: UTILS.$colors.mesh,
     *   planeColor: 0x447F8B
     * })
     */createClass(StateModule,[{key:"default",value:function _default(data){this.config({default:data});return this;}/**
       * @method setEqualCheck
       * @description Sets an equalCheck function
       * @param {Function} func function to generate equal check
       * @memberof module:modules/app.StateModule
       */},{key:"setEqualCheck",value:function setEqualCheck(func){this.store.replaceReducer(StateModule.actionGenerate(func));}},{key:"manager",value:function manager(_manager){_manager.define('state');}/**
       * @method config
       * @description Load configurations from object.
       * @param {Object} configs Configuration data
       * @memberof module:modules/app.StateModule
       * @example <caption> Adding `green` configuration</caption>
       * state.config({
       *   green: {
       *     sphereColor: 0x00ff00,
       *     planeColor: 0x00ff00
       *   }
       * });
       */},{key:"config",value:function config(configs){for(var key in configs){if(key){this.configuration[key]=key==='default'?configs[key]:Object.assign({},this.configuration.default,configs[key]);}}}/**
       * @method update
       * @description Load updates from object.
       * @param {Object} updates Updates data
       * @memberof module:modules/app.StateModule
       * @example <caption> Update callback for `sphereColor`</caption>
       * state.update({
       *   sphereColor: color => sphere.material.color.setHex(color)
       * });
       */},{key:"update",value:function update(){var _this=this;var updates=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.store.subscribe(function(){var _this$store$getState=_this.store.getState(),_this$store$getState2=slicedToArray(_this$store$getState,2),data=_this$store$getState2[0],changedKey=_this$store$getState2[1];var callback=updates[changedKey];if(callback)callback(data[changedKey]);});}/**
       * @method to
       * @description Switch to configuration.
       * @param {String} configName Configuration name.
       * @memberof module:modules/app.StateModule
       * @example <caption> Changes configuration to `green`</caption>
       * state.to('green');
       */},{key:"to",value:function to(configName){this.prevConfig=this.currentConfig;this.currentConfig=configName;var config=this.configuration[configName]?this.configuration[configName]:this.configuration.default;this.set(config);}/**
       * @method set
       * @description Set current parameters.
       * @param {Object} data Configuration parameters.
       * @memberof module:modules/app.StateModule
       * @example
       * state.set({
       *   sphereColor: 0x00ff00
       * });
       */},{key:"set",value:function set(data){for(var key in data){if(key)this.store.dispatch({type:'ADD',key:key,data:data[key]});}}/**
       * @method get
       * @description Return data of parameter.
       * @param {String} key Parameter name.
       * @memberof module:modules/app.StateModule
       * @example
       * state.get('sphereColor'); // 0x00ff00
       */},{key:"get",value:function get(key){return this.store.getState()[0][key];}/**
       * @method prev
       * @description Return `trueVal` if `config` match previous configuration, in other case - return `falseVal`.
       * @param {String} config Configuration name.
       * @param {Any} trueVal Value returned if condition is truthy.
       * @param {Any} falseVal Value returned if condition is falsy.
       * @memberof module:modules/app.StateModule
       */},{key:"prev",value:function prev(config,trueVal,falseVal){return this.prevConfig===config?trueVal:falseVal;}/**
       * @method current
       * @description Return `trueVal` if `config` match current configuration, in other case - return `falseVal`.
       * @param {String} config Configuration name.
       * @param {Any} trueVal Value returned if condition is truthy.
       * @param {Any} falseVal Value returned if condition is falsy.
       * @memberof module:modules/app.StateModule
       */},{key:"current",value:function current(config,trueVal,falseVal){return this.currentConfig===config?trueVal:falseVal;}}]);return StateModule;}();// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
  //
  //    Orbit - left mouse / touch: one finger move
  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
  //    Pan - right mouse, or arrow keys / touch: three finter swipe
  var ThreeOrbitControls=/*#__PURE__*/function(_EventDispatcher){function ThreeOrbitControls(object,domElement,eventHandler){var _this;classCallCheck(this,ThreeOrbitControls);_this=possibleConstructorReturn(this,getPrototypeOf$2(ThreeOrbitControls).call(this));_this.object=object;_this.domElement=domElement===undefined?document:domElement;_this.eventHandler=eventHandler;// Set to false to disable this control
  _this.enabled=true;// "target" sets the location of focus, where the object orbits around
  _this.target=new Vector3();// How far you can dolly in and out ( PerspectiveCamera only )
  _this.minDistance=0;_this.maxDistance=Infinity;// How far you can zoom in and out ( OrthographicCamera only )
  _this.minZoom=0;_this.maxZoom=Infinity;// How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.
  _this.minPolarAngle=0;// radians
  _this.maxPolarAngle=Math.PI;// radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
  _this.minAzimuthAngle=-Infinity;// radians
  _this.maxAzimuthAngle=Infinity;// radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop
  _this.enableDamping=false;_this.dampingFactor=0.25;// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming
  _this.enableZoom=true;_this.zoomSpeed=1.0;// Set to false to disable rotating
  _this.enableRotate=true;_this.rotateSpeed=1.0;// Set to false to disable panning
  _this.enablePan=true;_this.keyPanSpeed=7.0;// pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop
  _this.autoRotate=false;_this.autoRotateSpeed=2.0;// 30 seconds per round when fps is 60
  // Set to false to disable use of the keys
  _this.enableKeys=true;// The four arrow keys
  _this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40};// Mouse buttons
  _this.mouseButtons={ORBIT:MOUSE.LEFT,ZOOM:MOUSE.MIDDLE,PAN:MOUSE.RIGHT};// for reset
  _this.target0=_this.target.clone();_this.position0=_this.object.position.clone();_this.zoom0=_this.object.zoom;//
  // public methods
  //
  _this.getPolarAngle=function(){return spherical.phi;};_this.getAzimuthalAngle=function(){return spherical.theta;};_this.reset=function(){_this.target.copy(_this.target0);_this.object.position.copy(_this.position0);_this.object.zoom=_this.zoom0;_this.object.updateProjectionMatrix();_this.dispatchEvent(changeEvent);_this.update();state=STATE.NONE;};// this method is exposed, but perhaps it would be better if we can make it private...
  _this.update=function(){var offset=new Vector3();// so camera.up is the orbit axis
  var quat=new Quaternion().setFromUnitVectors(object.up,new Vector3(0,1,0));var quatInverse=quat.clone().inverse();var lastPosition=new Vector3();var lastQuaternion=new Quaternion();return function(){var position=_this.object.position;offset.copy(position).sub(_this.target);// rotate offset to "y-axis-is-up" space
  offset.applyQuaternion(quat);// angle from z-axis around y-axis
  spherical.setFromVector3(offset);if(_this.autoRotate&&state===STATE.NONE)rotateLeft(getAutoRotationAngle());spherical.theta+=sphericalDelta.theta;spherical.phi+=sphericalDelta.phi;// restrict theta to be between desired limits
  spherical.theta=Math.max(_this.minAzimuthAngle,Math.min(_this.maxAzimuthAngle,spherical.theta));// restrict phi to be between desired limits
  spherical.phi=Math.max(_this.minPolarAngle,Math.min(_this.maxPolarAngle,spherical.phi));spherical.makeSafe();spherical.radius*=scale;// restrict radius to be between desired limits
  spherical.radius=Math.max(_this.minDistance,Math.min(_this.maxDistance,spherical.radius));// move target to panned location
  _this.target.add(panOffset);offset.setFromSpherical(spherical);// rotate offset back to "camera-up-vector-is-up" space
  offset.applyQuaternion(quatInverse);position.copy(_this.target).add(offset);_this.object.lookAt(_this.target);if(_this.enableDamping===true){sphericalDelta.theta*=1-_this.dampingFactor;sphericalDelta.phi*=1-_this.dampingFactor;}else sphericalDelta.set(0,0,0);scale=1;panOffset.set(0,0,0);// update condition is:
  // min(camera displacement, camera rotation in radians)^2 > EPS
  // using small-angle approximation cos(x/2) = 1 - x^2 / 8
  if(zoomChanged||lastPosition.distanceToSquared(_this.object.position)>EPS||8*(1-lastQuaternion.dot(_this.object.quaternion))>EPS){_this.dispatchEvent(changeEvent);lastPosition.copy(_this.object.position);lastQuaternion.copy(_this.object.quaternion);zoomChanged=false;return true;}return false;}();};_this.dispose=function(){_this.domElement.removeEventListener('contextmenu',onContextMenu,false);_this.domElement.removeEventListener('mousedown',onMouseDown,false);_this.domElement.removeEventListener('wheel',onMouseWheel,false);_this.domElement.removeEventListener('touchstart',onTouchStart,false);_this.domElement.removeEventListener('touchend',onTouchEnd,false);_this.domElement.removeEventListener('touchmove',onTouchMove,false);document.removeEventListener('mousemove',onMouseMove,false);document.removeEventListener('mouseup',onMouseUp,false);window.removeEventListener('keydown',onKeyDown,false);// this.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  };//
  // internals
  //
  var changeEvent={type:'change'};var startEvent={type:'start'};var endEvent={type:'end'};var STATE={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5};var state=STATE.NONE;var EPS=0.000001;// current position in spherical coordinates
  var spherical=new Spherical();var sphericalDelta=new Spherical();var scale=1;var panOffset=new Vector3();var zoomChanged=false;var rotateStart=new Vector2();var rotateEnd=new Vector2();var rotateDelta=new Vector2();var panStart=new Vector2();var panEnd=new Vector2();var panDelta=new Vector2();var dollyStart=new Vector2();var dollyEnd=new Vector2();var dollyDelta=new Vector2();var getAutoRotationAngle=function getAutoRotationAngle(){return 2*Math.PI/60/60*_this.autoRotateSpeed;};var getZoomScale=function getZoomScale(){return Math.pow(0.95,_this.zoomSpeed);};var rotateLeft=function rotateLeft(angle){sphericalDelta.theta-=angle;};var rotateUp=function rotateUp(angle){sphericalDelta.phi-=angle;};var panLeft=function(){var v=new Vector3();return function(distance,objectMatrix){v.setFromMatrixColumn(objectMatrix,0);// get X column of objectMatrix
  v.multiplyScalar(-distance);panOffset.add(v);};}();var panUp=function(){var v=new Vector3();return function(distance,objectMatrix){v.setFromMatrixColumn(objectMatrix,1);// get Y column of objectMatrix
  v.multiplyScalar(distance);panOffset.add(v);};}();// deltaX and deltaY are in pixels; right and down are positive
  var pan=function(){var offset=new Vector3();return function(deltaX,deltaY){var element=_this.domElement===document?_this.domElement.body:_this.domElement;if(_this.object instanceof PerspectiveCamera){// perspective
  var position=_this.object.position;offset.copy(position).sub(_this.target);var targetDistance=offset.length();// half of the fov is center to top of screen
  targetDistance*=Math.tan(_this.object.fov/2*Math.PI/180.0);// we actually don't use screenWidth, since perspective camera is fixed to screen height
  panLeft(2*deltaX*targetDistance/element.clientHeight,_this.object.matrix);panUp(2*deltaY*targetDistance/element.clientHeight,_this.object.matrix);}else if(_this.object instanceof OrthographicCamera){// orthographic
  panLeft(deltaX*(_this.object.right-_this.object.left)/_this.object.zoom/element.clientWidth,_this.object.matrix);panUp(deltaY*(_this.object.top-_this.object.bottom)/_this.object.zoom/element.clientHeight,_this.object.matrix);}else{// camera neither orthographic nor perspective
  console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - pan disabled.');_this.enablePan=false;}};}();var dollyIn=function dollyIn(dollyScale){if(_this.object instanceof PerspectiveCamera)scale/=dollyScale;else if(_this.object instanceof OrthographicCamera){_this.object.zoom=Math.max(_this.minZoom,Math.min(_this.maxZoom,_this.object.zoom*dollyScale));_this.object.updateProjectionMatrix();zoomChanged=true;}else{console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');_this.enableZoom=false;}};var dollyOut=function dollyOut(dollyScale){if(_this.object instanceof PerspectiveCamera)scale*=dollyScale;else if(_this.object instanceof OrthographicCamera){_this.object.zoom=Math.max(_this.minZoom,Math.min(_this.maxZoom,_this.object.zoom/dollyScale));_this.object.updateProjectionMatrix();zoomChanged=true;}else{console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');_this.enableZoom=false;}};//
  // event callbacks - update the object state
  //
  var handleMouseDownRotate=function handleMouseDownRotate(event){// console.log( 'handleMouseDownRotate' );
  rotateStart.set(event.clientX,event.clientY);};var handleMouseDownDolly=function handleMouseDownDolly(event){// console.log( 'handleMouseDownDolly' );
  dollyStart.set(event.clientX,event.clientY);};var handleMouseDownPan=function handleMouseDownPan(event){// console.log( 'handleMouseDownPan' );
  panStart.set(event.clientX,event.clientY);};var handleMouseMoveRotate=function handleMouseMoveRotate(event){// console.log( 'handleMouseMoveRotate' );
  rotateEnd.set(event.clientX,event.clientY);rotateDelta.subVectors(rotateEnd,rotateStart);var element=_this.domElement===document?_this.domElement.body:_this.domElement;// rotating across whole screen goes 360 degrees around
  rotateLeft(2*Math.PI*rotateDelta.x/element.clientWidth*_this.rotateSpeed);// rotating up and down along whole screen attempts to go 360, but limited to 180
  rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight*_this.rotateSpeed);rotateStart.copy(rotateEnd);_this.update();};var handleMouseMoveDolly=function handleMouseMoveDolly(event){// console.log( 'handleMouseMoveDolly' );
  dollyEnd.set(event.clientX,event.clientY);dollyDelta.subVectors(dollyEnd,dollyStart);if(dollyDelta.y>0)dollyIn(getZoomScale());else if(dollyDelta.y<0)dollyOut(getZoomScale());dollyStart.copy(dollyEnd);_this.update();};var handleMouseMovePan=function handleMouseMovePan(event){// console.log( 'handleMouseMovePan' );
  panEnd.set(event.clientX,event.clientY);panDelta.subVectors(panEnd,panStart);pan(panDelta.x,panDelta.y);panStart.copy(panEnd);_this.update();};var handleMouseWheel=function handleMouseWheel(event){// console.log( 'handleMouseWheel' );
  if(event.deltaY<0)dollyOut(getZoomScale());else if(event.deltaY>0)dollyIn(getZoomScale());_this.update();};var handleKeyDown=function handleKeyDown(event){// console.log( 'handleKeyDown' );
  switch(event.keyCode){case _this.keys.UP:pan(0,_this.keyPanSpeed);_this.update();break;case _this.keys.BOTTOM:pan(0,-_this.keyPanSpeed);_this.update();break;case _this.keys.LEFT:pan(_this.keyPanSpeed,0);_this.update();break;case _this.keys.RIGHT:pan(-_this.keyPanSpeed,0);_this.update();break;}};var handleTouchStartRotate=function handleTouchStartRotate(event){// console.log( 'handleTouchStartRotate' );
  rotateStart.set(event.touches[0].pageX,event.touches[0].pageY);};var handleTouchStartDolly=function handleTouchStartDolly(event){// console.log( 'handleTouchStartDolly' );
  var dx=event.touches[0].pageX-event.touches[1].pageX;var dy=event.touches[0].pageY-event.touches[1].pageY;var distance=Math.sqrt(dx*dx+dy*dy);dollyStart.set(0,distance);};var handleTouchStartPan=function handleTouchStartPan(event){// console.log( 'handleTouchStartPan' );
  panStart.set(event.touches[0].pageX,event.touches[0].pageY);};var handleTouchMoveRotate=function handleTouchMoveRotate(event){// console.log( 'handleTouchMoveRotate' );
  rotateEnd.set(event.touches[0].pageX,event.touches[0].pageY);rotateDelta.subVectors(rotateEnd,rotateStart);var element=_this.domElement===document?_this.domElement.body:_this.domElement;// rotating across whole screen goes 360 degrees around
  rotateLeft(2*Math.PI*rotateDelta.x/element.clientWidth*_this.rotateSpeed);// rotating up and down along whole screen attempts to go 360, but limited to 180
  rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight*_this.rotateSpeed);rotateStart.copy(rotateEnd);_this.update();};var handleTouchMoveDolly=function handleTouchMoveDolly(event){// console.log( 'handleTouchMoveDolly' );
  var dx=event.touches[0].pageX-event.touches[1].pageX;var dy=event.touches[0].pageY-event.touches[1].pageY;var distance=Math.sqrt(dx*dx+dy*dy);dollyEnd.set(0,distance);dollyDelta.subVectors(dollyEnd,dollyStart);if(dollyDelta.y>0)dollyOut(getZoomScale());else if(dollyDelta.y<0)dollyIn(getZoomScale());dollyStart.copy(dollyEnd);_this.update();};var handleTouchMovePan=function handleTouchMovePan(event){// console.log( 'handleTouchMovePan' );
  panEnd.set(event.touches[0].pageX,event.touches[0].pageY);panDelta.subVectors(panEnd,panStart);pan(panDelta.x,panDelta.y);panStart.copy(panEnd);_this.update();};// event handlers - FSM: listen for events and reset state
  //
  var onMouseDown=function onMouseDown(event){if(_this.enabled===false)return;event.preventDefault();if(event.button===_this.mouseButtons.ORBIT){if(_this.enableRotate===false)return;handleMouseDownRotate(event);state=STATE.ROTATE;}else if(event.button===_this.mouseButtons.ZOOM){if(_this.enableZoom===false)return;handleMouseDownDolly(event);state=STATE.DOLLY;}else if(event.button===_this.mouseButtons.PAN){if(_this.enablePan===false)return;handleMouseDownPan(event);state=STATE.PAN;}if(state!==STATE.NONE){_this.eventHandler.on('mousemove',onMouseMove,false);_this.eventHandler.on('mouseup',onMouseUp,false);_this.dispatchEvent(startEvent);}};var onMouseMove=function onMouseMove(event){if(_this.enabled===false)return;event.preventDefault();if(state===STATE.ROTATE){if(_this.enableRotate===false)return;handleMouseMoveRotate(event);}else if(state===STATE.DOLLY){if(_this.enableZoom===false)return;handleMouseMoveDolly(event);}else if(state===STATE.PAN){if(_this.enablePan===false)return;handleMouseMovePan(event);}};var onMouseUp=function onMouseUp(event){if(_this.enabled===false)return;document.removeEventListener('mousemove',onMouseMove,false);document.removeEventListener('mouseup',onMouseUp,false);_this.dispatchEvent(endEvent);state=STATE.NONE;};var onMouseWheel=function onMouseWheel(event){if(_this.enabled===false||_this.enableZoom===false||state!==STATE.NONE&&state!==STATE.ROTATE)return;event.preventDefault();event.stopPropagation();handleMouseWheel(event);_this.dispatchEvent(startEvent);// not sure why these are here...
  _this.dispatchEvent(endEvent);};var onKeyDown=function onKeyDown(event){if(_this.enabled===false||_this.enableKeys===false||_this.enablePan===false)return;handleKeyDown(event);};var onTouchStart=function onTouchStart(event){if(_this.enabled===false)return;switch(event.touches.length){case 1:// one-fingered touch: rotate
  if(_this.enableRotate===false)return;handleTouchStartRotate(event);state=STATE.TOUCH_ROTATE;break;case 2:// two-fingered touch: dolly
  if(_this.enableZoom===false)return;handleTouchStartDolly(event);state=STATE.TOUCH_DOLLY;break;case 3:// three-fingered touch: pan
  if(_this.enablePan===false)return;handleTouchStartPan(event);state=STATE.TOUCH_PAN;break;default:state=STATE.NONE;}if(state!==STATE.NONE)_this.dispatchEvent(startEvent);};var onTouchMove=function onTouchMove(event){if(_this.enabled===false)return;event.preventDefault();event.stopPropagation();switch(event.touches.length){case 1:// one-fingered touch: rotate
  if(_this.enableRotate===false)return;if(state!==STATE.TOUCH_ROTATE)return;// is this needed?...
  handleTouchMoveRotate(event);break;case 2:// two-fingered touch: dolly
  if(_this.enableZoom===false)return;if(state!==STATE.TOUCH_DOLLY)return;// is this needed?...
  handleTouchMoveDolly(event);break;case 3:// three-fingered touch: pan
  if(_this.enablePan===false)return;if(state!==STATE.TOUCH_PAN)return;// is this needed?...
  handleTouchMovePan(event);break;default:state=STATE.NONE;}};var onTouchEnd=function onTouchEnd(event){if(_this.enabled===false)return;_this.dispatchEvent(endEvent);state=STATE.NONE;};var onContextMenu=function onContextMenu(event){event.preventDefault();};//
  _this.eventHandler.on('contextmenu',onContextMenu,false);_this.eventHandler.on('mousedown',onMouseDown,false);_this.eventHandler.on('wheel',onMouseWheel,false);_this.eventHandler.on('touchstart',onTouchStart,false);_this.eventHandler.on('touchend',onTouchEnd,false);_this.eventHandler.on('touchmove',onTouchMove,false);_this.eventHandler.on('keydown',onKeyDown,false);// force an update at start
  _this.update();return _this;}createClass(ThreeOrbitControls,[{key:"center",get:function get(){console.warn('OrbitControls: .center has been renamed to .target');return this.target;}},{key:"noZoom",get:function get(){console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');return !this.enableZoom;},set:function set(value){console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');this.enableZoom=!value;}},{key:"noRotate",get:function get(){console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');return !this.enableRotate;},set:function set(value){console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');this.enableRotate=!value;}},{key:"noPan",get:function get(){console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');return !this.enablePan;},set:function set(value){console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');this.enablePan=!value;}},{key:"noKeys",get:function get(){console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');return !this.enableKeys;},set:function set(value){console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');this.enableKeys=!value;}},{key:"staticMoving",get:function get(){console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');return !this.enableDamping;},set:function set(value){console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');this.enableDamping=!value;}},{key:"dynamicDampingFactor",get:function get(){console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');return this.dampingFactor;},set:function set(value){console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');this.dampingFactor=value;}}]);inherits(ThreeOrbitControls,_EventDispatcher);return ThreeOrbitControls;}(EventDispatcher);/**
   * @class OrbitControlsModule
   * @category modules/app
   * @param {Object} [params]
   * @param {Object} [params.object=camera] Object to which controls are applied.
   * @param {THREE.Vector3} [params.target=new Vector3()] Controls center vector.
   * @param {Boolean} [params.follow=false] Follow the target
   * @memberof module:modules/app
   * @example <caption> Creating a rendering module and passing it to App's modules</caption>
   * new App([
   *   new ElementModule(),
   *   new SceneModule(),
   *   new DefineModule('camera', new WHS.PerspectiveCamera({
   *     position: new THREE.Vector3(0, 6, 18),
   *     far: 10000
   *   })),
   *   new RenderingModule(),
   *   new OrbitControlsModule()
   * ]);
   */var OrbitControlsModule=/*#__PURE__*/function(_ControlsModule){function OrbitControlsModule(){var _this;var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,OrbitControlsModule);_this=possibleConstructorReturn(this,getPrototypeOf$2(OrbitControlsModule).call(this,params));_this.params=Object.assign({follow:false,object:null,target:new Vector3()},params);return _this;}createClass(OrbitControlsModule,[{key:"manager",value:function manager(_manager){get$3(getPrototypeOf$2(OrbitControlsModule.prototype),"manager",this).call(this,_manager);var _this$params=this.params,obj=_this$params.object,follow=_this$params.follow,target=_this$params.target;var object=obj?obj.native:_manager.get('camera').native;var controls=new ThreeOrbitControls(object,_manager.get('element'),_manager.handler);var updateProcessor=follow?function(c){controls.update(c.getDelta());controls.target.copy(target);}:function(c){controls.update(c.getDelta());};this.setControls(controls);this.setUpdate(updateProcessor);_manager.update({camera:function camera(_camera){if(obj)return;controls.object=_camera.native;},element:function element(_element){controls.domElement=_element;}});controls.target.copy(target);}}]);inherits(OrbitControlsModule,_ControlsModule);return OrbitControlsModule;}(ControlsModule);/** @module modules/app/controls */ /** @module modules/app */ /**
   * @class DynamicGeometryModule
   * @category modules/mesh
   * @param {Object} [params={attributes: false}] - params
   * @param {Boolean} [patchEvents=true]
   * @memberof module:modules/mesh
   */var DynamicGeometryModule=/*#__PURE__*/function(){function DynamicGeometryModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,DynamicGeometryModule);this.params=Object.assign({attributes:false},params);}createClass(DynamicGeometryModule,[{key:"integrate",value:function integrate(self){var _this=this;var params=self.params;this.g_=function(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(this.buildGeometry){this.native.geometry=this.buildGeometry(this.updateParams({geometry:params}));}};if(params.attributes){var _loop=function _loop(key){if(key){Object.defineProperty(_this,"g_".concat(key),{get:function get(){return this.native.geometry.parameters[key];},set:function set(value){this.native.geometry=this.buildGeometry(this.updateParams({geometry:defineProperty$3({},key,value)}));},configurable:true,enumerable:true});}};for(var key in this.params.geometry){_loop(key);}}}}]);return DynamicGeometryModule;}();var loader=new TextureLoader();/**
   * @class TextureModule
   * @category modules/mesh
   * @description A TextureModule can be applied to any Mesh or Model.
   * @param {Array} [textures] - array of texture objects
   * @memberof module:modules/mesh
   * @example <caption>Creating an instance. url takes a path, or a data object.</caption>
   * var woodTexture = new TextureModule({
   *   url: `${process.assetsPath}/textures/wood.jpg`
   * });
   * @example <caption>More comprehensive example, wood texture applied to a Box.</caption>
   * new Box({
   *   geometry: {
   *     width: 2,
   *     height: 2,
   *     depth: 2
   *   },
   *   modules: [
   *     new TextureModule({
   *       url: `path/to/texture.jpg`,
   *       repeat: new THREE.Vector2(1, 1) // optional
   *     })
   *   ],
   *   material: new THREE.MeshBasicMaterial({
   *     color: 0xffffff
   *   }),
   *   position: [50, 60, 70]
   * }).addTo(app);
   */var TextureModule=/*#__PURE__*/function(){createClass(TextureModule,null,[{key:"load",value:function load(url){return new TextureModule({url:url}).textures[0][1];}}]);function TextureModule(){var _this=this;classCallCheck(this,TextureModule);defineProperty$3(defineProperty$3(this,"textures",[]),"bridge",{material:function material(_material,self){self.textures.forEach(function(texture){_material[texture[0]]=texture[1];});_material.needsUpdate=true;return _material;}});for(var _len=arguments.length,textures=new Array(_len),_key=0;_key<_len;_key++){textures[_key]=arguments[_key];}textures.forEach(function(_ref){var url=_ref.url,_ref$type=_ref.type,type=_ref$type===void 0?'map':_ref$type,_ref$offset=_ref.offset,offset=_ref$offset===void 0?new Vector2(0,0):_ref$offset,_ref$repeat=_ref.repeat,repeat=_ref$repeat===void 0?new Vector2(1,1):_ref$repeat,_ref$wrap=_ref.wrap,wrap=_ref$wrap===void 0?RepeatWrapping:_ref$wrap,_ref$mapping=_ref.mapping,mapping=_ref$mapping===void 0?UVMapping:_ref$mapping,_ref$fix=_ref.fix,fix=_ref$fix===void 0?function(tex){return tex;}:_ref$fix;var texture=loader.load(url);if(wrap.length>0){texture.wrapS=wrap[0];texture.wrapT=wrap[1];}else texture.wrapS=texture.wrapT=wrap;texture.mapping=mapping;texture.offset.copy(offset);texture.repeat.copy(repeat);texture.magFilter=NearestFilter;texture.minFilter=LinearMipMapLinearFilter;_this.textures.push([type,fix(texture)]);});}return TextureModule;}();/**
   * @class AnimationModule
   * @category modules/mesh
   * @description Convenience module that wraps the <a href='https://threejs.org/docs/#manual/introduction/Animation-system'>three.js animation system</a>
   * @param {App} app - the app
   * @param {Boolean} [isDeferred=false] - set to true if animation should not start automatically
   * @param {Object} [params={speed: 1}] - the params
   * @memberof module:modules/mesh
   * @example <caption>Create animation module and play a given clip of an imported model</caption>
   * const animationModule = new AnimationModule(app, false, {
   *   speed: 1.2 // speed up animation by 20%
   * });
   *
   * new Importer({
   *   parser(geometry, materials) {
   *     // Override parse to generate a skinnedMesh, needed for skinned models
   *     return new THREE.SkinnedMesh(geometry, materials);
   *   },
   *
   *   url: `path/to/model.json`,
   *   useCustomMaterial: true,
   *
   *   material: new THREE.MeshStandardMaterial({
   *     skinning: true
   *   }),
   *
   *   modules: [animationModule]
   * }).addTo(app).then(() => {
   *   // adding model to app returns a promise, so pipe the function to kick off the animation clip
   *   animationModule.play('clipName');
   * });
   */var AnimationModule=/*#__PURE__*/function(){function AnimationModule(app,isDeferred){var params=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};classCallCheck(this,AnimationModule);defineProperty$3(this,"bridge",{mesh:function mesh(_mesh,self){_mesh.geometry.skeleton=_mesh.skeleton;self.mixer=new AnimationMixer(_mesh.geometry);self.clips=_mesh.geometry.animations;return _mesh;}});this.params=Object.assign({speed:1},params);this.clock=new Clock();this.app=app;this.isDeferred=isDeferred;}/**
     * @method play
     * @instance
     * @description Plays the given clip name
     * @param {String} clipName - the clip to play
     * @return {THREE.AnimationAction} Playing action 
     * @memberof module:modules/mesh.AnimationModule
     */createClass(AnimationModule,[{key:"play",value:function play(clipName){var clip=AnimationClip.findByName(this.clips,clipName);return this.mixer.clipAction(clip).play();}/**
       * @method update
       * @instance
       * @description Update the mixer (being called on frame animation loop)
       * @memberof module:modules/mesh.AnimationModule
       */},{key:"update",value:function update(){if(this.mixer)this.mixer.update(this.clock.getDelta()*this.params.speed);}},{key:"integrate",value:function integrate(self){self.loop=new Loop(function(){self.update();});if(!self.isDeferred)self.loop.start(self.app);}},{key:"manager",value:function manager(_manager){_manager.define('animation');}}]);return AnimationModule;}();/** @module modules/mesh */ /**
   * @class DefineModule
   * @category modules
   * @param {String} name
   * @param {Object} data
   * @memberof module:modules
   * @example <caption> Creating a DefineModule with PerspectiveCamera as camera module and passing it to App's modules</caption>
   * new App([
   *   // ...
   *   new DefineModule('camera', new PerspectiveCamera())
   * ]);
   */var DefineModule=/*#__PURE__*/function(){function DefineModule(name,data){classCallCheck(this,DefineModule);this.name=name;this.data=data;}createClass(DefineModule,[{key:"manager",value:function manager(_manager){_manager.set(this.name,this.data);}}]);return DefineModule;}();/** @module modules */var Model=/*#__PURE__*/function(_Importer){function Model(params){var _getPrototypeOf2;classCallCheck(this,Model);console.warn('Model is deprecated. Use Importer instead.');if(params.geometry){params.url=params.geometry.path;params.loader=params.geometry.loader;}for(var _len=arguments.length,additional=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){additional[_key-1]=arguments[_key];}return possibleConstructorReturn(this,(_getPrototypeOf2=getPrototypeOf$2(Model)).call.apply(_getPrototypeOf2,[this,params].concat(additional)));}inherits(Model,_Importer);return Model;}(Importer);var CameraModule=/*#__PURE__*/function(){function CameraModule(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};classCallCheck(this,CameraModule);console.warn('CameraModule is deprecated. Use DefineModule instead.');this.camera=new PerspectiveCamera$1(params);}createClass(CameraModule,[{key:"integrate",value:function integrate(self){this.add(self.camera);}},{key:"manager",value:function manager(_manager){_manager.set('camera',this.camera);}}]);return CameraModule;}();

  // Polyfills

  if ( Number.EPSILON === undefined ) {

  	Number.EPSILON = Math.pow( 2, - 52 );

  }

  if ( Number.isInteger === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

  	Number.isInteger = function ( value ) {

  		return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

  	};

  }

  //

  if ( Math.sign === undefined ) {

  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  	Math.sign = function ( x ) {

  		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  	};

  }

  if ( Function.prototype.name === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  	Object.defineProperty( Function.prototype, 'name', {

  		get: function () {

  			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

  		}

  	} );

  }

  if ( Object.assign === undefined ) {

  	// Missing in IE
  	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

  	( function () {

  		Object.assign = function ( target ) {

  			if ( target === undefined || target === null ) {

  				throw new TypeError( 'Cannot convert undefined or null to object' );

  			}

  			var output = Object( target );

  			for ( var index = 1; index < arguments.length; index ++ ) {

  				var source = arguments[ index ];

  				if ( source !== undefined && source !== null ) {

  					for ( var nextKey in source ) {

  						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

  							output[ nextKey ] = source[ nextKey ];

  						}

  					}

  				}

  			}

  			return output;

  		};

  	} )();

  }

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */

  function EventDispatcher$1() {}

  Object.assign( EventDispatcher$1.prototype, {

  	addEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) this._listeners = {};

  		var listeners = this._listeners;

  		if ( listeners[ type ] === undefined ) {

  			listeners[ type ] = [];

  		}

  		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

  			listeners[ type ].push( listener );

  		}

  	},

  	hasEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) return false;

  		var listeners = this._listeners;

  		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

  	},

  	removeEventListener: function ( type, listener ) {

  		if ( this._listeners === undefined ) return;

  		var listeners = this._listeners;
  		var listenerArray = listeners[ type ];

  		if ( listenerArray !== undefined ) {

  			var index = listenerArray.indexOf( listener );

  			if ( index !== - 1 ) {

  				listenerArray.splice( index, 1 );

  			}

  		}

  	},

  	dispatchEvent: function ( event ) {

  		if ( this._listeners === undefined ) return;

  		var listeners = this._listeners;
  		var listenerArray = listeners[ event.type ];

  		if ( listenerArray !== undefined ) {

  			event.target = this;

  			var array = [], i = 0;
  			var length = listenerArray.length;

  			for ( i = 0; i < length; i ++ ) {

  				array[ i ] = listenerArray[ i ];

  			}

  			for ( i = 0; i < length; i ++ ) {

  				array[ i ].call( this, event );

  			}

  		}

  	}

  } );

  var REVISION$1 = '85';
  var CullFaceNone$1 = 0;
  var CullFaceBack$1 = 1;
  var CullFaceFront$1 = 2;
  var FrontFaceDirectionCW = 0;
  var PCFShadowMap$1 = 1;
  var PCFSoftShadowMap$1 = 2;
  var FrontSide$1 = 0;
  var BackSide$1 = 1;
  var DoubleSide$1 = 2;
  var FlatShading$1 = 1;
  var SmoothShading = 2;
  var NoColors$1 = 0;
  var FaceColors$1 = 1;
  var VertexColors$1 = 2;
  var NoBlending$1 = 0;
  var NormalBlending$1 = 1;
  var AdditiveBlending$1 = 2;
  var SubtractiveBlending$1 = 3;
  var MultiplyBlending$1 = 4;
  var CustomBlending$1 = 5;
  var AddEquation$1 = 100;
  var SubtractEquation$1 = 101;
  var ReverseSubtractEquation$1 = 102;
  var MinEquation$1 = 103;
  var MaxEquation$1 = 104;
  var ZeroFactor$1 = 200;
  var OneFactor$1 = 201;
  var SrcColorFactor$1 = 202;
  var OneMinusSrcColorFactor$1 = 203;
  var SrcAlphaFactor$1 = 204;
  var OneMinusSrcAlphaFactor$1 = 205;
  var DstAlphaFactor$1 = 206;
  var OneMinusDstAlphaFactor$1 = 207;
  var DstColorFactor$1 = 208;
  var OneMinusDstColorFactor$1 = 209;
  var SrcAlphaSaturateFactor$1 = 210;
  var NeverDepth$1 = 0;
  var AlwaysDepth$1 = 1;
  var LessDepth$1 = 2;
  var LessEqualDepth$1 = 3;
  var EqualDepth$1 = 4;
  var GreaterEqualDepth$1 = 5;
  var GreaterDepth$1 = 6;
  var NotEqualDepth$1 = 7;
  var MultiplyOperation$1 = 0;
  var MixOperation$1 = 1;
  var AddOperation$1 = 2;
  var NoToneMapping$1 = 0;
  var LinearToneMapping$1 = 1;
  var ReinhardToneMapping$1 = 2;
  var Uncharted2ToneMapping$1 = 3;
  var CineonToneMapping$1 = 4;
  var UVMapping$1 = 300;
  var CubeReflectionMapping$1 = 301;
  var CubeRefractionMapping$1 = 302;
  var EquirectangularReflectionMapping$1 = 303;
  var EquirectangularRefractionMapping$1 = 304;
  var SphericalReflectionMapping$1 = 305;
  var CubeUVReflectionMapping$1 = 306;
  var CubeUVRefractionMapping$1 = 307;
  var RepeatWrapping$1 = 1000;
  var ClampToEdgeWrapping$1 = 1001;
  var MirroredRepeatWrapping$1 = 1002;
  var NearestFilter$1 = 1003;
  var NearestMipMapNearestFilter$1 = 1004;
  var NearestMipMapLinearFilter$1 = 1005;
  var LinearFilter$1 = 1006;
  var LinearMipMapNearestFilter$1 = 1007;
  var LinearMipMapLinearFilter$1 = 1008;
  var UnsignedByteType$1 = 1009;
  var ByteType$1 = 1010;
  var ShortType$1 = 1011;
  var UnsignedShortType$1 = 1012;
  var IntType$1 = 1013;
  var UnsignedIntType$1 = 1014;
  var FloatType$1 = 1015;
  var HalfFloatType$1 = 1016;
  var UnsignedShort4444Type$1 = 1017;
  var UnsignedShort5551Type$1 = 1018;
  var UnsignedShort565Type$1 = 1019;
  var UnsignedInt248Type$1 = 1020;
  var AlphaFormat$1 = 1021;
  var RGBFormat$1 = 1022;
  var RGBAFormat$1 = 1023;
  var LuminanceFormat$1 = 1024;
  var LuminanceAlphaFormat$1 = 1025;
  var DepthFormat$1 = 1026;
  var DepthStencilFormat$1 = 1027;
  var RGB_S3TC_DXT1_Format$1 = 2001;
  var RGBA_S3TC_DXT1_Format$1 = 2002;
  var RGBA_S3TC_DXT3_Format$1 = 2003;
  var RGBA_S3TC_DXT5_Format$1 = 2004;
  var RGB_PVRTC_4BPPV1_Format$1 = 2100;
  var RGB_PVRTC_2BPPV1_Format$1 = 2101;
  var RGBA_PVRTC_4BPPV1_Format$1 = 2102;
  var RGBA_PVRTC_2BPPV1_Format$1 = 2103;
  var RGB_ETC1_Format$1 = 2151;
  var LoopOnce$1 = 2200;
  var LoopRepeat$1 = 2201;
  var LoopPingPong$1 = 2202;
  var InterpolateDiscrete$1 = 2300;
  var InterpolateLinear$1 = 2301;
  var InterpolateSmooth$1 = 2302;
  var ZeroCurvatureEnding$1 = 2400;
  var ZeroSlopeEnding$1 = 2401;
  var WrapAroundEnding$1 = 2402;
  var TrianglesDrawMode$1 = 0;
  var TriangleStripDrawMode$1 = 1;
  var TriangleFanDrawMode$1 = 2;
  var LinearEncoding$1 = 3000;
  var sRGBEncoding$1 = 3001;
  var GammaEncoding$1 = 3007;
  var RGBEEncoding$1 = 3002;
  var RGBM7Encoding$1 = 3004;
  var RGBM16Encoding$1 = 3005;
  var RGBDEncoding$1 = 3006;
  var BasicDepthPacking$1 = 3200;
  var RGBADepthPacking$1 = 3201;

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  var _Math$1 = {

  	DEG2RAD: Math.PI / 180,
  	RAD2DEG: 180 / Math.PI,

  	generateUUID: function () {

  		// http://www.broofa.com/Tools/Math.uuid.htm

  		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
  		var uuid = new Array( 36 );
  		var rnd = 0, r;

  		return function generateUUID() {

  			for ( var i = 0; i < 36; i ++ ) {

  				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

  					uuid[ i ] = '-';

  				} else if ( i === 14 ) {

  					uuid[ i ] = '4';

  				} else {

  					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
  					r = rnd & 0xf;
  					rnd = rnd >> 4;
  					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

  				}

  			}

  			return uuid.join( '' );

  		};

  	}(),

  	clamp: function ( value, min, max ) {

  		return Math.max( min, Math.min( max, value ) );

  	},

  	// compute euclidian modulo of m % n
  	// https://en.wikipedia.org/wiki/Modulo_operation

  	euclideanModulo: function ( n, m ) {

  		return ( ( n % m ) + m ) % m;

  	},

  	// Linear mapping from range <a1, a2> to range <b1, b2>

  	mapLinear: function ( x, a1, a2, b1, b2 ) {

  		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  	},

  	// https://en.wikipedia.org/wiki/Linear_interpolation

  	lerp: function ( x, y, t ) {

  		return ( 1 - t ) * x + t * y;

  	},

  	// http://en.wikipedia.org/wiki/Smoothstep

  	smoothstep: function ( x, min, max ) {

  		if ( x <= min ) return 0;
  		if ( x >= max ) return 1;

  		x = ( x - min ) / ( max - min );

  		return x * x * ( 3 - 2 * x );

  	},

  	smootherstep: function ( x, min, max ) {

  		if ( x <= min ) return 0;
  		if ( x >= max ) return 1;

  		x = ( x - min ) / ( max - min );

  		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  	},

  	// Random integer from <low, high> interval

  	randInt: function ( low, high ) {

  		return low + Math.floor( Math.random() * ( high - low + 1 ) );

  	},

  	// Random float from <low, high> interval

  	randFloat: function ( low, high ) {

  		return low + Math.random() * ( high - low );

  	},

  	// Random float from <-range/2, range/2> interval

  	randFloatSpread: function ( range ) {

  		return range * ( 0.5 - Math.random() );

  	},

  	degToRad: function ( degrees ) {

  		return degrees * _Math$1.DEG2RAD;

  	},

  	radToDeg: function ( radians ) {

  		return radians * _Math$1.RAD2DEG;

  	},

  	isPowerOfTwo: function ( value ) {

  		return ( value & ( value - 1 ) ) === 0 && value !== 0;

  	},

  	nearestPowerOfTwo: function ( value ) {

  		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

  	},

  	nextPowerOfTwo: function ( value ) {

  		value --;
  		value |= value >> 1;
  		value |= value >> 2;
  		value |= value >> 4;
  		value |= value >> 8;
  		value |= value >> 16;
  		value ++;

  		return value;

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author philogb / http://blog.thejit.org/
   * @author egraether / http://egraether.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  function Vector2$1( x, y ) {

  	this.x = x || 0;
  	this.y = y || 0;

  }

  Object.defineProperties( Vector2$1.prototype, {

  	"width" : {

  		get: function () {

  			return this.x;

  		},

  		set: function ( value ) {

  			this.x = value;

  		}

  	},

  	"height" : {

  		get: function () {

  			return this.y;

  		},

  		set: function ( value ) {

  			this.y = value;

  		}

  	}

  } );

  Object.assign( Vector2$1.prototype, {

  	isVector2: true,

  	set: function ( x, y ) {

  		this.x = x;
  		this.y = y;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;

  		return this;

  	},

  	multiply: function ( v ) {

  		this.x *= v.x;
  		this.y *= v.y;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;

  		return this;

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// This function assumes min < max, if this assumption isn't true it will not operate correctly

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector2$1();
  		var max = new Vector2$1();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal );
  			max.set( maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y );

  	},

  	lengthManhattan: function() {

  		return Math.abs( this.x ) + Math.abs( this.y );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() );

  	},

  	angle: function () {

  		// computes the angle in radians with respect to the positive x-axis

  		var angle = Math.atan2( this.y, this.x );

  		if ( angle < 0 ) angle += 2 * Math.PI;

  		return angle;

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y;
  		return dx * dx + dy * dy;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

  	},

  	setLength: function ( length ) {

  		return this.multiplyScalar( length / this.length() );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );

  		return this;

  	},

  	rotateAround: function ( center, angle ) {

  		var c = Math.cos( angle ), s = Math.sin( angle );

  		var x = this.x - center.x;
  		var y = this.y - center.y;

  		this.x = x * c - y * s + center.x;
  		this.y = x * s + y * c + center.y;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   */

  var textureId$1 = 0;

  function Texture$1( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	Object.defineProperty( this, 'id', { value: textureId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';

  	this.image = image !== undefined ? image : Texture$1.DEFAULT_IMAGE;
  	this.mipmaps = [];

  	this.mapping = mapping !== undefined ? mapping : Texture$1.DEFAULT_MAPPING;

  	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping$1;
  	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping$1;

  	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter$1;

  	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  	this.format = format !== undefined ? format : RGBAFormat$1;
  	this.type = type !== undefined ? type : UnsignedByteType$1;

  	this.offset = new Vector2$1( 0, 0 );
  	this.repeat = new Vector2$1( 1, 1 );

  	this.generateMipmaps = true;
  	this.premultiplyAlpha = false;
  	this.flipY = true;
  	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  	//
  	// Also changing the encoding after already used by a Material will not automatically make the Material
  	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
  	this.encoding = encoding !== undefined ? encoding : LinearEncoding$1;

  	this.version = 0;
  	this.onUpdate = null;

  }

  Texture$1.DEFAULT_IMAGE = undefined;
  Texture$1.DEFAULT_MAPPING = UVMapping$1;

  Object.defineProperty( Texture$1.prototype, "needsUpdate", {

  	set: function ( value ) {

  		if ( value === true ) this.version ++;

  	}

  } );

  Object.assign( Texture$1.prototype, EventDispatcher$1.prototype, {

  	constructor: Texture$1,

  	isTexture: true,

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.image = source.image;
  		this.mipmaps = source.mipmaps.slice( 0 );

  		this.mapping = source.mapping;

  		this.wrapS = source.wrapS;
  		this.wrapT = source.wrapT;

  		this.magFilter = source.magFilter;
  		this.minFilter = source.minFilter;

  		this.anisotropy = source.anisotropy;

  		this.format = source.format;
  		this.type = source.type;

  		this.offset.copy( source.offset );
  		this.repeat.copy( source.repeat );

  		this.generateMipmaps = source.generateMipmaps;
  		this.premultiplyAlpha = source.premultiplyAlpha;
  		this.flipY = source.flipY;
  		this.unpackAlignment = source.unpackAlignment;
  		this.encoding = source.encoding;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		if ( meta.textures[ this.uuid ] !== undefined ) {

  			return meta.textures[ this.uuid ];

  		}

  		function getDataURL( image ) {

  			var canvas;

  			if ( image.toDataURL !== undefined ) {

  				canvas = image;

  			} else {

  				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  				canvas.width = image.width;
  				canvas.height = image.height;

  				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

  			}

  			if ( canvas.width > 2048 || canvas.height > 2048 ) {

  				return canvas.toDataURL( 'image/jpeg', 0.6 );

  			} else {

  				return canvas.toDataURL( 'image/png' );

  			}

  		}

  		var output = {
  			metadata: {
  				version: 4.5,
  				type: 'Texture',
  				generator: 'Texture.toJSON'
  			},

  			uuid: this.uuid,
  			name: this.name,

  			mapping: this.mapping,

  			repeat: [ this.repeat.x, this.repeat.y ],
  			offset: [ this.offset.x, this.offset.y ],
  			wrap: [ this.wrapS, this.wrapT ],

  			minFilter: this.minFilter,
  			magFilter: this.magFilter,
  			anisotropy: this.anisotropy,

  			flipY: this.flipY
  		};

  		if ( this.image !== undefined ) {

  			// TODO: Move to THREE.Image

  			var image = this.image;

  			if ( image.uuid === undefined ) {

  				image.uuid = _Math$1.generateUUID(); // UGH

  			}

  			if ( meta.images[ image.uuid ] === undefined ) {

  				meta.images[ image.uuid ] = {
  					uuid: image.uuid,
  					url: getDataURL( image )
  				};

  			}

  			output.image = image.uuid;

  		}

  		meta.textures[ this.uuid ] = output;

  		return output;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	},

  	transformUv: function ( uv ) {

  		if ( this.mapping !== UVMapping$1 ) return;

  		uv.multiply( this.repeat );
  		uv.add( this.offset );

  		if ( uv.x < 0 || uv.x > 1 ) {

  			switch ( this.wrapS ) {

  				case RepeatWrapping$1:

  					uv.x = uv.x - Math.floor( uv.x );
  					break;

  				case ClampToEdgeWrapping$1:

  					uv.x = uv.x < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping$1:

  					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

  						uv.x = Math.ceil( uv.x ) - uv.x;

  					} else {

  						uv.x = uv.x - Math.floor( uv.x );

  					}
  					break;

  			}

  		}

  		if ( uv.y < 0 || uv.y > 1 ) {

  			switch ( this.wrapT ) {

  				case RepeatWrapping$1:

  					uv.y = uv.y - Math.floor( uv.y );
  					break;

  				case ClampToEdgeWrapping$1:

  					uv.y = uv.y < 0 ? 0 : 1;
  					break;

  				case MirroredRepeatWrapping$1:

  					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

  						uv.y = Math.ceil( uv.y ) - uv.y;

  					} else {

  						uv.y = uv.y - Math.floor( uv.y );

  					}
  					break;

  			}

  		}

  		if ( this.flipY ) {

  			uv.y = 1 - uv.y;

  		}

  	}

  } );

  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector4$1( x, y, z, w ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;
  	this.w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Vector4$1.prototype, {

  	isVector4: true,

  	set: function ( x, y, z, w ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;
  		this.w = w;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;
  		this.w = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setW: function ( w ) {

  		this.w = w;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			case 3: this.w = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			case 3: return this.w;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z, this.w );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;
  		this.w = ( v.w !== undefined ) ? v.w : 1;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;
  		this.w += v.w;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;
  		this.w += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;
  		this.w = a.w + b.w;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;
  		this.w += v.w * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;
  		this.w -= v.w;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;
  		this.w -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;
  		this.w = a.w - b.w;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;
  		this.w *= scalar;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z, w = this.w;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
  		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	setAxisAngleFromQuaternion: function ( q ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

  		// q is assumed to be normalized

  		this.w = 2 * Math.acos( q.w );

  		var s = Math.sqrt( 1 - q.w * q.w );

  		if ( s < 0.0001 ) {

  			 this.x = 1;
  			 this.y = 0;
  			 this.z = 0;

  		} else {

  			 this.x = q.x / s;
  			 this.y = q.y / s;
  			 this.z = q.z / s;

  		}

  		return this;

  	},

  	setAxisAngleFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var angle, x, y, z,		// variables for result
  			epsilon = 0.01,		// margin to allow for rounding errors
  			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

  			te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
  		     ( Math.abs( m13 - m31 ) < epsilon ) &&
  		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

  			// singularity found
  			// first check for identity matrix which must have +1 for all terms
  			// in leading diagonal and zero in other terms

  			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
  			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
  			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
  			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

  				// this singularity is identity matrix so angle = 0

  				this.set( 1, 0, 0, 0 );

  				return this; // zero angle, arbitrary axis

  			}

  			// otherwise this singularity is angle = 180

  			angle = Math.PI;

  			var xx = ( m11 + 1 ) / 2;
  			var yy = ( m22 + 1 ) / 2;
  			var zz = ( m33 + 1 ) / 2;
  			var xy = ( m12 + m21 ) / 4;
  			var xz = ( m13 + m31 ) / 4;
  			var yz = ( m23 + m32 ) / 4;

  			if ( ( xx > yy ) && ( xx > zz ) ) {

  				// m11 is the largest diagonal term

  				if ( xx < epsilon ) {

  					x = 0;
  					y = 0.707106781;
  					z = 0.707106781;

  				} else {

  					x = Math.sqrt( xx );
  					y = xy / x;
  					z = xz / x;

  				}

  			} else if ( yy > zz ) {

  				// m22 is the largest diagonal term

  				if ( yy < epsilon ) {

  					x = 0.707106781;
  					y = 0;
  					z = 0.707106781;

  				} else {

  					y = Math.sqrt( yy );
  					x = xy / y;
  					z = yz / y;

  				}

  			} else {

  				// m33 is the largest diagonal term so base result on this

  				if ( zz < epsilon ) {

  					x = 0.707106781;
  					y = 0.707106781;
  					z = 0;

  				} else {

  					z = Math.sqrt( zz );
  					x = xz / z;
  					y = yz / z;

  				}

  			}

  			this.set( x, y, z, angle );

  			return this; // return 180 deg rotation

  		}

  		// as we have reached here there are no singularities so we can handle normally

  		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
  		                   ( m13 - m31 ) * ( m13 - m31 ) +
  		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

  		if ( Math.abs( s ) < 0.001 ) s = 1;

  		// prevent divide by zero, should not happen if matrix is orthogonal and should be
  		// caught by singularity test above, but I've left it in just in case

  		this.x = ( m32 - m23 ) / s;
  		this.y = ( m13 - m31 ) / s;
  		this.z = ( m21 - m12 ) / s;
  		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

  		return this;

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );
  		this.w = Math.min( this.w, v.w );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );
  		this.w = Math.max( this.w, v.w );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// This function assumes min < max, if this assumption isn't true it will not operate correctly

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
  		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector4$1();
  		var max = new Vector4$1();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );
  		this.w = Math.floor( this.w );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );
  		this.w = Math.ceil( this.w );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );
  		this.w = Math.round( this.w );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
  		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;
  		this.w = - this.w;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  	},

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() );

  	},

  	setLength: function ( length ) {

  		return this.multiplyScalar( length / this.length() );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;
  		this.w += ( v.w - this.w ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];
  		this.w = array[ offset + 3 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;
  		array[ offset + 3 ] = this.w;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );
  		this.w = attribute.getW( index );

  		return this;

  	}

  } );

  /**
   * @author szimek / https://github.com/szimek/
   * @author alteredq / http://alteredqualia.com/
   * @author Marius Kintel / https://github.com/kintel
   */

  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  function WebGLRenderTarget$1( width, height, options ) {

  	this.uuid = _Math$1.generateUUID();

  	this.width = width;
  	this.height = height;

  	this.scissor = new Vector4$1( 0, 0, width, height );
  	this.scissorTest = false;

  	this.viewport = new Vector4$1( 0, 0, width, height );

  	options = options || {};

  	if ( options.minFilter === undefined ) options.minFilter = LinearFilter$1;

  	this.texture = new Texture$1( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

  	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

  }

  Object.assign( WebGLRenderTarget$1.prototype, EventDispatcher$1.prototype, {

  	isWebGLRenderTarget: true,

  	setSize: function ( width, height ) {

  		if ( this.width !== width || this.height !== height ) {

  			this.width = width;
  			this.height = height;

  			this.dispose();

  		}

  		this.viewport.set( 0, 0, width, height );
  		this.scissor.set( 0, 0, width, height );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.width = source.width;
  		this.height = source.height;

  		this.viewport.copy( source.viewport );

  		this.texture = source.texture.clone();

  		this.depthBuffer = source.depthBuffer;
  		this.stencilBuffer = source.stencilBuffer;
  		this.depthTexture = source.depthTexture;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com
   */

  function WebGLRenderTargetCube$1( width, height, options ) {

  	WebGLRenderTarget$1.call( this, width, height, options );

  	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
  	this.activeMipMapLevel = 0;

  }

  WebGLRenderTargetCube$1.prototype = Object.create( WebGLRenderTarget$1.prototype );
  WebGLRenderTargetCube$1.prototype.constructor = WebGLRenderTargetCube$1;

  WebGLRenderTargetCube$1.prototype.isWebGLRenderTargetCube = true;

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Quaternion$1( x, y, z, w ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._w = ( w !== undefined ) ? w : 1;

  }

  Object.assign( Quaternion$1, {

  	slerp: function ( qa, qb, qm, t ) {

  		return qm.copy( qa ).slerp( qb, t );

  	},

  	slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

  		// fuzz-free, array-based Quaternion SLERP operation

  		var x0 = src0[ srcOffset0 + 0 ],
  			y0 = src0[ srcOffset0 + 1 ],
  			z0 = src0[ srcOffset0 + 2 ],
  			w0 = src0[ srcOffset0 + 3 ],

  			x1 = src1[ srcOffset1 + 0 ],
  			y1 = src1[ srcOffset1 + 1 ],
  			z1 = src1[ srcOffset1 + 2 ],
  			w1 = src1[ srcOffset1 + 3 ];

  		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

  			var s = 1 - t,

  				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

  				dir = ( cos >= 0 ? 1 : - 1 ),
  				sqrSin = 1 - cos * cos;

  			// Skip the Slerp for tiny steps to avoid numeric problems:
  			if ( sqrSin > Number.EPSILON ) {

  				var sin = Math.sqrt( sqrSin ),
  					len = Math.atan2( sin, cos * dir );

  				s = Math.sin( s * len ) / sin;
  				t = Math.sin( t * len ) / sin;

  			}

  			var tDir = t * dir;

  			x0 = x0 * s + x1 * tDir;
  			y0 = y0 * s + y1 * tDir;
  			z0 = z0 * s + z1 * tDir;
  			w0 = w0 * s + w1 * tDir;

  			// Normalize in case we just did a lerp:
  			if ( s === 1 - t ) {

  				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

  				x0 *= f;
  				y0 *= f;
  				z0 *= f;
  				w0 *= f;

  			}

  		}

  		dst[ dstOffset ] = x0;
  		dst[ dstOffset + 1 ] = y0;
  		dst[ dstOffset + 2 ] = z0;
  		dst[ dstOffset + 3 ] = w0;

  	}

  } );

  Object.defineProperties( Quaternion$1.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	w: {

  		get: function () {

  			return this._w;

  		},

  		set: function ( value ) {

  			this._w = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Quaternion$1.prototype, {

  	set: function ( x, y, z, w ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._w = w;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._w );

  	},

  	copy: function ( quaternion ) {

  		this._x = quaternion.x;
  		this._y = quaternion.y;
  		this._z = quaternion.z;
  		this._w = quaternion.w;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromEuler: function ( euler, update ) {

  		if ( ( euler && euler.isEuler ) === false ) {

  			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  		}

  		var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

  		// http://www.mathworks.com/matlabcentral/fileexchange/
  		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
  		//	content/SpinCalc.m

  		var cos = Math.cos;
  		var sin = Math.sin;

  		var c1 = cos( x / 2 );
  		var c2 = cos( y / 2 );
  		var c3 = cos( z / 2 );

  		var s1 = sin( x / 2 );
  		var s2 = sin( y / 2 );
  		var s3 = sin( z / 2 );

  		if ( order === 'XYZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'YXZ' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'ZXY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'ZYX' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		} else if ( order === 'YZX' ) {

  			this._x = s1 * c2 * c3 + c1 * s2 * s3;
  			this._y = c1 * s2 * c3 + s1 * c2 * s3;
  			this._z = c1 * c2 * s3 - s1 * s2 * c3;
  			this._w = c1 * c2 * c3 - s1 * s2 * s3;

  		} else if ( order === 'XZY' ) {

  			this._x = s1 * c2 * c3 - c1 * s2 * s3;
  			this._y = c1 * s2 * c3 - s1 * c2 * s3;
  			this._z = c1 * c2 * s3 + s1 * s2 * c3;
  			this._w = c1 * c2 * c3 + s1 * s2 * s3;

  		}

  		if ( update !== false ) this.onChangeCallback();

  		return this;

  	},

  	setFromAxisAngle: function ( axis, angle ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

  		// assumes axis is normalized

  		var halfAngle = angle / 2, s = Math.sin( halfAngle );

  		this._x = axis.x * s;
  		this._y = axis.y * s;
  		this._z = axis.z * s;
  		this._w = Math.cos( halfAngle );

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m ) {

  		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements,

  			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
  			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
  			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

  			trace = m11 + m22 + m33,
  			s;

  		if ( trace > 0 ) {

  			s = 0.5 / Math.sqrt( trace + 1.0 );

  			this._w = 0.25 / s;
  			this._x = ( m32 - m23 ) * s;
  			this._y = ( m13 - m31 ) * s;
  			this._z = ( m21 - m12 ) * s;

  		} else if ( m11 > m22 && m11 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

  			this._w = ( m32 - m23 ) / s;
  			this._x = 0.25 * s;
  			this._y = ( m12 + m21 ) / s;
  			this._z = ( m13 + m31 ) / s;

  		} else if ( m22 > m33 ) {

  			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

  			this._w = ( m13 - m31 ) / s;
  			this._x = ( m12 + m21 ) / s;
  			this._y = 0.25 * s;
  			this._z = ( m23 + m32 ) / s;

  		} else {

  			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

  			this._w = ( m21 - m12 ) / s;
  			this._x = ( m13 + m31 ) / s;
  			this._y = ( m23 + m32 ) / s;
  			this._z = 0.25 * s;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	setFromUnitVectors: function () {

  		// assumes direction vectors vFrom and vTo are normalized

  		var v1 = new Vector3$1();
  		var r;

  		var EPS = 0.000001;

  		return function setFromUnitVectors( vFrom, vTo ) {

  			if ( v1 === undefined ) v1 = new Vector3$1();

  			r = vFrom.dot( vTo ) + 1;

  			if ( r < EPS ) {

  				r = 0;

  				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

  					v1.set( - vFrom.y, vFrom.x, 0 );

  				} else {

  					v1.set( 0, - vFrom.z, vFrom.y );

  				}

  			} else {

  				v1.crossVectors( vFrom, vTo );

  			}

  			this._x = v1.x;
  			this._y = v1.y;
  			this._z = v1.z;
  			this._w = r;

  			return this.normalize();

  		};

  	}(),

  	inverse: function () {

  		return this.conjugate().normalize();

  	},

  	conjugate: function () {

  		this._x *= - 1;
  		this._y *= - 1;
  		this._z *= - 1;

  		this.onChangeCallback();

  		return this;

  	},

  	dot: function ( v ) {

  		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  	},

  	lengthSq: function () {

  		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  	},

  	length: function () {

  		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  	},

  	normalize: function () {

  		var l = this.length();

  		if ( l === 0 ) {

  			this._x = 0;
  			this._y = 0;
  			this._z = 0;
  			this._w = 1;

  		} else {

  			l = 1 / l;

  			this._x = this._x * l;
  			this._y = this._y * l;
  			this._z = this._z * l;
  			this._w = this._w * l;

  		}

  		this.onChangeCallback();

  		return this;

  	},

  	multiply: function ( q, p ) {

  		if ( p !== undefined ) {

  			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
  			return this.multiplyQuaternions( q, p );

  		}

  		return this.multiplyQuaternions( this, q );

  	},

  	premultiply: function ( q ) {

  		return this.multiplyQuaternions( q, this );

  	},

  	multiplyQuaternions: function ( a, b ) {

  		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

  		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
  		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

  		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
  		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
  		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
  		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

  		this.onChangeCallback();

  		return this;

  	},

  	slerp: function ( qb, t ) {

  		if ( t === 0 ) return this;
  		if ( t === 1 ) return this.copy( qb );

  		var x = this._x, y = this._y, z = this._z, w = this._w;

  		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

  		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

  		if ( cosHalfTheta < 0 ) {

  			this._w = - qb._w;
  			this._x = - qb._x;
  			this._y = - qb._y;
  			this._z = - qb._z;

  			cosHalfTheta = - cosHalfTheta;

  		} else {

  			this.copy( qb );

  		}

  		if ( cosHalfTheta >= 1.0 ) {

  			this._w = w;
  			this._x = x;
  			this._y = y;
  			this._z = z;

  			return this;

  		}

  		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

  		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

  			this._w = 0.5 * ( w + this._w );
  			this._x = 0.5 * ( x + this._x );
  			this._y = 0.5 * ( y + this._y );
  			this._z = 0.5 * ( z + this._z );

  			return this;

  		}

  		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
  		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
  			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

  		this._w = ( w * ratioA + this._w * ratioB );
  		this._x = ( x * ratioA + this._x * ratioB );
  		this._y = ( y * ratioA + this._y * ratioB );
  		this._z = ( z * ratioA + this._z * ratioB );

  		this.onChangeCallback();

  		return this;

  	},

  	equals: function ( quaternion ) {

  		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this._x = array[ offset ];
  		this._y = array[ offset + 1 ];
  		this._z = array[ offset + 2 ];
  		this._w = array[ offset + 3 ];

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._w;

  		return array;

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author *kile / http://kile.stravaganza.org/
   * @author philogb / http://blog.thejit.org/
   * @author mikael emtinger / http://gomo.se/
   * @author egraether / http://egraether.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function Vector3$1( x, y, z ) {

  	this.x = x || 0;
  	this.y = y || 0;
  	this.z = z || 0;

  }

  Object.assign( Vector3$1.prototype, {

  	isVector3: true,

  	set: function ( x, y, z ) {

  		this.x = x;
  		this.y = y;
  		this.z = z;

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.x = scalar;
  		this.y = scalar;
  		this.z = scalar;

  		return this;

  	},

  	setX: function ( x ) {

  		this.x = x;

  		return this;

  	},

  	setY: function ( y ) {

  		this.y = y;

  		return this;

  	},

  	setZ: function ( z ) {

  		this.z = z;

  		return this;

  	},

  	setComponent: function ( index, value ) {

  		switch ( index ) {

  			case 0: this.x = value; break;
  			case 1: this.y = value; break;
  			case 2: this.z = value; break;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  		return this;

  	},

  	getComponent: function ( index ) {

  		switch ( index ) {

  			case 0: return this.x;
  			case 1: return this.y;
  			case 2: return this.z;
  			default: throw new Error( 'index is out of range: ' + index );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.x, this.y, this.z );

  	},

  	copy: function ( v ) {

  		this.x = v.x;
  		this.y = v.y;
  		this.z = v.z;

  		return this;

  	},

  	add: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
  			return this.addVectors( v, w );

  		}

  		this.x += v.x;
  		this.y += v.y;
  		this.z += v.z;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.x += s;
  		this.y += s;
  		this.z += s;

  		return this;

  	},

  	addVectors: function ( a, b ) {

  		this.x = a.x + b.x;
  		this.y = a.y + b.y;
  		this.z = a.z + b.z;

  		return this;

  	},

  	addScaledVector: function ( v, s ) {

  		this.x += v.x * s;
  		this.y += v.y * s;
  		this.z += v.z * s;

  		return this;

  	},

  	sub: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
  			return this.subVectors( v, w );

  		}

  		this.x -= v.x;
  		this.y -= v.y;
  		this.z -= v.z;

  		return this;

  	},

  	subScalar: function ( s ) {

  		this.x -= s;
  		this.y -= s;
  		this.z -= s;

  		return this;

  	},

  	subVectors: function ( a, b ) {

  		this.x = a.x - b.x;
  		this.y = a.y - b.y;
  		this.z = a.z - b.z;

  		return this;

  	},

  	multiply: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
  			return this.multiplyVectors( v, w );

  		}

  		this.x *= v.x;
  		this.y *= v.y;
  		this.z *= v.z;

  		return this;

  	},

  	multiplyScalar: function ( scalar ) {

  		this.x *= scalar;
  		this.y *= scalar;
  		this.z *= scalar;

  		return this;

  	},

  	multiplyVectors: function ( a, b ) {

  		this.x = a.x * b.x;
  		this.y = a.y * b.y;
  		this.z = a.z * b.z;

  		return this;

  	},

  	applyEuler: function () {

  		var quaternion = new Quaternion$1();

  		return function applyEuler( euler ) {

  			if ( ( euler && euler.isEuler ) === false ) {

  				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

  			}

  			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

  		};

  	}(),

  	applyAxisAngle: function () {

  		var quaternion = new Quaternion$1();

  		return function applyAxisAngle( axis, angle ) {

  			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

  		};

  	}(),

  	applyMatrix3: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
  		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
  		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

  		return this;

  	},

  	applyMatrix4: function ( m ) {

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
  		var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];

  		return this.divideScalar( w );

  	},

  	applyQuaternion: function ( q ) {

  		var x = this.x, y = this.y, z = this.z;
  		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

  		// calculate quat * vector

  		var ix =  qw * x + qy * z - qz * y;
  		var iy =  qw * y + qz * x - qx * z;
  		var iz =  qw * z + qx * y - qy * x;
  		var iw = - qx * x - qy * y - qz * z;

  		// calculate result * inverse quat

  		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
  		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
  		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

  		return this;

  	},

  	project: function () {

  		var matrix = new Matrix4$1();

  		return function project( camera ) {

  			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	unproject: function () {

  		var matrix = new Matrix4$1();

  		return function unproject( camera ) {

  			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
  			return this.applyMatrix4( matrix );

  		};

  	}(),

  	transformDirection: function ( m ) {

  		// input: THREE.Matrix4 affine matrix
  		// vector interpreted as a direction

  		var x = this.x, y = this.y, z = this.z;
  		var e = m.elements;

  		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
  		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
  		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

  		return this.normalize();

  	},

  	divide: function ( v ) {

  		this.x /= v.x;
  		this.y /= v.y;
  		this.z /= v.z;

  		return this;

  	},

  	divideScalar: function ( scalar ) {

  		return this.multiplyScalar( 1 / scalar );

  	},

  	min: function ( v ) {

  		this.x = Math.min( this.x, v.x );
  		this.y = Math.min( this.y, v.y );
  		this.z = Math.min( this.z, v.z );

  		return this;

  	},

  	max: function ( v ) {

  		this.x = Math.max( this.x, v.x );
  		this.y = Math.max( this.y, v.y );
  		this.z = Math.max( this.z, v.z );

  		return this;

  	},

  	clamp: function ( min, max ) {

  		// This function assumes min < max, if this assumption isn't true it will not operate correctly

  		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
  		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
  		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

  		return this;

  	},

  	clampScalar: function () {

  		var min = new Vector3$1();
  		var max = new Vector3$1();

  		return function clampScalar( minVal, maxVal ) {

  			min.set( minVal, minVal, minVal );
  			max.set( maxVal, maxVal, maxVal );

  			return this.clamp( min, max );

  		};

  	}(),

  	clampLength: function ( min, max ) {

  		var length = this.length();

  		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

  	},

  	floor: function () {

  		this.x = Math.floor( this.x );
  		this.y = Math.floor( this.y );
  		this.z = Math.floor( this.z );

  		return this;

  	},

  	ceil: function () {

  		this.x = Math.ceil( this.x );
  		this.y = Math.ceil( this.y );
  		this.z = Math.ceil( this.z );

  		return this;

  	},

  	round: function () {

  		this.x = Math.round( this.x );
  		this.y = Math.round( this.y );
  		this.z = Math.round( this.z );

  		return this;

  	},

  	roundToZero: function () {

  		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
  		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
  		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

  		return this;

  	},

  	negate: function () {

  		this.x = - this.x;
  		this.y = - this.y;
  		this.z = - this.z;

  		return this;

  	},

  	dot: function ( v ) {

  		return this.x * v.x + this.y * v.y + this.z * v.z;

  	},

  	// TODO lengthSquared?

  	lengthSq: function () {

  		return this.x * this.x + this.y * this.y + this.z * this.z;

  	},

  	length: function () {

  		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  	},

  	lengthManhattan: function () {

  		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  	},

  	normalize: function () {

  		return this.divideScalar( this.length() );

  	},

  	setLength: function ( length ) {

  		return this.multiplyScalar( length / this.length() );

  	},

  	lerp: function ( v, alpha ) {

  		this.x += ( v.x - this.x ) * alpha;
  		this.y += ( v.y - this.y ) * alpha;
  		this.z += ( v.z - this.z ) * alpha;

  		return this;

  	},

  	lerpVectors: function ( v1, v2, alpha ) {

  		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

  	},

  	cross: function ( v, w ) {

  		if ( w !== undefined ) {

  			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
  			return this.crossVectors( v, w );

  		}

  		var x = this.x, y = this.y, z = this.z;

  		this.x = y * v.z - z * v.y;
  		this.y = z * v.x - x * v.z;
  		this.z = x * v.y - y * v.x;

  		return this;

  	},

  	crossVectors: function ( a, b ) {

  		var ax = a.x, ay = a.y, az = a.z;
  		var bx = b.x, by = b.y, bz = b.z;

  		this.x = ay * bz - az * by;
  		this.y = az * bx - ax * bz;
  		this.z = ax * by - ay * bx;

  		return this;

  	},

  	projectOnVector: function ( vector ) {

  		var scalar = vector.dot( this ) / vector.lengthSq();

  		return this.copy( vector ).multiplyScalar( scalar );

  	},

  	projectOnPlane: function () {

  		var v1 = new Vector3$1();

  		return function projectOnPlane( planeNormal ) {

  			v1.copy( this ).projectOnVector( planeNormal );

  			return this.sub( v1 );

  		};

  	}(),

  	reflect: function () {

  		// reflect incident vector off plane orthogonal to normal
  		// normal is assumed to have unit length

  		var v1 = new Vector3$1();

  		return function reflect( normal ) {

  			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

  		};

  	}(),

  	angleTo: function ( v ) {

  		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

  		// clamp, to handle numerical problems

  		return Math.acos( _Math$1.clamp( theta, - 1, 1 ) );

  	},

  	distanceTo: function ( v ) {

  		return Math.sqrt( this.distanceToSquared( v ) );

  	},

  	distanceToSquared: function ( v ) {

  		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

  		return dx * dx + dy * dy + dz * dz;

  	},

  	distanceToManhattan: function ( v ) {

  		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

  	},

  	setFromSpherical: function ( s ) {

  		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

  		this.x = sinPhiRadius * Math.sin( s.theta );
  		this.y = Math.cos( s.phi ) * s.radius;
  		this.z = sinPhiRadius * Math.cos( s.theta );

  		return this;

  	},

  	setFromCylindrical: function ( c ) {

  		this.x = c.radius * Math.sin( c.theta );
  		this.y = c.y;
  		this.z = c.radius * Math.cos( c.theta );

  		return this;

  	},

  	setFromMatrixPosition: function ( m ) {

  		return this.setFromMatrixColumn( m, 3 );

  	},

  	setFromMatrixScale: function ( m ) {

  		var sx = this.setFromMatrixColumn( m, 0 ).length();
  		var sy = this.setFromMatrixColumn( m, 1 ).length();
  		var sz = this.setFromMatrixColumn( m, 2 ).length();

  		this.x = sx;
  		this.y = sy;
  		this.z = sz;

  		return this;

  	},

  	setFromMatrixColumn: function ( m, index ) {


  		return this.fromArray( m.elements, index * 4 );

  	},

  	equals: function ( v ) {

  		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.x = array[ offset ];
  		this.y = array[ offset + 1 ];
  		this.z = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this.x;
  		array[ offset + 1 ] = this.y;
  		array[ offset + 2 ] = this.z;

  		return array;

  	},

  	fromBufferAttribute: function ( attribute, index, offset ) {

  		if ( offset !== undefined ) {

  			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

  		}

  		this.x = attribute.getX( index );
  		this.y = attribute.getY( index );
  		this.z = attribute.getZ( index );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author philogb / http://blog.thejit.org/
   * @author jordi_ros / http://plattsoft.com
   * @author D1plo1d / http://github.com/D1plo1d
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author timknip / http://www.floorplanner.com/
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Matrix4$1() {

  	this.elements = [

  		1, 0, 0, 0,
  		0, 1, 0, 0,
  		0, 0, 1, 0,
  		0, 0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix4$1.prototype, {

  	isMatrix4: true,

  	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
  		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
  		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
  		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0, 0,
  			0, 1, 0, 0,
  			0, 0, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new Matrix4$1().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
  		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
  		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
  		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

  		return this;

  	},

  	copyPosition: function ( m ) {

  		var te = this.elements, me = m.elements;

  		te[ 12 ] = me[ 12 ];
  		te[ 13 ] = me[ 13 ];
  		te[ 14 ] = me[ 14 ];

  		return this;

  	},

  	extractBasis: function ( xAxis, yAxis, zAxis ) {

  		xAxis.setFromMatrixColumn( this, 0 );
  		yAxis.setFromMatrixColumn( this, 1 );
  		zAxis.setFromMatrixColumn( this, 2 );

  		return this;

  	},

  	makeBasis: function ( xAxis, yAxis, zAxis ) {

  		this.set(
  			xAxis.x, yAxis.x, zAxis.x, 0,
  			xAxis.y, yAxis.y, zAxis.y, 0,
  			xAxis.z, yAxis.z, zAxis.z, 0,
  			0,       0,       0,       1
  		);

  		return this;

  	},

  	extractRotation: function () {

  		var v1 = new Vector3$1();

  		return function extractRotation( m ) {

  			var te = this.elements;
  			var me = m.elements;

  			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
  			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
  			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

  			te[ 0 ] = me[ 0 ] * scaleX;
  			te[ 1 ] = me[ 1 ] * scaleX;
  			te[ 2 ] = me[ 2 ] * scaleX;

  			te[ 4 ] = me[ 4 ] * scaleY;
  			te[ 5 ] = me[ 5 ] * scaleY;
  			te[ 6 ] = me[ 6 ] * scaleY;

  			te[ 8 ] = me[ 8 ] * scaleZ;
  			te[ 9 ] = me[ 9 ] * scaleZ;
  			te[ 10 ] = me[ 10 ] * scaleZ;

  			return this;

  		};

  	}(),

  	makeRotationFromEuler: function ( euler ) {

  		if ( ( euler && euler.isEuler ) === false ) {

  			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

  		}

  		var te = this.elements;

  		var x = euler.x, y = euler.y, z = euler.z;
  		var a = Math.cos( x ), b = Math.sin( x );
  		var c = Math.cos( y ), d = Math.sin( y );
  		var e = Math.cos( z ), f = Math.sin( z );

  		if ( euler.order === 'XYZ' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - c * f;
  			te[ 8 ] = d;

  			te[ 1 ] = af + be * d;
  			te[ 5 ] = ae - bf * d;
  			te[ 9 ] = - b * c;

  			te[ 2 ] = bf - ae * d;
  			te[ 6 ] = be + af * d;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YXZ' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce + df * b;
  			te[ 4 ] = de * b - cf;
  			te[ 8 ] = a * d;

  			te[ 1 ] = a * f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b;

  			te[ 2 ] = cf * b - de;
  			te[ 6 ] = df + ce * b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZXY' ) {

  			var ce = c * e, cf = c * f, de = d * e, df = d * f;

  			te[ 0 ] = ce - df * b;
  			te[ 4 ] = - a * f;
  			te[ 8 ] = de + cf * b;

  			te[ 1 ] = cf + de * b;
  			te[ 5 ] = a * e;
  			te[ 9 ] = df - ce * b;

  			te[ 2 ] = - a * d;
  			te[ 6 ] = b;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'ZYX' ) {

  			var ae = a * e, af = a * f, be = b * e, bf = b * f;

  			te[ 0 ] = c * e;
  			te[ 4 ] = be * d - af;
  			te[ 8 ] = ae * d + bf;

  			te[ 1 ] = c * f;
  			te[ 5 ] = bf * d + ae;
  			te[ 9 ] = af * d - be;

  			te[ 2 ] = - d;
  			te[ 6 ] = b * c;
  			te[ 10 ] = a * c;

  		} else if ( euler.order === 'YZX' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = bd - ac * f;
  			te[ 8 ] = bc * f + ad;

  			te[ 1 ] = f;
  			te[ 5 ] = a * e;
  			te[ 9 ] = - b * e;

  			te[ 2 ] = - d * e;
  			te[ 6 ] = ad * f + bc;
  			te[ 10 ] = ac - bd * f;

  		} else if ( euler.order === 'XZY' ) {

  			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

  			te[ 0 ] = c * e;
  			te[ 4 ] = - f;
  			te[ 8 ] = d * e;

  			te[ 1 ] = ac * f + bd;
  			te[ 5 ] = a * e;
  			te[ 9 ] = ad * f - bc;

  			te[ 2 ] = bc * f - ad;
  			te[ 6 ] = b * e;
  			te[ 10 ] = bd * f + ac;

  		}

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	makeRotationFromQuaternion: function ( q ) {

  		var te = this.elements;

  		var x = q._x, y = q._y, z = q._z, w = q._w;
  		var x2 = x + x, y2 = y + y, z2 = z + z;
  		var xx = x * x2, xy = x * y2, xz = x * z2;
  		var yy = y * y2, yz = y * z2, zz = z * z2;
  		var wx = w * x2, wy = w * y2, wz = w * z2;

  		te[ 0 ] = 1 - ( yy + zz );
  		te[ 4 ] = xy - wz;
  		te[ 8 ] = xz + wy;

  		te[ 1 ] = xy + wz;
  		te[ 5 ] = 1 - ( xx + zz );
  		te[ 9 ] = yz - wx;

  		te[ 2 ] = xz - wy;
  		te[ 6 ] = yz + wx;
  		te[ 10 ] = 1 - ( xx + yy );

  		// last column
  		te[ 3 ] = 0;
  		te[ 7 ] = 0;
  		te[ 11 ] = 0;

  		// bottom row
  		te[ 12 ] = 0;
  		te[ 13 ] = 0;
  		te[ 14 ] = 0;
  		te[ 15 ] = 1;

  		return this;

  	},

  	lookAt: function () {

  		var x = new Vector3$1();
  		var y = new Vector3$1();
  		var z = new Vector3$1();

  		return function lookAt( eye, target, up ) {

  			var te = this.elements;

  			z.subVectors( eye, target );

  			if ( z.lengthSq() === 0 ) {

  				// eye and target are in the same position

  				z.z = 1;

  			}

  			z.normalize();
  			x.crossVectors( up, z );

  			if ( x.lengthSq() === 0 ) {

  				// eye and target are in the same vertical

  				z.z += 0.0001;
  				x.crossVectors( up, z );

  			}

  			x.normalize();
  			y.crossVectors( z, x );

  			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
  			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
  			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

  			return this;

  		};

  	}(),

  	multiply: function ( m, n ) {

  		if ( n !== undefined ) {

  			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
  			return this.multiplyMatrices( m, n );

  		}

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
  		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
  		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
  		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

  		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
  		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
  		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
  		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

  		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
  		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
  		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
  		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$1();

  		return function applyToBufferAttribute( attribute ) {

  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix4( this );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	determinant: function () {

  		var te = this.elements;

  		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
  		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
  		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
  		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

  		//TODO: make this more efficient
  		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

  		return (
  			n41 * (
  				+ n14 * n23 * n32
  				 - n13 * n24 * n32
  				 - n14 * n22 * n33
  				 + n12 * n24 * n33
  				 + n13 * n22 * n34
  				 - n12 * n23 * n34
  			) +
  			n42 * (
  				+ n11 * n23 * n34
  				 - n11 * n24 * n33
  				 + n14 * n21 * n33
  				 - n13 * n21 * n34
  				 + n13 * n24 * n31
  				 - n14 * n23 * n31
  			) +
  			n43 * (
  				+ n11 * n24 * n32
  				 - n11 * n22 * n34
  				 - n14 * n21 * n32
  				 + n12 * n21 * n34
  				 + n14 * n22 * n31
  				 - n12 * n24 * n31
  			) +
  			n44 * (
  				- n13 * n22 * n31
  				 - n11 * n23 * n32
  				 + n11 * n22 * n33
  				 + n13 * n21 * n32
  				 - n12 * n21 * n33
  				 + n12 * n23 * n31
  			)

  		);

  	},

  	transpose: function () {

  		var te = this.elements;
  		var tmp;

  		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
  		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
  		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

  		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
  		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
  		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

  		return this;

  	},

  	setPosition: function ( v ) {

  		var te = this.elements;

  		te[ 12 ] = v.x;
  		te[ 13 ] = v.y;
  		te[ 14 ] = v.z;

  		return this;

  	},

  	getInverse: function ( m, throwOnDegenerate ) {

  		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
  		var te = this.elements,
  			me = m.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
  			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
  			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
  			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

  			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
  			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
  			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
  			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

  		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
  		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
  		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

  		te[ 4 ] = t12 * detInv;
  		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
  		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
  		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

  		te[ 8 ] = t13 * detInv;
  		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
  		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
  		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

  		te[ 12 ] = t14 * detInv;
  		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
  		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
  		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

  		return this;

  	},

  	scale: function ( v ) {

  		var te = this.elements;
  		var x = v.x, y = v.y, z = v.z;

  		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
  		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
  		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
  		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

  		return this;

  	},

  	getMaxScaleOnAxis: function () {

  		var te = this.elements;

  		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
  		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
  		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

  		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  	},

  	makeTranslation: function ( x, y, z ) {

  		this.set(

  			1, 0, 0, x,
  			0, 1, 0, y,
  			0, 0, 1, z,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationX: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			1, 0,  0, 0,
  			0, c, - s, 0,
  			0, s,  c, 0,
  			0, 0,  0, 1

  		);

  		return this;

  	},

  	makeRotationY: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			 c, 0, s, 0,
  			 0, 1, 0, 0,
  			- s, 0, c, 0,
  			 0, 0, 0, 1

  		);

  		return this;

  	},

  	makeRotationZ: function ( theta ) {

  		var c = Math.cos( theta ), s = Math.sin( theta );

  		this.set(

  			c, - s, 0, 0,
  			s,  c, 0, 0,
  			0,  0, 1, 0,
  			0,  0, 0, 1

  		);

  		return this;

  	},

  	makeRotationAxis: function ( axis, angle ) {

  		// Based on http://www.gamedev.net/reference/articles/article1199.asp

  		var c = Math.cos( angle );
  		var s = Math.sin( angle );
  		var t = 1 - c;
  		var x = axis.x, y = axis.y, z = axis.z;
  		var tx = t * x, ty = t * y;

  		this.set(

  			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
  			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
  			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
  			0, 0, 0, 1

  		);

  		 return this;

  	},

  	makeScale: function ( x, y, z ) {

  		this.set(

  			x, 0, 0, 0,
  			0, y, 0, 0,
  			0, 0, z, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	makeShear: function ( x, y, z ) {

  		this.set(

  			1, y, z, 0,
  			x, 1, z, 0,
  			x, y, 1, 0,
  			0, 0, 0, 1

  		);

  		return this;

  	},

  	compose: function ( position, quaternion, scale ) {

  		this.makeRotationFromQuaternion( quaternion );
  		this.scale( scale );
  		this.setPosition( position );

  		return this;

  	},

  	decompose: function () {

  		var vector = new Vector3$1();
  		var matrix = new Matrix4$1();

  		return function decompose( position, quaternion, scale ) {

  			var te = this.elements;

  			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
  			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
  			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

  			// if determine is negative, we need to invert one scale
  			var det = this.determinant();
  			if ( det < 0 ) sx = - sx;

  			position.x = te[ 12 ];
  			position.y = te[ 13 ];
  			position.z = te[ 14 ];

  			// scale the rotation part
  			matrix.copy( this );

  			var invSX = 1 / sx;
  			var invSY = 1 / sy;
  			var invSZ = 1 / sz;

  			matrix.elements[ 0 ] *= invSX;
  			matrix.elements[ 1 ] *= invSX;
  			matrix.elements[ 2 ] *= invSX;

  			matrix.elements[ 4 ] *= invSY;
  			matrix.elements[ 5 ] *= invSY;
  			matrix.elements[ 6 ] *= invSY;

  			matrix.elements[ 8 ] *= invSZ;
  			matrix.elements[ 9 ] *= invSZ;
  			matrix.elements[ 10 ] *= invSZ;

  			quaternion.setFromRotationMatrix( matrix );

  			scale.x = sx;
  			scale.y = sy;
  			scale.z = sz;

  			return this;

  		};

  	}(),

  	makePerspective: function ( left, right, top, bottom, near, far ) {

  		if ( far === undefined ) {

  			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

  		}

  		var te = this.elements;
  		var x = 2 * near / ( right - left );
  		var y = 2 * near / ( top - bottom );

  		var a = ( right + left ) / ( right - left );
  		var b = ( top + bottom ) / ( top - bottom );
  		var c = - ( far + near ) / ( far - near );
  		var d = - 2 * far * near / ( far - near );

  		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
  		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

  		return this;

  	},

  	makeOrthographic: function ( left, right, top, bottom, near, far ) {

  		var te = this.elements;
  		var w = 1.0 / ( right - left );
  		var h = 1.0 / ( top - bottom );
  		var p = 1.0 / ( far - near );

  		var x = ( right + left ) * w;
  		var y = ( top + bottom ) * h;
  		var z = ( far + near ) * p;

  		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
  		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
  		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
  		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 16; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		for ( var i = 0; i < 16; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];
  		array[ offset + 3 ] = te[ 3 ];

  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];
  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];

  		array[ offset + 8 ] = te[ 8 ];
  		array[ offset + 9 ] = te[ 9 ];
  		array[ offset + 10 ] = te[ 10 ];
  		array[ offset + 11 ] = te[ 11 ];

  		array[ offset + 12 ] = te[ 12 ];
  		array[ offset + 13 ] = te[ 13 ];
  		array[ offset + 14 ] = te[ 14 ];
  		array[ offset + 15 ] = te[ 15 ];

  		return array;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function DataTexture$1( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { data: data, width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter$1;

  	this.generateMipmaps = false;
  	this.flipY = false;
  	this.unpackAlignment = 1;

  }

  DataTexture$1.prototype = Object.create( Texture$1.prototype );
  DataTexture$1.prototype.constructor = DataTexture$1;

  DataTexture$1.prototype.isDataTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTexture$1( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

  	images = images !== undefined ? images : [];
  	mapping = mapping !== undefined ? mapping : CubeReflectionMapping$1;

  	Texture$1.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.flipY = false;

  }

  CubeTexture$1.prototype = Object.create( Texture$1.prototype );
  CubeTexture$1.prototype.constructor = CubeTexture$1;

  CubeTexture$1.prototype.isCubeTexture = true;

  Object.defineProperty( CubeTexture$1.prototype, 'images', {

  	get: function () {

  		return this.image;

  	},

  	set: function ( value ) {

  		this.image = value;

  	}

  } );

  /**
   * @author tschw
   *
   * Uniforms of a program.
   * Those form a tree structure with a special top-level container for the root,
   * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
   *
   *
   * Properties of inner nodes including the top-level container:
   *
   * .seq - array of nested uniforms
   * .map - nested uniforms by name
   *
   *
   * Methods of all nodes except the top-level container:
   *
   * .setValue( gl, value, [renderer] )
   *
   * 		uploads a uniform value(s)
   *  	the 'renderer' parameter is needed for sampler uniforms
   *
   *
   * Static methods of the top-level container (renderer factorizations):
   *
   * .upload( gl, seq, values, renderer )
   *
   * 		sets uniforms in 'seq' to 'values[id].value'
   *
   * .seqWithValue( seq, values ) : filteredSeq
   *
   * 		filters 'seq' entries with corresponding entry in values
   *
   *
   * Methods of the top-level container (renderer factorizations):
   *
   * .setValue( gl, name, value )
   *
   * 		sets uniform with  name 'name' to 'value'
   *
   * .set( gl, obj, prop )
   *
   * 		sets uniform from object and property with same name than uniform
   *
   * .setOptional( gl, obj, prop )
   *
   * 		like .set for an optional property of the object
   *
   */

  var emptyTexture$1 = new Texture$1();
  var emptyCubeTexture$1 = new CubeTexture$1();

  // --- Base for inner nodes (including the root) ---

  function UniformContainer$1() {

  	this.seq = [];
  	this.map = {};

  }

  // --- Utilities ---

  // Array Caches (provide typed arrays for temporary by size)

  var arrayCacheF32$1 = [];
  var arrayCacheI32$1 = [];

  // Float32Array caches used for uploading Matrix uniforms

  var mat4array$1 = new Float32Array( 16 );
  var mat3array$1 = new Float32Array( 9 );

  // Flattening for arrays of vectors and matrices

  function flatten$1( array, nBlocks, blockSize ) {

  	var firstElem = array[ 0 ];

  	if ( firstElem <= 0 || firstElem > 0 ) return array;
  	// unoptimized: ! isNaN( firstElem )
  	// see http://jacksondunstan.com/articles/983

  	var n = nBlocks * blockSize,
  		r = arrayCacheF32$1[ n ];

  	if ( r === undefined ) {

  		r = new Float32Array( n );
  		arrayCacheF32$1[ n ] = r;

  	}

  	if ( nBlocks !== 0 ) {

  		firstElem.toArray( r, 0 );

  		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

  			offset += blockSize;
  			array[ i ].toArray( r, offset );

  		}

  	}

  	return r;

  }

  // Texture unit allocation

  function allocTexUnits$1( renderer, n ) {

  	var r = arrayCacheI32$1[ n ];

  	if ( r === undefined ) {

  		r = new Int32Array( n );
  		arrayCacheI32$1[ n ] = r;

  	}

  	for ( var i = 0; i !== n; ++ i )
  		r[ i ] = renderer.allocTextureUnit();

  	return r;

  }

  // --- Setters ---

  // Note: Defining these methods externally, because they come in a bunch
  // and this way their names minify.

  // Single scalar

  function setValue1f$1( gl, v ) { gl.uniform1f( this.addr, v ); }
  function setValue1i$1( gl, v ) { gl.uniform1i( this.addr, v ); }

  // Single float vector (from flat array or THREE.VectorN)

  function setValue2fv$1( gl, v ) {

  	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
  	else gl.uniform2f( this.addr, v.x, v.y );

  }

  function setValue3fv$1( gl, v ) {

  	if ( v.x !== undefined )
  		gl.uniform3f( this.addr, v.x, v.y, v.z );
  	else if ( v.r !== undefined )
  		gl.uniform3f( this.addr, v.r, v.g, v.b );
  	else
  		gl.uniform3fv( this.addr, v );

  }

  function setValue4fv$1( gl, v ) {

  	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
  	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

  }

  // Single matrix (from flat array or MatrixN)

  function setValue2fm$1( gl, v ) {

  	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

  }

  function setValue3fm$1( gl, v ) {

  	if ( v.elements === undefined ) {

  		gl.uniformMatrix3fv( this.addr, false, v );

  	} else {

  		mat3array$1.set( v.elements );
  		gl.uniformMatrix3fv( this.addr, false, mat3array$1 );

  	}

  }

  function setValue4fm$1( gl, v ) {

  	if ( v.elements === undefined ) {

  		gl.uniformMatrix4fv( this.addr, false, v );

  	} else {

  		mat4array$1.set( v.elements );
  		gl.uniformMatrix4fv( this.addr, false, mat4array$1 );

  	}

  }

  // Single texture (2D / Cube)

  function setValueT1$1( gl, v, renderer ) {

  	var unit = renderer.allocTextureUnit();
  	gl.uniform1i( this.addr, unit );
  	renderer.setTexture2D( v || emptyTexture$1, unit );

  }

  function setValueT6$1( gl, v, renderer ) {

  	var unit = renderer.allocTextureUnit();
  	gl.uniform1i( this.addr, unit );
  	renderer.setTextureCube( v || emptyCubeTexture$1, unit );

  }

  // Integer / Boolean vectors or arrays thereof (always flat arrays)

  function setValue2iv$1( gl, v ) { gl.uniform2iv( this.addr, v ); }
  function setValue3iv$1( gl, v ) { gl.uniform3iv( this.addr, v ); }
  function setValue4iv$1( gl, v ) { gl.uniform4iv( this.addr, v ); }

  // Helper to pick the right setter for the singular case

  function getSingularSetter$1( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1f$1; // FLOAT
  		case 0x8b50: return setValue2fv$1; // _VEC2
  		case 0x8b51: return setValue3fv$1; // _VEC3
  		case 0x8b52: return setValue4fv$1; // _VEC4

  		case 0x8b5a: return setValue2fm$1; // _MAT2
  		case 0x8b5b: return setValue3fm$1; // _MAT3
  		case 0x8b5c: return setValue4fm$1; // _MAT4

  		case 0x8b5e: return setValueT1$1; // SAMPLER_2D
  		case 0x8b60: return setValueT6$1; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1i$1; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv$1; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv$1; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv$1; // _VEC4

  	}

  }

  // Array of scalars

  function setValue1fv$1( gl, v ) { gl.uniform1fv( this.addr, v ); }
  function setValue1iv$1( gl, v ) { gl.uniform1iv( this.addr, v ); }

  // Array of vectors (flat or from THREE classes)

  function setValueV2a$1( gl, v ) {

  	gl.uniform2fv( this.addr, flatten$1( v, this.size, 2 ) );

  }

  function setValueV3a$1( gl, v ) {

  	gl.uniform3fv( this.addr, flatten$1( v, this.size, 3 ) );

  }

  function setValueV4a$1( gl, v ) {

  	gl.uniform4fv( this.addr, flatten$1( v, this.size, 4 ) );

  }

  // Array of matrices (flat or from THREE clases)

  function setValueM2a$1( gl, v ) {

  	gl.uniformMatrix2fv( this.addr, false, flatten$1( v, this.size, 4 ) );

  }

  function setValueM3a$1( gl, v ) {

  	gl.uniformMatrix3fv( this.addr, false, flatten$1( v, this.size, 9 ) );

  }

  function setValueM4a$1( gl, v ) {

  	gl.uniformMatrix4fv( this.addr, false, flatten$1( v, this.size, 16 ) );

  }

  // Array of textures (2D / Cube)

  function setValueT1a$1( gl, v, renderer ) {

  	var n = v.length,
  		units = allocTexUnits$1( renderer, n );

  	gl.uniform1iv( this.addr, units );

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTexture2D( v[ i ] || emptyTexture$1, units[ i ] );

  	}

  }

  function setValueT6a$1( gl, v, renderer ) {

  	var n = v.length,
  		units = allocTexUnits$1( renderer, n );

  	gl.uniform1iv( this.addr, units );

  	for ( var i = 0; i !== n; ++ i ) {

  		renderer.setTextureCube( v[ i ] || emptyCubeTexture$1, units[ i ] );

  	}

  }

  // Helper to pick the right setter for a pure (bottom-level) array

  function getPureArraySetter$1( type ) {

  	switch ( type ) {

  		case 0x1406: return setValue1fv$1; // FLOAT
  		case 0x8b50: return setValueV2a$1; // _VEC2
  		case 0x8b51: return setValueV3a$1; // _VEC3
  		case 0x8b52: return setValueV4a$1; // _VEC4

  		case 0x8b5a: return setValueM2a$1; // _MAT2
  		case 0x8b5b: return setValueM3a$1; // _MAT3
  		case 0x8b5c: return setValueM4a$1; // _MAT4

  		case 0x8b5e: return setValueT1a$1; // SAMPLER_2D
  		case 0x8b60: return setValueT6a$1; // SAMPLER_CUBE

  		case 0x1404: case 0x8b56: return setValue1iv$1; // INT, BOOL
  		case 0x8b53: case 0x8b57: return setValue2iv$1; // _VEC2
  		case 0x8b54: case 0x8b58: return setValue3iv$1; // _VEC3
  		case 0x8b55: case 0x8b59: return setValue4iv$1; // _VEC4

  	}

  }

  // --- Uniform Classes ---

  function SingleUniform$1( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.setValue = getSingularSetter$1( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function PureArrayUniform$1( id, activeInfo, addr ) {

  	this.id = id;
  	this.addr = addr;
  	this.size = activeInfo.size;
  	this.setValue = getPureArraySetter$1( activeInfo.type );

  	// this.path = activeInfo.name; // DEBUG

  }

  function StructuredUniform$1( id ) {

  	this.id = id;

  	UniformContainer$1.call( this ); // mix-in

  }

  StructuredUniform$1.prototype.setValue = function ( gl, value ) {

  	// Note: Don't need an extra 'renderer' parameter, since samplers
  	// are not allowed in structured uniforms.

  	var seq = this.seq;

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		u.setValue( gl, value[ u.id ] );

  	}

  };

  // --- Top-level ---

  // Parser - builds up the property tree from the path strings

  var RePathPart$1 = /([\w\d_]+)(\])?(\[|\.)?/g;

  // extracts
  // 	- the identifier (member name or array index)
  //  - followed by an optional right bracket (found when array index)
  //  - followed by an optional left bracket or dot (type of subscript)
  //
  // Note: These portions can be read in a non-overlapping fashion and
  // allow straightforward parsing of the hierarchy that WebGL encodes
  // in the uniform names.

  function addUniform$1( container, uniformObject ) {

  	container.seq.push( uniformObject );
  	container.map[ uniformObject.id ] = uniformObject;

  }

  function parseUniform$1( activeInfo, addr, container ) {

  	var path = activeInfo.name,
  		pathLength = path.length;

  	// reset RegExp object, because of the early exit of a previous run
  	RePathPart$1.lastIndex = 0;

  	for ( ; ; ) {

  		var match = RePathPart$1.exec( path ),
  			matchEnd = RePathPart$1.lastIndex,

  			id = match[ 1 ],
  			idIsIndex = match[ 2 ] === ']',
  			subscript = match[ 3 ];

  		if ( idIsIndex ) id = id | 0; // convert to integer

  		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

  			// bare name or "pure" bottom-level array "[0]" suffix

  			addUniform$1( container, subscript === undefined ?
  					new SingleUniform$1( id, activeInfo, addr ) :
  					new PureArrayUniform$1( id, activeInfo, addr ) );

  			break;

  		} else {

  			// step into inner node / create it in case it doesn't exist

  			var map = container.map, next = map[ id ];

  			if ( next === undefined ) {

  				next = new StructuredUniform$1( id );
  				addUniform$1( container, next );

  			}

  			container = next;

  		}

  	}

  }

  // Root Container

  function WebGLUniforms$1( gl, program, renderer ) {

  	UniformContainer$1.call( this );

  	this.renderer = renderer;

  	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

  	for ( var i = 0; i < n; ++ i ) {

  		var info = gl.getActiveUniform( program, i ),
  			path = info.name,
  			addr = gl.getUniformLocation( program, path );

  		parseUniform$1( info, addr, this );

  	}

  }

  WebGLUniforms$1.prototype.setValue = function ( gl, name, value ) {

  	var u = this.map[ name ];

  	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

  };

  WebGLUniforms$1.prototype.setOptional = function ( gl, object, name ) {

  	var v = object[ name ];

  	if ( v !== undefined ) this.setValue( gl, name, v );

  };


  // Static interface

  WebGLUniforms$1.upload = function ( gl, seq, values, renderer ) {

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ],
  			v = values[ u.id ];

  		if ( v.needsUpdate !== false ) {

  			// note: always updating when .needsUpdate is undefined
  			u.setValue( gl, v.value, renderer );

  		}

  	}

  };

  WebGLUniforms$1.seqWithValue = function ( seq, values ) {

  	var r = [];

  	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

  		var u = seq[ i ];
  		if ( u.id in values ) r.push( u );

  	}

  	return r;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var ColorKeywords$1 = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
  	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
  	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
  	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
  	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
  	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
  	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
  	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
  	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
  	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
  	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
  	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
  	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
  	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
  	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
  	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
  	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
  	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
  	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
  	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
  	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
  	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
  	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
  	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

  function Color$1( r, g, b ) {

  	if ( g === undefined && b === undefined ) {

  		// r is THREE.Color, hex or string
  		return this.set( r );

  	}

  	return this.setRGB( r, g, b );

  }

  Object.assign( Color$1.prototype, {

  	isColor: true,

  	r: 1, g: 1, b: 1,

  	set: function ( value ) {

  		if ( value && value.isColor ) {

  			this.copy( value );

  		} else if ( typeof value === 'number' ) {

  			this.setHex( value );

  		} else if ( typeof value === 'string' ) {

  			this.setStyle( value );

  		}

  		return this;

  	},

  	setScalar: function ( scalar ) {

  		this.r = scalar;
  		this.g = scalar;
  		this.b = scalar;

  		return this;

  	},

  	setHex: function ( hex ) {

  		hex = Math.floor( hex );

  		this.r = ( hex >> 16 & 255 ) / 255;
  		this.g = ( hex >> 8 & 255 ) / 255;
  		this.b = ( hex & 255 ) / 255;

  		return this;

  	},

  	setRGB: function ( r, g, b ) {

  		this.r = r;
  		this.g = g;
  		this.b = b;

  		return this;

  	},

  	setHSL: function () {

  		function hue2rgb( p, q, t ) {

  			if ( t < 0 ) t += 1;
  			if ( t > 1 ) t -= 1;
  			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
  			if ( t < 1 / 2 ) return q;
  			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
  			return p;

  		}

  		return function setHSL( h, s, l ) {

  			// h,s,l ranges are in 0.0 - 1.0
  			h = _Math$1.euclideanModulo( h, 1 );
  			s = _Math$1.clamp( s, 0, 1 );
  			l = _Math$1.clamp( l, 0, 1 );

  			if ( s === 0 ) {

  				this.r = this.g = this.b = l;

  			} else {

  				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
  				var q = ( 2 * l ) - p;

  				this.r = hue2rgb( q, p, h + 1 / 3 );
  				this.g = hue2rgb( q, p, h );
  				this.b = hue2rgb( q, p, h - 1 / 3 );

  			}

  			return this;

  		};

  	}(),

  	setStyle: function ( style ) {

  		function handleAlpha( string ) {

  			if ( string === undefined ) return;

  			if ( parseFloat( string ) < 1 ) {

  				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

  			}

  		}


  		var m;

  		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

  			// rgb / hsl

  			var color;
  			var name = m[ 1 ];
  			var components = m[ 2 ];

  			switch ( name ) {

  				case 'rgb':
  				case 'rgba':

  					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(255,0,0) rgba(255,0,0,0.5)
  						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
  						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
  						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
  						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
  						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
  						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this;

  					}

  					break;

  				case 'hsl':
  				case 'hsla':

  					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

  						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
  						var h = parseFloat( color[ 1 ] ) / 360;
  						var s = parseInt( color[ 2 ], 10 ) / 100;
  						var l = parseInt( color[ 3 ], 10 ) / 100;

  						handleAlpha( color[ 5 ] );

  						return this.setHSL( h, s, l );

  					}

  					break;

  			}

  		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

  			// hex color

  			var hex = m[ 1 ];
  			var size = hex.length;

  			if ( size === 3 ) {

  				// #ff0
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

  				return this;

  			} else if ( size === 6 ) {

  				// #ff0000
  				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
  				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
  				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

  				return this;

  			}

  		}

  		if ( style && style.length > 0 ) {

  			// color keywords
  			var hex = ColorKeywords$1[ style ];

  			if ( hex !== undefined ) {

  				// red
  				this.setHex( hex );

  			} else {

  				// unknown color
  				console.warn( 'THREE.Color: Unknown color ' + style );

  			}

  		}

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.r, this.g, this.b );

  	},

  	copy: function ( color ) {

  		this.r = color.r;
  		this.g = color.g;
  		this.b = color.b;

  		return this;

  	},

  	copyGammaToLinear: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) gammaFactor = 2.0;

  		this.r = Math.pow( color.r, gammaFactor );
  		this.g = Math.pow( color.g, gammaFactor );
  		this.b = Math.pow( color.b, gammaFactor );

  		return this;

  	},

  	copyLinearToGamma: function ( color, gammaFactor ) {

  		if ( gammaFactor === undefined ) gammaFactor = 2.0;

  		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

  		this.r = Math.pow( color.r, safeInverse );
  		this.g = Math.pow( color.g, safeInverse );
  		this.b = Math.pow( color.b, safeInverse );

  		return this;

  	},

  	convertGammaToLinear: function () {

  		var r = this.r, g = this.g, b = this.b;

  		this.r = r * r;
  		this.g = g * g;
  		this.b = b * b;

  		return this;

  	},

  	convertLinearToGamma: function () {

  		this.r = Math.sqrt( this.r );
  		this.g = Math.sqrt( this.g );
  		this.b = Math.sqrt( this.b );

  		return this;

  	},

  	getHex: function () {

  		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  	},

  	getHexString: function () {

  		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  	},

  	getHSL: function ( optionalTarget ) {

  		// h,s,l ranges are in 0.0 - 1.0

  		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

  		var r = this.r, g = this.g, b = this.b;

  		var max = Math.max( r, g, b );
  		var min = Math.min( r, g, b );

  		var hue, saturation;
  		var lightness = ( min + max ) / 2.0;

  		if ( min === max ) {

  			hue = 0;
  			saturation = 0;

  		} else {

  			var delta = max - min;

  			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

  			switch ( max ) {

  				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
  				case g: hue = ( b - r ) / delta + 2; break;
  				case b: hue = ( r - g ) / delta + 4; break;

  			}

  			hue /= 6;

  		}

  		hsl.h = hue;
  		hsl.s = saturation;
  		hsl.l = lightness;

  		return hsl;

  	},

  	getStyle: function () {

  		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  	},

  	offsetHSL: function ( h, s, l ) {

  		var hsl = this.getHSL();

  		hsl.h += h; hsl.s += s; hsl.l += l;

  		this.setHSL( hsl.h, hsl.s, hsl.l );

  		return this;

  	},

  	add: function ( color ) {

  		this.r += color.r;
  		this.g += color.g;
  		this.b += color.b;

  		return this;

  	},

  	addColors: function ( color1, color2 ) {

  		this.r = color1.r + color2.r;
  		this.g = color1.g + color2.g;
  		this.b = color1.b + color2.b;

  		return this;

  	},

  	addScalar: function ( s ) {

  		this.r += s;
  		this.g += s;
  		this.b += s;

  		return this;

  	},

  	sub: function( color ) {

  		this.r = Math.max( 0, this.r - color.r );
  		this.g = Math.max( 0, this.g - color.g );
  		this.b = Math.max( 0, this.b - color.b );

  		return this;

  	},

  	multiply: function ( color ) {

  		this.r *= color.r;
  		this.g *= color.g;
  		this.b *= color.b;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		this.r *= s;
  		this.g *= s;
  		this.b *= s;

  		return this;

  	},

  	lerp: function ( color, alpha ) {

  		this.r += ( color.r - this.r ) * alpha;
  		this.g += ( color.g - this.g ) * alpha;
  		this.b += ( color.b - this.b ) * alpha;

  		return this;

  	},

  	equals: function ( c ) {

  		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.r = array[ offset ];
  		this.g = array[ offset + 1 ];
  		this.b = array[ offset + 2 ];

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this.r;
  		array[ offset + 1 ] = this.g;
  		array[ offset + 2 ] = this.b;

  		return array;

  	},

  	toJSON: function () {

  		return this.getHex();

  	}

  } );

  /**
   * Uniforms library for shared webgl shaders
   */

  var UniformsLib$1 = {

  	common: {

  		diffuse: { value: new Color$1( 0xeeeeee ) },
  		opacity: { value: 1.0 },

  		map: { value: null },
  		offsetRepeat: { value: new Vector4$1( 0, 0, 1, 1 ) },

  		specularMap: { value: null },
  		alphaMap: { value: null },

  		envMap: { value: null },
  		flipEnvMap: { value: - 1 },
  		reflectivity: { value: 1.0 },
  		refractionRatio: { value: 0.98 }

  	},

  	aomap: {

  		aoMap: { value: null },
  		aoMapIntensity: { value: 1 }

  	},

  	lightmap: {

  		lightMap: { value: null },
  		lightMapIntensity: { value: 1 }

  	},

  	emissivemap: {

  		emissiveMap: { value: null }

  	},

  	bumpmap: {

  		bumpMap: { value: null },
  		bumpScale: { value: 1 }

  	},

  	normalmap: {

  		normalMap: { value: null },
  		normalScale: { value: new Vector2$1( 1, 1 ) }

  	},

  	displacementmap: {

  		displacementMap: { value: null },
  		displacementScale: { value: 1 },
  		displacementBias: { value: 0 }

  	},

  	roughnessmap: {

  		roughnessMap: { value: null }

  	},

  	metalnessmap: {

  		metalnessMap: { value: null }

  	},

  	gradientmap: {

  		gradientMap: { value: null }

  	},

  	fog: {

  		fogDensity: { value: 0.00025 },
  		fogNear: { value: 1 },
  		fogFar: { value: 2000 },
  		fogColor: { value: new Color$1( 0xffffff ) }

  	},

  	lights: {

  		ambientLightColor: { value: [] },

  		directionalLights: { value: [], properties: {
  			direction: {},
  			color: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		directionalShadowMap: { value: [] },
  		directionalShadowMatrix: { value: [] },

  		spotLights: { value: [], properties: {
  			color: {},
  			position: {},
  			direction: {},
  			distance: {},
  			coneCos: {},
  			penumbraCos: {},
  			decay: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		spotShadowMap: { value: [] },
  		spotShadowMatrix: { value: [] },

  		pointLights: { value: [], properties: {
  			color: {},
  			position: {},
  			decay: {},
  			distance: {},

  			shadow: {},
  			shadowBias: {},
  			shadowRadius: {},
  			shadowMapSize: {}
  		} },

  		pointShadowMap: { value: [] },
  		pointShadowMatrix: { value: [] },

  		hemisphereLights: { value: [], properties: {
  			direction: {},
  			skyColor: {},
  			groundColor: {}
  		} },

  		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
  		rectAreaLights: { value: [], properties: {
  			color: {},
  			position: {},
  			width: {},
  			height: {}
  		} }

  	},

  	points: {

  		diffuse: { value: new Color$1( 0xeeeeee ) },
  		opacity: { value: 1.0 },
  		size: { value: 1.0 },
  		scale: { value: 1.0 },
  		map: { value: null },
  		offsetRepeat: { value: new Vector4$1( 0, 0, 1, 1 ) }

  	}

  };

  /**
   * Uniform Utilities
   */

  var UniformsUtils$1 = {

  	merge: function ( uniforms ) {

  		var merged = {};

  		for ( var u = 0; u < uniforms.length; u ++ ) {

  			var tmp = this.clone( uniforms[ u ] );

  			for ( var p in tmp ) {

  				merged[ p ] = tmp[ p ];

  			}

  		}

  		return merged;

  	},

  	clone: function ( uniforms_src ) {

  		var uniforms_dst = {};

  		for ( var u in uniforms_src ) {

  			uniforms_dst[ u ] = {};

  			for ( var p in uniforms_src[ u ] ) {

  				var parameter_src = uniforms_src[ u ][ p ];

  				if ( parameter_src && ( parameter_src.isColor ||
  					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
  					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
  					parameter_src.isTexture ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.clone();

  				} else if ( Array.isArray( parameter_src ) ) {

  					uniforms_dst[ u ][ p ] = parameter_src.slice();

  				} else {

  					uniforms_dst[ u ][ p ] = parameter_src;

  				}

  			}

  		}

  		return uniforms_dst;

  	}

  };

  var alphamap_fragment$1 = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

  var alphamap_pars_fragment$1 = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

  var alphatest_fragment$1 = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

  var aomap_fragment$1 = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

  var aomap_pars_fragment$1 = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

  var begin_vertex$1 = "\nvec3 transformed = vec3( position );\n";

  var beginnormal_vertex$1 = "\nvec3 objectNormal = vec3( normal );\n";

  var bsdfs$1 = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

  var bumpmap_pars_fragment$1 = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

  var clipping_planes_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

  var clipping_planes_pars_fragment$1 = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

  var clipping_planes_pars_vertex$1 = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

  var clipping_planes_vertex$1 = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

  var color_fragment$1 = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

  var color_pars_fragment$1 = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

  var color_pars_vertex$1 = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

  var color_vertex$1 = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

  var common$1 = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";

  var cube_uv_reflection_fragment$1 = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

  var defaultnormal_vertex$1 = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

  var displacementmap_pars_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

  var displacementmap_vertex$1 = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

  var emissivemap_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

  var emissivemap_pars_fragment$1 = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

  var encodings_fragment$1 = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

  var encodings_pars_fragment$1 = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

  var envmap_fragment$1 = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

  var envmap_pars_fragment$1 = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

  var envmap_pars_vertex$1 = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

  var envmap_vertex$1 = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

  var fog_vertex$1 = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

  var fog_pars_vertex$1 = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

  var fog_fragment$1 = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

  var fog_pars_fragment$1 = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

  var gradientmap_pars_fragment$1 = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

  var lightmap_fragment$1 = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

  var lightmap_pars_fragment$1 = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

  var lights_lambert_vertex$1 = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

  var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

  var lights_phong_fragment$1 = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

  var lights_phong_pars_fragment$1 = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

  var lights_physical_fragment$1 = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

  var lights_physical_pars_fragment$1 = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

  var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

  var logdepthbuf_fragment$1 = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

  var logdepthbuf_pars_fragment$1 = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

  var logdepthbuf_pars_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

  var logdepthbuf_vertex$1 = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

  var map_fragment$1 = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

  var map_pars_fragment$1 = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

  var map_particle_fragment$1 = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

  var map_particle_pars_fragment$1 = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

  var metalnessmap_fragment$1 = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

  var metalnessmap_pars_fragment$1 = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

  var morphnormal_vertex$1 = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

  var morphtarget_pars_vertex$1 = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

  var morphtarget_vertex$1 = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

  var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

  var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

  var normalmap_pars_fragment$1 = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

  var packing$1 = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

  var premultiplied_alpha_fragment$1 = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

  var project_vertex$1 = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

  var dithering_fragment$1 = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

  var dithering_pars_fragment$1 = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

  var roughnessmap_fragment$1 = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

  var roughnessmap_pars_fragment$1 = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

  var shadowmap_pars_fragment$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

  var shadowmap_pars_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

  var shadowmap_vertex$1 = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

  var shadowmask_pars_fragment$1 = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

  var skinbase_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

  var skinning_pars_vertex$1 = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

  var skinning_vertex$1 = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

  var skinnormal_vertex$1 = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

  var specularmap_fragment$1 = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

  var specularmap_pars_fragment$1 = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

  var tonemapping_fragment$1 = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

  var tonemapping_pars_fragment$1 = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

  var uv_pars_fragment$1 = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

  var uv_pars_vertex$1 = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

  var uv_vertex$1 = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

  var uv2_pars_fragment$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

  var uv2_pars_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

  var uv2_vertex$1 = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

  var worldpos_vertex$1 = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

  var cube_frag$1 = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

  var cube_vert$1 = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var depth_frag$1 = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

  var depth_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

  var distanceRGBA_frag$1 = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

  var distanceRGBA_vert$1 = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

  var equirect_frag$1 = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

  var equirect_vert$1 = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

  var linedashed_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var linedashed_vert$1 = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshbasic_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var meshbasic_vert$1 = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshlambert_frag$1 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshlambert_vert$1 = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphong_frag$1 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphong_vert$1 = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var meshphysical_frag$1 = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

  var meshphysical_vert$1 = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var normal_frag$1 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

  var normal_vert$1 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

  var points_frag$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

  var points_vert$1 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

  var shadow_frag$1 = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";

  var shadow_vert$1 = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

  var ShaderChunk$1 = {
  	alphamap_fragment: alphamap_fragment$1,
  	alphamap_pars_fragment: alphamap_pars_fragment$1,
  	alphatest_fragment: alphatest_fragment$1,
  	aomap_fragment: aomap_fragment$1,
  	aomap_pars_fragment: aomap_pars_fragment$1,
  	begin_vertex: begin_vertex$1,
  	beginnormal_vertex: beginnormal_vertex$1,
  	bsdfs: bsdfs$1,
  	bumpmap_pars_fragment: bumpmap_pars_fragment$1,
  	clipping_planes_fragment: clipping_planes_fragment$1,
  	clipping_planes_pars_fragment: clipping_planes_pars_fragment$1,
  	clipping_planes_pars_vertex: clipping_planes_pars_vertex$1,
  	clipping_planes_vertex: clipping_planes_vertex$1,
  	color_fragment: color_fragment$1,
  	color_pars_fragment: color_pars_fragment$1,
  	color_pars_vertex: color_pars_vertex$1,
  	color_vertex: color_vertex$1,
  	common: common$1,
  	cube_uv_reflection_fragment: cube_uv_reflection_fragment$1,
  	defaultnormal_vertex: defaultnormal_vertex$1,
  	displacementmap_pars_vertex: displacementmap_pars_vertex$1,
  	displacementmap_vertex: displacementmap_vertex$1,
  	emissivemap_fragment: emissivemap_fragment$1,
  	emissivemap_pars_fragment: emissivemap_pars_fragment$1,
  	encodings_fragment: encodings_fragment$1,
  	encodings_pars_fragment: encodings_pars_fragment$1,
  	envmap_fragment: envmap_fragment$1,
  	envmap_pars_fragment: envmap_pars_fragment$1,
  	envmap_pars_vertex: envmap_pars_vertex$1,
  	envmap_vertex: envmap_vertex$1,
  	fog_vertex: fog_vertex$1,
  	fog_pars_vertex: fog_pars_vertex$1,
  	fog_fragment: fog_fragment$1,
  	fog_pars_fragment: fog_pars_fragment$1,
  	gradientmap_pars_fragment: gradientmap_pars_fragment$1,
  	lightmap_fragment: lightmap_fragment$1,
  	lightmap_pars_fragment: lightmap_pars_fragment$1,
  	lights_lambert_vertex: lights_lambert_vertex$1,
  	lights_pars: lights_pars,
  	lights_phong_fragment: lights_phong_fragment$1,
  	lights_phong_pars_fragment: lights_phong_pars_fragment$1,
  	lights_physical_fragment: lights_physical_fragment$1,
  	lights_physical_pars_fragment: lights_physical_pars_fragment$1,
  	lights_template: lights_template,
  	logdepthbuf_fragment: logdepthbuf_fragment$1,
  	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment$1,
  	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex$1,
  	logdepthbuf_vertex: logdepthbuf_vertex$1,
  	map_fragment: map_fragment$1,
  	map_pars_fragment: map_pars_fragment$1,
  	map_particle_fragment: map_particle_fragment$1,
  	map_particle_pars_fragment: map_particle_pars_fragment$1,
  	metalnessmap_fragment: metalnessmap_fragment$1,
  	metalnessmap_pars_fragment: metalnessmap_pars_fragment$1,
  	morphnormal_vertex: morphnormal_vertex$1,
  	morphtarget_pars_vertex: morphtarget_pars_vertex$1,
  	morphtarget_vertex: morphtarget_vertex$1,
  	normal_flip: normal_flip,
  	normal_fragment: normal_fragment,
  	normalmap_pars_fragment: normalmap_pars_fragment$1,
  	packing: packing$1,
  	premultiplied_alpha_fragment: premultiplied_alpha_fragment$1,
  	project_vertex: project_vertex$1,
  	dithering_fragment: dithering_fragment$1,
  	dithering_pars_fragment: dithering_pars_fragment$1,
  	roughnessmap_fragment: roughnessmap_fragment$1,
  	roughnessmap_pars_fragment: roughnessmap_pars_fragment$1,
  	shadowmap_pars_fragment: shadowmap_pars_fragment$1,
  	shadowmap_pars_vertex: shadowmap_pars_vertex$1,
  	shadowmap_vertex: shadowmap_vertex$1,
  	shadowmask_pars_fragment: shadowmask_pars_fragment$1,
  	skinbase_vertex: skinbase_vertex$1,
  	skinning_pars_vertex: skinning_pars_vertex$1,
  	skinning_vertex: skinning_vertex$1,
  	skinnormal_vertex: skinnormal_vertex$1,
  	specularmap_fragment: specularmap_fragment$1,
  	specularmap_pars_fragment: specularmap_pars_fragment$1,
  	tonemapping_fragment: tonemapping_fragment$1,
  	tonemapping_pars_fragment: tonemapping_pars_fragment$1,
  	uv_pars_fragment: uv_pars_fragment$1,
  	uv_pars_vertex: uv_pars_vertex$1,
  	uv_vertex: uv_vertex$1,
  	uv2_pars_fragment: uv2_pars_fragment$1,
  	uv2_pars_vertex: uv2_pars_vertex$1,
  	uv2_vertex: uv2_vertex$1,
  	worldpos_vertex: worldpos_vertex$1,

  	cube_frag: cube_frag$1,
  	cube_vert: cube_vert$1,
  	depth_frag: depth_frag$1,
  	depth_vert: depth_vert$1,
  	distanceRGBA_frag: distanceRGBA_frag$1,
  	distanceRGBA_vert: distanceRGBA_vert$1,
  	equirect_frag: equirect_frag$1,
  	equirect_vert: equirect_vert$1,
  	linedashed_frag: linedashed_frag$1,
  	linedashed_vert: linedashed_vert$1,
  	meshbasic_frag: meshbasic_frag$1,
  	meshbasic_vert: meshbasic_vert$1,
  	meshlambert_frag: meshlambert_frag$1,
  	meshlambert_vert: meshlambert_vert$1,
  	meshphong_frag: meshphong_frag$1,
  	meshphong_vert: meshphong_vert$1,
  	meshphysical_frag: meshphysical_frag$1,
  	meshphysical_vert: meshphysical_vert$1,
  	normal_frag: normal_frag$1,
  	normal_vert: normal_vert$1,
  	points_frag: points_frag$1,
  	points_vert: points_vert$1,
  	shadow_frag: shadow_frag$1,
  	shadow_vert: shadow_vert$1
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   */

  var ShaderLib$1 = {

  	basic: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.aomap,
  			UniformsLib$1.lightmap,
  			UniformsLib$1.fog
  		] ),

  		vertexShader: ShaderChunk$1.meshbasic_vert,
  		fragmentShader: ShaderChunk$1.meshbasic_frag

  	},

  	lambert: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.aomap,
  			UniformsLib$1.lightmap,
  			UniformsLib$1.emissivemap,
  			UniformsLib$1.fog,
  			UniformsLib$1.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) }
  			}
  		] ),

  		vertexShader: ShaderChunk$1.meshlambert_vert,
  		fragmentShader: ShaderChunk$1.meshlambert_frag

  	},

  	phong: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.aomap,
  			UniformsLib$1.lightmap,
  			UniformsLib$1.emissivemap,
  			UniformsLib$1.bumpmap,
  			UniformsLib$1.normalmap,
  			UniformsLib$1.displacementmap,
  			UniformsLib$1.gradientmap,
  			UniformsLib$1.fog,
  			UniformsLib$1.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) },
  				specular: { value: new Color$1( 0x111111 ) },
  				shininess: { value: 30 }
  			}
  		] ),

  		vertexShader: ShaderChunk$1.meshphong_vert,
  		fragmentShader: ShaderChunk$1.meshphong_frag

  	},

  	standard: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.aomap,
  			UniformsLib$1.lightmap,
  			UniformsLib$1.emissivemap,
  			UniformsLib$1.bumpmap,
  			UniformsLib$1.normalmap,
  			UniformsLib$1.displacementmap,
  			UniformsLib$1.roughnessmap,
  			UniformsLib$1.metalnessmap,
  			UniformsLib$1.fog,
  			UniformsLib$1.lights,
  			{
  				emissive: { value: new Color$1( 0x000000 ) },
  				roughness: { value: 0.5 },
  				metalness: { value: 0.5 },
  				envMapIntensity: { value: 1 } // temporary
  			}
  		] ),

  		vertexShader: ShaderChunk$1.meshphysical_vert,
  		fragmentShader: ShaderChunk$1.meshphysical_frag

  	},

  	points: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.points,
  			UniformsLib$1.fog
  		] ),

  		vertexShader: ShaderChunk$1.points_vert,
  		fragmentShader: ShaderChunk$1.points_frag

  	},

  	dashed: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.fog,
  			{
  				scale: { value: 1 },
  				dashSize: { value: 1 },
  				totalSize: { value: 2 }
  			}
  		] ),

  		vertexShader: ShaderChunk$1.linedashed_vert,
  		fragmentShader: ShaderChunk$1.linedashed_frag

  	},

  	depth: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.displacementmap
  		] ),

  		vertexShader: ShaderChunk$1.depth_vert,
  		fragmentShader: ShaderChunk$1.depth_frag

  	},

  	normal: {

  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.common,
  			UniformsLib$1.bumpmap,
  			UniformsLib$1.normalmap,
  			UniformsLib$1.displacementmap,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),

  		vertexShader: ShaderChunk$1.normal_vert,
  		fragmentShader: ShaderChunk$1.normal_frag

  	},

  	/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */

  	cube: {

  		uniforms: {
  			tCube: { value: null },
  			tFlip: { value: - 1 },
  			opacity: { value: 1.0 }
  		},

  		vertexShader: ShaderChunk$1.cube_vert,
  		fragmentShader: ShaderChunk$1.cube_frag

  	},

  	/* -------------------------------------------------------------------------
  	//	Cube map shader
  	 ------------------------------------------------------------------------- */

  	equirect: {

  		uniforms: {
  			tEquirect: { value: null },
  			tFlip: { value: - 1 }
  		},

  		vertexShader: ShaderChunk$1.equirect_vert,
  		fragmentShader: ShaderChunk$1.equirect_frag

  	},

  	distanceRGBA: {

  		uniforms: {
  			lightPos: { value: new Vector3$1() }
  		},

  		vertexShader: ShaderChunk$1.distanceRGBA_vert,
  		fragmentShader: ShaderChunk$1.distanceRGBA_frag

  	}

  };

  ShaderLib$1.physical = {

  	uniforms: UniformsUtils$1.merge( [
  		ShaderLib$1.standard.uniforms,
  		{
  			clearCoat: { value: 0 },
  			clearCoatRoughness: { value: 0 }
  		}
  	] ),

  	vertexShader: ShaderChunk$1.meshphysical_vert,
  	fragmentShader: ShaderChunk$1.meshphysical_frag

  };

  /**
   * @author bhouston / http://clara.io
   */

  function Box2$1( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector2$1( + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector2$1( - Infinity, - Infinity );

  }

  Object.assign( Box2$1.prototype, {

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromPoints: function ( points ) {

  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector2$1();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = + Infinity;
  		this.max.x = this.max.y = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y;

  	},

  	getParameter: function ( point, optionalTarget ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		var result = optionalTarget || new Vector2$1();

  		return result.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 4 splitting planes to rule out intersections

  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector2$1();
  		return result.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector2$1();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function LensFlarePlugin( renderer, flares ) {

  	var gl = renderer.context;
  	var state = renderer.state;

  	var vertexBuffer, elementBuffer;
  	var shader, program, attributes, uniforms;

  	var tempTexture, occlusionTexture;

  	function init() {

  		var vertices = new Float32Array( [
  			- 1, - 1,  0, 0,
  			 1, - 1,  1, 0,
  			 1,  1,  1, 1,
  			- 1,  1,  0, 1
  		] );

  		var faces = new Uint16Array( [
  			0, 1, 2,
  			0, 2, 3
  		] );

  		// buffers

  		vertexBuffer     = gl.createBuffer();
  		elementBuffer    = gl.createBuffer();

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
  		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

  		// textures

  		tempTexture      = gl.createTexture();
  		occlusionTexture = gl.createTexture();

  		state.bindTexture( gl.TEXTURE_2D, tempTexture );
  		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

  		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
  		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
  		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

  		shader = {

  			vertexShader: [

  				"uniform lowp int renderType;",

  				"uniform vec3 screenPosition;",
  				"uniform vec2 scale;",
  				"uniform float rotation;",

  				"uniform sampler2D occlusionMap;",

  				"attribute vec2 position;",
  				"attribute vec2 uv;",

  				"varying vec2 vUV;",
  				"varying float vVisibility;",

  				"void main() {",

  					"vUV = uv;",

  					"vec2 pos = position;",

  					"if ( renderType == 2 ) {",

  						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
  						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

  						"vVisibility =        visibility.r / 9.0;",
  						"vVisibility *= 1.0 - visibility.g / 9.0;",
  						"vVisibility *=       visibility.b / 9.0;",
  						"vVisibility *= 1.0 - visibility.a / 9.0;",

  						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
  						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

  					"}",

  					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

  				"}"

  			].join( "\n" ),

  			fragmentShader: [

  				"uniform lowp int renderType;",

  				"uniform sampler2D map;",
  				"uniform float opacity;",
  				"uniform vec3 color;",

  				"varying vec2 vUV;",
  				"varying float vVisibility;",

  				"void main() {",

  					// pink square

  					"if ( renderType == 0 ) {",

  						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

  					// restore

  					"} else if ( renderType == 1 ) {",

  						"gl_FragColor = texture2D( map, vUV );",

  					// flare

  					"} else {",

  						"vec4 texture = texture2D( map, vUV );",
  						"texture.a *= opacity * vVisibility;",
  						"gl_FragColor = texture;",
  						"gl_FragColor.rgb *= color;",

  					"}",

  				"}"

  			].join( "\n" )

  		};

  		program = createProgram( shader );

  		attributes = {
  			vertex: gl.getAttribLocation ( program, "position" ),
  			uv:     gl.getAttribLocation ( program, "uv" )
  		};

  		uniforms = {
  			renderType:     gl.getUniformLocation( program, "renderType" ),
  			map:            gl.getUniformLocation( program, "map" ),
  			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
  			opacity:        gl.getUniformLocation( program, "opacity" ),
  			color:          gl.getUniformLocation( program, "color" ),
  			scale:          gl.getUniformLocation( program, "scale" ),
  			rotation:       gl.getUniformLocation( program, "rotation" ),
  			screenPosition: gl.getUniformLocation( program, "screenPosition" )
  		};

  	}

  	/*
  	 * Render lens flares
  	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
  	 *         reads these back and calculates occlusion.
  	 */

  	this.render = function ( scene, camera, viewport ) {

  		if ( flares.length === 0 ) return;

  		var tempPosition = new Vector3$1();

  		var invAspect = viewport.w / viewport.z,
  			halfViewportWidth = viewport.z * 0.5,
  			halfViewportHeight = viewport.w * 0.5;

  		var size = 16 / viewport.w,
  			scale = new Vector2$1( size * invAspect, size );

  		var screenPosition = new Vector3$1( 1, 1, 0 ),
  			screenPositionPixels = new Vector2$1( 1, 1 );

  		var validArea = new Box2$1();

  		validArea.min.set( viewport.x, viewport.y );
  		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

  		if ( program === undefined ) {

  			init();

  		}

  		gl.useProgram( program );

  		state.initAttributes();
  		state.enableAttribute( attributes.vertex );
  		state.enableAttribute( attributes.uv );
  		state.disableUnusedAttributes();

  		// loop through all lens flares to update their occlusion and positions
  		// setup gl and common used attribs/uniforms

  		gl.uniform1i( uniforms.occlusionMap, 0 );
  		gl.uniform1i( uniforms.map, 1 );

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
  		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

  		state.disable( gl.CULL_FACE );
  		state.buffers.depth.setMask( false );

  		for ( var i = 0, l = flares.length; i < l; i ++ ) {

  			size = 16 / viewport.w;
  			scale.set( size * invAspect, size );

  			// calc object screen position

  			var flare = flares[ i ];

  			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

  			tempPosition.applyMatrix4( camera.matrixWorldInverse );
  			tempPosition.applyMatrix4( camera.projectionMatrix );

  			// setup arrays for gl programs

  			screenPosition.copy( tempPosition );

  			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

  			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
  			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

  			// screen cull

  			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

  				// save current RGB to temp texture

  				state.activeTexture( gl.TEXTURE0 );
  				state.bindTexture( gl.TEXTURE_2D, null );
  				state.activeTexture( gl.TEXTURE1 );
  				state.bindTexture( gl.TEXTURE_2D, tempTexture );
  				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


  				// render pink quad

  				gl.uniform1i( uniforms.renderType, 0 );
  				gl.uniform2f( uniforms.scale, scale.x, scale.y );
  				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

  				state.disable( gl.BLEND );
  				state.enable( gl.DEPTH_TEST );

  				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


  				// copy result to occlusionMap

  				state.activeTexture( gl.TEXTURE0 );
  				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
  				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


  				// restore graphics

  				gl.uniform1i( uniforms.renderType, 1 );
  				state.disable( gl.DEPTH_TEST );

  				state.activeTexture( gl.TEXTURE1 );
  				state.bindTexture( gl.TEXTURE_2D, tempTexture );
  				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


  				// update object positions

  				flare.positionScreen.copy( screenPosition );

  				if ( flare.customUpdateCallback ) {

  					flare.customUpdateCallback( flare );

  				} else {

  					flare.updateLensFlares();

  				}

  				// render flares

  				gl.uniform1i( uniforms.renderType, 2 );
  				state.enable( gl.BLEND );

  				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

  					var sprite = flare.lensFlares[ j ];

  					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

  						screenPosition.x = sprite.x;
  						screenPosition.y = sprite.y;
  						screenPosition.z = sprite.z;

  						size = sprite.size * sprite.scale / viewport.w;

  						scale.x = size * invAspect;
  						scale.y = size;

  						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
  						gl.uniform2f( uniforms.scale, scale.x, scale.y );
  						gl.uniform1f( uniforms.rotation, sprite.rotation );

  						gl.uniform1f( uniforms.opacity, sprite.opacity );
  						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

  						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
  						renderer.setTexture2D( sprite.texture, 1 );

  						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

  					}

  				}

  			}

  		}

  		// restore gl

  		state.enable( gl.CULL_FACE );
  		state.enable( gl.DEPTH_TEST );
  		state.buffers.depth.setMask( true );

  		renderer.resetGLState();

  	};

  	function createProgram( shader ) {

  		var program = gl.createProgram();

  		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
  		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

  		var prefix = "precision " + renderer.getPrecision() + " float;\n";

  		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
  		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

  		gl.compileShader( fragmentShader );
  		gl.compileShader( vertexShader );

  		gl.attachShader( program, fragmentShader );
  		gl.attachShader( program, vertexShader );

  		gl.linkProgram( program );

  		return program;

  	}

  }

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function SpritePlugin( renderer, sprites ) {

  	var gl = renderer.context;
  	var state = renderer.state;

  	var vertexBuffer, elementBuffer;
  	var program, attributes, uniforms;

  	var texture;

  	// decompose matrixWorld

  	var spritePosition = new Vector3$1();
  	var spriteRotation = new Quaternion$1();
  	var spriteScale = new Vector3$1();

  	function init() {

  		var vertices = new Float32Array( [
  			- 0.5, - 0.5,  0, 0,
  			  0.5, - 0.5,  1, 0,
  			  0.5,   0.5,  1, 1,
  			- 0.5,   0.5,  0, 1
  		] );

  		var faces = new Uint16Array( [
  			0, 1, 2,
  			0, 2, 3
  		] );

  		vertexBuffer  = gl.createBuffer();
  		elementBuffer = gl.createBuffer();

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
  		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

  		program = createProgram();

  		attributes = {
  			position:			gl.getAttribLocation ( program, 'position' ),
  			uv:					gl.getAttribLocation ( program, 'uv' )
  		};

  		uniforms = {
  			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
  			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

  			rotation:			gl.getUniformLocation( program, 'rotation' ),
  			scale:				gl.getUniformLocation( program, 'scale' ),

  			color:				gl.getUniformLocation( program, 'color' ),
  			map:				gl.getUniformLocation( program, 'map' ),
  			opacity:			gl.getUniformLocation( program, 'opacity' ),

  			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
  			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

  			fogType:			gl.getUniformLocation( program, 'fogType' ),
  			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
  			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
  			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
  			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

  			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
  		};

  		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  		canvas.width = 8;
  		canvas.height = 8;

  		var context = canvas.getContext( '2d' );
  		context.fillStyle = 'white';
  		context.fillRect( 0, 0, 8, 8 );

  		texture = new Texture$1( canvas );
  		texture.needsUpdate = true;

  	}

  	this.render = function ( scene, camera ) {

  		if ( sprites.length === 0 ) return;

  		// setup gl

  		if ( program === undefined ) {

  			init();

  		}

  		gl.useProgram( program );

  		state.initAttributes();
  		state.enableAttribute( attributes.position );
  		state.enableAttribute( attributes.uv );
  		state.disableUnusedAttributes();

  		state.disable( gl.CULL_FACE );
  		state.enable( gl.BLEND );

  		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
  		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
  		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

  		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

  		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

  		state.activeTexture( gl.TEXTURE0 );
  		gl.uniform1i( uniforms.map, 0 );

  		var oldFogType = 0;
  		var sceneFogType = 0;
  		var fog = scene.fog;

  		if ( fog ) {

  			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

  			if ( fog.isFog ) {

  				gl.uniform1f( uniforms.fogNear, fog.near );
  				gl.uniform1f( uniforms.fogFar, fog.far );

  				gl.uniform1i( uniforms.fogType, 1 );
  				oldFogType = 1;
  				sceneFogType = 1;

  			} else if ( fog.isFogExp2 ) {

  				gl.uniform1f( uniforms.fogDensity, fog.density );

  				gl.uniform1i( uniforms.fogType, 2 );
  				oldFogType = 2;
  				sceneFogType = 2;

  			}

  		} else {

  			gl.uniform1i( uniforms.fogType, 0 );
  			oldFogType = 0;
  			sceneFogType = 0;

  		}


  		// update positions and sort

  		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

  			var sprite = sprites[ i ];

  			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
  			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

  		}

  		sprites.sort( painterSortStable );

  		// render all sprites

  		var scale = [];

  		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

  			var sprite = sprites[ i ];
  			var material = sprite.material;

  			if ( material.visible === false ) continue;

  			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
  			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

  			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

  			scale[ 0 ] = spriteScale.x;
  			scale[ 1 ] = spriteScale.y;

  			var fogType = 0;

  			if ( scene.fog && material.fog ) {

  				fogType = sceneFogType;

  			}

  			if ( oldFogType !== fogType ) {

  				gl.uniform1i( uniforms.fogType, fogType );
  				oldFogType = fogType;

  			}

  			if ( material.map !== null ) {

  				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
  				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

  			} else {

  				gl.uniform2f( uniforms.uvOffset, 0, 0 );
  				gl.uniform2f( uniforms.uvScale, 1, 1 );

  			}

  			gl.uniform1f( uniforms.opacity, material.opacity );
  			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

  			gl.uniform1f( uniforms.rotation, material.rotation );
  			gl.uniform2fv( uniforms.scale, scale );

  			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
  			state.buffers.depth.setTest( material.depthTest );
  			state.buffers.depth.setMask( material.depthWrite );

  			if ( material.map ) {

  				renderer.setTexture2D( material.map, 0 );

  			} else {

  				renderer.setTexture2D( texture, 0 );

  			}

  			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

  		}

  		// restore gl

  		state.enable( gl.CULL_FACE );

  		renderer.resetGLState();

  	};

  	function createProgram() {

  		var program = gl.createProgram();

  		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
  		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

  		gl.shaderSource( vertexShader, [

  			'precision ' + renderer.getPrecision() + ' float;',

  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform float rotation;',
  			'uniform vec2 scale;',
  			'uniform vec2 uvOffset;',
  			'uniform vec2 uvScale;',

  			'attribute vec2 position;',
  			'attribute vec2 uv;',

  			'varying vec2 vUV;',

  			'void main() {',

  				'vUV = uvOffset + uv * uvScale;',

  				'vec2 alignedPosition = position * scale;',

  				'vec2 rotatedPosition;',
  				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
  				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

  				'vec4 finalPosition;',

  				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
  				'finalPosition.xy += rotatedPosition;',
  				'finalPosition = projectionMatrix * finalPosition;',

  				'gl_Position = finalPosition;',

  			'}'

  		].join( '\n' ) );

  		gl.shaderSource( fragmentShader, [

  			'precision ' + renderer.getPrecision() + ' float;',

  			'uniform vec3 color;',
  			'uniform sampler2D map;',
  			'uniform float opacity;',

  			'uniform int fogType;',
  			'uniform vec3 fogColor;',
  			'uniform float fogDensity;',
  			'uniform float fogNear;',
  			'uniform float fogFar;',
  			'uniform float alphaTest;',

  			'varying vec2 vUV;',

  			'void main() {',

  				'vec4 texture = texture2D( map, vUV );',

  				'if ( texture.a < alphaTest ) discard;',

  				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

  				'if ( fogType > 0 ) {',

  					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
  					'float fogFactor = 0.0;',

  					'if ( fogType == 1 ) {',

  						'fogFactor = smoothstep( fogNear, fogFar, depth );',

  					'} else {',

  						'const float LOG2 = 1.442695;',
  						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
  						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

  					'}',

  					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

  				'}',

  			'}'

  		].join( '\n' ) );

  		gl.compileShader( vertexShader );
  		gl.compileShader( fragmentShader );

  		gl.attachShader( program, vertexShader );
  		gl.attachShader( program, fragmentShader );

  		gl.linkProgram( program );

  		return program;

  	}

  	function painterSortStable( a, b ) {

  		if ( a.renderOrder !== b.renderOrder ) {

  			return a.renderOrder - b.renderOrder;

  		} else if ( a.z !== b.z ) {

  			return b.z - a.z;

  		} else {

  			return b.id - a.id;

  		}

  	}

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  var materialId$1 = 0;

  function Material$1() {

  	Object.defineProperty( this, 'id', { value: materialId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Material';

  	this.fog = true;
  	this.lights = true;

  	this.blending = NormalBlending$1;
  	this.side = FrontSide$1;
  	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
  	this.vertexColors = NoColors$1; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

  	this.opacity = 1;
  	this.transparent = false;

  	this.blendSrc = SrcAlphaFactor$1;
  	this.blendDst = OneMinusSrcAlphaFactor$1;
  	this.blendEquation = AddEquation$1;
  	this.blendSrcAlpha = null;
  	this.blendDstAlpha = null;
  	this.blendEquationAlpha = null;

  	this.depthFunc = LessEqualDepth$1;
  	this.depthTest = true;
  	this.depthWrite = true;

  	this.clippingPlanes = null;
  	this.clipIntersection = false;
  	this.clipShadows = false;

  	this.colorWrite = true;

  	this.precision = null; // override the renderer's default precision for this material

  	this.polygonOffset = false;
  	this.polygonOffsetFactor = 0;
  	this.polygonOffsetUnits = 0;

  	this.dithering = false;

  	this.alphaTest = 0;
  	this.premultipliedAlpha = false;

  	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  	this.visible = true;

  	this.needsUpdate = true;

  }

  Object.assign( Material$1.prototype, EventDispatcher$1.prototype, {

  	isMaterial: true,

  	setValues: function ( values ) {

  		if ( values === undefined ) return;

  		for ( var key in values ) {

  			var newValue = values[ key ];

  			if ( newValue === undefined ) {

  				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
  				continue;

  			}

  			var currentValue = this[ key ];

  			if ( currentValue === undefined ) {

  				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
  				continue;

  			}

  			if ( currentValue && currentValue.isColor ) {

  				currentValue.set( newValue );

  			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

  				currentValue.copy( newValue );

  			} else if ( key === 'overdraw' ) {

  				// ensure overdraw is backwards-compatible with legacy boolean type
  				this[ key ] = Number( newValue );

  			} else {

  				this[ key ] = newValue;

  			}

  		}

  	},

  	toJSON: function ( meta ) {

  		var isRoot = meta === undefined;

  		if ( isRoot ) {

  			meta = {
  				textures: {},
  				images: {}
  			};

  		}

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Material',
  				generator: 'Material.toJSON'
  			}
  		};

  		// standard Material serialization
  		data.uuid = this.uuid;
  		data.type = this.type;

  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

  		if ( this.roughness !== undefined ) data.roughness = this.roughness;
  		if ( this.metalness !== undefined ) data.metalness = this.metalness;

  		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
  		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
  		if ( this.shininess !== undefined ) data.shininess = this.shininess;
  		if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
  		if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

  		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
  		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
  		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
  		if ( this.bumpMap && this.bumpMap.isTexture ) {

  			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
  			data.bumpScale = this.bumpScale;

  		}
  		if ( this.normalMap && this.normalMap.isTexture ) {

  			data.normalMap = this.normalMap.toJSON( meta ).uuid;
  			data.normalScale = this.normalScale.toArray();

  		}
  		if ( this.displacementMap && this.displacementMap.isTexture ) {

  			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
  			data.displacementScale = this.displacementScale;
  			data.displacementBias = this.displacementBias;

  		}
  		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
  		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

  		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
  		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

  		if ( this.envMap && this.envMap.isTexture ) {

  			data.envMap = this.envMap.toJSON( meta ).uuid;
  			data.reflectivity = this.reflectivity; // Scale behind envMap

  		}

  		if ( this.gradientMap && this.gradientMap.isTexture ) {

  			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

  		}

  		if ( this.size !== undefined ) data.size = this.size;
  		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

  		if ( this.blending !== NormalBlending$1 ) data.blending = this.blending;
  		if ( this.shading !== SmoothShading ) data.shading = this.shading;
  		if ( this.side !== FrontSide$1 ) data.side = this.side;
  		if ( this.vertexColors !== NoColors$1 ) data.vertexColors = this.vertexColors;

  		if ( this.opacity < 1 ) data.opacity = this.opacity;
  		if ( this.transparent === true ) data.transparent = this.transparent;

  		data.depthFunc = this.depthFunc;
  		data.depthTest = this.depthTest;
  		data.depthWrite = this.depthWrite;

  		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
  		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
  		if ( this.wireframe === true ) data.wireframe = this.wireframe;
  		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
  		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
  		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

  		data.skinning = this.skinning;
  		data.morphTargets = this.morphTargets;

  		data.dithering = this.dithering;

  		// TODO: Copied from Object3D.toJSON

  		function extractFromCache( cache ) {

  			var values = [];

  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}

  			return values;

  		}

  		if ( isRoot ) {

  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( textures.length > 0 ) data.textures = textures;
  			if ( images.length > 0 ) data.images = images;

  		}

  		return data;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.name = source.name;

  		this.fog = source.fog;
  		this.lights = source.lights;

  		this.blending = source.blending;
  		this.side = source.side;
  		this.shading = source.shading;
  		this.vertexColors = source.vertexColors;

  		this.opacity = source.opacity;
  		this.transparent = source.transparent;

  		this.blendSrc = source.blendSrc;
  		this.blendDst = source.blendDst;
  		this.blendEquation = source.blendEquation;
  		this.blendSrcAlpha = source.blendSrcAlpha;
  		this.blendDstAlpha = source.blendDstAlpha;
  		this.blendEquationAlpha = source.blendEquationAlpha;

  		this.depthFunc = source.depthFunc;
  		this.depthTest = source.depthTest;
  		this.depthWrite = source.depthWrite;

  		this.colorWrite = source.colorWrite;

  		this.precision = source.precision;

  		this.polygonOffset = source.polygonOffset;
  		this.polygonOffsetFactor = source.polygonOffsetFactor;
  		this.polygonOffsetUnits = source.polygonOffsetUnits;

  		this.dithering = source.dithering;

  		this.alphaTest = source.alphaTest;

  		this.premultipliedAlpha = source.premultipliedAlpha;

  		this.overdraw = source.overdraw;

  		this.visible = source.visible;
  		this.clipShadows = source.clipShadows;
  		this.clipIntersection = source.clipIntersection;

  		var srcPlanes = source.clippingPlanes,
  			dstPlanes = null;

  		if ( srcPlanes !== null ) {

  			var n = srcPlanes.length;
  			dstPlanes = new Array( n );

  			for ( var i = 0; i !== n; ++ i )
  				dstPlanes[ i ] = srcPlanes[ i ].clone();

  		}

  		this.clippingPlanes = dstPlanes;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  defines: { "label" : "value" },
   *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
   *
   *  fragmentShader: <string>,
   *  vertexShader: <string>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  lights: <bool>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function ShaderMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'ShaderMaterial';

  	this.defines = {};
  	this.uniforms = {};

  	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  	this.linewidth = 1;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false; // set to use scene fog
  	this.lights = false; // set to use scene lights
  	this.clipping = false; // set to use user-defined clipping planes

  	this.skinning = false; // set to use skinning attribute streams
  	this.morphTargets = false; // set to use morph targets
  	this.morphNormals = false; // set to use morph normals

  	this.extensions = {
  		derivatives: false, // set to use derivatives
  		fragDepth: false, // set to use fragment depth values
  		drawBuffers: false, // set to use draw buffers
  		shaderTextureLOD: false // set to use shader texture LOD
  	};

  	// When rendered geometry doesn't include these attributes but the material does,
  	// use these default values in WebGL. This avoids errors when buffer data is missing.
  	this.defaultAttributeValues = {
  		'color': [ 1, 1, 1 ],
  		'uv': [ 0, 0 ],
  		'uv2': [ 0, 0 ]
  	};

  	this.index0AttributeName = undefined;

  	if ( parameters !== undefined ) {

  		if ( parameters.attributes !== undefined ) {

  			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

  		}

  		this.setValues( parameters );

  	}

  }

  ShaderMaterial$1.prototype = Object.create( Material$1.prototype );
  ShaderMaterial$1.prototype.constructor = ShaderMaterial$1;

  ShaderMaterial$1.prototype.isShaderMaterial = true;

  ShaderMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.fragmentShader = source.fragmentShader;
  	this.vertexShader = source.vertexShader;

  	this.uniforms = UniformsUtils$1.clone( source.uniforms );

  	this.defines = source.defines;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.lights = source.lights;
  	this.clipping = source.clipping;

  	this.skinning = source.skinning;

  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	this.extensions = source.extensions;

  	return this;

  };

  ShaderMaterial$1.prototype.toJSON = function ( meta ) {

  	var data = Material$1.prototype.toJSON.call( this, meta );

  	data.uniforms = this.uniforms;
  	data.vertexShader = this.vertexShader;
  	data.fragmentShader = this.fragmentShader;

  	return data;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / https://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   * }
   */

  function MeshDepthMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshDepthMaterial';

  	this.depthPacking = BasicDepthPacking$1;

  	this.skinning = false;
  	this.morphTargets = false;

  	this.map = null;

  	this.alphaMap = null;

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshDepthMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshDepthMaterial$1.prototype.constructor = MeshDepthMaterial$1;

  MeshDepthMaterial$1.prototype.isMeshDepthMaterial = true;

  MeshDepthMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.depthPacking = source.depthPacking;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	this.map = source.map;

  	this.alphaMap = source.alphaMap;

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	return this;

  };

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   */

  function Box3$1( min, max ) {

  	this.min = ( min !== undefined ) ? min : new Vector3$1( + Infinity, + Infinity, + Infinity );
  	this.max = ( max !== undefined ) ? max : new Vector3$1( - Infinity, - Infinity, - Infinity );

  }

  Object.assign( Box3$1.prototype, {

  	isBox3: true,

  	set: function ( min, max ) {

  		this.min.copy( min );
  		this.max.copy( max );

  		return this;

  	},

  	setFromArray: function ( array ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = array.length; i < l; i += 3 ) {

  			var x = array[ i ];
  			var y = array[ i + 1 ];
  			var z = array[ i + 2 ];

  			if ( x < minX ) minX = x;
  			if ( y < minY ) minY = y;
  			if ( z < minZ ) minZ = z;

  			if ( x > maxX ) maxX = x;
  			if ( y > maxY ) maxY = y;
  			if ( z > maxZ ) maxZ = z;

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromBufferAttribute: function ( attribute ) {

  		var minX = + Infinity;
  		var minY = + Infinity;
  		var minZ = + Infinity;

  		var maxX = - Infinity;
  		var maxY = - Infinity;
  		var maxZ = - Infinity;

  		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  			var x = attribute.getX( i );
  			var y = attribute.getY( i );
  			var z = attribute.getZ( i );

  			if ( x < minX ) minX = x;
  			if ( y < minY ) minY = y;
  			if ( z < minZ ) minZ = z;

  			if ( x > maxX ) maxX = x;
  			if ( y > maxY ) maxY = y;
  			if ( z > maxZ ) maxZ = z;

  		}

  		this.min.set( minX, minY, minZ );
  		this.max.set( maxX, maxY, maxZ );

  		return this;

  	},

  	setFromPoints: function ( points ) {

  		this.makeEmpty();

  		for ( var i = 0, il = points.length; i < il; i ++ ) {

  			this.expandByPoint( points[ i ] );

  		}

  		return this;

  	},

  	setFromCenterAndSize: function () {

  		var v1 = new Vector3$1();

  		return function setFromCenterAndSize( center, size ) {

  			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

  			this.min.copy( center ).sub( halfSize );
  			this.max.copy( center ).add( halfSize );

  			return this;

  		};

  	}(),

  	setFromObject: function ( object ) {

  		this.makeEmpty();

  		return this.expandByObject( object );

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( box ) {

  		this.min.copy( box.min );
  		this.max.copy( box.max );

  		return this;

  	},

  	makeEmpty: function () {

  		this.min.x = this.min.y = this.min.z = + Infinity;
  		this.max.x = this.max.y = this.max.z = - Infinity;

  		return this;

  	},

  	isEmpty: function () {

  		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

  		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  	},

  	getSize: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

  	},

  	expandByPoint: function ( point ) {

  		this.min.min( point );
  		this.max.max( point );

  		return this;

  	},

  	expandByVector: function ( vector ) {

  		this.min.sub( vector );
  		this.max.add( vector );

  		return this;

  	},

  	expandByScalar: function ( scalar ) {

  		this.min.addScalar( - scalar );
  		this.max.addScalar( scalar );

  		return this;

  	},

  	expandByObject: function () {

  		// Computes the world-axis-aligned bounding box of an object (including its children),
  		// accounting for both the object's, and children's, world transforms

  		var v1 = new Vector3$1();

  		return function expandByObject( object ) {

  			var scope = this;

  			object.updateMatrixWorld( true );

  			object.traverse( function ( node ) {

  				var i, l;

  				var geometry = node.geometry;

  				if ( geometry !== undefined ) {

  					if ( geometry.isGeometry ) {

  						var vertices = geometry.vertices;

  						for ( i = 0, l = vertices.length; i < l; i ++ ) {

  							v1.copy( vertices[ i ] );
  							v1.applyMatrix4( node.matrixWorld );

  							scope.expandByPoint( v1 );

  						}

  					} else if ( geometry.isBufferGeometry ) {

  						var attribute = geometry.attributes.position;

  						if ( attribute !== undefined ) {

  							for ( i = 0, l = attribute.count; i < l; i ++ ) {

  								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

  								scope.expandByPoint( v1 );

  							}

  						}

  					}

  				}

  			} );

  			return this;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		return point.x < this.min.x || point.x > this.max.x ||
  			point.y < this.min.y || point.y > this.max.y ||
  			point.z < this.min.z || point.z > this.max.z ? false : true;

  	},

  	containsBox: function ( box ) {

  		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
  			this.min.y <= box.min.y && box.max.y <= this.max.y &&
  			this.min.z <= box.min.z && box.max.z <= this.max.z;

  	},

  	getParameter: function ( point, optionalTarget ) {

  		// This can potentially have a divide by zero if the box
  		// has a size dimension of 0.

  		var result = optionalTarget || new Vector3$1();

  		return result.set(
  			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
  			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
  			( point.z - this.min.z ) / ( this.max.z - this.min.z )
  		);

  	},

  	intersectsBox: function ( box ) {

  		// using 6 splitting planes to rule out intersections.
  		return box.max.x < this.min.x || box.min.x > this.max.x ||
  			box.max.y < this.min.y || box.min.y > this.max.y ||
  			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

  	},

  	intersectsSphere: ( function () {

  		var closestPoint = new Vector3$1();

  		return function intersectsSphere( sphere ) {

  			// Find the point on the AABB closest to the sphere center.
  			this.clampPoint( sphere.center, closestPoint );

  			// If that point is inside the sphere, the AABB and sphere intersect.
  			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

  		};

  	} )(),

  	intersectsPlane: function ( plane ) {

  		// We compute the minimum and maximum dot product values. If those values
  		// are on the same side (back or front) of the plane, then there is no intersection.

  		var min, max;

  		if ( plane.normal.x > 0 ) {

  			min = plane.normal.x * this.min.x;
  			max = plane.normal.x * this.max.x;

  		} else {

  			min = plane.normal.x * this.max.x;
  			max = plane.normal.x * this.min.x;

  		}

  		if ( plane.normal.y > 0 ) {

  			min += plane.normal.y * this.min.y;
  			max += plane.normal.y * this.max.y;

  		} else {

  			min += plane.normal.y * this.max.y;
  			max += plane.normal.y * this.min.y;

  		}

  		if ( plane.normal.z > 0 ) {

  			min += plane.normal.z * this.min.z;
  			max += plane.normal.z * this.max.z;

  		} else {

  			min += plane.normal.z * this.max.z;
  			max += plane.normal.z * this.min.z;

  		}

  		return ( min <= plane.constant && max >= plane.constant );

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.copy( point ).clamp( this.min, this.max );

  	},

  	distanceToPoint: function () {

  		var v1 = new Vector3$1();

  		return function distanceToPoint( point ) {

  			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
  			return clampedPoint.sub( point ).length();

  		};

  	}(),

  	getBoundingSphere: function () {

  		var v1 = new Vector3$1();

  		return function getBoundingSphere( optionalTarget ) {

  			var result = optionalTarget || new Sphere$2();

  			this.getCenter( result.center );

  			result.radius = this.getSize( v1 ).length() * 0.5;

  			return result;

  		};

  	}(),

  	intersect: function ( box ) {

  		this.min.max( box.min );
  		this.max.min( box.max );

  		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
  		if( this.isEmpty() ) this.makeEmpty();

  		return this;

  	},

  	union: function ( box ) {

  		this.min.min( box.min );
  		this.max.max( box.max );

  		return this;

  	},

  	applyMatrix4: function () {

  		var points = [
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1(),
  			new Vector3$1()
  		];

  		return function applyMatrix4( matrix ) {

  			// transform of empty box is an empty box.
  			if( this.isEmpty() ) return this;

  			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
  			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
  			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
  			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
  			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
  			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
  			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
  			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
  			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

  			this.setFromPoints( points );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.min.add( offset );
  		this.max.add( offset );

  		return this;

  	},

  	equals: function ( box ) {

  		return box.min.equals( this.min ) && box.max.equals( this.max );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Sphere$2( center, radius ) {

  	this.center = ( center !== undefined ) ? center : new Vector3$1();
  	this.radius = ( radius !== undefined ) ? radius : 0;

  }

  Object.assign( Sphere$2.prototype, {

  	set: function ( center, radius ) {

  		this.center.copy( center );
  		this.radius = radius;

  		return this;

  	},

  	setFromPoints: function () {

  		var box = new Box3$1();

  		return function setFromPoints( points, optionalCenter ) {

  			var center = this.center;

  			if ( optionalCenter !== undefined ) {

  				center.copy( optionalCenter );

  			} else {

  				box.setFromPoints( points ).getCenter( center );

  			}

  			var maxRadiusSq = 0;

  			for ( var i = 0, il = points.length; i < il; i ++ ) {

  				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

  			}

  			this.radius = Math.sqrt( maxRadiusSq );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( sphere ) {

  		this.center.copy( sphere.center );
  		this.radius = sphere.radius;

  		return this;

  	},

  	empty: function () {

  		return ( this.radius <= 0 );

  	},

  	containsPoint: function ( point ) {

  		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  	},

  	distanceToPoint: function ( point ) {

  		return ( point.distanceTo( this.center ) - this.radius );

  	},

  	intersectsSphere: function ( sphere ) {

  		var radiusSum = this.radius + sphere.radius;

  		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsSphere( this );

  	},

  	intersectsPlane: function ( plane ) {

  		// We use the following equation to compute the signed distance from
  		// the center of the sphere to the plane.
  		//
  		// distance = q * n - d
  		//
  		// If this distance is greater than the radius of the sphere,
  		// then there is no intersection.

  		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

  	},

  	clampPoint: function ( point, optionalTarget ) {

  		var deltaLengthSq = this.center.distanceToSquared( point );

  		var result = optionalTarget || new Vector3$1();

  		result.copy( point );

  		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

  			result.sub( this.center ).normalize();
  			result.multiplyScalar( this.radius ).add( this.center );

  		}

  		return result;

  	},

  	getBoundingBox: function ( optionalTarget ) {

  		var box = optionalTarget || new Box3$1();

  		box.set( this.center, this.center );
  		box.expandByScalar( this.radius );

  		return box;

  	},

  	applyMatrix4: function ( matrix ) {

  		this.center.applyMatrix4( matrix );
  		this.radius = this.radius * matrix.getMaxScaleOnAxis();

  		return this;

  	},

  	translate: function ( offset ) {

  		this.center.add( offset );

  		return this;

  	},

  	equals: function ( sphere ) {

  		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   * @author tschw
   */

  function Matrix3$1() {

  	this.elements = [

  		1, 0, 0,
  		0, 1, 0,
  		0, 0, 1

  	];

  	if ( arguments.length > 0 ) {

  		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  	}

  }

  Object.assign( Matrix3$1.prototype, {

  	isMatrix3: true,

  	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

  		var te = this.elements;

  		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
  		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
  		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

  		return this;

  	},

  	identity: function () {

  		this.set(

  			1, 0, 0,
  			0, 1, 0,
  			0, 0, 1

  		);

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().fromArray( this.elements );

  	},

  	copy: function ( m ) {

  		var te = this.elements;
  		var me = m.elements;

  		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
  		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
  		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

  		return this;

  	},

  	setFromMatrix4: function ( m ) {

  		var me = m.elements;

  		this.set(

  			me[ 0 ], me[ 4 ], me[  8 ],
  			me[ 1 ], me[ 5 ], me[  9 ],
  			me[ 2 ], me[ 6 ], me[ 10 ]

  		);

  		return this;

  	},

  	applyToBufferAttribute: function () {

  		var v1 = new Vector3$1();

  		return function applyToBufferAttribute( attribute ) {

  			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

  				v1.x = attribute.getX( i );
  				v1.y = attribute.getY( i );
  				v1.z = attribute.getZ( i );

  				v1.applyMatrix3( this );

  				attribute.setXYZ( i, v1.x, v1.y, v1.z );

  			}

  			return attribute;

  		};

  	}(),

  	multiply: function ( m ) {

  		return this.multiplyMatrices( this, m );

  	},

  	premultiply: function ( m ) {

  		return this.multiplyMatrices( m, this );

  	},

  	multiplyMatrices: function ( a, b ) {

  		var ae = a.elements;
  		var be = b.elements;
  		var te = this.elements;

  		var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
  		var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
  		var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

  		var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
  		var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
  		var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

  		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
  		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
  		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

  		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
  		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
  		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

  		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
  		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
  		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

  		return this;

  	},

  	multiplyScalar: function ( s ) {

  		var te = this.elements;

  		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
  		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
  		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

  		return this;

  	},

  	determinant: function () {

  		var te = this.elements;

  		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
  			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
  			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

  		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  	},

  	getInverse: function ( matrix, throwOnDegenerate ) {

  		if ( matrix && matrix.isMatrix4 ) {

  			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

  		}

  		var me = matrix.elements,
  			te = this.elements,

  			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
  			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
  			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

  			t11 = n33 * n22 - n32 * n23,
  			t12 = n32 * n13 - n33 * n12,
  			t13 = n23 * n12 - n22 * n13,

  			det = n11 * t11 + n21 * t12 + n31 * t13;

  		if ( det === 0 ) {

  			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

  			if ( throwOnDegenerate === true ) {

  				throw new Error( msg );

  			} else {

  				console.warn( msg );

  			}

  			return this.identity();

  		}

  		var detInv = 1 / det;

  		te[ 0 ] = t11 * detInv;
  		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
  		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

  		te[ 3 ] = t12 * detInv;
  		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
  		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

  		te[ 6 ] = t13 * detInv;
  		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
  		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

  		return this;

  	},

  	transpose: function () {

  		var tmp, m = this.elements;

  		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
  		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
  		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

  		return this;

  	},

  	getNormalMatrix: function ( matrix4 ) {

  		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

  	},

  	transposeIntoArray: function ( r ) {

  		var m = this.elements;

  		r[ 0 ] = m[ 0 ];
  		r[ 1 ] = m[ 3 ];
  		r[ 2 ] = m[ 6 ];
  		r[ 3 ] = m[ 1 ];
  		r[ 4 ] = m[ 4 ];
  		r[ 5 ] = m[ 7 ];
  		r[ 6 ] = m[ 2 ];
  		r[ 7 ] = m[ 5 ];
  		r[ 8 ] = m[ 8 ];

  		return this;

  	},

  	equals: function ( matrix ) {

  		var te = this.elements;
  		var me = matrix.elements;

  		for ( var i = 0; i < 9; i ++ ) {

  			if ( te[ i ] !== me[ i ] ) return false;

  		}

  		return true;

  	},

  	fromArray: function ( array, offset ) {

  		if ( offset === undefined ) offset = 0;

  		for ( var i = 0; i < 9; i ++ ) {

  			this.elements[ i ] = array[ i + offset ];

  		}

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		var te = this.elements;

  		array[ offset ] = te[ 0 ];
  		array[ offset + 1 ] = te[ 1 ];
  		array[ offset + 2 ] = te[ 2 ];

  		array[ offset + 3 ] = te[ 3 ];
  		array[ offset + 4 ] = te[ 4 ];
  		array[ offset + 5 ] = te[ 5 ];

  		array[ offset + 6 ] = te[ 6 ];
  		array[ offset + 7 ] = te[ 7 ];
  		array[ offset + 8 ] = te[ 8 ];

  		return array;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Plane$2( normal, constant ) {

  	this.normal = ( normal !== undefined ) ? normal : new Vector3$1( 1, 0, 0 );
  	this.constant = ( constant !== undefined ) ? constant : 0;

  }

  Object.assign( Plane$2.prototype, {

  	set: function ( normal, constant ) {

  		this.normal.copy( normal );
  		this.constant = constant;

  		return this;

  	},

  	setComponents: function ( x, y, z, w ) {

  		this.normal.set( x, y, z );
  		this.constant = w;

  		return this;

  	},

  	setFromNormalAndCoplanarPoint: function ( normal, point ) {

  		this.normal.copy( normal );
  		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

  		return this;

  	},

  	setFromCoplanarPoints: function () {

  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function setFromCoplanarPoints( a, b, c ) {

  			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

  			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

  			this.setFromNormalAndCoplanarPoint( normal, a );

  			return this;

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( plane ) {

  		this.normal.copy( plane.normal );
  		this.constant = plane.constant;

  		return this;

  	},

  	normalize: function () {

  		// Note: will lead to a divide by zero if the plane is invalid.

  		var inverseNormalLength = 1.0 / this.normal.length();
  		this.normal.multiplyScalar( inverseNormalLength );
  		this.constant *= inverseNormalLength;

  		return this;

  	},

  	negate: function () {

  		this.constant *= - 1;
  		this.normal.negate();

  		return this;

  	},

  	distanceToPoint: function ( point ) {

  		return this.normal.dot( point ) + this.constant;

  	},

  	distanceToSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) - sphere.radius;

  	},

  	projectPoint: function ( point, optionalTarget ) {

  		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  	},

  	orthoPoint: function ( point, optionalTarget ) {

  		var perpendicularMagnitude = this.distanceToPoint( point );

  		var result = optionalTarget || new Vector3$1();
  		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  	},

  	intersectLine: function () {

  		var v1 = new Vector3$1();

  		return function intersectLine( line, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			var direction = line.delta( v1 );

  			var denominator = this.normal.dot( direction );

  			if ( denominator === 0 ) {

  				// line is coplanar, return origin
  				if ( this.distanceToPoint( line.start ) === 0 ) {

  					return result.copy( line.start );

  				}

  				// Unsure if this is the correct method to handle this case.
  				return undefined;

  			}

  			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

  			if ( t < 0 || t > 1 ) {

  				return undefined;

  			}

  			return result.copy( direction ).multiplyScalar( t ).add( line.start );

  		};

  	}(),

  	intersectsLine: function ( line ) {

  		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

  		var startSign = this.distanceToPoint( line.start );
  		var endSign = this.distanceToPoint( line.end );

  		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  	},

  	intersectsBox: function ( box ) {

  		return box.intersectsPlane( this );

  	},

  	intersectsSphere: function ( sphere ) {

  		return sphere.intersectsPlane( this );

  	},

  	coplanarPoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.copy( this.normal ).multiplyScalar( - this.constant );

  	},

  	applyMatrix4: function () {

  		var v1 = new Vector3$1();
  		var m1 = new Matrix3$1();

  		return function applyMatrix4( matrix, optionalNormalMatrix ) {

  			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

  			// transform normal based on theory here:
  			// http://www.songho.ca/opengl/gl_normaltransform.html
  			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
  			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

  			// recalculate constant (like in setFromNormalAndCoplanarPoint)
  			this.constant = - referencePoint.dot( normal );

  			return this;

  		};

  	}(),

  	translate: function ( offset ) {

  		this.constant = this.constant - offset.dot( this.normal );

  		return this;

  	},

  	equals: function ( plane ) {

  		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author bhouston / http://clara.io
   */

  function Frustum$1( p0, p1, p2, p3, p4, p5 ) {

  	this.planes = [

  		( p0 !== undefined ) ? p0 : new Plane$2(),
  		( p1 !== undefined ) ? p1 : new Plane$2(),
  		( p2 !== undefined ) ? p2 : new Plane$2(),
  		( p3 !== undefined ) ? p3 : new Plane$2(),
  		( p4 !== undefined ) ? p4 : new Plane$2(),
  		( p5 !== undefined ) ? p5 : new Plane$2()

  	];

  }

  Object.assign( Frustum$1.prototype, {

  	set: function ( p0, p1, p2, p3, p4, p5 ) {

  		var planes = this.planes;

  		planes[ 0 ].copy( p0 );
  		planes[ 1 ].copy( p1 );
  		planes[ 2 ].copy( p2 );
  		planes[ 3 ].copy( p3 );
  		planes[ 4 ].copy( p4 );
  		planes[ 5 ].copy( p5 );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( frustum ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			planes[ i ].copy( frustum.planes[ i ] );

  		}

  		return this;

  	},

  	setFromMatrix: function ( m ) {

  		var planes = this.planes;
  		var me = m.elements;
  		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
  		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
  		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
  		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

  		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
  		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
  		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
  		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
  		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
  		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

  		return this;

  	},

  	intersectsObject: function () {

  		var sphere = new Sphere$2();

  		return function intersectsObject( object ) {

  			var geometry = object.geometry;

  			if ( geometry.boundingSphere === null )
  				geometry.computeBoundingSphere();

  			sphere.copy( geometry.boundingSphere )
  				.applyMatrix4( object.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSprite: function () {

  		var sphere = new Sphere$2();

  		return function intersectsSprite( sprite ) {

  			sphere.center.set( 0, 0, 0 );
  			sphere.radius = 0.7071067811865476;
  			sphere.applyMatrix4( sprite.matrixWorld );

  			return this.intersectsSphere( sphere );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		var planes = this.planes;
  		var center = sphere.center;
  		var negRadius = - sphere.radius;

  		for ( var i = 0; i < 6; i ++ ) {

  			var distance = planes[ i ].distanceToPoint( center );

  			if ( distance < negRadius ) {

  				return false;

  			}

  		}

  		return true;

  	},

  	intersectsBox: function () {

  		var p1 = new Vector3$1(),
  			p2 = new Vector3$1();

  		return function intersectsBox( box ) {

  			var planes = this.planes;

  			for ( var i = 0; i < 6; i ++ ) {

  				var plane = planes[ i ];

  				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
  				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
  				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
  				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
  				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
  				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

  				var d1 = plane.distanceToPoint( p1 );
  				var d2 = plane.distanceToPoint( p2 );

  				// if both outside plane, no intersection

  				if ( d1 < 0 && d2 < 0 ) {

  					return false;

  				}

  			}

  			return true;

  		};

  	}(),

  	containsPoint: function ( point ) {

  		var planes = this.planes;

  		for ( var i = 0; i < 6; i ++ ) {

  			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

  				return false;

  			}

  		}

  		return true;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLShadowMap$1( _renderer, _lights, _objects, capabilities ) {

  	var _gl = _renderer.context,
  		_state = _renderer.state,
  		_frustum = new Frustum$1(),
  		_projScreenMatrix = new Matrix4$1(),

  		_lightShadows = _lights.shadows,

  		_shadowMapSize = new Vector2$1(),
  		_maxShadowMapSize = new Vector2$1( capabilities.maxTextureSize, capabilities.maxTextureSize ),

  		_lookTarget = new Vector3$1(),
  		_lightPositionWorld = new Vector3$1(),

  		_MorphingFlag = 1,
  		_SkinningFlag = 2,

  		_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

  		_depthMaterials = new Array( _NumberOfMaterialVariants ),
  		_distanceMaterials = new Array( _NumberOfMaterialVariants ),

  		_materialCache = {};

  	var cubeDirections = [
  		new Vector3$1( 1, 0, 0 ), new Vector3$1( - 1, 0, 0 ), new Vector3$1( 0, 0, 1 ),
  		new Vector3$1( 0, 0, - 1 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, - 1, 0 )
  	];

  	var cubeUps = [
  		new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ),
  		new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 0, 1 ),	new Vector3$1( 0, 0, - 1 )
  	];

  	var cube2DViewPorts = [
  		new Vector4$1(), new Vector4$1(), new Vector4$1(),
  		new Vector4$1(), new Vector4$1(), new Vector4$1()
  	];

  	// init

  	var depthMaterialTemplate = new MeshDepthMaterial$1();
  	depthMaterialTemplate.depthPacking = RGBADepthPacking$1;
  	depthMaterialTemplate.clipping = true;

  	var distanceShader = ShaderLib$1[ "distanceRGBA" ];
  	var distanceUniforms = UniformsUtils$1.clone( distanceShader.uniforms );

  	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

  		var useMorphing = ( i & _MorphingFlag ) !== 0;
  		var useSkinning = ( i & _SkinningFlag ) !== 0;

  		var depthMaterial = depthMaterialTemplate.clone();
  		depthMaterial.morphTargets = useMorphing;
  		depthMaterial.skinning = useSkinning;

  		_depthMaterials[ i ] = depthMaterial;

  		var distanceMaterial = new ShaderMaterial$1( {
  			defines: {
  				'USE_SHADOWMAP': ''
  			},
  			uniforms: distanceUniforms,
  			vertexShader: distanceShader.vertexShader,
  			fragmentShader: distanceShader.fragmentShader,
  			morphTargets: useMorphing,
  			skinning: useSkinning,
  			clipping: true
  		} );

  		_distanceMaterials[ i ] = distanceMaterial;

  	}

  	//

  	var scope = this;

  	this.enabled = false;

  	this.autoUpdate = true;
  	this.needsUpdate = false;

  	this.type = PCFShadowMap$1;

  	this.renderReverseSided = true;
  	this.renderSingleSided = true;

  	this.render = function ( scene, camera ) {

  		if ( scope.enabled === false ) return;
  		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

  		if ( _lightShadows.length === 0 ) return;

  		// Set GL state for depth map.
  		_state.disable( _gl.BLEND );
  		_state.buffers.color.setClear( 1, 1, 1, 1 );
  		_state.buffers.depth.setTest( true );
  		_state.setScissorTest( false );

  		// render depth map

  		var faceCount, isPointLight;

  		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

  			var light = _lightShadows[ i ];
  			var shadow = light.shadow;

  			if ( shadow === undefined ) {

  				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
  				continue;

  			}

  			var shadowCamera = shadow.camera;
  			var shadowMatrix = shadow.matrix;

  			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
  			shadowCamera.position.copy( _lightPositionWorld );

  			_shadowMapSize.copy( shadow.mapSize );
  			_shadowMapSize.min( _maxShadowMapSize );

  			if ( light && light.isPointLight ) {

  				faceCount = 6;
  				isPointLight = true;

  				var vpWidth = _shadowMapSize.x;
  				var vpHeight = _shadowMapSize.y;

  				// These viewports map a cube-map onto a 2D texture with the
  				// following orientation:
  				//
  				//  xzXZ
  				//   y Y
  				//
  				// X - Positive x direction
  				// x - Negative x direction
  				// Y - Positive y direction
  				// y - Negative y direction
  				// Z - Positive z direction
  				// z - Negative z direction

  				// positive X
  				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
  				// negative X
  				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
  				// positive Z
  				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
  				// negative Z
  				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
  				// positive Y
  				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
  				// negative Y
  				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

  				_shadowMapSize.x *= 4.0;
  				_shadowMapSize.y *= 2.0;


  				// for point lights we set the shadow matrix to be a translation-only matrix
  				// equal to inverse of the light's position

  				shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

  			} else {

  				faceCount = 1;
  				isPointLight = false;

  				_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
  				shadowCamera.lookAt( _lookTarget );
  				shadowCamera.updateMatrixWorld();
  				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

  				// compute shadow matrix

  				shadowMatrix.set(
  					0.5, 0.0, 0.0, 0.5,
  					0.0, 0.5, 0.0, 0.5,
  					0.0, 0.0, 0.5, 0.5,
  					0.0, 0.0, 0.0, 1.0
  				);

  				shadowMatrix.multiply( shadowCamera.projectionMatrix );
  				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

  			}

  			if ( shadow.map === null ) {

  				var pars = { minFilter: NearestFilter$1, magFilter: NearestFilter$1, format: RGBAFormat$1 };

  				shadow.map = new WebGLRenderTarget$1( _shadowMapSize.x, _shadowMapSize.y, pars );
  				shadow.map.texture.name = light.name + ".shadowMap";

  				shadowCamera.updateProjectionMatrix();

  			}

  			if ( shadow.isSpotLightShadow ) {

  				shadow.update( light );

  			}

  			var shadowMap = shadow.map;

  			_renderer.setRenderTarget( shadowMap );
  			_renderer.clear();

  			// render shadow map for each cube face (if omni-directional) or
  			// run a single pass if not

  			for ( var face = 0; face < faceCount; face ++ ) {

  				if ( isPointLight ) {

  					_lookTarget.copy( shadowCamera.position );
  					_lookTarget.add( cubeDirections[ face ] );
  					shadowCamera.up.copy( cubeUps[ face ] );
  					shadowCamera.lookAt( _lookTarget );
  					shadowCamera.updateMatrixWorld();
  					shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

  					var vpDimensions = cube2DViewPorts[ face ];
  					_state.viewport( vpDimensions );

  				}

  				// update camera matrices and frustum

  				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
  				_frustum.setFromMatrix( _projScreenMatrix );

  				// set object matrices & frustum culling

  				renderObject( scene, camera, shadowCamera, isPointLight );

  			}

  		}

  		// Restore GL state.
  		var clearColor = _renderer.getClearColor();
  		var clearAlpha = _renderer.getClearAlpha();
  		_renderer.setClearColor( clearColor, clearAlpha );

  		scope.needsUpdate = false;

  	};

  	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

  		var geometry = object.geometry;

  		var result = null;

  		var materialVariants = _depthMaterials;
  		var customMaterial = object.customDepthMaterial;

  		if ( isPointLight ) {

  			materialVariants = _distanceMaterials;
  			customMaterial = object.customDistanceMaterial;

  		}

  		if ( ! customMaterial ) {

  			var useMorphing = false;

  			if ( material.morphTargets ) {

  				if ( geometry && geometry.isBufferGeometry ) {

  					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

  				} else if ( geometry && geometry.isGeometry ) {

  					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

  				}

  			}

  			if ( object.isSkinnedMesh && material.skinning === false ) {

  				console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

  			}

  			var useSkinning = object.isSkinnedMesh && material.skinning;

  			var variantIndex = 0;

  			if ( useMorphing ) variantIndex |= _MorphingFlag;
  			if ( useSkinning ) variantIndex |= _SkinningFlag;

  			result = materialVariants[ variantIndex ];

  		} else {

  			result = customMaterial;

  		}

  		if ( _renderer.localClippingEnabled &&
  				material.clipShadows === true &&
  				material.clippingPlanes.length !== 0 ) {

  			// in this case we need a unique material instance reflecting the
  			// appropriate state

  			var keyA = result.uuid, keyB = material.uuid;

  			var materialsForVariant = _materialCache[ keyA ];

  			if ( materialsForVariant === undefined ) {

  				materialsForVariant = {};
  				_materialCache[ keyA ] = materialsForVariant;

  			}

  			var cachedMaterial = materialsForVariant[ keyB ];

  			if ( cachedMaterial === undefined ) {

  				cachedMaterial = result.clone();
  				materialsForVariant[ keyB ] = cachedMaterial;

  			}

  			result = cachedMaterial;

  		}

  		result.visible = material.visible;
  		result.wireframe = material.wireframe;

  		var side = material.side;

  		if ( scope.renderSingleSided && side == DoubleSide$1 ) {

  			side = FrontSide$1;

  		}

  		if ( scope.renderReverseSided ) {

  			if ( side === FrontSide$1 ) side = BackSide$1;
  			else if ( side === BackSide$1 ) side = FrontSide$1;

  		}

  		result.side = side;

  		result.clipShadows = material.clipShadows;
  		result.clippingPlanes = material.clippingPlanes;

  		result.wireframeLinewidth = material.wireframeLinewidth;
  		result.linewidth = material.linewidth;

  		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

  			result.uniforms.lightPos.value.copy( lightPositionWorld );

  		}

  		return result;

  	}

  	function renderObject( object, camera, shadowCamera, isPointLight ) {

  		if ( object.visible === false ) return;

  		var visible = object.layers.test( camera.layers );

  		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

  			if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

  				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

  				var geometry = _objects.update( object );
  				var material = object.material;

  				if ( Array.isArray( material ) ) {

  					var groups = geometry.groups;

  					for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

  						var group = groups[ k ];
  						var groupMaterial = material[ group.materialIndex ];

  						if ( groupMaterial && groupMaterial.visible ) {

  							var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
  							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

  						}

  					}

  				} else if ( material.visible ) {

  					var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
  					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			renderObject( children[ i ], camera, shadowCamera, isPointLight );

  		}

  	}

  }

  /**
   * @author bhouston / http://clara.io
   */

  function Ray$1( origin, direction ) {

  	this.origin = ( origin !== undefined ) ? origin : new Vector3$1();
  	this.direction = ( direction !== undefined ) ? direction : new Vector3$1();

  }

  Object.assign( Ray$1.prototype, {

  	set: function ( origin, direction ) {

  		this.origin.copy( origin );
  		this.direction.copy( direction );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( ray ) {

  		this.origin.copy( ray.origin );
  		this.direction.copy( ray.direction );

  		return this;

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  	},

  	lookAt: function ( v ) {

  		this.direction.copy( v ).sub( this.origin ).normalize();

  		return this;

  	},

  	recast: function () {

  		var v1 = new Vector3$1();

  		return function recast( t ) {

  			this.origin.copy( this.at( t, v1 ) );

  			return this;

  		};

  	}(),

  	closestPointToPoint: function ( point, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		result.subVectors( point, this.origin );
  		var directionDistance = result.dot( this.direction );

  		if ( directionDistance < 0 ) {

  			return result.copy( this.origin );

  		}

  		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  	},

  	distanceToPoint: function ( point ) {

  		return Math.sqrt( this.distanceSqToPoint( point ) );

  	},

  	distanceSqToPoint: function () {

  		var v1 = new Vector3$1();

  		return function distanceSqToPoint( point ) {

  			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

  			// point behind the ray

  			if ( directionDistance < 0 ) {

  				return this.origin.distanceToSquared( point );

  			}

  			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  			return v1.distanceToSquared( point );

  		};

  	}(),

  	distanceSqToSegment: function () {

  		var segCenter = new Vector3$1();
  		var segDir = new Vector3$1();
  		var diff = new Vector3$1();

  		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
  			// It returns the min distance between the ray and the segment
  			// defined by v0 and v1
  			// It can also set two optional targets :
  			// - The closest point on the ray
  			// - The closest point on the segment

  			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
  			segDir.copy( v1 ).sub( v0 ).normalize();
  			diff.copy( this.origin ).sub( segCenter );

  			var segExtent = v0.distanceTo( v1 ) * 0.5;
  			var a01 = - this.direction.dot( segDir );
  			var b0 = diff.dot( this.direction );
  			var b1 = - diff.dot( segDir );
  			var c = diff.lengthSq();
  			var det = Math.abs( 1 - a01 * a01 );
  			var s0, s1, sqrDist, extDet;

  			if ( det > 0 ) {

  				// The ray and segment are not parallel.

  				s0 = a01 * b1 - b0;
  				s1 = a01 * b0 - b1;
  				extDet = segExtent * det;

  				if ( s0 >= 0 ) {

  					if ( s1 >= - extDet ) {

  						if ( s1 <= extDet ) {

  							// region 0
  							// Minimum at interior points of ray and segment.

  							var invDet = 1 / det;
  							s0 *= invDet;
  							s1 *= invDet;
  							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

  						} else {

  							// region 1

  							s1 = segExtent;
  							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  						}

  					} else {

  						// region 5

  						s1 = - segExtent;
  						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				} else {

  					if ( s1 <= - extDet ) {

  						// region 4

  						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					} else if ( s1 <= extDet ) {

  						// region 3

  						s0 = 0;
  						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

  					} else {

  						// region 2

  						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
  						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
  						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  					}

  				}

  			} else {

  				// Ray and segment are parallel.

  				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
  				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
  				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

  			}

  			if ( optionalPointOnRay ) {

  				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

  			}

  			if ( optionalPointOnSegment ) {

  				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

  			}

  			return sqrDist;

  		};

  	}(),

  	intersectSphere: function () {

  		var v1 = new Vector3$1();

  		return function intersectSphere( sphere, optionalTarget ) {

  			v1.subVectors( sphere.center, this.origin );
  			var tca = v1.dot( this.direction );
  			var d2 = v1.dot( v1 ) - tca * tca;
  			var radius2 = sphere.radius * sphere.radius;

  			if ( d2 > radius2 ) return null;

  			var thc = Math.sqrt( radius2 - d2 );

  			// t0 = first intersect point - entrance on front of sphere
  			var t0 = tca - thc;

  			// t1 = second intersect point - exit point on back of sphere
  			var t1 = tca + thc;

  			// test to see if both t0 and t1 are behind the ray - if so, return null
  			if ( t0 < 0 && t1 < 0 ) return null;

  			// test to see if t0 is behind the ray:
  			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
  			// in order to always return an intersect point that is in front of the ray.
  			if ( t0 < 0 ) return this.at( t1, optionalTarget );

  			// else t0 is in front of the ray, so return the first collision point scaled by t0
  			return this.at( t0, optionalTarget );

  		};

  	}(),

  	intersectsSphere: function ( sphere ) {

  		return this.distanceToPoint( sphere.center ) <= sphere.radius;

  	},

  	distanceToPlane: function ( plane ) {

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator === 0 ) {

  			// line is coplanar, return origin
  			if ( plane.distanceToPoint( this.origin ) === 0 ) {

  				return 0;

  			}

  			// Null is preferable to undefined since undefined means.... it is undefined

  			return null;

  		}

  		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

  		// Return if the ray never intersects the plane

  		return t >= 0 ? t :  null;

  	},

  	intersectPlane: function ( plane, optionalTarget ) {

  		var t = this.distanceToPlane( plane );

  		if ( t === null ) {

  			return null;

  		}

  		return this.at( t, optionalTarget );

  	},

  	intersectsPlane: function ( plane ) {

  		// check if the ray lies on the plane first

  		var distToPoint = plane.distanceToPoint( this.origin );

  		if ( distToPoint === 0 ) {

  			return true;

  		}

  		var denominator = plane.normal.dot( this.direction );

  		if ( denominator * distToPoint < 0 ) {

  			return true;

  		}

  		// ray origin is behind the plane (and is pointing behind it)

  		return false;

  	},

  	intersectBox: function ( box, optionalTarget ) {

  		var tmin, tmax, tymin, tymax, tzmin, tzmax;

  		var invdirx = 1 / this.direction.x,
  			invdiry = 1 / this.direction.y,
  			invdirz = 1 / this.direction.z;

  		var origin = this.origin;

  		if ( invdirx >= 0 ) {

  			tmin = ( box.min.x - origin.x ) * invdirx;
  			tmax = ( box.max.x - origin.x ) * invdirx;

  		} else {

  			tmin = ( box.max.x - origin.x ) * invdirx;
  			tmax = ( box.min.x - origin.x ) * invdirx;

  		}

  		if ( invdiry >= 0 ) {

  			tymin = ( box.min.y - origin.y ) * invdiry;
  			tymax = ( box.max.y - origin.y ) * invdiry;

  		} else {

  			tymin = ( box.max.y - origin.y ) * invdiry;
  			tymax = ( box.min.y - origin.y ) * invdiry;

  		}

  		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

  		// These lines also handle the case where tmin or tmax is NaN
  		// (result of 0 * Infinity). x !== x returns true if x is NaN

  		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

  		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

  		if ( invdirz >= 0 ) {

  			tzmin = ( box.min.z - origin.z ) * invdirz;
  			tzmax = ( box.max.z - origin.z ) * invdirz;

  		} else {

  			tzmin = ( box.max.z - origin.z ) * invdirz;
  			tzmax = ( box.min.z - origin.z ) * invdirz;

  		}

  		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

  		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

  		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

  		//return point closest to the ray (positive side)

  		if ( tmax < 0 ) return null;

  		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  	},

  	intersectsBox: ( function () {

  		var v = new Vector3$1();

  		return function intersectsBox( box ) {

  			return this.intersectBox( box, v ) !== null;

  		};

  	} )(),

  	intersectTriangle: function () {

  		// Compute the offset origin, edges, and normal.
  		var diff = new Vector3$1();
  		var edge1 = new Vector3$1();
  		var edge2 = new Vector3$1();
  		var normal = new Vector3$1();

  		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

  			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

  			edge1.subVectors( b, a );
  			edge2.subVectors( c, a );
  			normal.crossVectors( edge1, edge2 );

  			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
  			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
  			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
  			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
  			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
  			var DdN = this.direction.dot( normal );
  			var sign;

  			if ( DdN > 0 ) {

  				if ( backfaceCulling ) return null;
  				sign = 1;

  			} else if ( DdN < 0 ) {

  				sign = - 1;
  				DdN = - DdN;

  			} else {

  				return null;

  			}

  			diff.subVectors( this.origin, a );
  			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

  			// b1 < 0, no intersection
  			if ( DdQxE2 < 0 ) {

  				return null;

  			}

  			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

  			// b2 < 0, no intersection
  			if ( DdE1xQ < 0 ) {

  				return null;

  			}

  			// b1+b2 > 1, no intersection
  			if ( DdQxE2 + DdE1xQ > DdN ) {

  				return null;

  			}

  			// Line intersects triangle, check if ray does.
  			var QdN = - sign * diff.dot( normal );

  			// t < 0, no intersection
  			if ( QdN < 0 ) {

  				return null;

  			}

  			// Ray intersects triangle.
  			return this.at( QdN / DdN, optionalTarget );

  		};

  	}(),

  	applyMatrix4: function ( matrix4 ) {

  		this.direction.add( this.origin ).applyMatrix4( matrix4 );
  		this.origin.applyMatrix4( matrix4 );
  		this.direction.sub( this.origin );
  		this.direction.normalize();

  		return this;

  	},

  	equals: function ( ray ) {

  		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author bhouston / http://clara.io
   */

  function Euler$1( x, y, z, order ) {

  	this._x = x || 0;
  	this._y = y || 0;
  	this._z = z || 0;
  	this._order = order || Euler$1.DefaultOrder;

  }

  Euler$1.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

  Euler$1.DefaultOrder = 'XYZ';

  Object.defineProperties( Euler$1.prototype, {

  	x: {

  		get: function () {

  			return this._x;

  		},

  		set: function ( value ) {

  			this._x = value;
  			this.onChangeCallback();

  		}

  	},

  	y: {

  		get: function () {

  			return this._y;

  		},

  		set: function ( value ) {

  			this._y = value;
  			this.onChangeCallback();

  		}

  	},

  	z: {

  		get: function () {

  			return this._z;

  		},

  		set: function ( value ) {

  			this._z = value;
  			this.onChangeCallback();

  		}

  	},

  	order: {

  		get: function () {

  			return this._order;

  		},

  		set: function ( value ) {

  			this._order = value;
  			this.onChangeCallback();

  		}

  	}

  } );

  Object.assign( Euler$1.prototype, {

  	isEuler: true,

  	set: function ( x, y, z, order ) {

  		this._x = x;
  		this._y = y;
  		this._z = z;
  		this._order = order || this._order;

  		this.onChangeCallback();

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this._x, this._y, this._z, this._order );

  	},

  	copy: function ( euler ) {

  		this._x = euler._x;
  		this._y = euler._y;
  		this._z = euler._z;
  		this._order = euler._order;

  		this.onChangeCallback();

  		return this;

  	},

  	setFromRotationMatrix: function ( m, order, update ) {

  		var clamp = _Math$1.clamp;

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		var te = m.elements;
  		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
  		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
  		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

  		order = order || this._order;

  		if ( order === 'XYZ' ) {

  			this._y = Math.asin( clamp( m13, - 1, 1 ) );

  			if ( Math.abs( m13 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m33 );
  				this._z = Math.atan2( - m12, m11 );

  			} else {

  				this._x = Math.atan2( m32, m22 );
  				this._z = 0;

  			}

  		} else if ( order === 'YXZ' ) {

  			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

  			if ( Math.abs( m23 ) < 0.99999 ) {

  				this._y = Math.atan2( m13, m33 );
  				this._z = Math.atan2( m21, m22 );

  			} else {

  				this._y = Math.atan2( - m31, m11 );
  				this._z = 0;

  			}

  		} else if ( order === 'ZXY' ) {

  			this._x = Math.asin( clamp( m32, - 1, 1 ) );

  			if ( Math.abs( m32 ) < 0.99999 ) {

  				this._y = Math.atan2( - m31, m33 );
  				this._z = Math.atan2( - m12, m22 );

  			} else {

  				this._y = 0;
  				this._z = Math.atan2( m21, m11 );

  			}

  		} else if ( order === 'ZYX' ) {

  			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

  			if ( Math.abs( m31 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m33 );
  				this._z = Math.atan2( m21, m11 );

  			} else {

  				this._x = 0;
  				this._z = Math.atan2( - m12, m22 );

  			}

  		} else if ( order === 'YZX' ) {

  			this._z = Math.asin( clamp( m21, - 1, 1 ) );

  			if ( Math.abs( m21 ) < 0.99999 ) {

  				this._x = Math.atan2( - m23, m22 );
  				this._y = Math.atan2( - m31, m11 );

  			} else {

  				this._x = 0;
  				this._y = Math.atan2( m13, m33 );

  			}

  		} else if ( order === 'XZY' ) {

  			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

  			if ( Math.abs( m12 ) < 0.99999 ) {

  				this._x = Math.atan2( m32, m22 );
  				this._y = Math.atan2( m13, m11 );

  			} else {

  				this._x = Math.atan2( - m23, m33 );
  				this._y = 0;

  			}

  		} else {

  			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

  		}

  		this._order = order;

  		if ( update !== false ) this.onChangeCallback();

  		return this;

  	},

  	setFromQuaternion: function () {

  		var matrix = new Matrix4$1();

  		return function setFromQuaternion( q, order, update ) {

  			matrix.makeRotationFromQuaternion( q );

  			return this.setFromRotationMatrix( matrix, order, update );

  		};

  	}(),

  	setFromVector3: function ( v, order ) {

  		return this.set( v.x, v.y, v.z, order || this._order );

  	},

  	reorder: function () {

  		// WARNING: this discards revolution information -bhouston

  		var q = new Quaternion$1();

  		return function reorder( newOrder ) {

  			q.setFromEuler( this );

  			return this.setFromQuaternion( q, newOrder );

  		};

  	}(),

  	equals: function ( euler ) {

  		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  	},

  	fromArray: function ( array ) {

  		this._x = array[ 0 ];
  		this._y = array[ 1 ];
  		this._z = array[ 2 ];
  		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

  		this.onChangeCallback();

  		return this;

  	},

  	toArray: function ( array, offset ) {

  		if ( array === undefined ) array = [];
  		if ( offset === undefined ) offset = 0;

  		array[ offset ] = this._x;
  		array[ offset + 1 ] = this._y;
  		array[ offset + 2 ] = this._z;
  		array[ offset + 3 ] = this._order;

  		return array;

  	},

  	toVector3: function ( optionalResult ) {

  		if ( optionalResult ) {

  			return optionalResult.set( this._x, this._y, this._z );

  		} else {

  			return new Vector3$1( this._x, this._y, this._z );

  		}

  	},

  	onChange: function ( callback ) {

  		this.onChangeCallback = callback;

  		return this;

  	},

  	onChangeCallback: function () {}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Layers$1() {

  	this.mask = 1 | 0;

  }

  Object.assign( Layers$1.prototype, {

  	set: function ( channel ) {

  		this.mask = 1 << channel | 0;

  	},

  	enable: function ( channel ) {

  		this.mask |= 1 << channel | 0;

  	},

  	toggle: function ( channel ) {

  		this.mask ^= 1 << channel | 0;

  	},

  	disable: function ( channel ) {

  		this.mask &= ~ ( 1 << channel | 0 );

  	},

  	test: function ( layers ) {

  		return ( this.mask & layers.mask ) !== 0;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author WestLangley / http://github.com/WestLangley
   * @author elephantatwork / www.elephantatwork.ch
   */

  var object3DId$1 = 0;

  function Object3D$1() {

  	Object.defineProperty( this, 'id', { value: object3DId$1 ++ } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Object3D';

  	this.parent = null;
  	this.children = [];

  	this.up = Object3D$1.DefaultUp.clone();

  	var position = new Vector3$1();
  	var rotation = new Euler$1();
  	var quaternion = new Quaternion$1();
  	var scale = new Vector3$1( 1, 1, 1 );

  	function onRotationChange() {

  		quaternion.setFromEuler( rotation, false );

  	}

  	function onQuaternionChange() {

  		rotation.setFromQuaternion( quaternion, undefined, false );

  	}

  	rotation.onChange( onRotationChange );
  	quaternion.onChange( onQuaternionChange );

  	Object.defineProperties( this, {
  		position: {
  			enumerable: true,
  			value: position
  		},
  		rotation: {
  			enumerable: true,
  			value: rotation
  		},
  		quaternion: {
  			enumerable: true,
  			value: quaternion
  		},
  		scale: {
  			enumerable: true,
  			value: scale
  		},
  		modelViewMatrix: {
  			value: new Matrix4$1()
  		},
  		normalMatrix: {
  			value: new Matrix3$1()
  		}
  	} );

  	this.matrix = new Matrix4$1();
  	this.matrixWorld = new Matrix4$1();

  	this.matrixAutoUpdate = Object3D$1.DefaultMatrixAutoUpdate;
  	this.matrixWorldNeedsUpdate = false;

  	this.layers = new Layers$1();
  	this.visible = true;

  	this.castShadow = false;
  	this.receiveShadow = false;

  	this.frustumCulled = true;
  	this.renderOrder = 0;

  	this.userData = {};

  	this.onBeforeRender = function () {};
  	this.onAfterRender = function () {};

  }

  Object3D$1.DefaultUp = new Vector3$1( 0, 1, 0 );
  Object3D$1.DefaultMatrixAutoUpdate = true;

  Object.assign( Object3D$1.prototype, EventDispatcher$1.prototype, {

  	isObject3D: true,

  	applyMatrix: function ( matrix ) {

  		this.matrix.multiplyMatrices( matrix, this.matrix );

  		this.matrix.decompose( this.position, this.quaternion, this.scale );

  	},

  	setRotationFromAxisAngle: function ( axis, angle ) {

  		// assumes axis is normalized

  		this.quaternion.setFromAxisAngle( axis, angle );

  	},

  	setRotationFromEuler: function ( euler ) {

  		this.quaternion.setFromEuler( euler, true );

  	},

  	setRotationFromMatrix: function ( m ) {

  		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

  		this.quaternion.setFromRotationMatrix( m );

  	},

  	setRotationFromQuaternion: function ( q ) {

  		// assumes q is normalized

  		this.quaternion.copy( q );

  	},

  	rotateOnAxis: function () {

  		// rotate object on axis in object space
  		// axis is assumed to be normalized

  		var q1 = new Quaternion$1();

  		return function rotateOnAxis( axis, angle ) {

  			q1.setFromAxisAngle( axis, angle );

  			this.quaternion.multiply( q1 );

  			return this;

  		};

  	}(),

  	rotateX: function () {

  		var v1 = new Vector3$1( 1, 0, 0 );

  		return function rotateX( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateY: function () {

  		var v1 = new Vector3$1( 0, 1, 0 );

  		return function rotateY( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	rotateZ: function () {

  		var v1 = new Vector3$1( 0, 0, 1 );

  		return function rotateZ( angle ) {

  			return this.rotateOnAxis( v1, angle );

  		};

  	}(),

  	translateOnAxis: function () {

  		// translate object by distance along axis in object space
  		// axis is assumed to be normalized

  		var v1 = new Vector3$1();

  		return function translateOnAxis( axis, distance ) {

  			v1.copy( axis ).applyQuaternion( this.quaternion );

  			this.position.add( v1.multiplyScalar( distance ) );

  			return this;

  		};

  	}(),

  	translateX: function () {

  		var v1 = new Vector3$1( 1, 0, 0 );

  		return function translateX( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateY: function () {

  		var v1 = new Vector3$1( 0, 1, 0 );

  		return function translateY( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	translateZ: function () {

  		var v1 = new Vector3$1( 0, 0, 1 );

  		return function translateZ( distance ) {

  			return this.translateOnAxis( v1, distance );

  		};

  	}(),

  	localToWorld: function ( vector ) {

  		return vector.applyMatrix4( this.matrixWorld );

  	},

  	worldToLocal: function () {

  		var m1 = new Matrix4$1();

  		return function worldToLocal( vector ) {

  			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

  		};

  	}(),

  	lookAt: function () {

  		// This routine does not support objects with rotated and/or translated parent(s)

  		var m1 = new Matrix4$1();

  		return function lookAt( vector ) {

  			if ( this.isCamera ) {

  				m1.lookAt( this.position, vector, this.up );

  			} else {

  				m1.lookAt( vector, this.position, this.up );

  			}

  			this.quaternion.setFromRotationMatrix( m1 );

  		};

  	}(),

  	add: function ( object ) {

  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this.add( arguments[ i ] );

  			}

  			return this;

  		}

  		if ( object === this ) {

  			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
  			return this;

  		}

  		if ( ( object && object.isObject3D ) ) {

  			if ( object.parent !== null ) {

  				object.parent.remove( object );

  			}

  			object.parent = this;
  			object.dispatchEvent( { type: 'added' } );

  			this.children.push( object );

  		} else {

  			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

  		}

  		return this;

  	},

  	remove: function ( object ) {

  		if ( arguments.length > 1 ) {

  			for ( var i = 0; i < arguments.length; i ++ ) {

  				this.remove( arguments[ i ] );

  			}

  		}

  		var index = this.children.indexOf( object );

  		if ( index !== - 1 ) {

  			object.parent = null;

  			object.dispatchEvent( { type: 'removed' } );

  			this.children.splice( index, 1 );

  		}

  	},

  	getObjectById: function ( id ) {

  		return this.getObjectByProperty( 'id', id );

  	},

  	getObjectByName: function ( name ) {

  		return this.getObjectByProperty( 'name', name );

  	},

  	getObjectByProperty: function ( name, value ) {

  		if ( this[ name ] === value ) return this;

  		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

  			var child = this.children[ i ];
  			var object = child.getObjectByProperty( name, value );

  			if ( object !== undefined ) {

  				return object;

  			}

  		}

  		return undefined;

  	},

  	getWorldPosition: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		this.updateMatrixWorld( true );

  		return result.setFromMatrixPosition( this.matrixWorld );

  	},

  	getWorldQuaternion: function () {

  		var position = new Vector3$1();
  		var scale = new Vector3$1();

  		return function getWorldQuaternion( optionalTarget ) {

  			var result = optionalTarget || new Quaternion$1();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, result, scale );

  			return result;

  		};

  	}(),

  	getWorldRotation: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldRotation( optionalTarget ) {

  			var result = optionalTarget || new Euler$1();

  			this.getWorldQuaternion( quaternion );

  			return result.setFromQuaternion( quaternion, this.rotation.order, false );

  		};

  	}(),

  	getWorldScale: function () {

  		var position = new Vector3$1();
  		var quaternion = new Quaternion$1();

  		return function getWorldScale( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.updateMatrixWorld( true );

  			this.matrixWorld.decompose( position, quaternion, result );

  			return result;

  		};

  	}(),

  	getWorldDirection: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	raycast: function () {},

  	traverse: function ( callback ) {

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverse( callback );

  		}

  	},

  	traverseVisible: function ( callback ) {

  		if ( this.visible === false ) return;

  		callback( this );

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].traverseVisible( callback );

  		}

  	},

  	traverseAncestors: function ( callback ) {

  		var parent = this.parent;

  		if ( parent !== null ) {

  			callback( parent );

  			parent.traverseAncestors( callback );

  		}

  	},

  	updateMatrix: function () {

  		this.matrix.compose( this.position, this.quaternion, this.scale );

  		this.matrixWorldNeedsUpdate = true;

  	},

  	updateMatrixWorld: function ( force ) {

  		if ( this.matrixAutoUpdate ) this.updateMatrix();

  		if ( this.matrixWorldNeedsUpdate || force ) {

  			if ( this.parent === null ) {

  				this.matrixWorld.copy( this.matrix );

  			} else {

  				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

  			}

  			this.matrixWorldNeedsUpdate = false;

  			force = true;

  		}

  		// update children

  		var children = this.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			children[ i ].updateMatrixWorld( force );

  		}

  	},

  	toJSON: function ( meta ) {

  		// meta is '' when called from JSON.stringify
  		var isRootObject = ( meta === undefined || meta === '' );

  		var output = {};

  		// meta is a hash used to collect geometries, materials.
  		// not providing it implies that this is the root object
  		// being serialized.
  		if ( isRootObject ) {

  			// initialize meta obj
  			meta = {
  				geometries: {},
  				materials: {},
  				textures: {},
  				images: {}
  			};

  			output.metadata = {
  				version: 4.5,
  				type: 'Object',
  				generator: 'Object3D.toJSON'
  			};

  		}

  		// standard Object3D serialization

  		var object = {};

  		object.uuid = this.uuid;
  		object.type = this.type;

  		if ( this.name !== '' ) object.name = this.name;
  		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
  		if ( this.castShadow === true ) object.castShadow = true;
  		if ( this.receiveShadow === true ) object.receiveShadow = true;
  		if ( this.visible === false ) object.visible = false;

  		object.matrix = this.matrix.toArray();

  		//

  		function serialize( library, element ) {

  			if ( library[ element.uuid ] === undefined ) {

  				library[ element.uuid ] = element.toJSON( meta );

  			}

  			return element.uuid;

  		}

  		if ( this.geometry !== undefined ) {

  			object.geometry = serialize( meta.geometries, this.geometry );

  		}

  		if ( this.material !== undefined ) {

  			if ( Array.isArray( this.material ) ) {

  				var uuids = [];

  				for ( var i = 0, l = this.material.length; i < l; i ++ ) {

  					uuids.push( serialize( meta.materials, this.material[ i ] ) );

  				}

  				object.material = uuids;

  			} else {

  				object.material = serialize( meta.materials, this.material );

  			}

  		}

  		//

  		if ( this.children.length > 0 ) {

  			object.children = [];

  			for ( var i = 0; i < this.children.length; i ++ ) {

  				object.children.push( this.children[ i ].toJSON( meta ).object );

  			}

  		}

  		if ( isRootObject ) {

  			var geometries = extractFromCache( meta.geometries );
  			var materials = extractFromCache( meta.materials );
  			var textures = extractFromCache( meta.textures );
  			var images = extractFromCache( meta.images );

  			if ( geometries.length > 0 ) output.geometries = geometries;
  			if ( materials.length > 0 ) output.materials = materials;
  			if ( textures.length > 0 ) output.textures = textures;
  			if ( images.length > 0 ) output.images = images;

  		}

  		output.object = object;

  		return output;

  		// extract data from the cache hash
  		// remove metadata on each item
  		// and return as array
  		function extractFromCache( cache ) {

  			var values = [];
  			for ( var key in cache ) {

  				var data = cache[ key ];
  				delete data.metadata;
  				values.push( data );

  			}
  			return values;

  		}

  	},

  	clone: function ( recursive ) {

  		return new this.constructor().copy( this, recursive );

  	},

  	copy: function ( source, recursive ) {

  		if ( recursive === undefined ) recursive = true;

  		this.name = source.name;

  		this.up.copy( source.up );

  		this.position.copy( source.position );
  		this.quaternion.copy( source.quaternion );
  		this.scale.copy( source.scale );

  		this.matrix.copy( source.matrix );
  		this.matrixWorld.copy( source.matrixWorld );

  		this.matrixAutoUpdate = source.matrixAutoUpdate;
  		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

  		this.layers.mask = source.layers.mask;
  		this.visible = source.visible;

  		this.castShadow = source.castShadow;
  		this.receiveShadow = source.receiveShadow;

  		this.frustumCulled = source.frustumCulled;
  		this.renderOrder = source.renderOrder;

  		this.userData = JSON.parse( JSON.stringify( source.userData ) );

  		if ( recursive === true ) {

  			for ( var i = 0; i < source.children.length; i ++ ) {

  				var child = source.children[ i ];
  				this.add( child.clone() );

  			}

  		}

  		return this;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   */

  function Line3$1( start, end ) {

  	this.start = ( start !== undefined ) ? start : new Vector3$1();
  	this.end = ( end !== undefined ) ? end : new Vector3$1();

  }

  Object.assign( Line3$1.prototype, {

  	set: function ( start, end ) {

  		this.start.copy( start );
  		this.end.copy( end );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( line ) {

  		this.start.copy( line.start );
  		this.end.copy( line.end );

  		return this;

  	},

  	getCenter: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  	},

  	delta: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.subVectors( this.end, this.start );

  	},

  	distanceSq: function () {

  		return this.start.distanceToSquared( this.end );

  	},

  	distance: function () {

  		return this.start.distanceTo( this.end );

  	},

  	at: function ( t, optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	closestPointToPointParameter: function () {

  		var startP = new Vector3$1();
  		var startEnd = new Vector3$1();

  		return function closestPointToPointParameter( point, clampToLine ) {

  			startP.subVectors( point, this.start );
  			startEnd.subVectors( this.end, this.start );

  			var startEnd2 = startEnd.dot( startEnd );
  			var startEnd_startP = startEnd.dot( startP );

  			var t = startEnd_startP / startEnd2;

  			if ( clampToLine ) {

  				t = _Math$1.clamp( t, 0, 1 );

  			}

  			return t;

  		};

  	}(),

  	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

  		var t = this.closestPointToPointParameter( point, clampToLine );

  		var result = optionalTarget || new Vector3$1();

  		return this.delta( result ).multiplyScalar( t ).add( this.start );

  	},

  	applyMatrix4: function ( matrix ) {

  		this.start.applyMatrix4( matrix );
  		this.end.applyMatrix4( matrix );

  		return this;

  	},

  	equals: function ( line ) {

  		return line.start.equals( this.start ) && line.end.equals( this.end );

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author mrdoob / http://mrdoob.com/
   */

  function Triangle$1( a, b, c ) {

  	this.a = ( a !== undefined ) ? a : new Vector3$1();
  	this.b = ( b !== undefined ) ? b : new Vector3$1();
  	this.c = ( c !== undefined ) ? c : new Vector3$1();

  }

  Object.assign( Triangle$1, {

  	normal: function () {

  		var v0 = new Vector3$1();

  		return function normal( a, b, c, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			result.subVectors( c, b );
  			v0.subVectors( a, b );
  			result.cross( v0 );

  			var resultLengthSq = result.lengthSq();
  			if ( resultLengthSq > 0 ) {

  				return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

  			}

  			return result.set( 0, 0, 0 );

  		};

  	}(),

  	// static/instance method to calculate barycentric coordinates
  	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  	barycoordFromPoint: function () {

  		var v0 = new Vector3$1();
  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

  			v0.subVectors( c, a );
  			v1.subVectors( b, a );
  			v2.subVectors( point, a );

  			var dot00 = v0.dot( v0 );
  			var dot01 = v0.dot( v1 );
  			var dot02 = v0.dot( v2 );
  			var dot11 = v1.dot( v1 );
  			var dot12 = v1.dot( v2 );

  			var denom = ( dot00 * dot11 - dot01 * dot01 );

  			var result = optionalTarget || new Vector3$1();

  			// collinear or singular triangle
  			if ( denom === 0 ) {

  				// arbitrary location outside of triangle?
  				// not sure if this is the best idea, maybe should be returning undefined
  				return result.set( - 2, - 1, - 1 );

  			}

  			var invDenom = 1 / denom;
  			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
  			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

  			// barycentric coordinates must always sum to 1
  			return result.set( 1 - u - v, v, u );

  		};

  	}(),

  	containsPoint: function () {

  		var v1 = new Vector3$1();

  		return function containsPoint( point, a, b, c ) {

  			var result = Triangle$1.barycoordFromPoint( point, a, b, c, v1 );

  			return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  		};

  	}()

  } );

  Object.assign( Triangle$1.prototype, {

  	set: function ( a, b, c ) {

  		this.a.copy( a );
  		this.b.copy( b );
  		this.c.copy( c );

  		return this;

  	},

  	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

  		this.a.copy( points[ i0 ] );
  		this.b.copy( points[ i1 ] );
  		this.c.copy( points[ i2 ] );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( triangle ) {

  		this.a.copy( triangle.a );
  		this.b.copy( triangle.b );
  		this.c.copy( triangle.c );

  		return this;

  	},

  	area: function () {

  		var v0 = new Vector3$1();
  		var v1 = new Vector3$1();

  		return function area() {

  			v0.subVectors( this.c, this.b );
  			v1.subVectors( this.a, this.b );

  			return v0.cross( v1 ).length() * 0.5;

  		};

  	}(),

  	midpoint: function ( optionalTarget ) {

  		var result = optionalTarget || new Vector3$1();
  		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  	},

  	normal: function ( optionalTarget ) {

  		return Triangle$1.normal( this.a, this.b, this.c, optionalTarget );

  	},

  	plane: function ( optionalTarget ) {

  		var result = optionalTarget || new Plane$2();

  		return result.setFromCoplanarPoints( this.a, this.b, this.c );

  	},

  	barycoordFromPoint: function ( point, optionalTarget ) {

  		return Triangle$1.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  	},

  	containsPoint: function ( point ) {

  		return Triangle$1.containsPoint( point, this.a, this.b, this.c );

  	},

  	closestPointToPoint: function () {

  		var plane = new Plane$2();
  		var edgeList = [ new Line3$1(), new Line3$1(), new Line3$1() ];
  		var projectedPoint = new Vector3$1();
  		var closestPoint = new Vector3$1();

  		return function closestPointToPoint( point, optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();
  			var minDistance = Infinity;

  			// project the point onto the plane of the triangle

  			plane.setFromCoplanarPoints( this.a, this.b, this.c );
  			plane.projectPoint( point, projectedPoint );

  			// check if the projection lies within the triangle

  			if( this.containsPoint( projectedPoint ) === true ) {

  				// if so, this is the closest point

  				result.copy( projectedPoint );

  			} else {

  				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

  				edgeList[ 0 ].set( this.a, this.b );
  				edgeList[ 1 ].set( this.b, this.c );
  				edgeList[ 2 ].set( this.c, this.a );

  				for( var i = 0; i < edgeList.length; i ++ ) {

  					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

  					var distance = projectedPoint.distanceToSquared( closestPoint );

  					if( distance < minDistance ) {

  						minDistance = distance;

  						result.copy( closestPoint );

  					}

  				}

  			}

  			return result;

  		};

  	}(),

  	equals: function ( triangle ) {

  		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Face3$1( a, b, c, normal, color, materialIndex ) {

  	this.a = a;
  	this.b = b;
  	this.c = c;

  	this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3$1();
  	this.vertexNormals = Array.isArray( normal ) ? normal : [];

  	this.color = ( color && color.isColor ) ? color : new Color$1();
  	this.vertexColors = Array.isArray( color ) ? color : [];

  	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

  }

  Object.assign( Face3$1.prototype, {

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( source ) {

  		this.a = source.a;
  		this.b = source.b;
  		this.c = source.c;

  		this.normal.copy( source.normal );
  		this.color.copy( source.color );

  		this.materialIndex = source.materialIndex;

  		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

  			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

  		}

  		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

  			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  shading: THREE.SmoothShading,
   *  depthTest: <bool>,
   *  depthWrite: <bool>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>
   * }
   */

  function MeshBasicMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshBasicMaterial';

  	this.color = new Color$1( 0xffffff ); // emissive

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;

  	this.lights = false;

  	this.setValues( parameters );

  }

  MeshBasicMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshBasicMaterial$1.prototype.constructor = MeshBasicMaterial$1;

  MeshBasicMaterial$1.prototype.isMeshBasicMaterial = true;

  MeshBasicMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferAttribute$1( array, itemSize, normalized ) {

  	if ( Array.isArray( array ) ) {

  		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  	}

  	this.uuid = _Math$1.generateUUID();

  	this.array = array;
  	this.itemSize = itemSize;
  	this.count = array !== undefined ? array.length / itemSize : 0;
  	this.normalized = normalized === true;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.onUploadCallback = function () {};

  	this.version = 0;

  }

  Object.defineProperty( BufferAttribute$1.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) this.version ++;

  	}

  } );

  Object.assign( BufferAttribute$1.prototype, {

  	isBufferAttribute: true,

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.itemSize : 0;
  		this.array = array;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.itemSize = source.itemSize;
  		this.count = source.count;
  		this.normalized = source.normalized;

  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {

  		index1 *= this.itemSize;
  		index2 *= attribute.itemSize;

  		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	copyArray: function ( array ) {

  		this.array.set( array );

  		return this;

  	},

  	copyColorsArray: function ( colors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = colors.length; i < l; i ++ ) {

  			var color = colors[ i ];

  			if ( color === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
  				color = new Color$1();

  			}

  			array[ offset ++ ] = color.r;
  			array[ offset ++ ] = color.g;
  			array[ offset ++ ] = color.b;

  		}

  		return this;

  	},

  	copyIndicesArray: function ( indices ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = indices.length; i < l; i ++ ) {

  			var index = indices[ i ];

  			array[ offset ++ ] = index.a;
  			array[ offset ++ ] = index.b;
  			array[ offset ++ ] = index.c;

  		}

  		return this;

  	},

  	copyVector2sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
  				vector = new Vector2$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;

  		}

  		return this;

  	},

  	copyVector3sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
  				vector = new Vector3$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;

  		}

  		return this;

  	},

  	copyVector4sArray: function ( vectors ) {

  		var array = this.array, offset = 0;

  		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

  			var vector = vectors[ i ];

  			if ( vector === undefined ) {

  				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
  				vector = new Vector4$1();

  			}

  			array[ offset ++ ] = vector.x;
  			array[ offset ++ ] = vector.y;
  			array[ offset ++ ] = vector.z;
  			array[ offset ++ ] = vector.w;

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.array.set( value, offset );

  		return this;

  	},

  	getX: function ( index ) {

  		return this.array[ index * this.itemSize ];

  	},

  	setX: function ( index, x ) {

  		this.array[ index * this.itemSize ] = x;

  		return this;

  	},

  	getY: function ( index ) {

  		return this.array[ index * this.itemSize + 1 ];

  	},

  	setY: function ( index, y ) {

  		this.array[ index * this.itemSize + 1 ] = y;

  		return this;

  	},

  	getZ: function ( index ) {

  		return this.array[ index * this.itemSize + 2 ];

  	},

  	setZ: function ( index, z ) {

  		this.array[ index * this.itemSize + 2 ] = z;

  		return this;

  	},

  	getW: function ( index ) {

  		return this.array[ index * this.itemSize + 3 ];

  	},

  	setW: function ( index, w ) {

  		this.array[ index * this.itemSize + 3 ] = w;

  		return this;

  	},

  	setXY: function ( index, x, y ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index *= this.itemSize;

  		this.array[ index + 0 ] = x;
  		this.array[ index + 1 ] = y;
  		this.array[ index + 2 ] = z;
  		this.array[ index + 3 ] = w;

  		return this;

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor( this.array, this.itemSize ).copy( this );

  	}

  } );

  //

  function Int8BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int8Array( array ), itemSize );

  }

  Int8BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int8BufferAttribute$1.prototype.constructor = Int8BufferAttribute$1;


  function Uint8BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint8Array( array ), itemSize );

  }

  Uint8BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint8BufferAttribute$1.prototype.constructor = Uint8BufferAttribute$1;


  function Uint8ClampedBufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint8ClampedArray( array ), itemSize );

  }

  Uint8ClampedBufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint8ClampedBufferAttribute$1.prototype.constructor = Uint8ClampedBufferAttribute$1;


  function Int16BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int16Array( array ), itemSize );

  }

  Int16BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int16BufferAttribute$1.prototype.constructor = Int16BufferAttribute$1;


  function Uint16BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint16Array( array ), itemSize );

  }

  Uint16BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint16BufferAttribute$1.prototype.constructor = Uint16BufferAttribute$1;


  function Int32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Int32Array( array ), itemSize );

  }

  Int32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Int32BufferAttribute$1.prototype.constructor = Int32BufferAttribute$1;


  function Uint32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Uint32Array( array ), itemSize );

  }

  Uint32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Uint32BufferAttribute$1.prototype.constructor = Uint32BufferAttribute$1;


  function Float32BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Float32Array( array ), itemSize );

  }

  Float32BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Float32BufferAttribute$1.prototype.constructor = Float32BufferAttribute$1;


  function Float64BufferAttribute$1( array, itemSize ) {

  	BufferAttribute$1.call( this, new Float64Array( array ), itemSize );

  }

  Float64BufferAttribute$1.prototype = Object.create( BufferAttribute$1.prototype );
  Float64BufferAttribute$1.prototype.constructor = Float64BufferAttribute$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectGeometry$1() {

  	this.indices = [];
  	this.vertices = [];
  	this.normals = [];
  	this.colors = [];
  	this.uvs = [];
  	this.uvs2 = [];

  	this.groups = [];

  	this.morphTargets = {};

  	this.skinWeights = [];
  	this.skinIndices = [];

  	// this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.verticesNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( DirectGeometry$1.prototype, {

  	computeGroups: function ( geometry ) {

  		var group;
  		var groups = [];
  		var materialIndex = undefined;

  		var faces = geometry.faces;

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			// materials

  			if ( face.materialIndex !== materialIndex ) {

  				materialIndex = face.materialIndex;

  				if ( group !== undefined ) {

  					group.count = ( i * 3 ) - group.start;
  					groups.push( group );

  				}

  				group = {
  					start: i * 3,
  					materialIndex: materialIndex
  				};

  			}

  		}

  		if ( group !== undefined ) {

  			group.count = ( i * 3 ) - group.start;
  			groups.push( group );

  		}

  		this.groups = groups;

  	},

  	fromGeometry: function ( geometry ) {

  		var faces = geometry.faces;
  		var vertices = geometry.vertices;
  		var faceVertexUvs = geometry.faceVertexUvs;

  		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
  		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

  		// morphs

  		var morphTargets = geometry.morphTargets;
  		var morphTargetsLength = morphTargets.length;

  		var morphTargetsPosition;

  		if ( morphTargetsLength > 0 ) {

  			morphTargetsPosition = [];

  			for ( var i = 0; i < morphTargetsLength; i ++ ) {

  				morphTargetsPosition[ i ] = [];

  			}

  			this.morphTargets.position = morphTargetsPosition;

  		}

  		var morphNormals = geometry.morphNormals;
  		var morphNormalsLength = morphNormals.length;

  		var morphTargetsNormal;

  		if ( morphNormalsLength > 0 ) {

  			morphTargetsNormal = [];

  			for ( var i = 0; i < morphNormalsLength; i ++ ) {

  				morphTargetsNormal[ i ] = [];

  			}

  			this.morphTargets.normal = morphTargetsNormal;

  		}

  		// skins

  		var skinIndices = geometry.skinIndices;
  		var skinWeights = geometry.skinWeights;

  		var hasSkinIndices = skinIndices.length === vertices.length;
  		var hasSkinWeights = skinWeights.length === vertices.length;

  		//

  		for ( var i = 0; i < faces.length; i ++ ) {

  			var face = faces[ i ];

  			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

  			} else {

  				var normal = face.normal;

  				this.normals.push( normal, normal, normal );

  			}

  			var vertexColors = face.vertexColors;

  			if ( vertexColors.length === 3 ) {

  				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

  			} else {

  				var color = face.color;

  				this.colors.push( color, color, color );

  			}

  			if ( hasFaceVertexUv === true ) {

  				var vertexUvs = faceVertexUvs[ 0 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

  					this.uvs.push( new Vector2$1(), new Vector2$1(), new Vector2$1() );

  				}

  			}

  			if ( hasFaceVertexUv2 === true ) {

  				var vertexUvs = faceVertexUvs[ 1 ][ i ];

  				if ( vertexUvs !== undefined ) {

  					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

  				} else {

  					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

  					this.uvs2.push( new Vector2$1(), new Vector2$1(), new Vector2$1() );

  				}

  			}

  			// morphs

  			for ( var j = 0; j < morphTargetsLength; j ++ ) {

  				var morphTarget = morphTargets[ j ].vertices;

  				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

  			}

  			for ( var j = 0; j < morphNormalsLength; j ++ ) {

  				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

  				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

  			}

  			// skins

  			if ( hasSkinIndices ) {

  				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

  			}

  			if ( hasSkinWeights ) {

  				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

  			}

  		}

  		this.computeGroups( geometry );

  		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
  		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
  		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
  		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
  		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

  		return this;

  	}

  } );

  function arrayMax$1( array ) {

  	if ( array.length === 0 ) return - Infinity;

  	var max = array[ 0 ];

  	for ( var i = 1, l = array.length; i < l; ++ i ) {

  		if ( array[ i ] > max ) max = array[ i ];

  	}

  	return max;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author kile / http://kile.stravaganza.org/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author bhouston / http://clara.io
   */

  var count$1 = 0;
  function GeometryIdCount() { return count$1++; }

  function Geometry$1() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'Geometry';

  	this.vertices = [];
  	this.colors = [];
  	this.faces = [];
  	this.faceVertexUvs = [[]];

  	this.morphTargets = [];
  	this.morphNormals = [];

  	this.skinWeights = [];
  	this.skinIndices = [];

  	this.lineDistances = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	// update flags

  	this.elementsNeedUpdate = false;
  	this.verticesNeedUpdate = false;
  	this.uvsNeedUpdate = false;
  	this.normalsNeedUpdate = false;
  	this.colorsNeedUpdate = false;
  	this.lineDistancesNeedUpdate = false;
  	this.groupsNeedUpdate = false;

  }

  Object.assign( Geometry$1.prototype, EventDispatcher$1.prototype, {

  	isGeometry: true,

  	applyMatrix: function ( matrix ) {

  		var normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

  			var vertex = this.vertices[ i ];
  			vertex.applyMatrix4( matrix );

  		}

  		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

  			var face = this.faces[ i ];
  			face.normal.applyMatrix3( normalMatrix ).normalize();

  			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

  			}

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		this.verticesNeedUpdate = true;
  		this.normalsNeedUpdate = true;

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4$1();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4$1();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4$1();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4$1();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4$1();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D$1();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	fromBufferGeometry: function ( geometry ) {

  		var scope = this;

  		var indices = geometry.index !== null ? geometry.index.array : undefined;
  		var attributes = geometry.attributes;

  		var positions = attributes.position.array;
  		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
  		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
  		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
  		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

  		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

  		var tempNormals = [];
  		var tempUVs = [];
  		var tempUVs2 = [];

  		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

  			scope.vertices.push( new Vector3$1( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

  			if ( normals !== undefined ) {

  				tempNormals.push( new Vector3$1( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

  			}

  			if ( colors !== undefined ) {

  				scope.colors.push( new Color$1( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

  			}

  			if ( uvs !== undefined ) {

  				tempUVs.push( new Vector2$1( uvs[ j ], uvs[ j + 1 ] ) );

  			}

  			if ( uvs2 !== undefined ) {

  				tempUVs2.push( new Vector2$1( uvs2[ j ], uvs2[ j + 1 ] ) );

  			}

  		}

  		function addFace( a, b, c, materialIndex ) {

  			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
  			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

  			var face = new Face3$1( a, b, c, vertexNormals, vertexColors, materialIndex );

  			scope.faces.push( face );

  			if ( uvs !== undefined ) {

  				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

  			}

  			if ( uvs2 !== undefined ) {

  				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

  			}

  		}

  		var groups = geometry.groups;

  		if ( groups.length > 0 ) {

  			for ( var i = 0; i < groups.length; i ++ ) {

  				var group = groups[ i ];

  				var start = group.start;
  				var count = group.count;

  				for ( var j = start, jl = start + count; j < jl; j += 3 ) {

  					if ( indices !== undefined ) {

  						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

  					} else {

  						addFace( j, j + 1, j + 2, group.materialIndex );

  					}

  				}

  			}

  		} else {

  			if ( indices !== undefined ) {

  				for ( var i = 0; i < indices.length; i += 3 ) {

  					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

  				}

  			} else {

  				for ( var i = 0; i < positions.length / 3; i += 3 ) {

  					addFace( i, i + 1, i + 2 );

  				}

  			}

  		}

  		this.computeFaceNormals();

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		return this;

  	},

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	normalize: function () {

  		this.computeBoundingSphere();

  		var center = this.boundingSphere.center;
  		var radius = this.boundingSphere.radius;

  		var s = radius === 0 ? 1 : 1.0 / radius;

  		var matrix = new Matrix4$1();
  		matrix.set(
  			s, 0, 0, - s * center.x,
  			0, s, 0, - s * center.y,
  			0, 0, s, - s * center.z,
  			0, 0, 0, 1
  		);

  		this.applyMatrix( matrix );

  		return this;

  	},

  	computeFaceNormals: function () {

  		var cb = new Vector3$1(), ab = new Vector3$1();

  		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			var face = this.faces[ f ];

  			var vA = this.vertices[ face.a ];
  			var vB = this.vertices[ face.b ];
  			var vC = this.vertices[ face.c ];

  			cb.subVectors( vC, vB );
  			ab.subVectors( vA, vB );
  			cb.cross( ab );

  			cb.normalize();

  			face.normal.copy( cb );

  		}

  	},

  	computeVertexNormals: function ( areaWeighted ) {

  		if ( areaWeighted === undefined ) areaWeighted = true;

  		var v, vl, f, fl, face, vertices;

  		vertices = new Array( this.vertices.length );

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ] = new Vector3$1();

  		}

  		if ( areaWeighted ) {

  			// vertex normals weighted by triangle areas
  			// http://www.iquilezles.org/www/articles/normals/normals.htm

  			var vA, vB, vC;
  			var cb = new Vector3$1(), ab = new Vector3$1();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				vA = this.vertices[ face.a ];
  				vB = this.vertices[ face.b ];
  				vC = this.vertices[ face.c ];

  				cb.subVectors( vC, vB );
  				ab.subVectors( vA, vB );
  				cb.cross( ab );

  				vertices[ face.a ].add( cb );
  				vertices[ face.b ].add( cb );
  				vertices[ face.c ].add( cb );

  			}

  		} else {

  			this.computeFaceNormals();

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				vertices[ face.a ].add( face.normal );
  				vertices[ face.b ].add( face.normal );
  				vertices[ face.c ].add( face.normal );

  			}

  		}

  		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

  			vertices[ v ].normalize();

  		}

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( vertices[ face.a ] );
  				vertexNormals[ 1 ].copy( vertices[ face.b ] );
  				vertexNormals[ 2 ].copy( vertices[ face.c ] );

  			} else {

  				vertexNormals[ 0 ] = vertices[ face.a ].clone();
  				vertexNormals[ 1 ] = vertices[ face.b ].clone();
  				vertexNormals[ 2 ] = vertices[ face.c ].clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeFlatVertexNormals: function () {

  		var f, fl, face;

  		this.computeFaceNormals();

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this.faces[ f ];

  			var vertexNormals = face.vertexNormals;

  			if ( vertexNormals.length === 3 ) {

  				vertexNormals[ 0 ].copy( face.normal );
  				vertexNormals[ 1 ].copy( face.normal );
  				vertexNormals[ 2 ].copy( face.normal );

  			} else {

  				vertexNormals[ 0 ] = face.normal.clone();
  				vertexNormals[ 1 ] = face.normal.clone();
  				vertexNormals[ 2 ] = face.normal.clone();

  			}

  		}

  		if ( this.faces.length > 0 ) {

  			this.normalsNeedUpdate = true;

  		}

  	},

  	computeMorphNormals: function () {

  		var i, il, f, fl, face;

  		// save original normals
  		// - create temp variables on first access
  		//   otherwise just copy (for faster repeated calls)

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this.faces[ f ];

  			if ( ! face.__originalFaceNormal ) {

  				face.__originalFaceNormal = face.normal.clone();

  			} else {

  				face.__originalFaceNormal.copy( face.normal );

  			}

  			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

  			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

  				if ( ! face.__originalVertexNormals[ i ] ) {

  					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

  				} else {

  					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

  				}

  			}

  		}

  		// use temp geometry to compute face and vertex normals for each morph

  		var tmpGeo = new Geometry$1();
  		tmpGeo.faces = this.faces;

  		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

  			// create on first access

  			if ( ! this.morphNormals[ i ] ) {

  				this.morphNormals[ i ] = {};
  				this.morphNormals[ i ].faceNormals = [];
  				this.morphNormals[ i ].vertexNormals = [];

  				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
  				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

  				var faceNormal, vertexNormals;

  				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  					faceNormal = new Vector3$1();
  					vertexNormals = { a: new Vector3$1(), b: new Vector3$1(), c: new Vector3$1() };

  					dstNormalsFace.push( faceNormal );
  					dstNormalsVertex.push( vertexNormals );

  				}

  			}

  			var morphNormals = this.morphNormals[ i ];

  			// set vertices to morph target

  			tmpGeo.vertices = this.morphTargets[ i ].vertices;

  			// compute morph normals

  			tmpGeo.computeFaceNormals();
  			tmpGeo.computeVertexNormals();

  			// store morph normals

  			var faceNormal, vertexNormals;

  			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  				face = this.faces[ f ];

  				faceNormal = morphNormals.faceNormals[ f ];
  				vertexNormals = morphNormals.vertexNormals[ f ];

  				faceNormal.copy( face.normal );

  				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
  				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
  				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

  			}

  		}

  		// restore original normals

  		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

  			face = this.faces[ f ];

  			face.normal = face.__originalFaceNormal;
  			face.vertexNormals = face.__originalVertexNormals;

  		}

  	},

  	computeLineDistances: function () {

  		var d = 0;
  		var vertices = this.vertices;

  		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

  			if ( i > 0 ) {

  				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

  			}

  			this.lineDistances[ i ] = d;

  		}

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3$1();

  		}

  		this.boundingBox.setFromPoints( this.vertices );

  	},

  	computeBoundingSphere: function () {

  		if ( this.boundingSphere === null ) {

  			this.boundingSphere = new Sphere$2();

  		}

  		this.boundingSphere.setFromPoints( this.vertices );

  	},

  	merge: function ( geometry, matrix, materialIndexOffset ) {

  		if ( ( geometry && geometry.isGeometry ) === false ) {

  			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
  			return;

  		}

  		var normalMatrix,
  			vertexOffset = this.vertices.length,
  			vertices1 = this.vertices,
  			vertices2 = geometry.vertices,
  			faces1 = this.faces,
  			faces2 = geometry.faces,
  			uvs1 = this.faceVertexUvs[ 0 ],
  			uvs2 = geometry.faceVertexUvs[ 0 ],
  			colors1 = this.colors,
  			colors2 = geometry.colors;

  		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

  		if ( matrix !== undefined ) {

  			normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  		}

  		// vertices

  		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

  			var vertex = vertices2[ i ];

  			var vertexCopy = vertex.clone();

  			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

  			vertices1.push( vertexCopy );

  		}

  		// colors

  		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

  			colors1.push( colors2[ i ].clone() );

  		}

  		// faces

  		for ( i = 0, il = faces2.length; i < il; i ++ ) {

  			var face = faces2[ i ], faceCopy, normal, color,
  				faceVertexNormals = face.vertexNormals,
  				faceVertexColors = face.vertexColors;

  			faceCopy = new Face3$1( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
  			faceCopy.normal.copy( face.normal );

  			if ( normalMatrix !== undefined ) {

  				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

  			}

  			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

  				normal = faceVertexNormals[ j ].clone();

  				if ( normalMatrix !== undefined ) {

  					normal.applyMatrix3( normalMatrix ).normalize();

  				}

  				faceCopy.vertexNormals.push( normal );

  			}

  			faceCopy.color.copy( face.color );

  			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

  				color = faceVertexColors[ j ];
  				faceCopy.vertexColors.push( color.clone() );

  			}

  			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

  			faces1.push( faceCopy );

  		}

  		// uvs

  		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

  			var uv = uvs2[ i ], uvCopy = [];

  			if ( uv === undefined ) {

  				continue;

  			}

  			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

  				uvCopy.push( uv[ j ].clone() );

  			}

  			uvs1.push( uvCopy );

  		}

  	},

  	mergeMesh: function ( mesh ) {

  		if ( ( mesh && mesh.isMesh ) === false ) {

  			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
  			return;

  		}

  		mesh.matrixAutoUpdate && mesh.updateMatrix();

  		this.merge( mesh.geometry, mesh.matrix );

  	},

  	/*
  	 * Checks for duplicate vertices with hashmap.
  	 * Duplicated vertices are removed
  	 * and faces' vertices are updated.
  	 */

  	mergeVertices: function () {

  		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
  		var unique = [], changes = [];

  		var v, key;
  		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
  		var precision = Math.pow( 10, precisionPoints );
  		var i, il, face;
  		var indices, j, jl;

  		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

  			v = this.vertices[ i ];
  			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

  			if ( verticesMap[ key ] === undefined ) {

  				verticesMap[ key ] = i;
  				unique.push( this.vertices[ i ] );
  				changes[ i ] = unique.length - 1;

  			} else {

  				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
  				changes[ i ] = changes[ verticesMap[ key ] ];

  			}

  		}


  		// if faces are completely degenerate after merging vertices, we
  		// have to remove them from the geometry.
  		var faceIndicesToRemove = [];

  		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

  			face = this.faces[ i ];

  			face.a = changes[ face.a ];
  			face.b = changes[ face.b ];
  			face.c = changes[ face.c ];

  			indices = [ face.a, face.b, face.c ];

  			// if any duplicate vertices are found in a Face3
  			// we have to remove the face as nothing can be saved
  			for ( var n = 0; n < 3; n ++ ) {

  				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

  					faceIndicesToRemove.push( i );
  					break;

  				}

  			}

  		}

  		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

  			var idx = faceIndicesToRemove[ i ];

  			this.faces.splice( idx, 1 );

  			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

  				this.faceVertexUvs[ j ].splice( idx, 1 );

  			}

  		}

  		// Use unique set of vertices

  		var diff = this.vertices.length - unique.length;
  		this.vertices = unique;
  		return diff;

  	},

  	sortFacesByMaterialIndex: function () {

  		var faces = this.faces;
  		var length = faces.length;

  		// tag faces

  		for ( var i = 0; i < length; i ++ ) {

  			faces[ i ]._id = i;

  		}

  		// sort faces

  		function materialIndexSort( a, b ) {

  			return a.materialIndex - b.materialIndex;

  		}

  		faces.sort( materialIndexSort );

  		// sort uvs

  		var uvs1 = this.faceVertexUvs[ 0 ];
  		var uvs2 = this.faceVertexUvs[ 1 ];

  		var newUvs1, newUvs2;

  		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
  		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

  		for ( var i = 0; i < length; i ++ ) {

  			var id = faces[ i ]._id;

  			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
  			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

  		}

  		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
  		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

  	},

  	toJSON: function () {

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'Geometry',
  				generator: 'Geometry.toJSON'
  			}
  		};

  		// standard Geometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		var vertices = [];

  		for ( var i = 0; i < this.vertices.length; i ++ ) {

  			var vertex = this.vertices[ i ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  		var faces = [];
  		var normals = [];
  		var normalsHash = {};
  		var colors = [];
  		var colorsHash = {};
  		var uvs = [];
  		var uvsHash = {};

  		for ( var i = 0; i < this.faces.length; i ++ ) {

  			var face = this.faces[ i ];

  			var hasMaterial = true;
  			var hasFaceUv = false; // deprecated
  			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
  			var hasFaceNormal = face.normal.length() > 0;
  			var hasFaceVertexNormal = face.vertexNormals.length > 0;
  			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
  			var hasFaceVertexColor = face.vertexColors.length > 0;

  			var faceType = 0;

  			faceType = setBit( faceType, 0, 0 ); // isQuad
  			faceType = setBit( faceType, 1, hasMaterial );
  			faceType = setBit( faceType, 2, hasFaceUv );
  			faceType = setBit( faceType, 3, hasFaceVertexUv );
  			faceType = setBit( faceType, 4, hasFaceNormal );
  			faceType = setBit( faceType, 5, hasFaceVertexNormal );
  			faceType = setBit( faceType, 6, hasFaceColor );
  			faceType = setBit( faceType, 7, hasFaceVertexColor );

  			faces.push( faceType );
  			faces.push( face.a, face.b, face.c );
  			faces.push( face.materialIndex );

  			if ( hasFaceVertexUv ) {

  				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

  				faces.push(
  					getUvIndex( faceVertexUvs[ 0 ] ),
  					getUvIndex( faceVertexUvs[ 1 ] ),
  					getUvIndex( faceVertexUvs[ 2 ] )
  				);

  			}

  			if ( hasFaceNormal ) {

  				faces.push( getNormalIndex( face.normal ) );

  			}

  			if ( hasFaceVertexNormal ) {

  				var vertexNormals = face.vertexNormals;

  				faces.push(
  					getNormalIndex( vertexNormals[ 0 ] ),
  					getNormalIndex( vertexNormals[ 1 ] ),
  					getNormalIndex( vertexNormals[ 2 ] )
  				);

  			}

  			if ( hasFaceColor ) {

  				faces.push( getColorIndex( face.color ) );

  			}

  			if ( hasFaceVertexColor ) {

  				var vertexColors = face.vertexColors;

  				faces.push(
  					getColorIndex( vertexColors[ 0 ] ),
  					getColorIndex( vertexColors[ 1 ] ),
  					getColorIndex( vertexColors[ 2 ] )
  				);

  			}

  		}

  		function setBit( value, position, enabled ) {

  			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

  		}

  		function getNormalIndex( normal ) {

  			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

  			if ( normalsHash[ hash ] !== undefined ) {

  				return normalsHash[ hash ];

  			}

  			normalsHash[ hash ] = normals.length / 3;
  			normals.push( normal.x, normal.y, normal.z );

  			return normalsHash[ hash ];

  		}

  		function getColorIndex( color ) {

  			var hash = color.r.toString() + color.g.toString() + color.b.toString();

  			if ( colorsHash[ hash ] !== undefined ) {

  				return colorsHash[ hash ];

  			}

  			colorsHash[ hash ] = colors.length;
  			colors.push( color.getHex() );

  			return colorsHash[ hash ];

  		}

  		function getUvIndex( uv ) {

  			var hash = uv.x.toString() + uv.y.toString();

  			if ( uvsHash[ hash ] !== undefined ) {

  				return uvsHash[ hash ];

  			}

  			uvsHash[ hash ] = uvs.length / 2;
  			uvs.push( uv.x, uv.y );

  			return uvsHash[ hash ];

  		}

  		data.data = {};

  		data.data.vertices = vertices;
  		data.data.normals = normals;
  		if ( colors.length > 0 ) data.data.colors = colors;
  		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
  		data.data.faces = faces;

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new Geometry$1().copy( this );

  	},

  	copy: function ( source ) {

  		var i, il, j, jl, k, kl;

  		// reset

  		this.vertices = [];
  		this.colors = [];
  		this.faces = [];
  		this.faceVertexUvs = [[]];
  		this.morphTargets = [];
  		this.morphNormals = [];
  		this.skinWeights = [];
  		this.skinIndices = [];
  		this.lineDistances = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// vertices

  		var vertices = source.vertices;

  		for ( i = 0, il = vertices.length; i < il; i ++ ) {

  			this.vertices.push( vertices[ i ].clone() );

  		}

  		// colors

  		var colors = source.colors;

  		for ( i = 0, il = colors.length; i < il; i ++ ) {

  			this.colors.push( colors[ i ].clone() );

  		}

  		// faces

  		var faces = source.faces;

  		for ( i = 0, il = faces.length; i < il; i ++ ) {

  			this.faces.push( faces[ i ].clone() );

  		}

  		// face vertex uvs

  		for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

  			var faceVertexUvs = source.faceVertexUvs[ i ];

  			if ( this.faceVertexUvs[ i ] === undefined ) {

  				this.faceVertexUvs[ i ] = [];

  			}

  			for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

  				var uvs = faceVertexUvs[ j ], uvsCopy = [];

  				for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

  					var uv = uvs[ k ];

  					uvsCopy.push( uv.clone() );

  				}

  				this.faceVertexUvs[ i ].push( uvsCopy );

  			}

  		}

  		// morph targets

  		var morphTargets = source.morphTargets;

  		for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = {};
  			morphTarget.name = morphTargets[ i ].name;

  			// vertices

  			if ( morphTargets[ i ].vertices !== undefined ) {

  				morphTarget.vertices = [];

  				for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

  					morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

  				}

  			}

  			// normals

  			if ( morphTargets[ i ].normals !== undefined ) {

  				morphTarget.normals = [];

  				for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

  					morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

  				}

  			}

  			this.morphTargets.push( morphTarget );

  		}

  		// morph normals

  		var morphNormals = source.morphNormals;

  		for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

  			var morphNormal = {};

  			// vertex normals

  			if ( morphNormals[ i ].vertexNormals !== undefined ) {

  				morphNormal.vertexNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

  					var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
  					var destVertexNormal = {};

  					destVertexNormal.a = srcVertexNormal.a.clone();
  					destVertexNormal.b = srcVertexNormal.b.clone();
  					destVertexNormal.c = srcVertexNormal.c.clone();

  					morphNormal.vertexNormals.push( destVertexNormal );

  				}

  			}

  			// face normals

  			if ( morphNormals[ i ].faceNormals !== undefined ) {

  				morphNormal.faceNormals = [];

  				for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

  					morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

  				}

  			}

  			this.morphNormals.push( morphNormal );

  		}

  		// skin weights

  		var skinWeights = source.skinWeights;

  		for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

  			this.skinWeights.push( skinWeights[ i ].clone() );

  		}

  		// skin indices

  		var skinIndices = source.skinIndices;

  		for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

  			this.skinIndices.push( skinIndices[ i ].clone() );

  		}

  		// line distances

  		var lineDistances = source.lineDistances;

  		for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

  			this.lineDistances.push( lineDistances[ i ] );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// update flags

  		this.elementsNeedUpdate = source.elementsNeedUpdate;
  		this.verticesNeedUpdate = source.verticesNeedUpdate;
  		this.uvsNeedUpdate = source.uvsNeedUpdate;
  		this.normalsNeedUpdate = source.normalsNeedUpdate;
  		this.colorsNeedUpdate = source.colorsNeedUpdate;
  		this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
  		this.groupsNeedUpdate = source.groupsNeedUpdate;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometry$1() {

  	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

  	this.uuid = _Math$1.generateUUID();

  	this.name = '';
  	this.type = 'BufferGeometry';

  	this.index = null;
  	this.attributes = {};

  	this.morphAttributes = {};

  	this.groups = [];

  	this.boundingBox = null;
  	this.boundingSphere = null;

  	this.drawRange = { start: 0, count: Infinity };

  }

  BufferGeometry$1.MaxIndex = 65535;

  Object.assign( BufferGeometry$1.prototype, EventDispatcher$1.prototype, {

  	isBufferGeometry: true,

  	getIndex: function () {

  		return this.index;

  	},

  	setIndex: function ( index ) {

  		if ( Array.isArray( index ) ) {

  			this.index = new ( arrayMax$1( index ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( index, 1 );

  		} else {

  			this.index = index;

  		}

  	},

  	addAttribute: function ( name, attribute ) {

  		if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {

  			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

  			this.addAttribute( name, new BufferAttribute$1( arguments[ 1 ], arguments[ 2 ] ) );

  			return;

  		}

  		if ( name === 'index' ) {

  			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
  			this.setIndex( attribute );

  			return;

  		}

  		this.attributes[ name ] = attribute;

  		return this;

  	},

  	getAttribute: function ( name ) {

  		return this.attributes[ name ];

  	},

  	removeAttribute: function ( name ) {

  		delete this.attributes[ name ];

  		return this;

  	},

  	addGroup: function ( start, count, materialIndex ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex !== undefined ? materialIndex : 0

  		} );

  	},

  	clearGroups: function () {

  		this.groups = [];

  	},

  	setDrawRange: function ( start, count ) {

  		this.drawRange.start = start;
  		this.drawRange.count = count;

  	},

  	applyMatrix: function ( matrix ) {

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			matrix.applyToBufferAttribute( position );
  			position.needsUpdate = true;

  		}

  		var normal = this.attributes.normal;

  		if ( normal !== undefined ) {

  			var normalMatrix = new Matrix3$1().getNormalMatrix( matrix );

  			normalMatrix.applyToBufferAttribute( normal );
  			normal.needsUpdate = true;

  		}

  		if ( this.boundingBox !== null ) {

  			this.computeBoundingBox();

  		}

  		if ( this.boundingSphere !== null ) {

  			this.computeBoundingSphere();

  		}

  		return this;

  	},

  	rotateX: function () {

  		// rotate geometry around world x-axis

  		var m1 = new Matrix4$1();

  		return function rotateX( angle ) {

  			m1.makeRotationX( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateY: function () {

  		// rotate geometry around world y-axis

  		var m1 = new Matrix4$1();

  		return function rotateY( angle ) {

  			m1.makeRotationY( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	rotateZ: function () {

  		// rotate geometry around world z-axis

  		var m1 = new Matrix4$1();

  		return function rotateZ( angle ) {

  			m1.makeRotationZ( angle );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	translate: function () {

  		// translate geometry

  		var m1 = new Matrix4$1();

  		return function translate( x, y, z ) {

  			m1.makeTranslation( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	scale: function () {

  		// scale geometry

  		var m1 = new Matrix4$1();

  		return function scale( x, y, z ) {

  			m1.makeScale( x, y, z );

  			this.applyMatrix( m1 );

  			return this;

  		};

  	}(),

  	lookAt: function () {

  		var obj = new Object3D$1();

  		return function lookAt( vector ) {

  			obj.lookAt( vector );

  			obj.updateMatrix();

  			this.applyMatrix( obj.matrix );

  		};

  	}(),

  	center: function () {

  		this.computeBoundingBox();

  		var offset = this.boundingBox.getCenter().negate();

  		this.translate( offset.x, offset.y, offset.z );

  		return offset;

  	},

  	setFromObject: function ( object ) {

  		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

  		var geometry = object.geometry;

  		if ( object.isPoints || object.isLine ) {

  			var positions = new Float32BufferAttribute$1( geometry.vertices.length * 3, 3 );
  			var colors = new Float32BufferAttribute$1( geometry.colors.length * 3, 3 );

  			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
  			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

  			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

  				var lineDistances = new Float32BufferAttribute$1( geometry.lineDistances.length, 1 );

  				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

  			}

  			if ( geometry.boundingSphere !== null ) {

  				this.boundingSphere = geometry.boundingSphere.clone();

  			}

  			if ( geometry.boundingBox !== null ) {

  				this.boundingBox = geometry.boundingBox.clone();

  			}

  		} else if ( object.isMesh ) {

  			if ( geometry && geometry.isGeometry ) {

  				this.fromGeometry( geometry );

  			}

  		}

  		return this;

  	},

  	updateFromObject: function ( object ) {

  		var geometry = object.geometry;

  		if ( object.isMesh ) {

  			var direct = geometry.__directGeometry;

  			if ( geometry.elementsNeedUpdate === true ) {

  				direct = undefined;
  				geometry.elementsNeedUpdate = false;

  			}

  			if ( direct === undefined ) {

  				return this.fromGeometry( geometry );

  			}

  			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
  			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
  			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
  			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
  			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

  			geometry.verticesNeedUpdate = false;
  			geometry.normalsNeedUpdate = false;
  			geometry.colorsNeedUpdate = false;
  			geometry.uvsNeedUpdate = false;
  			geometry.groupsNeedUpdate = false;

  			geometry = direct;

  		}

  		var attribute;

  		if ( geometry.verticesNeedUpdate === true ) {

  			attribute = this.attributes.position;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.vertices );
  				attribute.needsUpdate = true;

  			}

  			geometry.verticesNeedUpdate = false;

  		}

  		if ( geometry.normalsNeedUpdate === true ) {

  			attribute = this.attributes.normal;

  			if ( attribute !== undefined ) {

  				attribute.copyVector3sArray( geometry.normals );
  				attribute.needsUpdate = true;

  			}

  			geometry.normalsNeedUpdate = false;

  		}

  		if ( geometry.colorsNeedUpdate === true ) {

  			attribute = this.attributes.color;

  			if ( attribute !== undefined ) {

  				attribute.copyColorsArray( geometry.colors );
  				attribute.needsUpdate = true;

  			}

  			geometry.colorsNeedUpdate = false;

  		}

  		if ( geometry.uvsNeedUpdate ) {

  			attribute = this.attributes.uv;

  			if ( attribute !== undefined ) {

  				attribute.copyVector2sArray( geometry.uvs );
  				attribute.needsUpdate = true;

  			}

  			geometry.uvsNeedUpdate = false;

  		}

  		if ( geometry.lineDistancesNeedUpdate ) {

  			attribute = this.attributes.lineDistance;

  			if ( attribute !== undefined ) {

  				attribute.copyArray( geometry.lineDistances );
  				attribute.needsUpdate = true;

  			}

  			geometry.lineDistancesNeedUpdate = false;

  		}

  		if ( geometry.groupsNeedUpdate ) {

  			geometry.computeGroups( object.geometry );
  			this.groups = geometry.groups;

  			geometry.groupsNeedUpdate = false;

  		}

  		return this;

  	},

  	fromGeometry: function ( geometry ) {

  		geometry.__directGeometry = new DirectGeometry$1().fromGeometry( geometry );

  		return this.fromDirectGeometry( geometry.__directGeometry );

  	},

  	fromDirectGeometry: function ( geometry ) {

  		var positions = new Float32Array( geometry.vertices.length * 3 );
  		this.addAttribute( 'position', new BufferAttribute$1( positions, 3 ).copyVector3sArray( geometry.vertices ) );

  		if ( geometry.normals.length > 0 ) {

  			var normals = new Float32Array( geometry.normals.length * 3 );
  			this.addAttribute( 'normal', new BufferAttribute$1( normals, 3 ).copyVector3sArray( geometry.normals ) );

  		}

  		if ( geometry.colors.length > 0 ) {

  			var colors = new Float32Array( geometry.colors.length * 3 );
  			this.addAttribute( 'color', new BufferAttribute$1( colors, 3 ).copyColorsArray( geometry.colors ) );

  		}

  		if ( geometry.uvs.length > 0 ) {

  			var uvs = new Float32Array( geometry.uvs.length * 2 );
  			this.addAttribute( 'uv', new BufferAttribute$1( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

  		}

  		if ( geometry.uvs2.length > 0 ) {

  			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
  			this.addAttribute( 'uv2', new BufferAttribute$1( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

  		}

  		if ( geometry.indices.length > 0 ) {

  			var TypeArray = arrayMax$1( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
  			var indices = new TypeArray( geometry.indices.length * 3 );
  			this.setIndex( new BufferAttribute$1( indices, 1 ).copyIndicesArray( geometry.indices ) );

  		}

  		// groups

  		this.groups = geometry.groups;

  		// morphs

  		for ( var name in geometry.morphTargets ) {

  			var array = [];
  			var morphTargets = geometry.morphTargets[ name ];

  			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

  				var morphTarget = morphTargets[ i ];

  				var attribute = new Float32BufferAttribute$1( morphTarget.length * 3, 3 );

  				array.push( attribute.copyVector3sArray( morphTarget ) );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		// skinning

  		if ( geometry.skinIndices.length > 0 ) {

  			var skinIndices = new Float32BufferAttribute$1( geometry.skinIndices.length * 4, 4 );
  			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

  		}

  		if ( geometry.skinWeights.length > 0 ) {

  			var skinWeights = new Float32BufferAttribute$1( geometry.skinWeights.length * 4, 4 );
  			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

  		}

  		//

  		if ( geometry.boundingSphere !== null ) {

  			this.boundingSphere = geometry.boundingSphere.clone();

  		}

  		if ( geometry.boundingBox !== null ) {

  			this.boundingBox = geometry.boundingBox.clone();

  		}

  		return this;

  	},

  	computeBoundingBox: function () {

  		if ( this.boundingBox === null ) {

  			this.boundingBox = new Box3$1();

  		}

  		var position = this.attributes.position;

  		if ( position !== undefined ) {

  			this.boundingBox.setFromBufferAttribute( position );

  		} else {

  			this.boundingBox.makeEmpty();

  		}

  		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

  			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

  		}

  	},

  	computeBoundingSphere: function () {

  		var box = new Box3$1();
  		var vector = new Vector3$1();

  		return function computeBoundingSphere() {

  			if ( this.boundingSphere === null ) {

  				this.boundingSphere = new Sphere$2();

  			}

  			var position = this.attributes.position;

  			if ( position ) {

  				var center = this.boundingSphere.center;

  				box.setFromBufferAttribute( position );
  				box.getCenter( center );

  				// hoping to find a boundingSphere with a radius smaller than the
  				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

  				var maxRadiusSq = 0;

  				for ( var i = 0, il = position.count; i < il; i ++ ) {

  					vector.x = position.getX( i );
  					vector.y = position.getY( i );
  					vector.z = position.getZ( i );
  					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

  				}

  				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

  				if ( isNaN( this.boundingSphere.radius ) ) {

  					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

  				}

  			}

  		};

  	}(),

  	computeFaceNormals: function () {

  		// backwards compatibility

  	},

  	computeVertexNormals: function () {

  		var index = this.index;
  		var attributes = this.attributes;
  		var groups = this.groups;

  		if ( attributes.position ) {

  			var positions = attributes.position.array;

  			if ( attributes.normal === undefined ) {

  				this.addAttribute( 'normal', new BufferAttribute$1( new Float32Array( positions.length ), 3 ) );

  			} else {

  				// reset existing normals to zero

  				var array = attributes.normal.array;

  				for ( var i = 0, il = array.length; i < il; i ++ ) {

  					array[ i ] = 0;

  				}

  			}

  			var normals = attributes.normal.array;

  			var vA, vB, vC;
  			var pA = new Vector3$1(), pB = new Vector3$1(), pC = new Vector3$1();
  			var cb = new Vector3$1(), ab = new Vector3$1();

  			// indexed elements

  			if ( index ) {

  				var indices = index.array;

  				if ( groups.length === 0 ) {

  					this.addGroup( 0, indices.length );

  				}

  				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

  					var group = groups[ j ];

  					var start = group.start;
  					var count = group.count;

  					for ( var i = start, il = start + count; i < il; i += 3 ) {

  						vA = indices[ i + 0 ] * 3;
  						vB = indices[ i + 1 ] * 3;
  						vC = indices[ i + 2 ] * 3;

  						pA.fromArray( positions, vA );
  						pB.fromArray( positions, vB );
  						pC.fromArray( positions, vC );

  						cb.subVectors( pC, pB );
  						ab.subVectors( pA, pB );
  						cb.cross( ab );

  						normals[ vA ] += cb.x;
  						normals[ vA + 1 ] += cb.y;
  						normals[ vA + 2 ] += cb.z;

  						normals[ vB ] += cb.x;
  						normals[ vB + 1 ] += cb.y;
  						normals[ vB + 2 ] += cb.z;

  						normals[ vC ] += cb.x;
  						normals[ vC + 1 ] += cb.y;
  						normals[ vC + 2 ] += cb.z;

  					}

  				}

  			} else {

  				// non-indexed elements (unconnected triangle soup)

  				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

  					pA.fromArray( positions, i );
  					pB.fromArray( positions, i + 3 );
  					pC.fromArray( positions, i + 6 );

  					cb.subVectors( pC, pB );
  					ab.subVectors( pA, pB );
  					cb.cross( ab );

  					normals[ i ] = cb.x;
  					normals[ i + 1 ] = cb.y;
  					normals[ i + 2 ] = cb.z;

  					normals[ i + 3 ] = cb.x;
  					normals[ i + 4 ] = cb.y;
  					normals[ i + 5 ] = cb.z;

  					normals[ i + 6 ] = cb.x;
  					normals[ i + 7 ] = cb.y;
  					normals[ i + 8 ] = cb.z;

  				}

  			}

  			this.normalizeNormals();

  			attributes.normal.needsUpdate = true;

  		}

  	},

  	merge: function ( geometry, offset ) {

  		if ( ( geometry && geometry.isBufferGeometry ) === false ) {

  			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
  			return;

  		}

  		if ( offset === undefined ) offset = 0;

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			if ( geometry.attributes[ key ] === undefined ) continue;

  			var attribute1 = attributes[ key ];
  			var attributeArray1 = attribute1.array;

  			var attribute2 = geometry.attributes[ key ];
  			var attributeArray2 = attribute2.array;

  			var attributeSize = attribute2.itemSize;

  			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

  				attributeArray1[ j ] = attributeArray2[ i ];

  			}

  		}

  		return this;

  	},

  	normalizeNormals: function () {

  		var normals = this.attributes.normal;

  		var x, y, z, n;

  		for ( var i = 0, il = normals.count; i < il; i ++ ) {

  			x = normals.getX( i );
  			y = normals.getY( i );
  			z = normals.getZ( i );

  			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

  			normals.setXYZ( i, x * n, y * n, z * n );

  		}

  	},

  	toNonIndexed: function () {

  		if ( this.index === null ) {

  			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
  			return this;

  		}

  		var geometry2 = new BufferGeometry$1();

  		var indices = this.index.array;
  		var attributes = this.attributes;

  		for ( var name in attributes ) {

  			var attribute = attributes[ name ];

  			var array = attribute.array;
  			var itemSize = attribute.itemSize;

  			var array2 = new array.constructor( indices.length * itemSize );

  			var index = 0, index2 = 0;

  			for ( var i = 0, l = indices.length; i < l; i ++ ) {

  				index = indices[ i ] * itemSize;

  				for ( var j = 0; j < itemSize; j ++ ) {

  					array2[ index2 ++ ] = array[ index ++ ];

  				}

  			}

  			geometry2.addAttribute( name, new BufferAttribute$1( array2, itemSize ) );

  		}

  		return geometry2;

  	},

  	toJSON: function () {

  		var data = {
  			metadata: {
  				version: 4.5,
  				type: 'BufferGeometry',
  				generator: 'BufferGeometry.toJSON'
  			}
  		};

  		// standard BufferGeometry serialization

  		data.uuid = this.uuid;
  		data.type = this.type;
  		if ( this.name !== '' ) data.name = this.name;

  		if ( this.parameters !== undefined ) {

  			var parameters = this.parameters;

  			for ( var key in parameters ) {

  				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

  			}

  			return data;

  		}

  		data.data = { attributes: {} };

  		var index = this.index;

  		if ( index !== null ) {

  			var array = Array.prototype.slice.call( index.array );

  			data.data.index = {
  				type: index.array.constructor.name,
  				array: array
  			};

  		}

  		var attributes = this.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];

  			var array = Array.prototype.slice.call( attribute.array );

  			data.data.attributes[ key ] = {
  				itemSize: attribute.itemSize,
  				type: attribute.array.constructor.name,
  				array: array,
  				normalized: attribute.normalized
  			};

  		}

  		var groups = this.groups;

  		if ( groups.length > 0 ) {

  			data.data.groups = JSON.parse( JSON.stringify( groups ) );

  		}

  		var boundingSphere = this.boundingSphere;

  		if ( boundingSphere !== null ) {

  			data.data.boundingSphere = {
  				center: boundingSphere.center.toArray(),
  				radius: boundingSphere.radius
  			};

  		}

  		return data;

  	},

  	clone: function () {

  		/*
  		 // Handle primitives

  		 var parameters = this.parameters;

  		 if ( parameters !== undefined ) {

  		 var values = [];

  		 for ( var key in parameters ) {

  		 values.push( parameters[ key ] );

  		 }

  		 var geometry = Object.create( this.constructor.prototype );
  		 this.constructor.apply( geometry, values );
  		 return geometry;

  		 }

  		 return new this.constructor().copy( this );
  		 */

  		return new BufferGeometry$1().copy( this );

  	},

  	copy: function ( source ) {

  		var name, i, l;

  		// reset

  		this.index = null;
  		this.attributes = {};
  		this.morphAttributes = {};
  		this.groups = [];
  		this.boundingBox = null;
  		this.boundingSphere = null;

  		// name

  		this.name = source.name;

  		// index

  		var index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		// attributes

  		var attributes = source.attributes;

  		for ( name in attributes ) {

  			var attribute = attributes[ name ];
  			this.addAttribute( name, attribute.clone() );

  		}

  		// morph attributes

  		var morphAttributes = source.morphAttributes;

  		for ( name in morphAttributes ) {

  			var array = [];
  			var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

  			for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

  				array.push( morphAttribute[ i ].clone() );

  			}

  			this.morphAttributes[ name ] = array;

  		}

  		// groups

  		var groups = source.groups;

  		for ( i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		// bounding box

  		var boundingBox = source.boundingBox;

  		if ( boundingBox !== null ) {

  			this.boundingBox = boundingBox.clone();

  		}

  		// bounding sphere

  		var boundingSphere = source.boundingSphere;

  		if ( boundingSphere !== null ) {

  			this.boundingSphere = boundingSphere.clone();

  		}

  		// draw range

  		this.drawRange.start = source.drawRange.start;
  		this.drawRange.count = source.drawRange.count;

  		return this;

  	},

  	dispose: function () {

  		this.dispatchEvent( { type: 'dispose' } );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author mikael emtinger / http://gomo.se/
   * @author jonobr1 / http://jonobr1.com/
   */

  function Mesh$1( geometry, material ) {

  	Object3D$1.call( this );

  	this.type = 'Mesh';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new MeshBasicMaterial$1( { color: Math.random() * 0xffffff } );

  	this.drawMode = TrianglesDrawMode$1;

  	this.updateMorphTargets();

  }

  Mesh$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Mesh$1,

  	isMesh: true,

  	setDrawMode: function ( value ) {

  		this.drawMode = value;

  	},

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.drawMode = source.drawMode;

  		return this;

  	},

  	updateMorphTargets: function () {

  		var morphTargets = this.geometry.morphTargets;

  		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

  			this.morphTargetInfluences = [];
  			this.morphTargetDictionary = {};

  			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

  				this.morphTargetInfluences.push( 0 );
  				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

  			}

  		}

  	},

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$2();

  		var vA = new Vector3$1();
  		var vB = new Vector3$1();
  		var vC = new Vector3$1();

  		var tempA = new Vector3$1();
  		var tempB = new Vector3$1();
  		var tempC = new Vector3$1();

  		var uvA = new Vector2$1();
  		var uvB = new Vector2$1();
  		var uvC = new Vector2$1();

  		var barycoord = new Vector3$1();

  		var intersectionPoint = new Vector3$1();
  		var intersectionPointWorld = new Vector3$1();

  		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

  			Triangle$1.barycoordFromPoint( point, p1, p2, p3, barycoord );

  			uv1.multiplyScalar( barycoord.x );
  			uv2.multiplyScalar( barycoord.y );
  			uv3.multiplyScalar( barycoord.z );

  			uv1.add( uv2 ).add( uv3 );

  			return uv1.clone();

  		}

  		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

  			var intersect;
  			var material = object.material;

  			if ( material.side === BackSide$1 ) {

  				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

  			} else {

  				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide$1, point );

  			}

  			if ( intersect === null ) return null;

  			intersectionPointWorld.copy( point );
  			intersectionPointWorld.applyMatrix4( object.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

  			if ( distance < raycaster.near || distance > raycaster.far ) return null;

  			return {
  				distance: distance,
  				point: intersectionPointWorld.clone(),
  				object: object
  			};

  		}

  		function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {

  			vA.fromBufferAttribute( position, a );
  			vB.fromBufferAttribute( position, b );
  			vC.fromBufferAttribute( position, c );

  			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

  			if ( intersection ) {

  				if ( uv ) {

  					uvA.fromBufferAttribute( uv, a );
  					uvB.fromBufferAttribute( uv, b );
  					uvC.fromBufferAttribute( uv, c );

  					intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

  				}

  				intersection.face = new Face3$1( a, b, c, Triangle$1.normal( vA, vB, vC ) );
  				intersection.faceIndex = a;

  			}

  			return intersection;

  		}

  		return function raycast( raycaster, intersects ) {

  			var geometry = this.geometry;
  			var material = this.material;
  			var matrixWorld = this.matrixWorld;

  			if ( material === undefined ) return;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			// Check boundingBox before continuing

  			if ( geometry.boundingBox !== null ) {

  				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

  			}

  			var intersection;

  			if ( geometry.isBufferGeometry ) {

  				var a, b, c;
  				var index = geometry.index;
  				var position = geometry.attributes.position;
  				var uv = geometry.attributes.uv;
  				var i, l;

  				if ( index !== null ) {

  					// indexed buffer geometry

  					for ( i = 0, l = index.count; i < l; i += 3 ) {

  						a = index.getX( i );
  						b = index.getX( i + 1 );
  						c = index.getX( i + 2 );

  						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				} else {

  					// non-indexed buffer geometry

  					for ( i = 0, l = position.count; i < l; i += 3 ) {

  						a = i;
  						b = i + 1;
  						c = i + 2;

  						intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );

  						if ( intersection ) {

  							intersection.index = a; // triangle number in positions buffer semantics
  							intersects.push( intersection );

  						}

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var fvA, fvB, fvC;
  				var isMultiMaterial = Array.isArray( material );

  				var vertices = geometry.vertices;
  				var faces = geometry.faces;
  				var uvs;

  				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
  				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

  				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

  					var face = faces[ f ];
  					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

  					if ( faceMaterial === undefined ) continue;

  					fvA = vertices[ face.a ];
  					fvB = vertices[ face.b ];
  					fvC = vertices[ face.c ];

  					if ( faceMaterial.morphTargets === true ) {

  						var morphTargets = geometry.morphTargets;
  						var morphInfluences = this.morphTargetInfluences;

  						vA.set( 0, 0, 0 );
  						vB.set( 0, 0, 0 );
  						vC.set( 0, 0, 0 );

  						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

  							var influence = morphInfluences[ t ];

  							if ( influence === 0 ) continue;

  							var targets = morphTargets[ t ].vertices;

  							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
  							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
  							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

  						}

  						vA.add( fvA );
  						vB.add( fvB );
  						vC.add( fvC );

  						fvA = vA;
  						fvB = vB;
  						fvC = vC;

  					}

  					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

  					if ( intersection ) {

  						if ( uvs && uvs[ f ] ) {

  							var uvs_f = uvs[ f ];
  							uvA.copy( uvs_f[ 0 ] );
  							uvB.copy( uvs_f[ 1 ] );
  							uvC.copy( uvs_f[ 2 ] );

  							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

  						}

  						intersection.face = face;
  						intersection.faceIndex = f;
  						intersects.push( intersection );

  					}

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // BoxGeometry

  function BoxGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	Geometry$1.call( this );

  	this.type = 'BoxGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	this.fromBufferGeometry( new BoxBufferGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) );
  	this.mergeVertices();

  }

  BoxGeometry$1.prototype = Object.create( Geometry$1.prototype );
  BoxGeometry$1.prototype.constructor = BoxGeometry$1;

  // BoxBufferGeometry

  function BoxBufferGeometry$1( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  	BufferGeometry$1.call( this );

  	this.type = 'BoxBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		depth: depth,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		depthSegments: depthSegments
  	};

  	var scope = this;

  	// segments

  	widthSegments = Math.floor( widthSegments ) || 1;
  	heightSegments = Math.floor( heightSegments ) || 1;
  	depthSegments = Math.floor( depthSegments ) || 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var numberOfVertices = 0;
  	var groupStart = 0;

  	// build each side of the box geometry

  	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
  	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
  	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
  	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
  	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
  	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

  		var segmentWidth = width / gridX;
  		var segmentHeight = height / gridY;

  		var widthHalf = width / 2;
  		var heightHalf = height / 2;
  		var depthHalf = depth / 2;

  		var gridX1 = gridX + 1;
  		var gridY1 = gridY + 1;

  		var vertexCounter = 0;
  		var groupCount = 0;

  		var ix, iy;

  		var vector = new Vector3$1();

  		// generate vertices, normals and uvs

  		for ( iy = 0; iy < gridY1; iy ++ ) {

  			var y = iy * segmentHeight - heightHalf;

  			for ( ix = 0; ix < gridX1; ix ++ ) {

  				var x = ix * segmentWidth - widthHalf;

  				// set values to correct vector component

  				vector[ u ] = x * udir;
  				vector[ v ] = y * vdir;
  				vector[ w ] = depthHalf;

  				// now apply vector to vertex buffer

  				vertices.push( vector.x, vector.y, vector.z );

  				// set values to correct vector component

  				vector[ u ] = 0;
  				vector[ v ] = 0;
  				vector[ w ] = depth > 0 ? 1 : - 1;

  				// now apply vector to normal buffer

  				normals.push( vector.x, vector.y, vector.z );

  				// uvs

  				uvs.push( ix / gridX );
  				uvs.push( 1 - ( iy / gridY ) );

  				// counters

  				vertexCounter += 1;

  			}

  		}

  		// indices

  		// 1. you need three indices to draw a single face
  		// 2. a single segment consists of two faces
  		// 3. so we need to generate six (2*3) indices per segment

  		for ( iy = 0; iy < gridY; iy ++ ) {

  			for ( ix = 0; ix < gridX; ix ++ ) {

  				var a = numberOfVertices + ix + gridX1 * iy;
  				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
  				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
  				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// increase counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, materialIndex );

  		// calculate new start value for groups

  		groupStart += groupCount;

  		// update total number of vertices

  		numberOfVertices += vertexCounter;

  	}

  }

  BoxBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  BoxBufferGeometry$1.prototype.constructor = BoxBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PlaneGeometry

  function PlaneGeometry$1( width, height, widthSegments, heightSegments ) {

  	Geometry$1.call( this );

  	this.type = 'PlaneGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	this.fromBufferGeometry( new PlaneBufferGeometry$1( width, height, widthSegments, heightSegments ) );
  	this.mergeVertices();

  }

  PlaneGeometry$1.prototype = Object.create( Geometry$1.prototype );
  PlaneGeometry$1.prototype.constructor = PlaneGeometry$1;

  // PlaneBufferGeometry

  function PlaneBufferGeometry$1( width, height, widthSegments, heightSegments ) {

  	BufferGeometry$1.call( this );

  	this.type = 'PlaneBufferGeometry';

  	this.parameters = {
  		width: width,
  		height: height,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments
  	};

  	var width_half = width / 2;
  	var height_half = height / 2;

  	var gridX = Math.floor( widthSegments ) || 1;
  	var gridY = Math.floor( heightSegments ) || 1;

  	var gridX1 = gridX + 1;
  	var gridY1 = gridY + 1;

  	var segment_width = width / gridX;
  	var segment_height = height / gridY;

  	var ix, iy;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy < gridY1; iy ++ ) {

  		var y = iy * segment_height - height_half;

  		for ( ix = 0; ix < gridX1; ix ++ ) {

  			var x = ix * segment_width - width_half;

  			vertices.push( x, - y, 0 );

  			normals.push( 0, 0, 1 );

  			uvs.push( ix / gridX );
  			uvs.push( 1 - ( iy / gridY ) );

  		}

  	}

  	// indices

  	for ( iy = 0; iy < gridY; iy ++ ) {

  		for ( ix = 0; ix < gridX; ix ++ ) {

  			var a = ix + gridX1 * iy;
  			var b = ix + gridX1 * ( iy + 1 );
  			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
  			var d = ( ix + 1 ) + gridX1 * iy;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  PlaneBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  PlaneBufferGeometry$1.prototype.constructor = PlaneBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author mikael emtinger / http://gomo.se/
   * @author WestLangley / http://github.com/WestLangley
  */

  function Camera$1() {

  	Object3D$1.call( this );

  	this.type = 'Camera';

  	this.matrixWorldInverse = new Matrix4$1();
  	this.projectionMatrix = new Matrix4$1();

  }

  Camera$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Camera$1,

  	isCamera: true,

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.matrixWorldInverse.copy( source.matrixWorldInverse );
  		this.projectionMatrix.copy( source.projectionMatrix );

  		return this;

  	},

  	getWorldDirection: function () {

  		var quaternion = new Quaternion$1();

  		return function getWorldDirection( optionalTarget ) {

  			var result = optionalTarget || new Vector3$1();

  			this.getWorldQuaternion( quaternion );

  			return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  		};

  	}(),

  	clone: function () {

  		return new this.constructor().copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author greggman / http://games.greggman.com/
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author tschw
   */

  function PerspectiveCamera$2( fov, aspect, near, far ) {

  	Camera$1.call( this );

  	this.type = 'PerspectiveCamera';

  	this.fov = fov !== undefined ? fov : 50;
  	this.zoom = 1;

  	this.near = near !== undefined ? near : 0.1;
  	this.far = far !== undefined ? far : 2000;
  	this.focus = 10;

  	this.aspect = aspect !== undefined ? aspect : 1;
  	this.view = null;

  	this.filmGauge = 35;	// width of the film (default in millimeters)
  	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

  	this.updateProjectionMatrix();

  }

  PerspectiveCamera$2.prototype = Object.assign( Object.create( Camera$1.prototype ), {

  	constructor: PerspectiveCamera$2,

  	isPerspectiveCamera: true,

  	copy: function ( source ) {

  		Camera$1.prototype.copy.call( this, source );

  		this.fov = source.fov;
  		this.zoom = source.zoom;

  		this.near = source.near;
  		this.far = source.far;
  		this.focus = source.focus;

  		this.aspect = source.aspect;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		this.filmGauge = source.filmGauge;
  		this.filmOffset = source.filmOffset;

  		return this;

  	},

  	/**
  	 * Sets the FOV by focal length in respect to the current .filmGauge.
  	 *
  	 * The default film gauge is 35, so that the focal length can be specified for
  	 * a 35mm (full frame) camera.
  	 *
  	 * Values for focal length and film gauge must have the same unit.
  	 */
  	setFocalLength: function ( focalLength ) {

  		// see http://www.bobatkins.com/photography/technical/field_of_view.html
  		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

  		this.fov = _Math$1.RAD2DEG * 2 * Math.atan( vExtentSlope );
  		this.updateProjectionMatrix();

  	},

  	/**
  	 * Calculates the focal length from the current .fov and .filmGauge.
  	 */
  	getFocalLength: function () {

  		var vExtentSlope = Math.tan( _Math$1.DEG2RAD * 0.5 * this.fov );

  		return 0.5 * this.getFilmHeight() / vExtentSlope;

  	},

  	getEffectiveFOV: function () {

  		return _Math$1.RAD2DEG * 2 * Math.atan(
  				Math.tan( _Math$1.DEG2RAD * 0.5 * this.fov ) / this.zoom );

  	},

  	getFilmWidth: function () {

  		// film not completely covered in portrait format (aspect < 1)
  		return this.filmGauge * Math.min( this.aspect, 1 );

  	},

  	getFilmHeight: function () {

  		// film not completely covered in landscape format (aspect > 1)
  		return this.filmGauge / Math.max( this.aspect, 1 );

  	},

  	/**
  	 * Sets an offset in a larger frustum. This is useful for multi-window or
  	 * multi-monitor/multi-machine setups.
  	 *
  	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
  	 * the monitors are in grid like this
  	 *
  	 *   +---+---+---+
  	 *   | A | B | C |
  	 *   +---+---+---+
  	 *   | D | E | F |
  	 *   +---+---+---+
  	 *
  	 * then for each monitor you would call it like this
  	 *
  	 *   var w = 1920;
  	 *   var h = 1080;
  	 *   var fullWidth = w * 3;
  	 *   var fullHeight = h * 2;
  	 *
  	 *   --A--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
  	 *   --B--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
  	 *   --C--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
  	 *   --D--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
  	 *   --E--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
  	 *   --F--
  	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
  	 *
  	 *   Note there is no reason monitors have to be the same size or in a grid.
  	 */
  	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

  		this.aspect = fullWidth / fullHeight;

  		this.view = {
  			fullWidth: fullWidth,
  			fullHeight: fullHeight,
  			offsetX: x,
  			offsetY: y,
  			width: width,
  			height: height
  		};

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function () {

  		this.view = null;
  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var near = this.near,
  			top = near * Math.tan(
  					_Math$1.DEG2RAD * 0.5 * this.fov ) / this.zoom,
  			height = 2 * top,
  			width = this.aspect * height,
  			left = - 0.5 * width,
  			view = this.view;

  		if ( view !== null ) {

  			var fullWidth = view.fullWidth,
  				fullHeight = view.fullHeight;

  			left += view.offsetX * width / fullWidth;
  			top -= view.offsetY * height / fullHeight;
  			width *= view.width / fullWidth;
  			height *= view.height / fullHeight;

  		}

  		var skew = this.filmOffset;
  		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

  		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.fov = this.fov;
  		data.object.zoom = this.zoom;

  		data.object.near = this.near;
  		data.object.far = this.far;
  		data.object.focus = this.focus;

  		data.object.aspect = this.aspect;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		data.object.filmGauge = this.filmGauge;
  		data.object.filmOffset = this.filmOffset;

  		return data;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author arose / http://github.com/arose
   */

  function OrthographicCamera$2( left, right, top, bottom, near, far ) {

  	Camera$1.call( this );

  	this.type = 'OrthographicCamera';

  	this.zoom = 1;
  	this.view = null;

  	this.left = left;
  	this.right = right;
  	this.top = top;
  	this.bottom = bottom;

  	this.near = ( near !== undefined ) ? near : 0.1;
  	this.far = ( far !== undefined ) ? far : 2000;

  	this.updateProjectionMatrix();

  }

  OrthographicCamera$2.prototype = Object.assign( Object.create( Camera$1.prototype ), {

  	constructor: OrthographicCamera$2,

  	isOrthographicCamera: true,

  	copy: function ( source ) {

  		Camera$1.prototype.copy.call( this, source );

  		this.left = source.left;
  		this.right = source.right;
  		this.top = source.top;
  		this.bottom = source.bottom;
  		this.near = source.near;
  		this.far = source.far;

  		this.zoom = source.zoom;
  		this.view = source.view === null ? null : Object.assign( {}, source.view );

  		return this;

  	},

  	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

  		this.view = {
  			fullWidth: fullWidth,
  			fullHeight: fullHeight,
  			offsetX: x,
  			offsetY: y,
  			width: width,
  			height: height
  		};

  		this.updateProjectionMatrix();

  	},

  	clearViewOffset: function() {

  		this.view = null;
  		this.updateProjectionMatrix();

  	},

  	updateProjectionMatrix: function () {

  		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  		var cx = ( this.right + this.left ) / 2;
  		var cy = ( this.top + this.bottom ) / 2;

  		var left = cx - dx;
  		var right = cx + dx;
  		var top = cy + dy;
  		var bottom = cy - dy;

  		if ( this.view !== null ) {

  			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
  			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
  			var scaleW = ( this.right - this.left ) / this.view.width;
  			var scaleH = ( this.top - this.bottom ) / this.view.height;

  			left += scaleW * ( this.view.offsetX / zoomW );
  			right = left + scaleW * ( this.view.width / zoomW );
  			top -= scaleH * ( this.view.offsetY / zoomH );
  			bottom = top - scaleH * ( this.view.height / zoomH );

  		}

  		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.zoom = this.zoom;
  		data.object.left = this.left;
  		data.object.right = this.right;
  		data.object.top = this.top;
  		data.object.bottom = this.bottom;
  		data.object.near = this.near;
  		data.object.far = this.far;

  		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

  		return data;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLAttributes$1( gl ) {

  	var buffers = {};

  	function createBuffer( attribute, bufferType ) {

  		var array = attribute.array;
  		var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

  		var buffer = gl.createBuffer();

  		gl.bindBuffer( bufferType, buffer );
  		gl.bufferData( bufferType, array, usage );

  		attribute.onUploadCallback();

  		var type = gl.FLOAT;

  		if ( array instanceof Float32Array ) {

  			type = gl.FLOAT;

  		} else if ( array instanceof Float64Array ) {

  			console.warn( "Unsupported data buffer format: Float64Array" );

  		} else if ( array instanceof Uint16Array ) {

  			type = gl.UNSIGNED_SHORT;

  		} else if ( array instanceof Int16Array ) {

  			type = gl.SHORT;

  		} else if ( array instanceof Uint32Array ) {

  			type = gl.UNSIGNED_INT;

  		} else if ( array instanceof Int32Array ) {

  			type = gl.INT;

  		} else if ( array instanceof Int8Array ) {

  			type = gl.BYTE;

  		} else if ( array instanceof Uint8Array ) {

  			type = gl.UNSIGNED_BYTE;

  		}

  		return {
  			buffer: buffer,
  			type: type,
  			bytesPerElement: array.BYTES_PER_ELEMENT,
  			version: attribute.version
  		};

  	}

  	function updateBuffer( buffer, attribute, bufferType ) {

  		var array = attribute.array;
  		var updateRange = attribute.updateRange;

  		gl.bindBuffer( bufferType, buffer );

  		if ( attribute.dynamic === false ) {

  			gl.bufferData( bufferType, array, gl.STATIC_DRAW );

  		} else if ( updateRange.count === - 1 ) {

  			// Not using update ranges

  			gl.bufferSubData( bufferType, 0, array );

  		} else if ( updateRange.count === 0 ) {

  			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

  		} else {

  			gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
  				array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

  			updateRange.count = 0; // reset range

  		}

  	}

  	//

  	function get( attribute ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		return buffers[ attribute.uuid ];

  	}

  	function remove( attribute ) {

  		var data = buffers[ attribute.uuid ];

  		if ( data ) {

  			gl.deleteBuffer( data.buffer );

  			delete buffers[ attribute.uuid ];

  		}

  	}

  	function update( attribute, bufferType ) {

  		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

  		var data = buffers[ attribute.uuid ];

  		if ( data === undefined ) {

  			buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );

  		} else if ( data.version < attribute.version ) {

  			updateBuffer( data.buffer, attribute, bufferType );

  			data.version = attribute.version;

  		}

  	}

  	return {

  		get: get,
  		remove: remove,
  		update: update

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function painterSortStable$1( a, b ) {

  	if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} else if ( a.program && b.program && a.program !== b.program ) {

  		return a.program.id - b.program.id;

  	} else if ( a.material.id !== b.material.id ) {

  		return a.material.id - b.material.id;

  	} else if ( a.z !== b.z ) {

  		return a.z - b.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function reversePainterSortStable$1( a, b ) {

  	if ( a.renderOrder !== b.renderOrder ) {

  		return a.renderOrder - b.renderOrder;

  	} if ( a.z !== b.z ) {

  		return b.z - a.z;

  	} else {

  		return a.id - b.id;

  	}

  }

  function WebGLRenderList$1() {

  	var opaque = [];
  	var opaqueLastIndex = - 1;

  	var transparent = [];
  	var transparentLastIndex = - 1;

  	function init() {

  		opaqueLastIndex = - 1;
  		transparentLastIndex = - 1;

  	}

  	function push( object, geometry, material, z, group ) {

  		var array, index;

  		// allocate the next position in the appropriate array

  		if ( material.transparent ) {

  			array = transparent;
  			index = ++ transparentLastIndex;

  		} else {

  			array = opaque;
  			index = ++ opaqueLastIndex;

  		}

  		// recycle existing render item or grow the array

  		var renderItem = array[ index ];

  		if ( renderItem ) {

  			renderItem.id = object.id;
  			renderItem.object = object;
  			renderItem.geometry = geometry;
  			renderItem.material = material;
  			renderItem.program = material.program;
  			renderItem.renderOrder = object.renderOrder;
  			renderItem.z = z;
  			renderItem.group = group;

  		} else {

  			renderItem = {
  				id: object.id,
  				object: object,
  				geometry: geometry,
  				material: material,
  				program: material.program,
  				renderOrder: object.renderOrder,
  				z: z,
  				group: group
  			};

  			// assert( index === array.length );
  			array.push( renderItem );

  		}

  	}

  	function finish() {

  		opaque.length = opaqueLastIndex + 1;
  		transparent.length = transparentLastIndex + 1;

  	}

  	function sort() {

  		opaque.sort( painterSortStable$1 );
  		transparent.sort( reversePainterSortStable$1 );

  	}

  	return {
  		opaque: opaque,
  		transparent: transparent,

  		init: init,
  		push: push,
  		finish: finish,

  		sort: sort
  	};

  }

  function WebGLRenderLists$1() {

  	var lists = {};

  	function get( scene, camera ) {

  		var hash = scene.id + ',' + camera.id;
  		var list = lists[ hash ];

  		if ( list === undefined ) {

  			// console.log( 'THREE.WebGLRenderLists:', hash );

  			list = new WebGLRenderList$1();
  			lists[ hash ] = list;

  		}

  		return list;

  	}

  	function dispose() {

  		lists = {};

  	}

  	return {
  		get: get,
  		dispose: dispose
  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLIndexedBufferRenderer$1( gl, extensions, infoRender ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	var type, size;

  	function setIndex( index ) {

  		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

  			type = gl.UNSIGNED_INT;
  			size = 4;

  		} else if ( index.array instanceof Uint16Array ) {

  			type = gl.UNSIGNED_SHORT;
  			size = 2;

  		} else {

  			type = gl.UNSIGNED_BYTE;
  			size = 1;

  		}

  	}

  	function render( start, count ) {

  		gl.drawElements( mode, count, type, start * size );

  		infoRender.calls ++;
  		infoRender.vertices += count;

  		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension = extensions.get( 'ANGLE_instanced_arrays' );

  		if ( extension === null ) {

  			console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  			return;

  		}

  		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

  		infoRender.calls ++;
  		infoRender.vertices += count * geometry.maxInstancedCount;

  		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

  	}

  	//

  	this.setMode = setMode;
  	this.setIndex = setIndex;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLBufferRenderer$1( gl, extensions, infoRender ) {

  	var mode;

  	function setMode( value ) {

  		mode = value;

  	}

  	function render( start, count ) {

  		gl.drawArrays( mode, start, count );

  		infoRender.calls ++;
  		infoRender.vertices += count;

  		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

  	}

  	function renderInstances( geometry, start, count ) {

  		var extension = extensions.get( 'ANGLE_instanced_arrays' );

  		if ( extension === null ) {

  			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  			return;

  		}

  		var position = geometry.attributes.position;

  		if ( position.isInterleavedBufferAttribute ) {

  			count = position.data.count;

  			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

  		} else {

  			extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

  		}

  		infoRender.calls ++;
  		infoRender.vertices += count * geometry.maxInstancedCount;

  		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

  	}

  	//

  	this.setMode = setMode;
  	this.render = render;
  	this.renderInstances = renderInstances;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLGeometries$1( gl, attributes, infoMemory ) {

  	var geometries = {};
  	var wireframeAttributes = {};

  	function onGeometryDispose( event ) {

  		var geometry = event.target;
  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry.index !== null ) {

  			attributes.remove( buffergeometry.index );

  		}

  		for ( var name in buffergeometry.attributes ) {

  			attributes.remove( buffergeometry.attributes[ name ] );

  		}

  		geometry.removeEventListener( 'dispose', onGeometryDispose );

  		delete geometries[ geometry.id ];

  		// TODO Remove duplicate code

  		var attribute = wireframeAttributes[ geometry.id ];

  		if ( attribute ) {

  			attributes.remove( attribute );
  			delete wireframeAttributes[ geometry.id ];

  		}

  		attribute = wireframeAttributes[ buffergeometry.id ];

  		if ( attribute ) {

  			attributes.remove( attribute );
  			delete wireframeAttributes[ buffergeometry.id ];

  		}

  		//

  		infoMemory.geometries --;

  	}

  	function get( object, geometry ) {

  		var buffergeometry = geometries[ geometry.id ];

  		if ( buffergeometry ) return buffergeometry;

  		geometry.addEventListener( 'dispose', onGeometryDispose );

  		if ( geometry.isBufferGeometry ) {

  			buffergeometry = geometry;

  		} else if ( geometry.isGeometry ) {

  			if ( geometry._bufferGeometry === undefined ) {

  				geometry._bufferGeometry = new BufferGeometry$1().setFromObject( object );

  			}

  			buffergeometry = geometry._bufferGeometry;

  		}

  		geometries[ geometry.id ] = buffergeometry;

  		infoMemory.geometries ++;

  		return buffergeometry;

  	}

  	function update( geometry ) {

  		var index = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		if ( index !== null ) {

  			attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

  		}

  		for ( var name in geometryAttributes ) {

  			attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

  		}

  		// morph targets

  		var morphAttributes = geometry.morphAttributes;

  		for ( var name in morphAttributes ) {

  			var array = morphAttributes[ name ];

  			for ( var i = 0, l = array.length; i < l; i ++ ) {

  				attributes.update( array[ i ], gl.ARRAY_BUFFER );

  			}

  		}

  	}

  	function getWireframeAttribute( geometry ) {

  		var attribute = wireframeAttributes[ geometry.id ];

  		if ( attribute ) return attribute;

  		var indices = [];

  		var geometryIndex = geometry.index;
  		var geometryAttributes = geometry.attributes;

  		// console.time( 'wireframe' );

  		if ( geometryIndex !== null ) {

  			var array = geometryIndex.array;

  			for ( var i = 0, l = array.length; i < l; i += 3 ) {

  				var a = array[ i + 0 ];
  				var b = array[ i + 1 ];
  				var c = array[ i + 2 ];

  				indices.push( a, b, b, c, c, a );

  			}

  		} else {

  			var array = geometryAttributes.position.array;

  			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

  				var a = i + 0;
  				var b = i + 1;
  				var c = i + 2;

  				indices.push( a, b, b, c, c, a );

  			}

  		}

  		// console.timeEnd( 'wireframe' );

  		attribute = new ( arrayMax$1( indices ) > 65535 ? Uint32BufferAttribute$1 : Uint16BufferAttribute$1 )( indices, 1 );

  		attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

  		wireframeAttributes[ geometry.id ] = attribute;

  		return attribute;

  	}

  	return {

  		get: get,
  		update: update,

  		getWireframeAttribute: getWireframeAttribute

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLLights$1() {

  	var lights = {};

  	return {

  		get: function ( light ) {

  			if ( lights[ light.id ] !== undefined ) {

  				return lights[ light.id ];

  			}

  			var uniforms;

  			switch ( light.type ) {

  				case 'DirectionalLight':
  					uniforms = {
  						direction: new Vector3$1(),
  						color: new Color$1(),

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1()
  					};
  					break;

  				case 'SpotLight':
  					uniforms = {
  						position: new Vector3$1(),
  						direction: new Vector3$1(),
  						color: new Color$1(),
  						distance: 0,
  						coneCos: 0,
  						penumbraCos: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1()
  					};
  					break;

  				case 'PointLight':
  					uniforms = {
  						position: new Vector3$1(),
  						color: new Color$1(),
  						distance: 0,
  						decay: 0,

  						shadow: false,
  						shadowBias: 0,
  						shadowRadius: 1,
  						shadowMapSize: new Vector2$1()
  					};
  					break;

  				case 'HemisphereLight':
  					uniforms = {
  						direction: new Vector3$1(),
  						skyColor: new Color$1(),
  						groundColor: new Color$1()
  					};
  					break;

  				case 'RectAreaLight':
  					uniforms = {
  						color: new Color$1(),
  						position: new Vector3$1(),
  						halfWidth: new Vector3$1(),
  						halfHeight: new Vector3$1()
  						// TODO (abelnation): set RectAreaLight shadow uniforms
  					};
  					break;

  			}

  			lights[ light.id ] = uniforms;

  			return uniforms;

  		}

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLObjects$1( gl, geometries, infoRender ) {

  	var updateList = {};

  	function update( object ) {

  		var frame = infoRender.frame;

  		var geometry = object.geometry;
  		var buffergeometry = geometries.get( object, geometry );

  		// Update once per frame

  		if ( updateList[ buffergeometry.id ] !== frame ) {

  			if ( geometry.isGeometry ) {

  				buffergeometry.updateFromObject( object );

  			}

  			geometries.update( buffergeometry );

  			updateList[ buffergeometry.id ] = frame;

  		}

  		return buffergeometry;

  	}

  	function clear() {

  		updateList = {};

  	}

  	return {

  		update: update,
  		clear: clear

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function addLineNumbers$1( string ) {

  	var lines = string.split( '\n' );

  	for ( var i = 0; i < lines.length; i ++ ) {

  		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

  	}

  	return lines.join( '\n' );

  }

  function WebGLShader$1( gl, type, string ) {

  	var shader = gl.createShader( type );

  	gl.shaderSource( shader, string );
  	gl.compileShader( shader );

  	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

  		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

  	}

  	if ( gl.getShaderInfoLog( shader ) !== '' ) {

  		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers$1( string ) );

  	}

  	// --enable-privileged-webgl-extension
  	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  	return shader;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var programIdCount$1 = 0;

  function getEncodingComponents$1( encoding ) {

  	switch ( encoding ) {

  		case LinearEncoding$1:
  			return [ 'Linear','( value )' ];
  		case sRGBEncoding$1:
  			return [ 'sRGB','( value )' ];
  		case RGBEEncoding$1:
  			return [ 'RGBE','( value )' ];
  		case RGBM7Encoding$1:
  			return [ 'RGBM','( value, 7.0 )' ];
  		case RGBM16Encoding$1:
  			return [ 'RGBM','( value, 16.0 )' ];
  		case RGBDEncoding$1:
  			return [ 'RGBD','( value, 256.0 )' ];
  		case GammaEncoding$1:
  			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
  		default:
  			throw new Error( 'unsupported encoding: ' + encoding );

  	}

  }

  function getTexelDecodingFunction$1( functionName, encoding ) {

  	var components = getEncodingComponents$1( encoding );
  	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

  }

  function getTexelEncodingFunction$1( functionName, encoding ) {

  	var components = getEncodingComponents$1( encoding );
  	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

  }

  function getToneMappingFunction$1( functionName, toneMapping ) {

  	var toneMappingName;

  	switch ( toneMapping ) {

  		case LinearToneMapping$1:
  			toneMappingName = "Linear";
  			break;

  		case ReinhardToneMapping$1:
  			toneMappingName = "Reinhard";
  			break;

  		case Uncharted2ToneMapping$1:
  			toneMappingName = "Uncharted2";
  			break;

  		case CineonToneMapping$1:
  			toneMappingName = "OptimizedCineon";
  			break;

  		default:
  			throw new Error( 'unsupported toneMapping: ' + toneMapping );

  	}

  	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

  }

  function generateExtensions$1( extensions, parameters, rendererExtensions ) {

  	extensions = extensions || {};

  	var chunks = [
  		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
  		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
  		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
  		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
  	];

  	return chunks.filter( filterEmptyLine$1 ).join( '\n' );

  }

  function generateDefines$1( defines ) {

  	var chunks = [];

  	for ( var name in defines ) {

  		var value = defines[ name ];

  		if ( value === false ) continue;

  		chunks.push( '#define ' + name + ' ' + value );

  	}

  	return chunks.join( '\n' );

  }

  function fetchAttributeLocations$1( gl, program, identifiers ) {

  	var attributes = {};

  	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

  	for ( var i = 0; i < n; i ++ ) {

  		var info = gl.getActiveAttrib( program, i );
  		var name = info.name;

  		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

  		attributes[ name ] = gl.getAttribLocation( program, name );

  	}

  	return attributes;

  }

  function filterEmptyLine$1( string ) {

  	return string !== '';

  }

  function replaceLightNums$1( string, parameters ) {

  	return string
  		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
  		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
  		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
  		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
  		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

  }

  function parseIncludes$1( string ) {

  	var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

  	function replace( match, include ) {

  		var replace = ShaderChunk$1[ include ];

  		if ( replace === undefined ) {

  			throw new Error( 'Can not resolve #include <' + include + '>' );

  		}

  		return parseIncludes$1( replace );

  	}

  	return string.replace( pattern, replace );

  }

  function unrollLoops$1( string ) {

  	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

  	function replace( match, start, end, snippet ) {

  		var unroll = '';

  		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

  			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

  		}

  		return unroll;

  	}

  	return string.replace( pattern, replace );

  }

  function WebGLProgram$1( renderer, code, material, parameters ) {

  	var gl = renderer.context;

  	var extensions = material.extensions;
  	var defines = material.defines;

  	var vertexShader = material.__webglShader.vertexShader;
  	var fragmentShader = material.__webglShader.fragmentShader;

  	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  	if ( parameters.shadowMapType === PCFShadowMap$1 ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

  	} else if ( parameters.shadowMapType === PCFSoftShadowMap$1 ) {

  		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

  	}

  	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
  	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

  	if ( parameters.envMap ) {

  		switch ( material.envMap.mapping ) {

  			case CubeReflectionMapping$1:
  			case CubeRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
  				break;

  			case CubeUVReflectionMapping$1:
  			case CubeUVRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
  				break;

  			case EquirectangularReflectionMapping$1:
  			case EquirectangularRefractionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
  				break;

  			case SphericalReflectionMapping$1:
  				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
  				break;

  		}

  		switch ( material.envMap.mapping ) {

  			case CubeRefractionMapping$1:
  			case EquirectangularRefractionMapping$1:
  				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
  				break;

  		}

  		switch ( material.combine ) {

  			case MultiplyOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
  				break;

  			case MixOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
  				break;

  			case AddOperation$1:
  				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
  				break;

  		}

  	}

  	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

  	// console.log( 'building new program ' );

  	//

  	var customExtensions = generateExtensions$1( extensions, parameters, renderer.extensions );

  	var customDefines = generateDefines$1( defines );

  	//

  	var program = gl.createProgram();

  	var prefixVertex, prefixFragment;

  	if ( material.isRawShaderMaterial ) {

  		prefixVertex = [

  			customDefines,

  			'\n'

  		].filter( filterEmptyLine$1 ).join( '\n' );

  		prefixFragment = [

  			customExtensions,
  			customDefines,

  			'\n'

  		].filter( filterEmptyLine$1 ).join( '\n' );

  	} else {

  		prefixVertex = [

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + material.__webglShader.name,

  			customDefines,

  			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			'#define MAX_BONES ' + parameters.maxBones,
  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.skinning ? '#define USE_SKINNING' : '',
  			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

  			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
  			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			'uniform mat4 modelMatrix;',
  			'uniform mat4 modelViewMatrix;',
  			'uniform mat4 projectionMatrix;',
  			'uniform mat4 viewMatrix;',
  			'uniform mat3 normalMatrix;',
  			'uniform vec3 cameraPosition;',

  			'attribute vec3 position;',
  			'attribute vec3 normal;',
  			'attribute vec2 uv;',

  			'#ifdef USE_COLOR',

  			'	attribute vec3 color;',

  			'#endif',

  			'#ifdef USE_MORPHTARGETS',

  			'	attribute vec3 morphTarget0;',
  			'	attribute vec3 morphTarget1;',
  			'	attribute vec3 morphTarget2;',
  			'	attribute vec3 morphTarget3;',

  			'	#ifdef USE_MORPHNORMALS',

  			'		attribute vec3 morphNormal0;',
  			'		attribute vec3 morphNormal1;',
  			'		attribute vec3 morphNormal2;',
  			'		attribute vec3 morphNormal3;',

  			'	#else',

  			'		attribute vec3 morphTarget4;',
  			'		attribute vec3 morphTarget5;',
  			'		attribute vec3 morphTarget6;',
  			'		attribute vec3 morphTarget7;',

  			'	#endif',

  			'#endif',

  			'#ifdef USE_SKINNING',

  			'	attribute vec4 skinIndex;',
  			'	attribute vec4 skinWeight;',

  			'#endif',

  			'\n'

  		].filter( filterEmptyLine$1 ).join( '\n' );

  		prefixFragment = [

  			customExtensions,

  			'precision ' + parameters.precision + ' float;',
  			'precision ' + parameters.precision + ' int;',

  			'#define SHADER_NAME ' + material.__webglShader.name,

  			customDefines,

  			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

  			'#define GAMMA_FACTOR ' + gammaFactorDefine,

  			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
  			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

  			parameters.map ? '#define USE_MAP' : '',
  			parameters.envMap ? '#define USE_ENVMAP' : '',
  			parameters.envMap ? '#define ' + envMapTypeDefine : '',
  			parameters.envMap ? '#define ' + envMapModeDefine : '',
  			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
  			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
  			parameters.aoMap ? '#define USE_AOMAP' : '',
  			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
  			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
  			parameters.normalMap ? '#define USE_NORMALMAP' : '',
  			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
  			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
  			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
  			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
  			parameters.vertexColors ? '#define USE_COLOR' : '',

  			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

  			parameters.flatShading ? '#define FLAT_SHADED' : '',

  			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
  			parameters.flipSided ? '#define FLIP_SIDED' : '',

  			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
  			'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

  			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
  			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

  			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

  			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

  			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
  			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

  			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

  			'uniform mat4 viewMatrix;',
  			'uniform vec3 cameraPosition;',

  			( parameters.toneMapping !== NoToneMapping$1 ) ? "#define TONE_MAPPING" : '',
  			( parameters.toneMapping !== NoToneMapping$1 ) ? ShaderChunk$1[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
  			( parameters.toneMapping !== NoToneMapping$1 ) ? getToneMappingFunction$1( "toneMapping", parameters.toneMapping ) : '',

  			parameters.dithering ? '#define DITHERING' : '',

  			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk$1[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
  			parameters.mapEncoding ? getTexelDecodingFunction$1( 'mapTexelToLinear', parameters.mapEncoding ) : '',
  			parameters.envMapEncoding ? getTexelDecodingFunction$1( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
  			parameters.emissiveMapEncoding ? getTexelDecodingFunction$1( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
  			parameters.outputEncoding ? getTexelEncodingFunction$1( "linearToOutputTexel", parameters.outputEncoding ) : '',

  			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

  			'\n'

  		].filter( filterEmptyLine$1 ).join( '\n' );

  	}

  	vertexShader = parseIncludes$1( vertexShader, parameters );
  	vertexShader = replaceLightNums$1( vertexShader, parameters );

  	fragmentShader = parseIncludes$1( fragmentShader, parameters );
  	fragmentShader = replaceLightNums$1( fragmentShader, parameters );

  	if ( ! material.isShaderMaterial ) {

  		vertexShader = unrollLoops$1( vertexShader );
  		fragmentShader = unrollLoops$1( fragmentShader );

  	}

  	var vertexGlsl = prefixVertex + vertexShader;
  	var fragmentGlsl = prefixFragment + fragmentShader;

  	// console.log( '*VERTEX*', vertexGlsl );
  	// console.log( '*FRAGMENT*', fragmentGlsl );

  	var glVertexShader = WebGLShader$1( gl, gl.VERTEX_SHADER, vertexGlsl );
  	var glFragmentShader = WebGLShader$1( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

  	gl.attachShader( program, glVertexShader );
  	gl.attachShader( program, glFragmentShader );

  	// Force a particular attribute to index 0.

  	if ( material.index0AttributeName !== undefined ) {

  		gl.bindAttribLocation( program, 0, material.index0AttributeName );

  	} else if ( parameters.morphTargets === true ) {

  		// programs with morphTargets displace position out of attribute 0
  		gl.bindAttribLocation( program, 0, 'position' );

  	}

  	gl.linkProgram( program );

  	var programLog = gl.getProgramInfoLog( program );
  	var vertexLog = gl.getShaderInfoLog( glVertexShader );
  	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

  	var runnable = true;
  	var haveDiagnostics = true;

  	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
  	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

  	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

  		runnable = false;

  		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

  	} else if ( programLog !== '' ) {

  		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

  	} else if ( vertexLog === '' || fragmentLog === '' ) {

  		haveDiagnostics = false;

  	}

  	if ( haveDiagnostics ) {

  		this.diagnostics = {

  			runnable: runnable,
  			material: material,

  			programLog: programLog,

  			vertexShader: {

  				log: vertexLog,
  				prefix: prefixVertex

  			},

  			fragmentShader: {

  				log: fragmentLog,
  				prefix: prefixFragment

  			}

  		};

  	}

  	// clean up

  	gl.deleteShader( glVertexShader );
  	gl.deleteShader( glFragmentShader );

  	// set up caching for uniform locations

  	var cachedUniforms;

  	this.getUniforms = function() {

  		if ( cachedUniforms === undefined ) {

  			cachedUniforms =
  				new WebGLUniforms$1( gl, program, renderer );

  		}

  		return cachedUniforms;

  	};

  	// set up caching for attribute locations

  	var cachedAttributes;

  	this.getAttributes = function() {

  		if ( cachedAttributes === undefined ) {

  			cachedAttributes = fetchAttributeLocations$1( gl, program );

  		}

  		return cachedAttributes;

  	};

  	// free resource

  	this.destroy = function() {

  		gl.deleteProgram( program );
  		this.program = undefined;

  	};

  	// DEPRECATED

  	Object.defineProperties( this, {

  		uniforms: {
  			get: function() {

  				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
  				return this.getUniforms();

  			}
  		},

  		attributes: {
  			get: function() {

  				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
  				return this.getAttributes();

  			}
  		}

  	} );


  	//

  	this.id = programIdCount$1 ++;
  	this.code = code;
  	this.usedTimes = 1;
  	this.program = program;
  	this.vertexShader = glVertexShader;
  	this.fragmentShader = glFragmentShader;

  	return this;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLPrograms$1( renderer, capabilities ) {

  	var programs = [];

  	var shaderIDs = {
  		MeshDepthMaterial: 'depth',
  		MeshNormalMaterial: 'normal',
  		MeshBasicMaterial: 'basic',
  		MeshLambertMaterial: 'lambert',
  		MeshPhongMaterial: 'phong',
  		MeshToonMaterial: 'phong',
  		MeshStandardMaterial: 'physical',
  		MeshPhysicalMaterial: 'physical',
  		LineBasicMaterial: 'basic',
  		LineDashedMaterial: 'dashed',
  		PointsMaterial: 'points'
  	};

  	var parameterNames = [
  		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
  		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
  		"roughnessMap", "metalnessMap", "gradientMap",
  		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
  		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
  		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
  		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
  		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
  		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
  		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
  	];


  	function allocateBones( object ) {

  		var skeleton = object.skeleton;
  		var bones = skeleton.bones;

  		if ( capabilities.floatVertexTextures ) {

  			return 1024;

  		} else {

  			// default for when object is not specified
  			// ( for example when prebuilding shader to be used with multiple objects )
  			//
  			//  - leave some extra space for other uniforms
  			//  - limit here is ANGLE's 254 max uniform vectors
  			//    (up to 54 should be safe)

  			var nVertexUniforms = capabilities.maxVertexUniforms;
  			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

  			var maxBones = Math.min( nVertexMatrices, bones.length );

  			if ( maxBones < bones.length ) {

  				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
  				return 0;

  			}

  			return maxBones;

  		}

  	}

  	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

  		var encoding;

  		if ( ! map ) {

  			encoding = LinearEncoding$1;

  		} else if ( map.isTexture ) {

  			encoding = map.encoding;

  		} else if ( map.isWebGLRenderTarget ) {

  			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
  			encoding = map.texture.encoding;

  		}

  		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
  		if ( encoding === LinearEncoding$1 && gammaOverrideLinear ) {

  			encoding = GammaEncoding$1;

  		}

  		return encoding;

  	}

  	this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

  		var shaderID = shaderIDs[ material.type ];

  		// heuristics to create shader parameters according to lights in the scene
  		// (not to blow over maxLights budget)

  		var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
  		var precision = renderer.getPrecision();

  		if ( material.precision !== null ) {

  			precision = capabilities.getMaxPrecision( material.precision );

  			if ( precision !== material.precision ) {

  				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

  			}

  		}

  		var currentRenderTarget = renderer.getRenderTarget();

  		var parameters = {

  			shaderID: shaderID,

  			precision: precision,
  			supportsVertexTextures: capabilities.vertexTextures,
  			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
  			map: !! material.map,
  			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
  			envMap: !! material.envMap,
  			envMapMode: material.envMap && material.envMap.mapping,
  			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
  			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping$1 ) || ( material.envMap.mapping === CubeUVRefractionMapping$1 ) ),
  			lightMap: !! material.lightMap,
  			aoMap: !! material.aoMap,
  			emissiveMap: !! material.emissiveMap,
  			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
  			bumpMap: !! material.bumpMap,
  			normalMap: !! material.normalMap,
  			displacementMap: !! material.displacementMap,
  			roughnessMap: !! material.roughnessMap,
  			metalnessMap: !! material.metalnessMap,
  			specularMap: !! material.specularMap,
  			alphaMap: !! material.alphaMap,

  			gradientMap: !! material.gradientMap,

  			combine: material.combine,

  			vertexColors: material.vertexColors,

  			fog: !! fog,
  			useFog: material.fog,
  			fogExp: ( fog && fog.isFogExp2 ),

  			flatShading: material.shading === FlatShading$1,

  			sizeAttenuation: material.sizeAttenuation,
  			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

  			skinning: material.skinning && maxBones > 0,
  			maxBones: maxBones,
  			useVertexTexture: capabilities.floatVertexTextures,

  			morphTargets: material.morphTargets,
  			morphNormals: material.morphNormals,
  			maxMorphTargets: renderer.maxMorphTargets,
  			maxMorphNormals: renderer.maxMorphNormals,

  			numDirLights: lights.directional.length,
  			numPointLights: lights.point.length,
  			numSpotLights: lights.spot.length,
  			numRectAreaLights: lights.rectArea.length,
  			numHemiLights: lights.hemi.length,

  			numClippingPlanes: nClipPlanes,
  			numClipIntersection: nClipIntersection,

  			dithering: material.dithering,

  			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
  			shadowMapType: renderer.shadowMap.type,

  			toneMapping: renderer.toneMapping,
  			physicallyCorrectLights: renderer.physicallyCorrectLights,

  			premultipliedAlpha: material.premultipliedAlpha,

  			alphaTest: material.alphaTest,
  			doubleSided: material.side === DoubleSide$1,
  			flipSided: material.side === BackSide$1,

  			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

  		};

  		return parameters;

  	};

  	this.getProgramCode = function ( material, parameters ) {

  		var array = [];

  		if ( parameters.shaderID ) {

  			array.push( parameters.shaderID );

  		} else {

  			array.push( material.fragmentShader );
  			array.push( material.vertexShader );

  		}

  		if ( material.defines !== undefined ) {

  			for ( var name in material.defines ) {

  				array.push( name );
  				array.push( material.defines[ name ] );

  			}

  		}

  		for ( var i = 0; i < parameterNames.length; i ++ ) {

  			array.push( parameters[ parameterNames[ i ] ] );

  		}

  		return array.join();

  	};

  	this.acquireProgram = function ( material, parameters, code ) {

  		var program;

  		// Check if code has been already compiled
  		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

  			var programInfo = programs[ p ];

  			if ( programInfo.code === code ) {

  				program = programInfo;
  				++ program.usedTimes;

  				break;

  			}

  		}

  		if ( program === undefined ) {

  			program = new WebGLProgram$1( renderer, code, material, parameters );
  			programs.push( program );

  		}

  		return program;

  	};

  	this.releaseProgram = function ( program ) {

  		if ( -- program.usedTimes === 0 ) {

  			// Remove from unordered set
  			var i = programs.indexOf( program );
  			programs[ i ] = programs[ programs.length - 1 ];
  			programs.pop();

  			// Free WebGL resources
  			program.destroy();

  		}

  	};

  	// Exposed for resource monitoring & error feedback via renderer.info:
  	this.programs = programs;

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLTextures$1( _gl, extensions, state, properties, capabilities, paramThreeToGL, infoMemory ) {

  	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

  	//

  	function clampToMaxSize( image, maxSize ) {

  		if ( image.width > maxSize || image.height > maxSize ) {

  			// Warning: Scaling through the canvas will only work with images that use
  			// premultiplied alpha.

  			var scale = maxSize / Math.max( image.width, image.height );

  			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  			canvas.width = Math.floor( image.width * scale );
  			canvas.height = Math.floor( image.height * scale );

  			var context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

  			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

  			return canvas;

  		}

  		return image;

  	}

  	function isPowerOfTwo( image ) {

  		return _Math$1.isPowerOfTwo( image.width ) && _Math$1.isPowerOfTwo( image.height );

  	}

  	function makePowerOfTwo( image ) {

  		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

  			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
  			canvas.width = _Math$1.nearestPowerOfTwo( image.width );
  			canvas.height = _Math$1.nearestPowerOfTwo( image.height );

  			var context = canvas.getContext( '2d' );
  			context.drawImage( image, 0, 0, canvas.width, canvas.height );

  			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

  			return canvas;

  		}

  		return image;

  	}

  	function textureNeedsPowerOfTwo( texture ) {

  		return ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) ||
  			( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 );

  	}

  	// Fallback filters for non-power-of-2 textures

  	function filterFallback( f ) {

  		if ( f === NearestFilter$1 || f === NearestMipMapNearestFilter$1 || f === NearestMipMapLinearFilter$1 ) {

  			return _gl.NEAREST;

  		}

  		return _gl.LINEAR;

  	}

  	//

  	function onTextureDispose( event ) {

  		var texture = event.target;

  		texture.removeEventListener( 'dispose', onTextureDispose );

  		deallocateTexture( texture );

  		infoMemory.textures --;


  	}

  	function onRenderTargetDispose( event ) {

  		var renderTarget = event.target;

  		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

  		deallocateRenderTarget( renderTarget );

  		infoMemory.textures --;

  	}

  	//

  	function deallocateTexture( texture ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.image && textureProperties.__image__webglTextureCube ) {

  			// cube texture

  			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

  		} else {

  			// 2D texture

  			if ( textureProperties.__webglInit === undefined ) return;

  			_gl.deleteTexture( textureProperties.__webglTexture );

  		}

  		// remove all webgl properties
  		properties.remove( texture );

  	}

  	function deallocateRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		if ( ! renderTarget ) return;

  		if ( textureProperties.__webglTexture !== undefined ) {

  			_gl.deleteTexture( textureProperties.__webglTexture );

  		}

  		if ( renderTarget.depthTexture ) {

  			renderTarget.depthTexture.dispose();

  		}

  		if ( renderTarget.isWebGLRenderTargetCube ) {

  			for ( var i = 0; i < 6; i ++ ) {

  				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
  				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

  			}

  		} else {

  			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
  			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

  		}

  		properties.remove( renderTarget.texture );
  		properties.remove( renderTarget );

  	}

  	//



  	function setTexture2D( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  			var image = texture.image;

  			if ( image === undefined ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

  			} else if ( image.complete === false ) {

  				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

  			} else {

  				uploadTexture( textureProperties, texture, slot );
  				return;

  			}

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  	}

  	function setTextureCube( texture, slot ) {

  		var textureProperties = properties.get( texture );

  		if ( texture.image.length === 6 ) {

  			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

  				if ( ! textureProperties.__image__webglTextureCube ) {

  					texture.addEventListener( 'dispose', onTextureDispose );

  					textureProperties.__image__webglTextureCube = _gl.createTexture();

  					infoMemory.textures ++;

  				}

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

  				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

  				var isCompressed = ( texture && texture.isCompressedTexture );
  				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

  				var cubeImage = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed && ! isDataTexture ) {

  						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

  					} else {

  						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

  					}

  				}

  				var image = cubeImage[ 0 ],
  				isPowerOfTwoImage = isPowerOfTwo( image ),
  				glFormat = paramThreeToGL( texture.format ),
  				glType = paramThreeToGL( texture.type );

  				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

  				for ( var i = 0; i < 6; i ++ ) {

  					if ( ! isCompressed ) {

  						if ( isDataTexture ) {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

  						} else {

  							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

  						}

  					} else {

  						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

  						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

  							mipmap = mipmaps[ j ];

  							if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

  								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  								} else {

  									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

  								}

  							} else {

  								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  							}

  						}

  					}

  				}

  				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

  					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

  				}

  				textureProperties.__version = texture.version;

  				if ( texture.onUpdate ) texture.onUpdate( texture );

  			} else {

  				state.activeTexture( _gl.TEXTURE0 + slot );
  				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

  			}

  		}

  	}

  	function setTextureCubeDynamic( texture, slot ) {

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

  	}

  	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

  		var extension;

  		if ( isPowerOfTwoImage ) {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

  		} else {

  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
  			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

  			if ( texture.wrapS !== ClampToEdgeWrapping$1 || texture.wrapT !== ClampToEdgeWrapping$1 ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

  			}

  			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
  			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

  			if ( texture.minFilter !== NearestFilter$1 && texture.minFilter !== LinearFilter$1 ) {

  				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

  			}

  		}

  		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension ) {

  			if ( texture.type === FloatType$1 && extensions.get( 'OES_texture_float_linear' ) === null ) return;
  			if ( texture.type === HalfFloatType$1 && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

  			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

  				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
  				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

  			}

  		}

  	}

  	function uploadTexture( textureProperties, texture, slot ) {

  		if ( textureProperties.__webglInit === undefined ) {

  			textureProperties.__webglInit = true;

  			texture.addEventListener( 'dispose', onTextureDispose );

  			textureProperties.__webglTexture = _gl.createTexture();

  			infoMemory.textures ++;

  		}

  		state.activeTexture( _gl.TEXTURE0 + slot );
  		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
  		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
  		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

  		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

  		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

  			image = makePowerOfTwo( image );

  		}

  		var isPowerOfTwoImage = isPowerOfTwo( image ),
  		glFormat = paramThreeToGL( texture.format ),
  		glType = paramThreeToGL( texture.type );

  		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

  		var mipmap, mipmaps = texture.mipmaps;

  		if ( texture.isDepthTexture ) {

  			// populate depth texture with dummy data

  			var internalFormat = _gl.DEPTH_COMPONENT;

  			if ( texture.type === FloatType$1 ) {

  				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
  				internalFormat = _gl.DEPTH_COMPONENT32F;

  			} else if ( _isWebGL2 ) {

  				// WebGL 2.0 requires signed internalformat for glTexImage2D
  				internalFormat = _gl.DEPTH_COMPONENT16;

  			}

  			if ( texture.format === DepthFormat$1 && internalFormat === _gl.DEPTH_COMPONENT ) {

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedShortType$1 && texture.type !== UnsignedIntType$1 ) {

  				        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

  					texture.type = UnsignedShortType$1;
  					glType = paramThreeToGL( texture.type );

  				}

  			}

  			// Depth stencil textures need the DEPTH_STENCIL internal format
  			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  			if ( texture.format === DepthStencilFormat$1 ) {

  				internalFormat = _gl.DEPTH_STENCIL;

  				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
  				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
  				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  				if ( texture.type !== UnsignedInt248Type$1 ) {

  				        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

  					texture.type = UnsignedInt248Type$1;
  					glType = paramThreeToGL( texture.type );

  				}

  			}

  			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

  		} else if ( texture.isDataTexture ) {

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  				texture.generateMipmaps = false;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

  			}

  		} else if ( texture.isCompressedTexture ) {

  			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  				mipmap = mipmaps[ i ];

  				if ( texture.format !== RGBAFormat$1 && texture.format !== RGBFormat$1 ) {

  					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

  						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

  					} else {

  						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

  					}

  				} else {

  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

  				}

  			}

  		} else {

  			// regular Texture (image, video, canvas)

  			// use manually created mipmaps if available
  			// if there are no manual mipmaps
  			// set 0 level mipmap and then use GL to generate other mipmap levels

  			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

  				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

  					mipmap = mipmaps[ i ];
  					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

  				}

  				texture.generateMipmaps = false;

  			} else {

  				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

  			}

  		}

  		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

  		textureProperties.__version = texture.version;

  		if ( texture.onUpdate ) texture.onUpdate( texture );

  	}

  	// Render targets

  	// Setup storage for target texture and bind it to correct framebuffer
  	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

  		var glFormat = paramThreeToGL( renderTarget.texture.format );
  		var glType = paramThreeToGL( renderTarget.texture.type );
  		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

  		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
  			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

  		} else {

  			// FIXME: We don't support !depth !stencil
  			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

  		}

  		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  	}

  	// Setup resources for a Depth Texture for a FBO (needs an extension)
  	function setupDepthTexture( framebuffer, renderTarget ) {

  		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
  		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  		if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

  			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

  		}

  		// upload an empty depth texture with framebuffer size
  		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
  				renderTarget.depthTexture.image.width !== renderTarget.width ||
  				renderTarget.depthTexture.image.height !== renderTarget.height ) {
  			renderTarget.depthTexture.image.width = renderTarget.width;
  			renderTarget.depthTexture.image.height = renderTarget.height;
  			renderTarget.depthTexture.needsUpdate = true;
  		}

  		setTexture2D( renderTarget.depthTexture, 0 );

  		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

  		if ( renderTarget.depthTexture.format === DepthFormat$1 ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else if ( renderTarget.depthTexture.format === DepthStencilFormat$1 ) {

  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

  		} else {

  			throw new Error('Unknown depthTexture format')

  		}

  	}

  	// Setup GL resources for a non-texture depth buffer
  	function setupDepthRenderbuffer( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

  		if ( renderTarget.depthTexture ) {

  			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

  			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

  		} else {

  			if ( isCube ) {

  				renderTargetProperties.__webglDepthbuffer = [];

  				for ( var i = 0; i < 6; i ++ ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
  					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
  					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

  				}

  			} else {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
  				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
  				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

  			}

  		}

  		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  	}

  	// Set up GL resources for the render target
  	function setupRenderTarget( renderTarget ) {

  		var renderTargetProperties = properties.get( renderTarget );
  		var textureProperties = properties.get( renderTarget.texture );

  		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

  		textureProperties.__webglTexture = _gl.createTexture();

  		infoMemory.textures ++;

  		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
  		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

  		// Setup framebuffer

  		if ( isCube ) {

  			renderTargetProperties.__webglFramebuffer = [];

  			for ( var i = 0; i < 6; i ++ ) {

  				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

  			}

  		} else {

  			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

  		}

  		// Setup color buffer

  		if ( isCube ) {

  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

  			for ( var i = 0; i < 6; i ++ ) {

  				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

  			}

  			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
  			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

  		} else {

  			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
  			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
  			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

  			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
  			state.bindTexture( _gl.TEXTURE_2D, null );

  		}

  		// Setup depth and stencil buffers

  		if ( renderTarget.depthBuffer ) {

  			setupDepthRenderbuffer( renderTarget );

  		}

  	}

  	function updateRenderTargetMipmap( renderTarget ) {

  		var texture = renderTarget.texture;

  		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
  				texture.minFilter !== NearestFilter$1 &&
  				texture.minFilter !== LinearFilter$1 ) {

  			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
  			var webglTexture = properties.get( texture ).__webglTexture;

  			state.bindTexture( target, webglTexture );
  			_gl.generateMipmap( target );
  			state.bindTexture( target, null );

  		}

  	}

  	this.setTexture2D = setTexture2D;
  	this.setTextureCube = setTextureCube;
  	this.setTextureCubeDynamic = setTextureCubeDynamic;
  	this.setupRenderTarget = setupRenderTarget;
  	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

  }

  /**
   * @author fordacious / fordacious.github.io
   */

  function WebGLProperties$1() {

  	var properties = {};

  	function get( object ) {

  		var uuid = object.uuid;
  		var map = properties[ uuid ];

  		if ( map === undefined ) {

  			map = {};
  			properties[ uuid ] = map;

  		}

  		return map;

  	}

  	function remove( object ) {

  		delete properties[ object.uuid ];

  	}

  	function clear() {

  		properties = {};

  	}

  	return {
  		get: get,
  		remove: remove,
  		clear: clear
  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLState$1( gl, extensions, paramThreeToGL ) {

  	function ColorBuffer() {

  		var locked = false;

  		var color = new Vector4$1();
  		var currentColorMask = null;
  		var currentColorClear = new Vector4$1();

  		return {

  			setMask: function ( colorMask ) {

  				if ( currentColorMask !== colorMask && ! locked ) {

  					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
  					currentColorMask = colorMask;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( r, g, b, a, premultipliedAlpha ) {

  				if ( premultipliedAlpha === true ) {

  					r *= a; g *= a; b *= a;

  				}

  				color.set( r, g, b, a );

  				if ( currentColorClear.equals( color ) === false ) {

  					gl.clearColor( r, g, b, a );
  					currentColorClear.copy( color );

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentColorMask = null;
  				currentColorClear.set( 0, 0, 0, 1 );

  			}

  		};

  	}

  	function DepthBuffer() {

  		var locked = false;

  		var currentDepthMask = null;
  		var currentDepthFunc = null;
  		var currentDepthClear = null;

  		return {

  			setTest: function ( depthTest ) {

  				if ( depthTest ) {

  					enable( gl.DEPTH_TEST );

  				} else {

  					disable( gl.DEPTH_TEST );

  				}

  			},

  			setMask: function ( depthMask ) {

  				if ( currentDepthMask !== depthMask && ! locked ) {

  					gl.depthMask( depthMask );
  					currentDepthMask = depthMask;

  				}

  			},

  			setFunc: function ( depthFunc ) {

  				if ( currentDepthFunc !== depthFunc ) {

  					if ( depthFunc ) {

  						switch ( depthFunc ) {

  							case NeverDepth$1:

  								gl.depthFunc( gl.NEVER );
  								break;

  							case AlwaysDepth$1:

  								gl.depthFunc( gl.ALWAYS );
  								break;

  							case LessDepth$1:

  								gl.depthFunc( gl.LESS );
  								break;

  							case LessEqualDepth$1:

  								gl.depthFunc( gl.LEQUAL );
  								break;

  							case EqualDepth$1:

  								gl.depthFunc( gl.EQUAL );
  								break;

  							case GreaterEqualDepth$1:

  								gl.depthFunc( gl.GEQUAL );
  								break;

  							case GreaterDepth$1:

  								gl.depthFunc( gl.GREATER );
  								break;

  							case NotEqualDepth$1:

  								gl.depthFunc( gl.NOTEQUAL );
  								break;

  							default:

  								gl.depthFunc( gl.LEQUAL );

  						}

  					} else {

  						gl.depthFunc( gl.LEQUAL );

  					}

  					currentDepthFunc = depthFunc;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( depth ) {

  				if ( currentDepthClear !== depth ) {

  					gl.clearDepth( depth );
  					currentDepthClear = depth;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentDepthMask = null;
  				currentDepthFunc = null;
  				currentDepthClear = null;

  			}

  		};

  	}

  	function StencilBuffer() {

  		var locked = false;

  		var currentStencilMask = null;
  		var currentStencilFunc = null;
  		var currentStencilRef = null;
  		var currentStencilFuncMask = null;
  		var currentStencilFail = null;
  		var currentStencilZFail = null;
  		var currentStencilZPass = null;
  		var currentStencilClear = null;

  		return {

  			setTest: function ( stencilTest ) {

  				if ( stencilTest ) {

  					enable( gl.STENCIL_TEST );

  				} else {

  					disable( gl.STENCIL_TEST );

  				}

  			},

  			setMask: function ( stencilMask ) {

  				if ( currentStencilMask !== stencilMask && ! locked ) {

  					gl.stencilMask( stencilMask );
  					currentStencilMask = stencilMask;

  				}

  			},

  			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

  				if ( currentStencilFunc !== stencilFunc ||
  				     currentStencilRef 	!== stencilRef 	||
  				     currentStencilFuncMask !== stencilMask ) {

  					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

  					currentStencilFunc = stencilFunc;
  					currentStencilRef = stencilRef;
  					currentStencilFuncMask = stencilMask;

  				}

  			},

  			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

  				if ( currentStencilFail	 !== stencilFail 	||
  				     currentStencilZFail !== stencilZFail ||
  				     currentStencilZPass !== stencilZPass ) {

  					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

  					currentStencilFail = stencilFail;
  					currentStencilZFail = stencilZFail;
  					currentStencilZPass = stencilZPass;

  				}

  			},

  			setLocked: function ( lock ) {

  				locked = lock;

  			},

  			setClear: function ( stencil ) {

  				if ( currentStencilClear !== stencil ) {

  					gl.clearStencil( stencil );
  					currentStencilClear = stencil;

  				}

  			},

  			reset: function () {

  				locked = false;

  				currentStencilMask = null;
  				currentStencilFunc = null;
  				currentStencilRef = null;
  				currentStencilFuncMask = null;
  				currentStencilFail = null;
  				currentStencilZFail = null;
  				currentStencilZPass = null;
  				currentStencilClear = null;

  			}

  		};

  	}

  	//

  	var colorBuffer = new ColorBuffer();
  	var depthBuffer = new DepthBuffer();
  	var stencilBuffer = new StencilBuffer();

  	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var newAttributes = new Uint8Array( maxVertexAttributes );
  	var enabledAttributes = new Uint8Array( maxVertexAttributes );
  	var attributeDivisors = new Uint8Array( maxVertexAttributes );

  	var capabilities = {};

  	var compressedTextureFormats = null;

  	var currentBlending = null;
  	var currentBlendEquation = null;
  	var currentBlendSrc = null;
  	var currentBlendDst = null;
  	var currentBlendEquationAlpha = null;
  	var currentBlendSrcAlpha = null;
  	var currentBlendDstAlpha = null;
  	var currentPremultipledAlpha = false;

  	var currentFlipSided = null;
  	var currentCullFace = null;

  	var currentLineWidth = null;

  	var currentPolygonOffsetFactor = null;
  	var currentPolygonOffsetUnits = null;

  	var currentScissorTest = null;

  	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

  	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
  	var lineWidthAvailable = parseFloat( version ) >= 1.0;

  	var currentTextureSlot = null;
  	var currentBoundTextures = {};

  	var currentScissor = new Vector4$1();
  	var currentViewport = new Vector4$1();

  	function createTexture( type, target, count ) {

  		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
  		var texture = gl.createTexture();

  		gl.bindTexture( type, texture );
  		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
  		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

  		for ( var i = 0; i < count; i ++ ) {

  			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

  		}

  		return texture;

  	}

  	var emptyTextures = {};
  	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
  	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

  	//

  	function init() {

  		colorBuffer.setClear( 0, 0, 0, 1 );
  		depthBuffer.setClear( 1 );
  		stencilBuffer.setClear( 0 );

  		enable( gl.DEPTH_TEST );
  		depthBuffer.setFunc( LessEqualDepth$1 );

  		setFlipSided( false );
  		setCullFace( CullFaceBack$1 );
  		enable( gl.CULL_FACE );

  		enable( gl.BLEND );
  		setBlending( NormalBlending$1 );

  	}

  	function initAttributes() {

  		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

  			newAttributes[ i ] = 0;

  		}

  	}

  	function enableAttribute( attribute ) {

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== 0 ) {

  			var extension = extensions.get( 'ANGLE_instanced_arrays' );

  			extension.vertexAttribDivisorANGLE( attribute, 0 );
  			attributeDivisors[ attribute ] = 0;

  		}

  	}

  	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

  		newAttributes[ attribute ] = 1;

  		if ( enabledAttributes[ attribute ] === 0 ) {

  			gl.enableVertexAttribArray( attribute );
  			enabledAttributes[ attribute ] = 1;

  		}

  		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

  			var extension = extensions.get( 'ANGLE_instanced_arrays' );

  			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
  			attributeDivisors[ attribute ] = meshPerAttribute;

  		}

  	}

  	function disableUnusedAttributes() {

  		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

  			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  	}

  	function enable( id ) {

  		if ( capabilities[ id ] !== true ) {

  			gl.enable( id );
  			capabilities[ id ] = true;

  		}

  	}

  	function disable( id ) {

  		if ( capabilities[ id ] !== false ) {

  			gl.disable( id );
  			capabilities[ id ] = false;

  		}

  	}

  	function getCompressedTextureFormats() {

  		if ( compressedTextureFormats === null ) {

  			compressedTextureFormats = [];

  			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
  			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

  				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

  				for ( var i = 0; i < formats.length; i ++ ) {

  					compressedTextureFormats.push( formats[ i ] );

  				}

  			}

  		}

  		return compressedTextureFormats;

  	}

  	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

  		if ( blending !== NoBlending$1 ) {

  			enable( gl.BLEND );

  		} else {

  			disable( gl.BLEND );

  		}

  		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

  			if ( blending === AdditiveBlending$1 ) {

  				if ( premultipliedAlpha ) {

  					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

  				} else {

  					gl.blendEquation( gl.FUNC_ADD );
  					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

  				}

  			} else if ( blending === SubtractiveBlending$1 ) {

  				if ( premultipliedAlpha ) {

  					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

  				} else {

  					gl.blendEquation( gl.FUNC_ADD );
  					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

  				}

  			} else if ( blending === MultiplyBlending$1 ) {

  				if ( premultipliedAlpha ) {

  					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

  				} else {

  					gl.blendEquation( gl.FUNC_ADD );
  					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

  				}

  			} else {

  				if ( premultipliedAlpha ) {

  					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

  				} else {

  					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
  					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

  				}

  			}

  			currentBlending = blending;
  			currentPremultipledAlpha = premultipliedAlpha;

  		}

  		if ( blending === CustomBlending$1 ) {

  			blendEquationAlpha = blendEquationAlpha || blendEquation;
  			blendSrcAlpha = blendSrcAlpha || blendSrc;
  			blendDstAlpha = blendDstAlpha || blendDst;

  			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

  				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

  				currentBlendEquation = blendEquation;
  				currentBlendEquationAlpha = blendEquationAlpha;

  			}

  			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

  				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

  				currentBlendSrc = blendSrc;
  				currentBlendDst = blendDst;
  				currentBlendSrcAlpha = blendSrcAlpha;
  				currentBlendDstAlpha = blendDstAlpha;

  			}

  		} else {

  			currentBlendEquation = null;
  			currentBlendSrc = null;
  			currentBlendDst = null;
  			currentBlendEquationAlpha = null;
  			currentBlendSrcAlpha = null;
  			currentBlendDstAlpha = null;

  		}

  	}

  	function setMaterial( material ) {

  		material.side === DoubleSide$1
  			? disable( gl.CULL_FACE )
  			: enable( gl.CULL_FACE );

  		setFlipSided( material.side === BackSide$1 );

  		material.transparent === true
  			? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
  			: setBlending( NoBlending$1 );

  		depthBuffer.setFunc( material.depthFunc );
  		depthBuffer.setTest( material.depthTest );
  		depthBuffer.setMask( material.depthWrite );
  		colorBuffer.setMask( material.colorWrite );

  		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  	}

  	//

  	function setFlipSided( flipSided ) {

  		if ( currentFlipSided !== flipSided ) {

  			if ( flipSided ) {

  				gl.frontFace( gl.CW );

  			} else {

  				gl.frontFace( gl.CCW );

  			}

  			currentFlipSided = flipSided;

  		}

  	}

  	function setCullFace( cullFace ) {

  		if ( cullFace !== CullFaceNone$1 ) {

  			enable( gl.CULL_FACE );

  			if ( cullFace !== currentCullFace ) {

  				if ( cullFace === CullFaceBack$1 ) {

  					gl.cullFace( gl.BACK );

  				} else if ( cullFace === CullFaceFront$1 ) {

  					gl.cullFace( gl.FRONT );

  				} else {

  					gl.cullFace( gl.FRONT_AND_BACK );

  				}

  			}

  		} else {

  			disable( gl.CULL_FACE );

  		}

  		currentCullFace = cullFace;

  	}

  	function setLineWidth( width ) {

  		if ( width !== currentLineWidth ) {

  			if ( lineWidthAvailable ) gl.lineWidth( width );

  			currentLineWidth = width;

  		}

  	}

  	function setPolygonOffset( polygonOffset, factor, units ) {

  		if ( polygonOffset ) {

  			enable( gl.POLYGON_OFFSET_FILL );

  			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

  				gl.polygonOffset( factor, units );

  				currentPolygonOffsetFactor = factor;
  				currentPolygonOffsetUnits = units;

  			}

  		} else {

  			disable( gl.POLYGON_OFFSET_FILL );

  		}

  	}

  	function getScissorTest() {

  		return currentScissorTest;

  	}

  	function setScissorTest( scissorTest ) {

  		currentScissorTest = scissorTest;

  		if ( scissorTest ) {

  			enable( gl.SCISSOR_TEST );

  		} else {

  			disable( gl.SCISSOR_TEST );

  		}

  	}

  	// texture

  	function activeTexture( webglSlot ) {

  		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

  		if ( currentTextureSlot !== webglSlot ) {

  			gl.activeTexture( webglSlot );
  			currentTextureSlot = webglSlot;

  		}

  	}

  	function bindTexture( webglType, webglTexture ) {

  		if ( currentTextureSlot === null ) {

  			activeTexture();

  		}

  		var boundTexture = currentBoundTextures[ currentTextureSlot ];

  		if ( boundTexture === undefined ) {

  			boundTexture = { type: undefined, texture: undefined };
  			currentBoundTextures[ currentTextureSlot ] = boundTexture;

  		}

  		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

  			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

  			boundTexture.type = webglType;
  			boundTexture.texture = webglTexture;

  		}

  	}

  	function compressedTexImage2D() {

  		try {

  			gl.compressedTexImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( error );

  		}

  	}

  	function texImage2D() {

  		try {

  			gl.texImage2D.apply( gl, arguments );

  		} catch ( error ) {

  			console.error( error );

  		}

  	}

  	//

  	function scissor( scissor ) {

  		if ( currentScissor.equals( scissor ) === false ) {

  			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
  			currentScissor.copy( scissor );

  		}

  	}

  	function viewport( viewport ) {

  		if ( currentViewport.equals( viewport ) === false ) {

  			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
  			currentViewport.copy( viewport );

  		}

  	}

  	//

  	function reset() {

  		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

  			if ( enabledAttributes[ i ] === 1 ) {

  				gl.disableVertexAttribArray( i );
  				enabledAttributes[ i ] = 0;

  			}

  		}

  		capabilities = {};

  		compressedTextureFormats = null;

  		currentTextureSlot = null;
  		currentBoundTextures = {};

  		currentBlending = null;

  		currentFlipSided = null;
  		currentCullFace = null;

  		colorBuffer.reset();
  		depthBuffer.reset();
  		stencilBuffer.reset();

  	}

  	return {

  		buffers: {
  			color: colorBuffer,
  			depth: depthBuffer,
  			stencil: stencilBuffer
  		},

  		init: init,
  		initAttributes: initAttributes,
  		enableAttribute: enableAttribute,
  		enableAttributeAndDivisor: enableAttributeAndDivisor,
  		disableUnusedAttributes: disableUnusedAttributes,
  		enable: enable,
  		disable: disable,
  		getCompressedTextureFormats: getCompressedTextureFormats,

  		setBlending: setBlending,
  		setMaterial: setMaterial,

  		setFlipSided: setFlipSided,
  		setCullFace: setCullFace,

  		setLineWidth: setLineWidth,
  		setPolygonOffset: setPolygonOffset,

  		getScissorTest: getScissorTest,
  		setScissorTest: setScissorTest,

  		activeTexture: activeTexture,
  		bindTexture: bindTexture,
  		compressedTexImage2D: compressedTexImage2D,
  		texImage2D: texImage2D,

  		scissor: scissor,
  		viewport: viewport,

  		reset: reset

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLCapabilities$1( gl, extensions, parameters ) {

  	var maxAnisotropy;

  	function getMaxAnisotropy() {

  		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

  		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

  		if ( extension !== null ) {

  			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

  		} else {

  			maxAnisotropy = 0;

  		}

  		return maxAnisotropy;

  	}

  	function getMaxPrecision( precision ) {

  		if ( precision === 'highp' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

  				return 'highp';

  			}

  			precision = 'mediump';

  		}

  		if ( precision === 'mediump' ) {

  			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
  			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

  				return 'mediump';

  			}

  		}

  		return 'lowp';

  	}

  	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  	var maxPrecision = getMaxPrecision( precision );

  	if ( maxPrecision !== precision ) {

  		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
  		precision = maxPrecision;

  	}

  	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

  	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  	var vertexTextures = maxVertexTextures > 0;
  	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
  	var floatVertexTextures = vertexTextures && floatFragmentTextures;

  	return {

  		getMaxAnisotropy: getMaxAnisotropy,
  		getMaxPrecision: getMaxPrecision,

  		precision: precision,
  		logarithmicDepthBuffer: logarithmicDepthBuffer,

  		maxTextures: maxTextures,
  		maxVertexTextures: maxVertexTextures,
  		maxTextureSize: maxTextureSize,
  		maxCubemapSize: maxCubemapSize,

  		maxAttributes: maxAttributes,
  		maxVertexUniforms: maxVertexUniforms,
  		maxVaryings: maxVaryings,
  		maxFragmentUniforms: maxFragmentUniforms,

  		vertexTextures: vertexTextures,
  		floatFragmentTextures: floatFragmentTextures,
  		floatVertexTextures: floatVertexTextures

  	};

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function WebGLExtensions$1( gl ) {

  	var extensions = {};

  	return {

  		get: function ( name ) {

  			if ( extensions[ name ] !== undefined ) {

  				return extensions[ name ];

  			}

  			var extension;

  			switch ( name ) {

  				case 'WEBGL_depth_texture':
  					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
  					break;

  				case 'EXT_texture_filter_anisotropic':
  					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
  					break;

  				case 'WEBGL_compressed_texture_s3tc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
  					break;

  				case 'WEBGL_compressed_texture_pvrtc':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
  					break;

  				case 'WEBGL_compressed_texture_etc1':
  					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
  					break;

  				default:
  					extension = gl.getExtension( name );

  			}

  			if ( extension === null ) {

  				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

  			}

  			extensions[ name ] = extension;

  			return extension;

  		}

  	};

  }

  /**
   * @author tschw
   */

  function WebGLClipping$1() {

  	var scope = this,

  		globalState = null,
  		numGlobalPlanes = 0,
  		localClippingEnabled = false,
  		renderingShadows = false,

  		plane = new Plane$2(),
  		viewNormalMatrix = new Matrix3$1(),

  		uniform = { value: null, needsUpdate: false };

  	this.uniform = uniform;
  	this.numPlanes = 0;
  	this.numIntersection = 0;

  	this.init = function( planes, enableLocalClipping, camera ) {

  		var enabled =
  			planes.length !== 0 ||
  			enableLocalClipping ||
  			// enable state of previous frame - the clipping code has to
  			// run another frame in order to reset the state:
  			numGlobalPlanes !== 0 ||
  			localClippingEnabled;

  		localClippingEnabled = enableLocalClipping;

  		globalState = projectPlanes( planes, camera, 0 );
  		numGlobalPlanes = planes.length;

  		return enabled;

  	};

  	this.beginShadows = function() {

  		renderingShadows = true;
  		projectPlanes( null );

  	};

  	this.endShadows = function() {

  		renderingShadows = false;
  		resetGlobalState();

  	};

  	this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

  		if ( ! localClippingEnabled ||
  				planes === null || planes.length === 0 ||
  				renderingShadows && ! clipShadows ) {
  			// there's no local clipping

  			if ( renderingShadows ) {
  				// there's no global clipping

  				projectPlanes( null );

  			} else {

  				resetGlobalState();
  			}

  		} else {

  			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
  				lGlobal = nGlobal * 4,

  				dstArray = cache.clippingState || null;

  			uniform.value = dstArray; // ensure unique state

  			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

  			for ( var i = 0; i !== lGlobal; ++ i ) {

  				dstArray[ i ] = globalState[ i ];

  			}

  			cache.clippingState = dstArray;
  			this.numIntersection = clipIntersection ? this.numPlanes : 0;
  			this.numPlanes += nGlobal;

  		}


  	};

  	function resetGlobalState() {

  		if ( uniform.value !== globalState ) {

  			uniform.value = globalState;
  			uniform.needsUpdate = numGlobalPlanes > 0;

  		}

  		scope.numPlanes = numGlobalPlanes;
  		scope.numIntersection = 0;

  	}

  	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

  		var nPlanes = planes !== null ? planes.length : 0,
  			dstArray = null;

  		if ( nPlanes !== 0 ) {

  			dstArray = uniform.value;

  			if ( skipTransform !== true || dstArray === null ) {

  				var flatSize = dstOffset + nPlanes * 4,
  					viewMatrix = camera.matrixWorldInverse;

  				viewNormalMatrix.getNormalMatrix( viewMatrix );

  				if ( dstArray === null || dstArray.length < flatSize ) {

  					dstArray = new Float32Array( flatSize );

  				}

  				for ( var i = 0, i4 = dstOffset;
  									i !== nPlanes; ++ i, i4 += 4 ) {

  					plane.copy( planes[ i ] ).
  							applyMatrix4( viewMatrix, viewNormalMatrix );

  					plane.normal.toArray( dstArray, i4 );
  					dstArray[ i4 + 3 ] = plane.constant;

  				}

  			}

  			uniform.value = dstArray;
  			uniform.needsUpdate = true;

  		}

  		scope.numPlanes = nPlanes;
  		
  		return dstArray;

  	}

  }

  // import { Sphere } from '../math/Sphere';
  /**
   * @author supereggbert / http://www.paulbrunt.co.uk/
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   * @author szimek / https://github.com/szimek/
   * @author tschw
   */

  function WebGLRenderer$1( parameters ) {

  	console.log( 'THREE.WebGLRenderer', REVISION$1 );

  	parameters = parameters || {};

  	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
  		_context = parameters.context !== undefined ? parameters.context : null,

  		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  		_depth = parameters.depth !== undefined ? parameters.depth : true,
  		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

  	var lights = [];

  	var currentRenderList = null;

  	var morphInfluences = new Float32Array( 8 );

  	var sprites = [];
  	var lensFlares = [];

  	// public properties

  	this.domElement = _canvas;
  	this.context = null;

  	// clearing

  	this.autoClear = true;
  	this.autoClearColor = true;
  	this.autoClearDepth = true;
  	this.autoClearStencil = true;

  	// scene graph

  	this.sortObjects = true;

  	// user-defined clipping

  	this.clippingPlanes = [];
  	this.localClippingEnabled = false;

  	// physically based shading

  	this.gammaFactor = 2.0;	// for backwards compatibility
  	this.gammaInput = false;
  	this.gammaOutput = false;

  	// physical lights

  	this.physicallyCorrectLights = false;

  	// tone mapping

  	this.toneMapping = LinearToneMapping$1;
  	this.toneMappingExposure = 1.0;
  	this.toneMappingWhitePoint = 1.0;

  	// morphs

  	this.maxMorphTargets = 8;
  	this.maxMorphNormals = 4;

  	// internal properties

  	var _this = this,

  		// internal state cache

  		_currentProgram = null,
  		_currentRenderTarget = null,
  		_currentFramebuffer = null,
  		_currentMaterialId = - 1,
  		_currentGeometryProgram = '',
  		_currentCamera = null,

  		_currentScissor = new Vector4$1(),
  		_currentScissorTest = null,

  		_currentViewport = new Vector4$1(),

  		//

  		_usedTextureUnits = 0,

  		//

  		_clearColor = new Color$1( 0x000000 ),
  		_clearAlpha = 0,

  		_width = _canvas.width,
  		_height = _canvas.height,

  		_pixelRatio = 1,

  		_scissor = new Vector4$1( 0, 0, _width, _height ),
  		_scissorTest = false,

  		_viewport = new Vector4$1( 0, 0, _width, _height ),

  		// frustum

  		_frustum = new Frustum$1(),

  		// clipping

  		_clipping = new WebGLClipping$1(),
  		_clippingEnabled = false,
  		_localClippingEnabled = false,

  		// camera matrices cache

  		_projScreenMatrix = new Matrix4$1(),

  		_vector3 = new Vector3$1(),
  		_matrix4 = new Matrix4$1(),
  		_matrix42 = new Matrix4$1(),

  		// light arrays cache

  		_lights = {

  			hash: '',

  			ambient: [ 0, 0, 0 ],
  			directional: [],
  			directionalShadowMap: [],
  			directionalShadowMatrix: [],
  			spot: [],
  			spotShadowMap: [],
  			spotShadowMatrix: [],
  			rectArea: [],
  			point: [],
  			pointShadowMap: [],
  			pointShadowMatrix: [],
  			hemi: [],

  			shadows: []

  		},

  		// info

  		_infoMemory = {
  			geometries: 0,
  			textures: 0
  		},

  		_infoRender = {

  			frame: 0,
  			calls: 0,
  			vertices: 0,
  			faces: 0,
  			points: 0

  		};

  	this.info = {

  		render: _infoRender,
  		memory: _infoMemory,
  		programs: null

  	};


  	// initialize

  	var _gl;

  	try {

  		var contextAttributes = {
  			alpha: _alpha,
  			depth: _depth,
  			stencil: _stencil,
  			antialias: _antialias,
  			premultipliedAlpha: _premultipliedAlpha,
  			preserveDrawingBuffer: _preserveDrawingBuffer
  		};

  		_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

  		if ( _gl === null ) {

  			if ( _canvas.getContext( 'webgl' ) !== null ) {

  				throw 'Error creating WebGL context with your selected attributes.';

  			} else {

  				throw 'Error creating WebGL context.';

  			}

  		}

  		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

  		if ( _gl.getShaderPrecisionFormat === undefined ) {

  			_gl.getShaderPrecisionFormat = function () {

  				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

  			};

  		}

  		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

  	} catch ( error ) {

  		console.error( 'THREE.WebGLRenderer: ' + error );

  	}

  	var extensions = new WebGLExtensions$1( _gl );

  	extensions.get( 'WEBGL_depth_texture' );
  	extensions.get( 'OES_texture_float' );
  	extensions.get( 'OES_texture_float_linear' );
  	extensions.get( 'OES_texture_half_float' );
  	extensions.get( 'OES_texture_half_float_linear' );
  	extensions.get( 'OES_standard_derivatives' );
  	extensions.get( 'ANGLE_instanced_arrays' );

  	if ( extensions.get( 'OES_element_index_uint' ) ) {

  		BufferGeometry$1.MaxIndex = 4294967296;

  	}

  	var capabilities = new WebGLCapabilities$1( _gl, extensions, parameters );

  	var state = new WebGLState$1( _gl, extensions, paramThreeToGL );

  	var properties = new WebGLProperties$1();
  	var textures = new WebGLTextures$1( _gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory );
  	var attributes = new WebGLAttributes$1( _gl );
  	var geometries = new WebGLGeometries$1( _gl, attributes, _infoMemory );
  	var objects = new WebGLObjects$1( _gl, geometries, _infoRender );
  	var programCache = new WebGLPrograms$1( this, capabilities );
  	var lightCache = new WebGLLights$1();
  	var renderLists = new WebGLRenderLists$1();

  	this.info.programs = programCache.programs;

  	var bufferRenderer = new WebGLBufferRenderer$1( _gl, extensions, _infoRender );
  	var indexedBufferRenderer = new WebGLIndexedBufferRenderer$1( _gl, extensions, _infoRender );

  	//

  	var backgroundPlaneCamera, backgroundPlaneMesh;
  	var backgroundBoxCamera, backgroundBoxMesh;

  	//

  	function getTargetPixelRatio() {

  		return _currentRenderTarget === null ? _pixelRatio : 1;

  	}

  	function setDefaultGLState() {

  		state.init();

  		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
  		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

  		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

  	}

  	function resetGLState() {

  		_currentProgram = null;
  		_currentCamera = null;

  		_currentGeometryProgram = '';
  		_currentMaterialId = - 1;

  		state.reset();

  	}

  	setDefaultGLState();

  	this.context = _gl;
  	this.capabilities = capabilities;
  	this.extensions = extensions;
  	this.properties = properties;
  	this.state = state;

  	// shadow map

  	var shadowMap = new WebGLShadowMap$1( this, _lights, objects, capabilities );

  	this.shadowMap = shadowMap;


  	// Plugins

  	var spritePlugin = new SpritePlugin( this, sprites );
  	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

  	// API

  	this.getContext = function () {

  		return _gl;

  	};

  	this.getContextAttributes = function () {

  		return _gl.getContextAttributes();

  	};

  	this.forceContextLoss = function () {

  		var extension = extensions.get( 'WEBGL_lose_context' );
  		if ( extension ) extension.loseContext();

  	};

  	this.getMaxAnisotropy = function () {

  		return capabilities.getMaxAnisotropy();

  	};

  	this.getPrecision = function () {

  		return capabilities.precision;

  	};

  	this.getPixelRatio = function () {

  		return _pixelRatio;

  	};

  	this.setPixelRatio = function ( value ) {

  		if ( value === undefined ) return;

  		_pixelRatio = value;

  		this.setSize( _viewport.z, _viewport.w, false );

  	};

  	this.getSize = function () {

  		return {
  			width: _width,
  			height: _height
  		};

  	};

  	this.setSize = function ( width, height, updateStyle ) {

  		_width = width;
  		_height = height;

  		_canvas.width = width * _pixelRatio;
  		_canvas.height = height * _pixelRatio;

  		if ( updateStyle !== false ) {

  			_canvas.style.width = width + 'px';
  			_canvas.style.height = height + 'px';

  		}

  		this.setViewport( 0, 0, width, height );

  	};

  	this.setViewport = function ( x, y, width, height ) {

  		state.viewport( _viewport.set( x, y, width, height ) );

  	};

  	this.setScissor = function ( x, y, width, height ) {

  		state.scissor( _scissor.set( x, y, width, height ) );

  	};

  	this.setScissorTest = function ( boolean ) {

  		state.setScissorTest( _scissorTest = boolean );

  	};

  	// Clearing

  	this.getClearColor = function () {

  		return _clearColor;

  	};

  	this.setClearColor = function ( color, alpha ) {

  		_clearColor.set( color );

  		_clearAlpha = alpha !== undefined ? alpha : 1;

  		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

  	};

  	this.getClearAlpha = function () {

  		return _clearAlpha;

  	};

  	this.setClearAlpha = function ( alpha ) {

  		_clearAlpha = alpha;

  		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

  	};

  	this.clear = function ( color, depth, stencil ) {

  		var bits = 0;

  		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
  		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
  		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

  		_gl.clear( bits );

  	};

  	this.clearColor = function () {

  		this.clear( true, false, false );

  	};

  	this.clearDepth = function () {

  		this.clear( false, true, false );

  	};

  	this.clearStencil = function () {

  		this.clear( false, false, true );

  	};

  	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

  		this.setRenderTarget( renderTarget );
  		this.clear( color, depth, stencil );

  	};

  	// Reset

  	this.resetGLState = resetGLState;

  	this.dispose = function () {

  		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

  		renderLists.dispose();

  	};

  	// Events

  	function onContextLost( event ) {

  		event.preventDefault();

  		resetGLState();
  		setDefaultGLState();

  		properties.clear();
  		objects.clear();

  	}

  	function onMaterialDispose( event ) {

  		var material = event.target;

  		material.removeEventListener( 'dispose', onMaterialDispose );

  		deallocateMaterial( material );

  	}

  	// Buffer deallocation

  	function deallocateMaterial( material ) {

  		releaseMaterialProgramReference( material );

  		properties.remove( material );

  	}


  	function releaseMaterialProgramReference( material ) {

  		var programInfo = properties.get( material ).program;

  		material.program = undefined;

  		if ( programInfo !== undefined ) {

  			programCache.releaseProgram( programInfo );

  		}

  	}

  	// Buffer rendering

  	function renderObjectImmediate( object, program, material ) {

  		object.render( function ( object ) {

  			_this.renderBufferImmediate( object, program, material );

  		} );

  	}

  	this.renderBufferImmediate = function ( object, program, material ) {

  		state.initAttributes();

  		var buffers = properties.get( object );

  		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
  		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
  		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
  		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

  		var programAttributes = program.getAttributes();

  		if ( object.hasPositions ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.position );
  			_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasNormals ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

  			if ( ! material.isMeshPhongMaterial &&
  				! material.isMeshStandardMaterial &&
  				! material.isMeshNormalMaterial &&
  				material.shading === FlatShading$1 ) {

  				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

  					var array = object.normalArray;

  					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
  					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
  					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

  					array[ i + 0 ] = nx;
  					array[ i + 1 ] = ny;
  					array[ i + 2 ] = nz;

  					array[ i + 3 ] = nx;
  					array[ i + 4 ] = ny;
  					array[ i + 5 ] = nz;

  					array[ i + 6 ] = nx;
  					array[ i + 7 ] = ny;
  					array[ i + 8 ] = nz;

  				}

  			}

  			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.normal );

  			_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasUvs && material.map ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.uv );

  			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

  		}

  		if ( object.hasColors && material.vertexColors !== NoColors$1 ) {

  			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
  			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

  			state.enableAttribute( programAttributes.color );

  			_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

  		}

  		state.disableUnusedAttributes();

  		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

  		object.count = 0;

  	};

  	function absNumericalSort( a, b ) {

  		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

  	}

  	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

  		state.setMaterial( material );

  		var program = setProgram( camera, fog, material, object );
  		var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

  		var updateBuffers = false;

  		if ( geometryProgram !== _currentGeometryProgram ) {

  			_currentGeometryProgram = geometryProgram;
  			updateBuffers = true;

  		}

  		// morph targets

  		var morphTargetInfluences = object.morphTargetInfluences;

  		if ( morphTargetInfluences !== undefined ) {

  			// TODO Remove allocations

  			var activeInfluences = [];

  			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

  				var influence = morphTargetInfluences[ i ];
  				activeInfluences.push( [ influence, i ] );

  			}

  			activeInfluences.sort( absNumericalSort );

  			if ( activeInfluences.length > 8 ) {

  				activeInfluences.length = 8;

  			}

  			var morphAttributes = geometry.morphAttributes;

  			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

  				var influence = activeInfluences[ i ];
  				morphInfluences[ i ] = influence[ 0 ];

  				if ( influence[ 0 ] !== 0 ) {

  					var index = influence[ 1 ];

  					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
  					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

  				} else {

  					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
  					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

  				}

  			}

  			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

  				morphInfluences[ i ] = 0.0;

  			}

  			program.getUniforms().setValue( _gl, 'morphTargetInfluences', morphInfluences );

  			updateBuffers = true;

  		}

  		//

  		var index = geometry.index;
  		var position = geometry.attributes.position;
  		var rangeFactor = 1;

  		if ( material.wireframe === true ) {

  			index = geometries.getWireframeAttribute( geometry );
  			rangeFactor = 2;

  		}

  		var renderer = bufferRenderer;

  		if ( index !== null ) {

  			renderer = indexedBufferRenderer;
  			renderer.setIndex( index );

  		}

  		if ( updateBuffers ) {

  			setupVertexAttributes( material, program, geometry );

  			if ( index !== null ) {

  				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

  			}

  		}

  		//

  		var dataCount = 0;

  		if ( index !== null ) {

  			dataCount = index.count;

  		} else if ( position !== undefined ) {

  			dataCount = position.count;

  		}

  		var rangeStart = geometry.drawRange.start * rangeFactor;
  		var rangeCount = geometry.drawRange.count * rangeFactor;

  		var groupStart = group !== null ? group.start * rangeFactor : 0;
  		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

  		var drawStart = Math.max( rangeStart, groupStart );
  		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

  		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

  		if ( drawCount === 0 ) return;

  		//

  		if ( object.isMesh ) {

  			if ( material.wireframe === true ) {

  				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
  				renderer.setMode( _gl.LINES );

  			} else {

  				switch ( object.drawMode ) {

  					case TrianglesDrawMode$1:
  						renderer.setMode( _gl.TRIANGLES );
  						break;

  					case TriangleStripDrawMode$1:
  						renderer.setMode( _gl.TRIANGLE_STRIP );
  						break;

  					case TriangleFanDrawMode$1:
  						renderer.setMode( _gl.TRIANGLE_FAN );
  						break;

  				}

  			}


  		} else if ( object.isLine ) {

  			var lineWidth = material.linewidth;

  			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

  			state.setLineWidth( lineWidth * getTargetPixelRatio() );

  			if ( object.isLineSegments ) {

  				renderer.setMode( _gl.LINES );

  			} else if ( object.isLineLoop ) {

  				renderer.setMode( _gl.LINE_LOOP );

  			} else {

  				renderer.setMode( _gl.LINE_STRIP );

  			}

  		} else if ( object.isPoints ) {

  			renderer.setMode( _gl.POINTS );

  		}

  		if ( geometry && geometry.isInstancedBufferGeometry ) {

  			if ( geometry.maxInstancedCount > 0 ) {

  				renderer.renderInstances( geometry, drawStart, drawCount );

  			}

  		} else {

  			renderer.render( drawStart, drawCount );

  		}

  	};

  	function setupVertexAttributes( material, program, geometry, startIndex ) {

  		if ( geometry && geometry.isInstancedBufferGeometry ) {

  			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

  				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
  				return;

  			}

  		}

  		if ( startIndex === undefined ) startIndex = 0;

  		state.initAttributes();

  		var geometryAttributes = geometry.attributes;

  		var programAttributes = program.getAttributes();

  		var materialDefaultAttributeValues = material.defaultAttributeValues;

  		for ( var name in programAttributes ) {

  			var programAttribute = programAttributes[ name ];

  			if ( programAttribute >= 0 ) {

  				var geometryAttribute = geometryAttributes[ name ];

  				if ( geometryAttribute !== undefined ) {

  					var normalized = geometryAttribute.normalized;
  					var size = geometryAttribute.itemSize;

  					var attributeProperties = attributes.get( geometryAttribute );

  					var buffer = attributeProperties.buffer;
  					var type = attributeProperties.type;
  					var bytesPerElement = attributeProperties.bytesPerElement;

  					if ( geometryAttribute.isInterleavedBufferAttribute ) {

  						var data = geometryAttribute.data;
  						var stride = data.stride;
  						var offset = geometryAttribute.offset;

  						if ( data && data.isInstancedInterleavedBuffer ) {

  							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

  					} else {

  						if ( geometryAttribute.isInstancedBufferAttribute ) {

  							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

  							if ( geometry.maxInstancedCount === undefined ) {

  								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

  							}

  						} else {

  							state.enableAttribute( programAttribute );

  						}

  						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
  						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

  					}

  				} else if ( materialDefaultAttributeValues !== undefined ) {

  					var value = materialDefaultAttributeValues[ name ];

  					if ( value !== undefined ) {

  						switch ( value.length ) {

  							case 2:
  								_gl.vertexAttrib2fv( programAttribute, value );
  								break;

  							case 3:
  								_gl.vertexAttrib3fv( programAttribute, value );
  								break;

  							case 4:
  								_gl.vertexAttrib4fv( programAttribute, value );
  								break;

  							default:
  								_gl.vertexAttrib1fv( programAttribute, value );

  						}

  					}

  				}

  			}

  		}

  		state.disableUnusedAttributes();

  	}

  	// Compile

  	this.compile = function ( scene, camera ) {

  		lights = [];

  		scene.traverse( function ( object ) {

  			if ( object.isLight ) {

  				lights.push( object );

  			}

  		} );

  		setupLights( lights, camera );

  		scene.traverse( function ( object ) {

  			if ( object.material ) {

  				if ( Array.isArray( object.material ) ) {

  					for ( var i = 0; i < object.material.length; i ++ ) {

  						initMaterial( object.material[ i ], scene.fog, object );

  					}

  				} else {

  					initMaterial( object.material, scene.fog, object );

  				}

  			}

  		} );

  	};

  	// Rendering

  	this.render = function ( scene, camera, renderTarget, forceClear ) {

  		if ( camera !== undefined && camera.isCamera !== true ) {

  			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
  			return;

  		}

  		// reset caching for this frame

  		_currentGeometryProgram = '';
  		_currentMaterialId = - 1;
  		_currentCamera = null;

  		// update scene graph

  		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

  		// update camera matrices and frustum

  		camera.onBeforeRender( _this );

  		if ( camera.parent === null ) camera.updateMatrixWorld();

  		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

  		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
  		_frustum.setFromMatrix( _projScreenMatrix );

  		lights.length = 0;
  		sprites.length = 0;
  		lensFlares.length = 0;

  		_localClippingEnabled = this.localClippingEnabled;
  		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

  		currentRenderList = renderLists.get( scene, camera );
  		currentRenderList.init();

  		projectObject( scene, camera, _this.sortObjects );

  		currentRenderList.finish();

  		if ( _this.sortObjects === true ) {

  			currentRenderList.sort();

  		}

  		//

  		if ( _clippingEnabled ) _clipping.beginShadows();

  		setupShadows( lights );

  		shadowMap.render( scene, camera );

  		setupLights( lights, camera );

  		if ( _clippingEnabled ) _clipping.endShadows();

  		//

  		_infoRender.frame ++;
  		_infoRender.calls = 0;
  		_infoRender.vertices = 0;
  		_infoRender.faces = 0;
  		_infoRender.points = 0;

  		if ( renderTarget === undefined ) {

  			renderTarget = null;

  		}

  		this.setRenderTarget( renderTarget );

  		//

  		var background = scene.background;

  		if ( background === null ) {

  			state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

  		} else if ( background && background.isColor ) {

  			state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
  			forceClear = true;

  		}

  		if ( this.autoClear || forceClear ) {

  			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

  		}

  		if ( background && background.isCubeTexture ) {

  			if ( backgroundBoxCamera === undefined ) {

  				backgroundBoxCamera = new PerspectiveCamera$2();

  				backgroundBoxMesh = new Mesh$1(
  					new BoxBufferGeometry$1( 5, 5, 5 ),
  					new ShaderMaterial$1( {
  						uniforms: ShaderLib$1.cube.uniforms,
  						vertexShader: ShaderLib$1.cube.vertexShader,
  						fragmentShader: ShaderLib$1.cube.fragmentShader,
  						side: BackSide$1,
  						depthTest: false,
  						depthWrite: false,
  						fog: false
  					} )
  				);

  			}

  			backgroundBoxCamera.projectionMatrix.copy( camera.projectionMatrix );

  			backgroundBoxCamera.matrixWorld.extractRotation( camera.matrixWorld );
  			backgroundBoxCamera.matrixWorldInverse.getInverse( backgroundBoxCamera.matrixWorld );


  			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
  			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

  			objects.update( backgroundBoxMesh );

  			_this.renderBufferDirect( backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

  		} else if ( background && background.isTexture ) {

  			if ( backgroundPlaneCamera === undefined ) {

  				backgroundPlaneCamera = new OrthographicCamera$2( - 1, 1, 1, - 1, 0, 1 );

  				backgroundPlaneMesh = new Mesh$1(
  					new PlaneBufferGeometry$1( 2, 2 ),
  					new MeshBasicMaterial$1( { depthTest: false, depthWrite: false, fog: false } )
  				);

  			}

  			backgroundPlaneMesh.material.map = background;

  			objects.update( backgroundPlaneMesh );

  			_this.renderBufferDirect( backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

  		}

  		//

  		var opaqueObjects = currentRenderList.opaque;
  		var transparentObjects = currentRenderList.transparent;

  		if ( scene.overrideMaterial ) {

  			var overrideMaterial = scene.overrideMaterial;

  			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
  			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

  		} else {

  			// opaque pass (front-to-back order)

  			if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

  			// transparent pass (back-to-front order)

  			if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

  		}

  		// custom render plugins (post pass)

  		spritePlugin.render( scene, camera );
  		lensFlarePlugin.render( scene, camera, _currentViewport );

  		// Generate mipmap if we're using any kind of mipmap filtering

  		if ( renderTarget ) {

  			textures.updateRenderTargetMipmap( renderTarget );

  		}

  		// Ensure depth buffer writing is enabled so it can be cleared on next render

  		state.buffers.depth.setTest( true );
  		state.buffers.depth.setMask( true );
  		state.buffers.color.setMask( true );

  		if ( camera.isArrayCamera && camera.enabled ) {

  			_this.setScissorTest( false );

  		}

  		camera.onAfterRender( _this );

  		// _gl.finish();

  	};

  	/*
  	// TODO Duplicated code (Frustum)

  	var _sphere = new Sphere();

  	function isObjectViewable( object ) {

  		var geometry = object.geometry;

  		if ( geometry.boundingSphere === null )
  			geometry.computeBoundingSphere();

  		_sphere.copy( geometry.boundingSphere ).
  		applyMatrix4( object.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSpriteViewable( sprite ) {

  		_sphere.center.set( 0, 0, 0 );
  		_sphere.radius = 0.7071067811865476;
  		_sphere.applyMatrix4( sprite.matrixWorld );

  		return isSphereViewable( _sphere );

  	}

  	function isSphereViewable( sphere ) {

  		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

  		var numPlanes = _clipping.numPlanes;

  		if ( numPlanes === 0 ) return true;

  		var planes = _this.clippingPlanes,

  			center = sphere.center,
  			negRad = - sphere.radius,
  			i = 0;

  		do {

  			// out when deeper than radius in the negative halfspace
  			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

  		} while ( ++ i !== numPlanes );

  		return true;

  	}
  	*/

  	function projectObject( object, camera, sortObjects ) {

  		if ( ! object.visible ) return;

  		var visible = object.layers.test( camera.layers );

  		if ( visible ) {

  			if ( object.isLight ) {

  				lights.push( object );

  			} else if ( object.isSprite ) {

  				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

  					sprites.push( object );

  				}

  			} else if ( object.isLensFlare ) {

  				lensFlares.push( object );

  			} else if ( object.isImmediateRenderObject ) {

  				if ( sortObjects ) {

  					_vector3.setFromMatrixPosition( object.matrixWorld )
  						.applyMatrix4( _projScreenMatrix );

  				}

  				currentRenderList.push( object, null, object.material, _vector3.z, null );

  			} else if ( object.isMesh || object.isLine || object.isPoints ) {

  				if ( object.isSkinnedMesh ) {

  					object.skeleton.update();

  				}

  				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

  					if ( sortObjects ) {

  						_vector3.setFromMatrixPosition( object.matrixWorld )
  							.applyMatrix4( _projScreenMatrix );

  					}

  					var geometry = objects.update( object );
  					var material = object.material;

  					if ( Array.isArray( material ) ) {

  						var groups = geometry.groups;

  						for ( var i = 0, l = groups.length; i < l; i ++ ) {

  							var group = groups[ i ];
  							var groupMaterial = material[ group.materialIndex ];

  							if ( groupMaterial && groupMaterial.visible ) {

  								currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

  							}

  						}

  					} else if ( material.visible ) {

  						currentRenderList.push( object, geometry, material, _vector3.z, null );

  					}

  				}

  			}

  		}

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			projectObject( children[ i ], camera, sortObjects );

  		}

  	}

  	function renderObjects( renderList, scene, camera, overrideMaterial ) {

  		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

  			var renderItem = renderList[ i ];

  			var object = renderItem.object;
  			var geometry = renderItem.geometry;
  			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
  			var group = renderItem.group;

  			object.onBeforeRender( _this, scene, camera, geometry, material, group );

  			if ( camera.isArrayCamera && camera.enabled ) {

  				var cameras = camera.cameras;

  				for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

  					var camera2 = cameras[ j ];
  					var bounds = camera2.bounds;

  					_this.setViewport(
  						bounds.x * _width * _pixelRatio, bounds.y * _height * _pixelRatio,
  						bounds.z * _width * _pixelRatio, bounds.w * _height * _pixelRatio
  					);
  					_this.setScissor(
  						bounds.x * _width * _pixelRatio, bounds.y * _height * _pixelRatio,
  						bounds.z * _width * _pixelRatio, bounds.w * _height * _pixelRatio
  					);
  					_this.setScissorTest( true );

  					renderObject( object, scene, camera2, geometry, material, group );

  				}

  			} else {

  				renderObject( object, scene, camera, geometry, material, group );

  			}

  			object.onAfterRender( _this, scene, camera, geometry, material, group );

  		}

  	}

  	function renderObject( object, scene, camera, geometry, material, group ) {

  		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
  		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

  		if ( object.isImmediateRenderObject ) {

  			state.setMaterial( material );

  			var program = setProgram( camera, scene.fog, material, object );

  			_currentGeometryProgram = '';

  			renderObjectImmediate( object, program, material );

  		} else {

  			_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

  		}

  	}

  	function initMaterial( material, fog, object ) {

  		var materialProperties = properties.get( material );

  		var parameters = programCache.getParameters(
  			material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

  		var code = programCache.getProgramCode( material, parameters );

  		var program = materialProperties.program;
  		var programChange = true;

  		if ( program === undefined ) {

  			// new material
  			material.addEventListener( 'dispose', onMaterialDispose );

  		} else if ( program.code !== code ) {

  			// changed glsl or parameters
  			releaseMaterialProgramReference( material );

  		} else if ( parameters.shaderID !== undefined ) {

  			// same glsl and uniform list
  			return;

  		} else {

  			// only rebuild uniform list
  			programChange = false;

  		}

  		if ( programChange ) {

  			if ( parameters.shaderID ) {

  				var shader = ShaderLib$1[ parameters.shaderID ];

  				materialProperties.__webglShader = {
  					name: material.type,
  					uniforms: UniformsUtils$1.clone( shader.uniforms ),
  					vertexShader: shader.vertexShader,
  					fragmentShader: shader.fragmentShader
  				};

  			} else {

  				materialProperties.__webglShader = {
  					name: material.type,
  					uniforms: material.uniforms,
  					vertexShader: material.vertexShader,
  					fragmentShader: material.fragmentShader
  				};

  			}

  			material.__webglShader = materialProperties.__webglShader;

  			program = programCache.acquireProgram( material, parameters, code );

  			materialProperties.program = program;
  			material.program = program;

  		}

  		var programAttributes = program.getAttributes();

  		if ( material.morphTargets ) {

  			material.numSupportedMorphTargets = 0;

  			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

  				if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

  					material.numSupportedMorphTargets ++;

  				}

  			}

  		}

  		if ( material.morphNormals ) {

  			material.numSupportedMorphNormals = 0;

  			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

  				if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

  					material.numSupportedMorphNormals ++;

  				}

  			}

  		}

  		var uniforms = materialProperties.__webglShader.uniforms;

  		if ( ! material.isShaderMaterial &&
  			! material.isRawShaderMaterial ||
  			material.clipping === true ) {

  			materialProperties.numClippingPlanes = _clipping.numPlanes;
  			materialProperties.numIntersection = _clipping.numIntersection;
  			uniforms.clippingPlanes = _clipping.uniform;

  		}

  		materialProperties.fog = fog;

  		// store the light setup it was created for

  		materialProperties.lightsHash = _lights.hash;

  		if ( material.lights ) {

  			// wire up the material to this renderer's lighting state

  			uniforms.ambientLightColor.value = _lights.ambient;
  			uniforms.directionalLights.value = _lights.directional;
  			uniforms.spotLights.value = _lights.spot;
  			uniforms.rectAreaLights.value = _lights.rectArea;
  			uniforms.pointLights.value = _lights.point;
  			uniforms.hemisphereLights.value = _lights.hemi;

  			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
  			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
  			uniforms.spotShadowMap.value = _lights.spotShadowMap;
  			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
  			uniforms.pointShadowMap.value = _lights.pointShadowMap;
  			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
  			// TODO (abelnation): add area lights shadow info to uniforms

  		}

  		var progUniforms = materialProperties.program.getUniforms(),
  			uniformsList =
  				WebGLUniforms$1.seqWithValue( progUniforms.seq, uniforms );

  		materialProperties.uniformsList = uniformsList;

  	}

  	function setProgram( camera, fog, material, object ) {

  		_usedTextureUnits = 0;

  		var materialProperties = properties.get( material );

  		if ( _clippingEnabled ) {

  			if ( _localClippingEnabled || camera !== _currentCamera ) {

  				var useCache =
  					camera === _currentCamera &&
  					material.id === _currentMaterialId;

  				// we might want to call this function with some ClippingGroup
  				// object instead of the material, once it becomes feasible
  				// (#8465, #8379)
  				_clipping.setState(
  					material.clippingPlanes, material.clipIntersection, material.clipShadows,
  					camera, materialProperties, useCache );

  			}

  		}

  		if ( material.needsUpdate === false ) {

  			if ( materialProperties.program === undefined ) {

  				material.needsUpdate = true;

  			} else if ( material.fog && materialProperties.fog !== fog ) {

  				material.needsUpdate = true;

  			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

  				material.needsUpdate = true;

  			} else if ( materialProperties.numClippingPlanes !== undefined &&
  				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
  				materialProperties.numIntersection !== _clipping.numIntersection ) ) {

  				material.needsUpdate = true;

  			}

  		}

  		if ( material.needsUpdate ) {

  			initMaterial( material, fog, object );
  			material.needsUpdate = false;

  		}

  		var refreshProgram = false;
  		var refreshMaterial = false;
  		var refreshLights = false;

  		var program = materialProperties.program,
  			p_uniforms = program.getUniforms(),
  			m_uniforms = materialProperties.__webglShader.uniforms;

  		if ( program.id !== _currentProgram ) {

  			_gl.useProgram( program.program );
  			_currentProgram = program.id;

  			refreshProgram = true;
  			refreshMaterial = true;
  			refreshLights = true;

  		}

  		if ( material.id !== _currentMaterialId ) {

  			_currentMaterialId = material.id;

  			refreshMaterial = true;

  		}

  		if ( refreshProgram || camera !== _currentCamera ) {

  			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

  			if ( capabilities.logarithmicDepthBuffer ) {

  				p_uniforms.setValue( _gl, 'logDepthBufFC',
  					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

  			}


  			if ( camera !== _currentCamera ) {

  				_currentCamera = camera;

  				// lighting uniforms depend on the camera so enforce an update
  				// now, in case this material supports lights - or later, when
  				// the next material that does gets activated:

  				refreshMaterial = true;		// set to true on material change
  				refreshLights = true;		// remains set until update done

  			}

  			// load material specific uniforms
  			// (shader material also gets them for the sake of genericity)

  			if ( material.isShaderMaterial ||
  				material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial ||
  				material.envMap ) {

  				var uCamPos = p_uniforms.map.cameraPosition;

  				if ( uCamPos !== undefined ) {

  					uCamPos.setValue( _gl,
  						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

  				}

  			}

  			if ( material.isMeshPhongMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshBasicMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isShaderMaterial ||
  				material.skinning ) {

  				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

  			}

  			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
  			p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

  		}

  		// skinning uniforms must be set even if material didn't change
  		// auto-setting of texture unit for bone texture must go before other textures
  		// not sure why, but otherwise weird things happen

  		if ( material.skinning ) {

  			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
  			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

  			var skeleton = object.skeleton;

  			if ( skeleton ) {

  				var bones = skeleton.bones;

  				if ( capabilities.floatVertexTextures ) {

  					if ( skeleton.boneTexture === undefined ) {

  						// layout (1 matrix = 4 pixels)
  						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
  						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
  						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
  						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
  						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


  						var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
  						size = _Math$1.nextPowerOfTwo( Math.ceil( size ) );
  						size = Math.max( size, 4 );

  						var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
  						boneMatrices.set( skeleton.boneMatrices ); // copy current values

  						var boneTexture = new DataTexture$1( boneMatrices, size, size, RGBAFormat$1, FloatType$1 );

  						skeleton.boneMatrices = boneMatrices;
  						skeleton.boneTexture = boneTexture;
  						skeleton.boneTextureSize = size;

  					}

  					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
  					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

  				} else {

  					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

  				}

  			}

  		}

  		if ( refreshMaterial ) {

  			if ( material.lights ) {

  				// the current material requires lighting info

  				// note: all lighting uniforms are always set correctly
  				// they simply reference the renderer's state for their
  				// values
  				//
  				// use the current material's .needsUpdate flags to set
  				// the GL state when required

  				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

  			}

  			// refresh uniforms common to several materials

  			if ( fog && material.fog ) {

  				refreshUniformsFog( m_uniforms, fog );

  			}

  			if ( material.isMeshBasicMaterial ||
  				material.isMeshLambertMaterial ||
  				material.isMeshPhongMaterial ||
  				material.isMeshStandardMaterial ||
  				material.isMeshNormalMaterial ||
  				material.isMeshDepthMaterial ) {

  				refreshUniformsCommon( m_uniforms, material );

  			}

  			// refresh single material specific uniforms

  			if ( material.isLineBasicMaterial ) {

  				refreshUniformsLine( m_uniforms, material );

  			} else if ( material.isLineDashedMaterial ) {

  				refreshUniformsLine( m_uniforms, material );
  				refreshUniformsDash( m_uniforms, material );

  			} else if ( material.isPointsMaterial ) {

  				refreshUniformsPoints( m_uniforms, material );

  			} else if ( material.isMeshLambertMaterial ) {

  				refreshUniformsLambert( m_uniforms, material );

  			} else if ( material.isMeshToonMaterial ) {

  				refreshUniformsToon( m_uniforms, material );

  			} else if ( material.isMeshPhongMaterial ) {

  				refreshUniformsPhong( m_uniforms, material );

  			} else if ( material.isMeshPhysicalMaterial ) {

  				refreshUniformsPhysical( m_uniforms, material );

  			} else if ( material.isMeshStandardMaterial ) {

  				refreshUniformsStandard( m_uniforms, material );

  			} else if ( material.isMeshDepthMaterial ) {

  				if ( material.displacementMap ) {

  					m_uniforms.displacementMap.value = material.displacementMap;
  					m_uniforms.displacementScale.value = material.displacementScale;
  					m_uniforms.displacementBias.value = material.displacementBias;

  				}

  			} else if ( material.isMeshNormalMaterial ) {

  				refreshUniformsNormal( m_uniforms, material );

  			}

  			// RectAreaLight Texture
  			// TODO (mrdoob): Find a nicer implementation

  			if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib$1.LTC_MAT_TEXTURE;
  			if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib$1.LTC_MAG_TEXTURE;

  			WebGLUniforms$1.upload(
  				_gl, materialProperties.uniformsList, m_uniforms, _this );

  		}


  		// common matrices

  		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
  		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
  		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

  		return program;

  	}

  	// Uniforms (refresh uniforms objects)

  	function refreshUniformsCommon( uniforms, material ) {

  		uniforms.opacity.value = material.opacity;

  		uniforms.diffuse.value = material.color;

  		if ( material.emissive ) {

  			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

  		}

  		uniforms.map.value = material.map;
  		uniforms.specularMap.value = material.specularMap;
  		uniforms.alphaMap.value = material.alphaMap;

  		if ( material.lightMap ) {

  			uniforms.lightMap.value = material.lightMap;
  			uniforms.lightMapIntensity.value = material.lightMapIntensity;

  		}

  		if ( material.aoMap ) {

  			uniforms.aoMap.value = material.aoMap;
  			uniforms.aoMapIntensity.value = material.aoMapIntensity;

  		}

  		// uv repeat and offset setting priorities
  		// 1. color map
  		// 2. specular map
  		// 3. normal map
  		// 4. bump map
  		// 5. alpha map
  		// 6. emissive map

  		var uvScaleMap;

  		if ( material.map ) {

  			uvScaleMap = material.map;

  		} else if ( material.specularMap ) {

  			uvScaleMap = material.specularMap;

  		} else if ( material.displacementMap ) {

  			uvScaleMap = material.displacementMap;

  		} else if ( material.normalMap ) {

  			uvScaleMap = material.normalMap;

  		} else if ( material.bumpMap ) {

  			uvScaleMap = material.bumpMap;

  		} else if ( material.roughnessMap ) {

  			uvScaleMap = material.roughnessMap;

  		} else if ( material.metalnessMap ) {

  			uvScaleMap = material.metalnessMap;

  		} else if ( material.alphaMap ) {

  			uvScaleMap = material.alphaMap;

  		} else if ( material.emissiveMap ) {

  			uvScaleMap = material.emissiveMap;

  		}

  		if ( uvScaleMap !== undefined ) {

  			// backwards compatibility
  			if ( uvScaleMap.isWebGLRenderTarget ) {

  				uvScaleMap = uvScaleMap.texture;

  			}

  			var offset = uvScaleMap.offset;
  			var repeat = uvScaleMap.repeat;

  			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

  		}

  		uniforms.envMap.value = material.envMap;

  		// don't flip CubeTexture envMaps, flip everything else:
  		//  WebGLRenderTargetCube will be flipped for backwards compatibility
  		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
  		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
  		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

  		uniforms.reflectivity.value = material.reflectivity;
  		uniforms.refractionRatio.value = material.refractionRatio;

  	}

  	function refreshUniformsLine( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;

  	}

  	function refreshUniformsDash( uniforms, material ) {

  		uniforms.dashSize.value = material.dashSize;
  		uniforms.totalSize.value = material.dashSize + material.gapSize;
  		uniforms.scale.value = material.scale;

  	}

  	function refreshUniformsPoints( uniforms, material ) {

  		uniforms.diffuse.value = material.color;
  		uniforms.opacity.value = material.opacity;
  		uniforms.size.value = material.size * _pixelRatio;
  		uniforms.scale.value = _height * 0.5;

  		uniforms.map.value = material.map;

  		if ( material.map !== null ) {

  			var offset = material.map.offset;
  			var repeat = material.map.repeat;

  			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

  		}

  	}

  	function refreshUniformsFog( uniforms, fog ) {

  		uniforms.fogColor.value = fog.color;

  		if ( fog.isFog ) {

  			uniforms.fogNear.value = fog.near;
  			uniforms.fogFar.value = fog.far;

  		} else if ( fog.isFogExp2 ) {

  			uniforms.fogDensity.value = fog.density;

  		}

  	}

  	function refreshUniformsLambert( uniforms, material ) {

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  	}

  	function refreshUniformsPhong( uniforms, material ) {

  		uniforms.specular.value = material.specular;
  		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	function refreshUniformsToon( uniforms, material ) {

  		refreshUniformsPhong( uniforms, material );

  		if ( material.gradientMap ) {

  			uniforms.gradientMap.value = material.gradientMap;

  		}

  	}

  	function refreshUniformsStandard( uniforms, material ) {

  		uniforms.roughness.value = material.roughness;
  		uniforms.metalness.value = material.metalness;

  		if ( material.roughnessMap ) {

  			uniforms.roughnessMap.value = material.roughnessMap;

  		}

  		if ( material.metalnessMap ) {

  			uniforms.metalnessMap.value = material.metalnessMap;

  		}

  		if ( material.emissiveMap ) {

  			uniforms.emissiveMap.value = material.emissiveMap;

  		}

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  		if ( material.envMap ) {

  			//uniforms.envMap.value = material.envMap; // part of uniforms common
  			uniforms.envMapIntensity.value = material.envMapIntensity;

  		}

  	}

  	function refreshUniformsPhysical( uniforms, material ) {

  		uniforms.clearCoat.value = material.clearCoat;
  		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

  		refreshUniformsStandard( uniforms, material );

  	}

  	function refreshUniformsNormal( uniforms, material ) {

  		if ( material.bumpMap ) {

  			uniforms.bumpMap.value = material.bumpMap;
  			uniforms.bumpScale.value = material.bumpScale;

  		}

  		if ( material.normalMap ) {

  			uniforms.normalMap.value = material.normalMap;
  			uniforms.normalScale.value.copy( material.normalScale );

  		}

  		if ( material.displacementMap ) {

  			uniforms.displacementMap.value = material.displacementMap;
  			uniforms.displacementScale.value = material.displacementScale;
  			uniforms.displacementBias.value = material.displacementBias;

  		}

  	}

  	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

  	function markUniformsLightsNeedsUpdate( uniforms, value ) {

  		uniforms.ambientLightColor.needsUpdate = value;

  		uniforms.directionalLights.needsUpdate = value;
  		uniforms.pointLights.needsUpdate = value;
  		uniforms.spotLights.needsUpdate = value;
  		uniforms.rectAreaLights.needsUpdate = value;
  		uniforms.hemisphereLights.needsUpdate = value;

  	}

  	// Lighting

  	function setupShadows( lights ) {

  		var lightShadowsLength = 0;

  		for ( var i = 0, l = lights.length; i < l; i ++ ) {

  			var light = lights[ i ];

  			if ( light.castShadow ) {

  				_lights.shadows[ lightShadowsLength ] = light;
  				lightShadowsLength ++;

  			}

  		}

  		_lights.shadows.length = lightShadowsLength;

  	}

  	function setupLights( lights, camera ) {

  		var l, ll, light, shadow,
  			r = 0, g = 0, b = 0,
  			color,
  			intensity,
  			distance,
  			shadowMap,

  			viewMatrix = camera.matrixWorldInverse,

  			directionalLength = 0,
  			pointLength = 0,
  			spotLength = 0,
  			rectAreaLength = 0,
  			hemiLength = 0;

  		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

  			light = lights[ l ];

  			color = light.color;
  			intensity = light.intensity;
  			distance = light.distance;

  			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

  			if ( light.isAmbientLight ) {

  				r += color.r * intensity;
  				g += color.g * intensity;
  				b += color.b * intensity;

  			} else if ( light.isDirectionalLight ) {

  				var uniforms = lightCache.get( light );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				_vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( _vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
  				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
  				_lights.directional[ directionalLength ] = uniforms;

  				directionalLength ++;

  			} else if ( light.isSpotLight ) {

  				var uniforms = lightCache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( color ).multiplyScalar( intensity );
  				uniforms.distance = distance;

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				_vector3.setFromMatrixPosition( light.target.matrixWorld );
  				uniforms.direction.sub( _vector3 );
  				uniforms.direction.transformDirection( viewMatrix );

  				uniforms.coneCos = Math.cos( light.angle );
  				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
  				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				_lights.spotShadowMap[ spotLength ] = shadowMap;
  				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
  				_lights.spot[ spotLength ] = uniforms;

  				spotLength ++;

  			} else if ( light.isRectAreaLight ) {

  				var uniforms = lightCache.get( light );

  				// (a) intensity controls irradiance of entire light
  				uniforms.color
  					.copy( color )
  					.multiplyScalar( intensity / ( light.width * light.height ) );

  				// (b) intensity controls the radiance per light area
  				// uniforms.color.copy( color ).multiplyScalar( intensity );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				// extract local rotation of light to derive width/height half vectors
  				_matrix42.identity();
  				_matrix4.copy( light.matrixWorld );
  				_matrix4.premultiply( viewMatrix );
  				_matrix42.extractRotation( _matrix4 );

  				uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
  				uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );

  				uniforms.halfWidth.applyMatrix4( _matrix42 );
  				uniforms.halfHeight.applyMatrix4( _matrix42 );

  				// TODO (abelnation): RectAreaLight distance?
  				// uniforms.distance = distance;

  				_lights.rectArea[ rectAreaLength ] = uniforms;

  				rectAreaLength ++;

  			} else if ( light.isPointLight ) {

  				var uniforms = lightCache.get( light );

  				uniforms.position.setFromMatrixPosition( light.matrixWorld );
  				uniforms.position.applyMatrix4( viewMatrix );

  				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
  				uniforms.distance = light.distance;
  				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

  				uniforms.shadow = light.castShadow;

  				if ( light.castShadow ) {

  					shadow = light.shadow;

  					uniforms.shadowBias = shadow.bias;
  					uniforms.shadowRadius = shadow.radius;
  					uniforms.shadowMapSize = shadow.mapSize;

  				}

  				_lights.pointShadowMap[ pointLength ] = shadowMap;
  				_lights.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
  				_lights.point[ pointLength ] = uniforms;

  				pointLength ++;

  			} else if ( light.isHemisphereLight ) {

  				var uniforms = lightCache.get( light );

  				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
  				uniforms.direction.transformDirection( viewMatrix );
  				uniforms.direction.normalize();

  				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
  				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

  				_lights.hemi[ hemiLength ] = uniforms;

  				hemiLength ++;

  			}

  		}

  		_lights.ambient[ 0 ] = r;
  		_lights.ambient[ 1 ] = g;
  		_lights.ambient[ 2 ] = b;

  		_lights.directional.length = directionalLength;
  		_lights.spot.length = spotLength;
  		_lights.rectArea.length = rectAreaLength;
  		_lights.point.length = pointLength;
  		_lights.hemi.length = hemiLength;

  		// TODO (sam-g-steel) why aren't we using join
  		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;

  	}

  	// GL state setting

  	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

  		state.setCullFace( cullFace );
  		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

  	};

  	// Textures

  	function allocTextureUnit() {

  		var textureUnit = _usedTextureUnits;

  		if ( textureUnit >= capabilities.maxTextures ) {

  			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

  		}

  		_usedTextureUnits += 1;

  		return textureUnit;

  	}

  	this.allocTextureUnit = allocTextureUnit;

  	// this.setTexture2D = setTexture2D;
  	this.setTexture2D = ( function () {

  		var warned = false;

  		// backwards compatibility: peel texture.texture
  		return function setTexture2D( texture, slot ) {

  			if ( texture && texture.isWebGLRenderTarget ) {

  				if ( ! warned ) {

  					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTexture = ( function () {

  		var warned = false;

  		return function setTexture( texture, slot ) {

  			if ( ! warned ) {

  				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
  				warned = true;

  			}

  			textures.setTexture2D( texture, slot );

  		};

  	}() );

  	this.setTextureCube = ( function () {

  		var warned = false;

  		return function setTextureCube( texture, slot ) {

  			// backwards compatibility: peel texture.texture
  			if ( texture && texture.isWebGLRenderTargetCube ) {

  				if ( ! warned ) {

  					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
  					warned = true;

  				}

  				texture = texture.texture;

  			}

  			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
  			// TODO: unify these code paths
  			if ( ( texture && texture.isCubeTexture ) ||
  				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

  				// CompressedTexture can have Array in image :/

  				// this function alone should take care of cube textures
  				textures.setTextureCube( texture, slot );

  			} else {

  				// assumed: texture property of THREE.WebGLRenderTargetCube

  				textures.setTextureCubeDynamic( texture, slot );

  			}

  		};

  	}() );

  	this.getRenderTarget = function () {

  		return _currentRenderTarget;

  	};

  	this.setRenderTarget = function ( renderTarget ) {

  		_currentRenderTarget = renderTarget;

  		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

  			textures.setupRenderTarget( renderTarget );

  		}

  		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
  		var framebuffer;

  		if ( renderTarget ) {

  			var renderTargetProperties = properties.get( renderTarget );

  			if ( isCube ) {

  				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

  			} else {

  				framebuffer = renderTargetProperties.__webglFramebuffer;

  			}

  			_currentScissor.copy( renderTarget.scissor );
  			_currentScissorTest = renderTarget.scissorTest;

  			_currentViewport.copy( renderTarget.viewport );

  		} else {

  			framebuffer = null;

  			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
  			_currentScissorTest = _scissorTest;

  			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

  		}

  		if ( _currentFramebuffer !== framebuffer ) {

  			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
  			_currentFramebuffer = framebuffer;

  		}

  		state.scissor( _currentScissor );
  		state.setScissorTest( _currentScissorTest );

  		state.viewport( _currentViewport );

  		if ( isCube ) {

  			var textureProperties = properties.get( renderTarget.texture );
  			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

  		}

  	};

  	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

  		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

  			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
  			return;

  		}

  		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

  		if ( framebuffer ) {

  			var restore = false;

  			if ( framebuffer !== _currentFramebuffer ) {

  				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

  				restore = true;

  			}

  			try {

  				var texture = renderTarget.texture;
  				var textureFormat = texture.format;
  				var textureType = texture.type;

  				if ( textureFormat !== RGBAFormat$1 && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
  					return;

  				}

  				if ( textureType !== UnsignedByteType$1 && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
  					! ( textureType === FloatType$1 && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
  					! ( textureType === HalfFloatType$1 && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
  					return;

  				}

  				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

  					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

  					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

  						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

  					}

  				} else {

  					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

  				}

  			} finally {

  				if ( restore ) {

  					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

  				}

  			}

  		}

  	};

  	// Map three.js constants to WebGL constants

  	function paramThreeToGL( p ) {

  		var extension;

  		if ( p === RepeatWrapping$1 ) return _gl.REPEAT;
  		if ( p === ClampToEdgeWrapping$1 ) return _gl.CLAMP_TO_EDGE;
  		if ( p === MirroredRepeatWrapping$1 ) return _gl.MIRRORED_REPEAT;

  		if ( p === NearestFilter$1 ) return _gl.NEAREST;
  		if ( p === NearestMipMapNearestFilter$1 ) return _gl.NEAREST_MIPMAP_NEAREST;
  		if ( p === NearestMipMapLinearFilter$1 ) return _gl.NEAREST_MIPMAP_LINEAR;

  		if ( p === LinearFilter$1 ) return _gl.LINEAR;
  		if ( p === LinearMipMapNearestFilter$1 ) return _gl.LINEAR_MIPMAP_NEAREST;
  		if ( p === LinearMipMapLinearFilter$1 ) return _gl.LINEAR_MIPMAP_LINEAR;

  		if ( p === UnsignedByteType$1 ) return _gl.UNSIGNED_BYTE;
  		if ( p === UnsignedShort4444Type$1 ) return _gl.UNSIGNED_SHORT_4_4_4_4;
  		if ( p === UnsignedShort5551Type$1 ) return _gl.UNSIGNED_SHORT_5_5_5_1;
  		if ( p === UnsignedShort565Type$1 ) return _gl.UNSIGNED_SHORT_5_6_5;

  		if ( p === ByteType$1 ) return _gl.BYTE;
  		if ( p === ShortType$1 ) return _gl.SHORT;
  		if ( p === UnsignedShortType$1 ) return _gl.UNSIGNED_SHORT;
  		if ( p === IntType$1 ) return _gl.INT;
  		if ( p === UnsignedIntType$1 ) return _gl.UNSIGNED_INT;
  		if ( p === FloatType$1 ) return _gl.FLOAT;

  		if ( p === HalfFloatType$1 ) {

  			extension = extensions.get( 'OES_texture_half_float' );

  			if ( extension !== null ) return extension.HALF_FLOAT_OES;

  		}

  		if ( p === AlphaFormat$1 ) return _gl.ALPHA;
  		if ( p === RGBFormat$1 ) return _gl.RGB;
  		if ( p === RGBAFormat$1 ) return _gl.RGBA;
  		if ( p === LuminanceFormat$1 ) return _gl.LUMINANCE;
  		if ( p === LuminanceAlphaFormat$1 ) return _gl.LUMINANCE_ALPHA;
  		if ( p === DepthFormat$1 ) return _gl.DEPTH_COMPONENT;
  		if ( p === DepthStencilFormat$1 ) return _gl.DEPTH_STENCIL;

  		if ( p === AddEquation$1 ) return _gl.FUNC_ADD;
  		if ( p === SubtractEquation$1 ) return _gl.FUNC_SUBTRACT;
  		if ( p === ReverseSubtractEquation$1 ) return _gl.FUNC_REVERSE_SUBTRACT;

  		if ( p === ZeroFactor$1 ) return _gl.ZERO;
  		if ( p === OneFactor$1 ) return _gl.ONE;
  		if ( p === SrcColorFactor$1 ) return _gl.SRC_COLOR;
  		if ( p === OneMinusSrcColorFactor$1 ) return _gl.ONE_MINUS_SRC_COLOR;
  		if ( p === SrcAlphaFactor$1 ) return _gl.SRC_ALPHA;
  		if ( p === OneMinusSrcAlphaFactor$1 ) return _gl.ONE_MINUS_SRC_ALPHA;
  		if ( p === DstAlphaFactor$1 ) return _gl.DST_ALPHA;
  		if ( p === OneMinusDstAlphaFactor$1 ) return _gl.ONE_MINUS_DST_ALPHA;

  		if ( p === DstColorFactor$1 ) return _gl.DST_COLOR;
  		if ( p === OneMinusDstColorFactor$1 ) return _gl.ONE_MINUS_DST_COLOR;
  		if ( p === SrcAlphaSaturateFactor$1 ) return _gl.SRC_ALPHA_SATURATE;

  		if ( p === RGB_S3TC_DXT1_Format$1 || p === RGBA_S3TC_DXT1_Format$1 ||
  			p === RGBA_S3TC_DXT3_Format$1 || p === RGBA_S3TC_DXT5_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

  			if ( extension !== null ) {

  				if ( p === RGB_S3TC_DXT1_Format$1 ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
  				if ( p === RGBA_S3TC_DXT1_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
  				if ( p === RGBA_S3TC_DXT3_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
  				if ( p === RGBA_S3TC_DXT5_Format$1 ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

  			}

  		}

  		if ( p === RGB_PVRTC_4BPPV1_Format$1 || p === RGB_PVRTC_2BPPV1_Format$1 ||
  			p === RGBA_PVRTC_4BPPV1_Format$1 || p === RGBA_PVRTC_2BPPV1_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  			if ( extension !== null ) {

  				if ( p === RGB_PVRTC_4BPPV1_Format$1 ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
  				if ( p === RGB_PVRTC_2BPPV1_Format$1 ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
  				if ( p === RGBA_PVRTC_4BPPV1_Format$1 ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
  				if ( p === RGBA_PVRTC_2BPPV1_Format$1 ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

  			}

  		}

  		if ( p === RGB_ETC1_Format$1 ) {

  			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

  			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

  		}

  		if ( p === MinEquation$1 || p === MaxEquation$1 ) {

  			extension = extensions.get( 'EXT_blend_minmax' );

  			if ( extension !== null ) {

  				if ( p === MinEquation$1 ) return extension.MIN_EXT;
  				if ( p === MaxEquation$1 ) return extension.MAX_EXT;

  			}

  		}

  		if ( p === UnsignedInt248Type$1 ) {

  			extension = extensions.get( 'WEBGL_depth_texture' );

  			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

  		}

  		return 0;

  	}

  }

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function FogExp2$1 ( color, density ) {

  	this.name = '';

  	this.color = new Color$1( color );
  	this.density = ( density !== undefined ) ? density : 0.00025;

  }

  FogExp2$1.prototype.isFogExp2 = true;

  FogExp2$1.prototype.clone = function () {

  	return new FogExp2$1( this.color.getHex(), this.density );

  };

  FogExp2$1.prototype.toJSON = function ( meta ) {

  	return {
  		type: 'FogExp2',
  		color: this.color.getHex(),
  		density: this.density
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Fog$1 ( color, near, far ) {

  	this.name = '';

  	this.color = new Color$1( color );

  	this.near = ( near !== undefined ) ? near : 1;
  	this.far = ( far !== undefined ) ? far : 1000;

  }

  Fog$1.prototype.isFog = true;

  Fog$1.prototype.clone = function () {

  	return new Fog$1( this.color.getHex(), this.near, this.far );

  };

  Fog$1.prototype.toJSON = function ( meta ) {

  	return {
  		type: 'Fog',
  		color: this.color.getHex(),
  		near: this.near,
  		far: this.far
  	};

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Scene$1 () {

  	Object3D$1.call( this );

  	this.type = 'Scene';

  	this.background = null;
  	this.fog = null;
  	this.overrideMaterial = null;

  	this.autoUpdate = true; // checked by the renderer

  }

  Scene$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Scene$1,

  	copy: function ( source, recursive ) {

  		Object3D$1.prototype.copy.call( this, source, recursive );

  		if ( source.background !== null ) this.background = source.background.clone();
  		if ( source.fog !== null ) this.fog = source.fog.clone();
  		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  		this.autoUpdate = source.autoUpdate;
  		this.matrixAutoUpdate = source.matrixAutoUpdate;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
  		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

  		return data;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function LensFlare( texture, size, distance, blending, color ) {

  	Object3D$1.call( this );

  	this.lensFlares = [];

  	this.positionScreen = new Vector3$1();
  	this.customUpdateCallback = undefined;

  	if ( texture !== undefined ) {

  		this.add( texture, size, distance, blending, color );

  	}

  }

  LensFlare.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: LensFlare,

  	isLensFlare: true,

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.positionScreen.copy( source.positionScreen );
  		this.customUpdateCallback = source.customUpdateCallback;

  		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

  			this.lensFlares.push( source.lensFlares[ i ] );

  		}

  		return this;

  	},

  	add: function ( texture, size, distance, blending, color, opacity ) {

  		if ( size === undefined ) size = - 1;
  		if ( distance === undefined ) distance = 0;
  		if ( opacity === undefined ) opacity = 1;
  		if ( color === undefined ) color = new Color$1( 0xffffff );
  		if ( blending === undefined ) blending = NormalBlending$1;

  		distance = Math.min( distance, Math.max( 0, distance ) );

  		this.lensFlares.push( {
  			texture: texture,	// THREE.Texture
  			size: size, 		// size in pixels (-1 = use texture.width)
  			distance: distance, 	// distance (0-1) from light source (0=at light source)
  			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
  			scale: 1, 		// scale
  			rotation: 0, 		// rotation
  			opacity: opacity,	// opacity
  			color: color,		// color
  			blending: blending	// blending
  		} );

  	},

  	/*
  	 * Update lens flares update positions on all flares based on the screen position
  	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
  	 */

  	updateLensFlares: function () {

  		var f, fl = this.lensFlares.length;
  		var flare;
  		var vecX = - this.positionScreen.x * 2;
  		var vecY = - this.positionScreen.y * 2;

  		for ( f = 0; f < fl; f ++ ) {

  			flare = this.lensFlares[ f ];

  			flare.x = this.positionScreen.x + vecX * flare.distance;
  			flare.y = this.positionScreen.y + vecY * flare.distance;

  			flare.wantedRotation = flare.x * Math.PI * 0.25;
  			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  		}

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *	uvOffset: new THREE.Vector2(),
   *	uvScale: new THREE.Vector2()
   * }
   */

  function SpriteMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'SpriteMaterial';

  	this.color = new Color$1( 0xffffff );
  	this.map = null;

  	this.rotation = 0;

  	this.fog = false;
  	this.lights = false;

  	this.setValues( parameters );

  }

  SpriteMaterial$1.prototype = Object.create( Material$1.prototype );
  SpriteMaterial$1.prototype.constructor = SpriteMaterial$1;
  SpriteMaterial$1.prototype.isSpriteMaterial = true;

  SpriteMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.map = source.map;

  	this.rotation = source.rotation;

  	return this;

  };

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   */

  function Sprite$1( material ) {

  	Object3D$1.call( this );

  	this.type = 'Sprite';

  	this.material = ( material !== undefined ) ? material : new SpriteMaterial$1();

  }

  Sprite$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Sprite$1,

  	isSprite: true,

  	raycast: ( function () {

  		var intersectPoint = new Vector3$1();
  		var worldPosition = new Vector3$1();
  		var worldScale = new Vector3$1();

  		return function raycast( raycaster, intersects ) {

  			worldPosition.setFromMatrixPosition( this.matrixWorld );
  			raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );

  			worldScale.setFromMatrixScale( this.matrixWorld );
  			var guessSizeSq = worldScale.x * worldScale.y / 4;

  			if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;

  			var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  			if ( distance < raycaster.near || distance > raycaster.far ) return;

  			intersects.push( {

  				distance: distance,
  				point: intersectPoint.clone(),
  				face: null,
  				object: this

  			} );

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.material ).copy( this );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function LOD$1() {

  	Object3D$1.call( this );

  	this.type = 'LOD';

  	Object.defineProperties( this, {
  		levels: {
  			enumerable: true,
  			value: []
  		}
  	} );

  }

  LOD$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: LOD$1,

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source, false );

  		var levels = source.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			this.addLevel( level.object.clone(), level.distance );

  		}

  		return this;

  	},

  	addLevel: function ( object, distance ) {

  		if ( distance === undefined ) distance = 0;

  		distance = Math.abs( distance );

  		var levels = this.levels;

  		for ( var l = 0; l < levels.length; l ++ ) {

  			if ( distance < levels[ l ].distance ) {

  				break;

  			}

  		}

  		levels.splice( l, 0, { distance: distance, object: object } );

  		this.add( object );

  	},

  	getObjectForDistance: function ( distance ) {

  		var levels = this.levels;

  		for ( var i = 1, l = levels.length; i < l; i ++ ) {

  			if ( distance < levels[ i ].distance ) {

  				break;

  			}

  		}

  		return levels[ i - 1 ].object;

  	},

  	raycast: ( function () {

  		var matrixPosition = new Vector3$1();

  		return function raycast( raycaster, intersects ) {

  			matrixPosition.setFromMatrixPosition( this.matrixWorld );

  			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

  			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  		};

  	}() ),

  	update: function () {

  		var v1 = new Vector3$1();
  		var v2 = new Vector3$1();

  		return function update( camera ) {

  			var levels = this.levels;

  			if ( levels.length > 1 ) {

  				v1.setFromMatrixPosition( camera.matrixWorld );
  				v2.setFromMatrixPosition( this.matrixWorld );

  				var distance = v1.distanceTo( v2 );

  				levels[ 0 ].object.visible = true;

  				for ( var i = 1, l = levels.length; i < l; i ++ ) {

  					if ( distance >= levels[ i ].distance ) {

  						levels[ i - 1 ].object.visible = false;
  						levels[ i ].object.visible = true;

  					} else {

  						break;

  					}

  				}

  				for ( ; i < l; i ++ ) {

  					levels[ i ].object.visible = false;

  				}

  			}

  		};

  	}(),

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.levels = [];

  		var levels = this.levels;

  		for ( var i = 0, l = levels.length; i < l; i ++ ) {

  			var level = levels[ i ];

  			data.object.levels.push( {
  				object: level.object.uuid,
  				distance: level.distance
  			} );

  		}

  		return data;

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author michael guerrero / http://realitymeltdown.com
   * @author ikerr / http://verold.com
   */

  function Skeleton$1( bones, boneInverses ) {

  	// copy the bone array

  	bones = bones || [];

  	this.bones = bones.slice( 0 );
  	this.boneMatrices = new Float32Array( this.bones.length * 16 );

  	// use the supplied bone inverses or calculate the inverses

  	if ( boneInverses === undefined ) {

  		this.calculateInverses();

  	} else {

  		if ( this.bones.length === boneInverses.length ) {

  			this.boneInverses = boneInverses.slice( 0 );

  		} else {

  			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

  			this.boneInverses = [];

  			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  				this.boneInverses.push( new Matrix4$1() );

  			}

  		}

  	}

  }

  Object.assign( Skeleton$1.prototype, {

  	calculateInverses: function () {

  		this.boneInverses = [];

  		for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

  			var inverse = new Matrix4$1();

  			if ( this.bones[ i ] ) {

  				inverse.getInverse( this.bones[ i ].matrixWorld );

  			}

  			this.boneInverses.push( inverse );

  		}

  	},

  	pose: function () {

  		var bone, i, il;

  		// recover the bind-time world matrices

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this.bones[ i ];

  			if ( bone ) {

  				bone.matrixWorld.getInverse( this.boneInverses[ i ] );

  			}

  		}

  		// compute the local matrices, positions, rotations and scales

  		for ( i = 0, il = this.bones.length; i < il; i ++ ) {

  			bone = this.bones[ i ];

  			if ( bone ) {

  				if ( bone.parent && bone.parent.isBone ) {

  					bone.matrix.getInverse( bone.parent.matrixWorld );
  					bone.matrix.multiply( bone.matrixWorld );

  				} else {

  					bone.matrix.copy( bone.matrixWorld );

  				}

  				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

  			}

  		}

  	},

  	update: ( function () {

  		var offsetMatrix = new Matrix4$1();
  		var identityMatrix = new Matrix4$1();

  		return function update() {

  			var bones = this.bones;
  			var boneInverses = this.boneInverses;
  			var boneMatrices = this.boneMatrices;
  			var boneTexture = this.boneTexture;

  			// flatten bone matrices to array

  			for ( var i = 0, il = bones.length; i < il; i ++ ) {

  				// compute the offset between the current and the original transform

  				var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

  				offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
  				offsetMatrix.toArray( boneMatrices, i * 16 );

  			}

  			if ( boneTexture !== undefined ) {

  				boneTexture.needsUpdate = true;

  			}

  		};

  	} )(),

  	clone: function () {

  		return new Skeleton$1( this.bones, this.boneInverses );

  	}

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function Bone$1() {

  	Object3D$1.call( this );

  	this.type = 'Bone';

  }

  Bone$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Bone$1,

  	isBone: true

  } );

  /**
   * @author mikael emtinger / http://gomo.se/
   * @author alteredq / http://alteredqualia.com/
   * @author ikerr / http://verold.com
   */

  function SkinnedMesh$1( geometry, material ) {

  	Mesh$1.call( this, geometry, material );

  	this.type = 'SkinnedMesh';

  	this.bindMode = 'attached';
  	this.bindMatrix = new Matrix4$1();
  	this.bindMatrixInverse = new Matrix4$1();

  	var bones = this.initBones();
  	var skeleton = new Skeleton$1( bones );

  	this.bind( skeleton, this.matrixWorld );

  	this.normalizeSkinWeights();

  }

  SkinnedMesh$1.prototype = Object.assign( Object.create( Mesh$1.prototype ), {

  	constructor: SkinnedMesh$1,

  	isSkinnedMesh: true,

  	initBones: function () {

  		var bones = [], bone, gbone;
  		var i, il;

  		if ( this.geometry && this.geometry.bones !== undefined ) {

  			// first, create array of 'Bone' objects from geometry data

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this.geometry.bones[ i ];

  				// create new 'Bone' object

  				bone = new Bone$1();
  				bones.push( bone );

  				// apply values

  				bone.name = gbone.name;
  				bone.position.fromArray( gbone.pos );
  				bone.quaternion.fromArray( gbone.rotq );
  				if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

  			}

  			// second, create bone hierarchy

  			for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

  				gbone = this.geometry.bones[ i ];

  				if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

  					// subsequent bones in the hierarchy

  					bones[ gbone.parent ].add( bones[ i ] );

  				} else {

  					// topmost bone, immediate child of the skinned mesh

  					this.add( bones[ i ] );

  				}

  			}

  		}

  		// now the bones are part of the scene graph and children of the skinned mesh.
  		// let's update the corresponding matrices

  		this.updateMatrixWorld( true );

  		return bones;

  	},

  	bind: function ( skeleton, bindMatrix ) {

  		this.skeleton = skeleton;

  		if ( bindMatrix === undefined ) {

  			this.updateMatrixWorld( true );

  			this.skeleton.calculateInverses();

  			bindMatrix = this.matrixWorld;

  		}

  		this.bindMatrix.copy( bindMatrix );
  		this.bindMatrixInverse.getInverse( bindMatrix );

  	},

  	pose: function () {

  		this.skeleton.pose();

  	},

  	normalizeSkinWeights: function () {

  		var scale, i;

  		if ( this.geometry && this.geometry.isGeometry ) {

  			for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

  				var sw = this.geometry.skinWeights[ i ];

  				scale = 1.0 / sw.lengthManhattan();

  				if ( scale !== Infinity ) {

  					sw.multiplyScalar( scale );

  				} else {

  					sw.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  			}

  		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

  			var vec = new Vector4$1();

  			var skinWeight = this.geometry.attributes.skinWeight;

  			for ( i = 0; i < skinWeight.count; i ++ ) {

  				vec.x = skinWeight.getX( i );
  				vec.y = skinWeight.getY( i );
  				vec.z = skinWeight.getZ( i );
  				vec.w = skinWeight.getW( i );

  				scale = 1.0 / vec.lengthManhattan();

  				if ( scale !== Infinity ) {

  					vec.multiplyScalar( scale );

  				} else {

  					vec.set( 1, 0, 0, 0 ); // do something reasonable

  				}

  				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

  			}

  		}

  	},

  	updateMatrixWorld: function ( force ) {

  		Mesh$1.prototype.updateMatrixWorld.call( this, force );

  		if ( this.bindMode === 'attached' ) {

  			this.bindMatrixInverse.getInverse( this.matrixWorld );

  		} else if ( this.bindMode === 'detached' ) {

  			this.bindMatrixInverse.getInverse( this.bindMatrix );

  		} else {

  			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

  		}

  	},

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *  linecap: "round",
   *  linejoin: "round"
   * }
   */

  function LineBasicMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'LineBasicMaterial';

  	this.color = new Color$1( 0xffffff );

  	this.linewidth = 1;
  	this.linecap = 'round';
  	this.linejoin = 'round';

  	this.lights = false;

  	this.setValues( parameters );

  }

  LineBasicMaterial$1.prototype = Object.create( Material$1.prototype );
  LineBasicMaterial$1.prototype.constructor = LineBasicMaterial$1;

  LineBasicMaterial$1.prototype.isLineBasicMaterial = true;

  LineBasicMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;
  	this.linecap = source.linecap;
  	this.linejoin = source.linejoin;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Line$2( geometry, material, mode ) {

  	if ( mode === 1 ) {

  		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
  		return new LineSegments$1( geometry, material );

  	}

  	Object3D$1.call( this );

  	this.type = 'Line';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new LineBasicMaterial$1( { color: Math.random() * 0xffffff } );

  }

  Line$2.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Line$2,

  	isLine: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$2();

  		return function raycast( raycaster, intersects ) {

  			var precision = raycaster.linePrecision;
  			var precisionSq = precision * precision;

  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var vStart = new Vector3$1();
  			var vEnd = new Vector3$1();
  			var interSegment = new Vector3$1();
  			var interRay = new Vector3$1();
  			var step = (this && this.isLineSegments) ? 2 : 1;

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

  						var a = indices[ i ];
  						var b = indices[ i + 1 ];

  						vStart.fromArray( positions, a * 3 );
  						vEnd.fromArray( positions, b * 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) continue;

  						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) continue;

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this

  						} );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

  						vStart.fromArray( positions, 3 * i );
  						vEnd.fromArray( positions, 3 * i + 3 );

  						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

  						if ( distSq > precisionSq ) continue;

  						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  						var distance = raycaster.ray.origin.distanceTo( interRay );

  						if ( distance < raycaster.near || distance > raycaster.far ) continue;

  						intersects.push( {

  							distance: distance,
  							// What do we want? intersection point on the ray or on the segment??
  							// point: raycaster.ray.at( distance ),
  							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  							index: i,
  							face: null,
  							faceIndex: null,
  							object: this

  						} );

  					}

  				}

  			} else if ( geometry.isGeometry ) {

  				var vertices = geometry.vertices;
  				var nbVertices = vertices.length;

  				for ( var i = 0; i < nbVertices - 1; i += step ) {

  					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

  					if ( distSq > precisionSq ) continue;

  					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

  					var distance = raycaster.ray.origin.distanceTo( interRay );

  					if ( distance < raycaster.near || distance > raycaster.far ) continue;

  					intersects.push( {

  						distance: distance,
  						// What do we want? intersection point on the ray or on the segment??
  						// point: raycaster.ray.at( distance ),
  						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
  						index: i,
  						face: null,
  						faceIndex: null,
  						object: this

  					} );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LineSegments$1( geometry, material ) {

  	Line$2.call( this, geometry, material );

  	this.type = 'LineSegments';

  }

  LineSegments$1.prototype = Object.assign( Object.create( Line$2.prototype ), {

  	constructor: LineSegments$1,

  	isLineSegments: true

  } );

  /**
   * @author mgreter / http://github.com/mgreter
   */

  function LineLoop$1( geometry, material ) {

  	Line$2.call( this, geometry, material );

  	this.type = 'LineLoop';

  }

  LineLoop$1.prototype = Object.assign( Object.create( Line$2.prototype ), {

  	constructor: LineLoop$1,

  	isLineLoop: true,

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *  map: new THREE.Texture( <Image> ),
   *
   *  size: <float>,
   *  sizeAttenuation: <bool>
   * }
   */

  function PointsMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'PointsMaterial';

  	this.color = new Color$1( 0xffffff );

  	this.map = null;

  	this.size = 1;
  	this.sizeAttenuation = true;

  	this.lights = false;

  	this.setValues( parameters );

  }

  PointsMaterial$1.prototype = Object.create( Material$1.prototype );
  PointsMaterial$1.prototype.constructor = PointsMaterial$1;

  PointsMaterial$1.prototype.isPointsMaterial = true;

  PointsMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.size = source.size;
  	this.sizeAttenuation = source.sizeAttenuation;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Points$1( geometry, material ) {

  	Object3D$1.call( this );

  	this.type = 'Points';

  	this.geometry = geometry !== undefined ? geometry : new BufferGeometry$1();
  	this.material = material !== undefined ? material : new PointsMaterial$1( { color: Math.random() * 0xffffff } );

  }

  Points$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Points$1,

  	isPoints: true,

  	raycast: ( function () {

  		var inverseMatrix = new Matrix4$1();
  		var ray = new Ray$1();
  		var sphere = new Sphere$2();

  		return function raycast( raycaster, intersects ) {

  			var object = this;
  			var geometry = this.geometry;
  			var matrixWorld = this.matrixWorld;
  			var threshold = raycaster.params.Points.threshold;

  			// Checking boundingSphere distance to ray

  			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

  			sphere.copy( geometry.boundingSphere );
  			sphere.applyMatrix4( matrixWorld );
  			sphere.radius += threshold;

  			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

  			//

  			inverseMatrix.getInverse( matrixWorld );
  			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

  			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
  			var localThresholdSq = localThreshold * localThreshold;
  			var position = new Vector3$1();

  			function testPoint( point, index ) {

  				var rayPointDistanceSq = ray.distanceSqToPoint( point );

  				if ( rayPointDistanceSq < localThresholdSq ) {

  					var intersectPoint = ray.closestPointToPoint( point );
  					intersectPoint.applyMatrix4( matrixWorld );

  					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

  					if ( distance < raycaster.near || distance > raycaster.far ) return;

  					intersects.push( {

  						distance: distance,
  						distanceToRay: Math.sqrt( rayPointDistanceSq ),
  						point: intersectPoint.clone(),
  						index: index,
  						face: null,
  						object: object

  					} );

  				}

  			}

  			if ( geometry.isBufferGeometry ) {

  				var index = geometry.index;
  				var attributes = geometry.attributes;
  				var positions = attributes.position.array;

  				if ( index !== null ) {

  					var indices = index.array;

  					for ( var i = 0, il = indices.length; i < il; i ++ ) {

  						var a = indices[ i ];

  						position.fromArray( positions, a * 3 );

  						testPoint( position, a );

  					}

  				} else {

  					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

  						position.fromArray( positions, i * 3 );

  						testPoint( position, i );

  					}

  				}

  			} else {

  				var vertices = geometry.vertices;

  				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

  					testPoint( vertices[ i ], i );

  				}

  			}

  		};

  	}() ),

  	clone: function () {

  		return new this.constructor( this.geometry, this.material ).copy( this );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Group$2() {

  	Object3D$1.call( this );

  	this.type = 'Group';

  }

  Group$2.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Group$2

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function VideoTexture$1( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture$1.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.generateMipmaps = false;

  	var scope = this;

  	function update() {

  		requestAnimationFrame( update );

  		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

  			scope.needsUpdate = true;

  		}

  	}

  	update();

  }

  VideoTexture$1.prototype = Object.create( Texture$1.prototype );
  VideoTexture$1.prototype.constructor = VideoTexture$1;

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function CompressedTexture$1( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

  	this.image = { width: width, height: height };
  	this.mipmaps = mipmaps;

  	// no flipping for cube textures
  	// (also flipping doesn't work for compressed textures )

  	this.flipY = false;

  	// can't generate mipmaps for compressed textures
  	// mips must be embedded in DDS files

  	this.generateMipmaps = false;

  }

  CompressedTexture$1.prototype = Object.create( Texture$1.prototype );
  CompressedTexture$1.prototype.constructor = CompressedTexture$1;

  CompressedTexture$1.prototype.isCompressedTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CanvasTexture$1( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  	Texture$1.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.needsUpdate = true;

  }

  CanvasTexture$1.prototype = Object.create( Texture$1.prototype );
  CanvasTexture$1.prototype.constructor = CanvasTexture$1;

  /**
   * @author Matt DesLauriers / @mattdesl
   * @author atix / arthursilber.de
   */

  function DepthTexture$1( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

  	format = format !== undefined ? format : DepthFormat$1;

  	if ( format !== DepthFormat$1 && format !== DepthStencilFormat$1 ) {

  		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

  	}

  	if ( type === undefined && format === DepthFormat$1 ) type = UnsignedShortType$1;
  	if ( type === undefined && format === DepthStencilFormat$1 ) type = UnsignedInt248Type$1;

  	Texture$1.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  	this.image = { width: width, height: height };

  	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter$1;
  	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter$1;

  	this.flipY = false;
  	this.generateMipmaps	= false;

  }

  DepthTexture$1.prototype = Object.create( Texture$1.prototype );
  DepthTexture$1.prototype.constructor = DepthTexture$1;
  DepthTexture$1.prototype.isDepthTexture = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function WireframeGeometry$1( geometry ) {

  	BufferGeometry$1.call( this );

  	this.type = 'WireframeGeometry';

  	// buffer

  	var vertices = [];

  	// helper variables

  	var i, j, l, o, ol;
  	var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];
  	var vertex;

  	// different logic for Geometry and BufferGeometry

  	if ( geometry && geometry.isGeometry ) {

  		// create a data structure that contains all edges without duplicates

  		var faces = geometry.faces;

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			for ( j = 0; j < 3; j ++ ) {

  				edge1 = face[ keys[ j ] ];
  				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  				edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  				edge[ 1 ] = Math.max( edge1, edge2 );

  				key = edge[ 0 ] + ',' + edge[ 1 ];

  				if ( edges[ key ] === undefined ) {

  					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  				}

  			}

  		}

  		// generate vertices

  		for ( key in edges ) {

  			e = edges[ key ];

  			vertex = geometry.vertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = geometry.vertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	} else if ( geometry && geometry.isBufferGeometry ) {

  		var position, indices, groups;
  		var group, start, count;
  		var index1, index2;

  		vertex = new Vector3$1();

  		if ( geometry.index !== null ) {

  			// indexed BufferGeometry

  			position = geometry.attributes.position;
  			indices = geometry.index;
  			groups = geometry.groups;

  			if ( groups.length === 0 ) {

  				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

  			}

  			// create a data structure that contains all eges without duplicates

  			for ( o = 0, ol = groups.length; o < ol; ++ o ) {

  				group = groups[ o ];

  				start = group.start;
  				count = group.count;

  				for ( i = start, l = ( start + count ); i < l; i += 3 ) {

  					for ( j = 0; j < 3; j ++ ) {

  						edge1 = indices.getX( i + j );
  						edge2 = indices.getX( i + ( j + 1 ) % 3 );
  						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
  						edge[ 1 ] = Math.max( edge1, edge2 );

  						key = edge[ 0 ] + ',' + edge[ 1 ];

  						if ( edges[ key ] === undefined ) {

  							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

  						}

  					}

  				}

  			}

  			// generate vertices

  			for ( key in edges ) {

  				e = edges[ key ];

  				vertex.fromBufferAttribute( position, e.index1 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				vertex.fromBufferAttribute( position, e.index2 );
  				vertices.push( vertex.x, vertex.y, vertex.z );

  			}

  		} else {

  			// non-indexed BufferGeometry

  			position = geometry.attributes.position;

  			for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

  				for ( j = 0; j < 3; j ++ ) {

  					// three edges per triangle, an edge is represented as (index1, index2)
  					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

  					index1 = 3 * i + j;
  					vertex.fromBufferAttribute( position, index1 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  					index2 = 3 * i + ( ( j + 1 ) % 3 );
  					vertex.fromBufferAttribute( position, index2 );
  					vertices.push( vertex.x, vertex.y, vertex.z );

  				}

  			}

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );

  }

  WireframeGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  WireframeGeometry$1.prototype.constructor = WireframeGeometry$1;

  /**
   * @author zz85 / https://github.com/zz85
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Parametric Surfaces Geometry
   * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
   */

  // ParametricGeometry

  function ParametricGeometry$1( func, slices, stacks ) {

  	Geometry$1.call( this );

  	this.type = 'ParametricGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	this.fromBufferGeometry( new ParametricBufferGeometry$1( func, slices, stacks ) );
  	this.mergeVertices();

  }

  ParametricGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ParametricGeometry$1.prototype.constructor = ParametricGeometry$1;

  // ParametricBufferGeometry

  function ParametricBufferGeometry$1( func, slices, stacks ) {

  	BufferGeometry$1.call( this );

  	this.type = 'ParametricBufferGeometry';

  	this.parameters = {
  		func: func,
  		slices: slices,
  		stacks: stacks
  	};

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	var EPS = 0.00001;

  	var normal = new Vector3$1();

  	var p0 = new Vector3$1(), p1 = new Vector3$1();
  	var pu = new Vector3$1(), pv = new Vector3$1();

  	var i, j;

  	// generate vertices, normals and uvs

  	var sliceCount = slices + 1;

  	for ( i = 0; i <= stacks; i ++ ) {

  		var v = i / stacks;

  		for ( j = 0; j <= slices; j ++ ) {

  			var u = j / slices;

  			// vertex

  			p0 = func( u, v, p0 );
  			vertices.push( p0.x, p0.y, p0.z );

  			// normal

  			// approximate tangent vectors via finite differences

  			if ( u - EPS >= 0 ) {

  				p1 = func( u - EPS, v, p1 );
  				pu.subVectors( p0, p1 );

  			} else {

  				p1 = func( u + EPS, v, p1 );
  				pu.subVectors( p1, p0 );

  			}

  			if ( v - EPS >= 0 ) {

  				p1 = func( u, v - EPS, p1 );
  				pv.subVectors( p0, p1 );

  			} else {

  				p1 = func( u, v + EPS, p1 );
  				pv.subVectors( p1, p0 );

  			}

  			// cross product of tangent vectors returns surface normal

  			normal.crossVectors( pu, pv ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, v );

  		}

  	}

  	// generate indices

  	for ( i = 0; i < stacks; i ++ ) {

  		for ( j = 0; j < slices; j ++ ) {

  			var a = i * sliceCount + j;
  			var b = i * sliceCount + j + 1;
  			var c = ( i + 1 ) * sliceCount + j + 1;
  			var d = ( i + 1 ) * sliceCount + j;

  			// faces one and two

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  ParametricBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ParametricBufferGeometry$1.prototype.constructor = ParametricBufferGeometry$1;

  /**
   * @author clockworkgeek / https://github.com/clockworkgeek
   * @author timothypratley / https://github.com/timothypratley
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // PolyhedronGeometry

  function PolyhedronGeometry$1( vertices, indices, radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'PolyhedronGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new PolyhedronBufferGeometry$1( vertices, indices, radius, detail ) );
  	this.mergeVertices();

  }

  PolyhedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  PolyhedronGeometry$1.prototype.constructor = PolyhedronGeometry$1;

  // PolyhedronBufferGeometry

  function PolyhedronBufferGeometry$1( vertices, indices, radius, detail ) {

  	BufferGeometry$1.call( this );

  	this.type = 'PolyhedronBufferGeometry';

  	this.parameters = {
  		vertices: vertices,
  		indices: indices,
  		radius: radius,
  		detail: detail
  	};

  	radius = radius || 1;
  	detail = detail || 0;

  	// default buffer data

  	var vertexBuffer = [];
  	var uvBuffer = [];

  	// the subdivision creates the vertex buffer data

  	subdivide( detail );

  	// all vertices should lie on a conceptual sphere with a given radius

  	appplyRadius( radius );

  	// finally, create the uv data

  	generateUVs();

  	// build non-indexed geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertexBuffer, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( vertexBuffer.slice(), 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvBuffer, 2 ) );
  	this.normalizeNormals();

  	// helper functions

  	function subdivide( detail ) {

  		var a = new Vector3$1();
  		var b = new Vector3$1();
  		var c = new Vector3$1();

  		// iterate over all faces and apply a subdivison with the given detail value

  		for ( var i = 0; i < indices.length; i += 3 ) {

  			// get the vertices of the face

  			getVertexByIndex( indices[ i + 0 ], a );
  			getVertexByIndex( indices[ i + 1 ], b );
  			getVertexByIndex( indices[ i + 2 ], c );

  			// perform subdivision

  			subdivideFace( a, b, c, detail );

  		}

  	}

  	function subdivideFace( a, b, c, detail ) {

  		var cols = Math.pow( 2, detail );

  		// we use this multidimensional array as a data structure for creating the subdivision

  		var v = [];

  		var i, j;

  		// construct all of the vertices for this subdivision

  		for ( i = 0; i <= cols; i ++ ) {

  			v[ i ] = [];

  			var aj = a.clone().lerp( c, i / cols );
  			var bj = b.clone().lerp( c, i / cols );

  			var rows = cols - i;

  			for ( j = 0; j <= rows; j ++ ) {

  				if ( j === 0 && i === cols ) {

  					v[ i ][ j ] = aj;

  				} else {

  					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

  				}

  			}

  		}

  		// construct all of the faces

  		for ( i = 0; i < cols; i ++ ) {

  			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

  				var k = Math.floor( j / 2 );

  				if ( j % 2 === 0 ) {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );
  					pushVertex( v[ i ][ k ] );

  				} else {

  					pushVertex( v[ i ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k + 1 ] );
  					pushVertex( v[ i + 1 ][ k ] );

  				}

  			}

  		}

  	}

  	function appplyRadius( radius ) {

  		var vertex = new Vector3$1();

  		// iterate over the entire buffer and apply the radius to each vertex

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			vertex.normalize().multiplyScalar( radius );

  			vertexBuffer[ i + 0 ] = vertex.x;
  			vertexBuffer[ i + 1 ] = vertex.y;
  			vertexBuffer[ i + 2 ] = vertex.z;

  		}

  	}

  	function generateUVs() {

  		var vertex = new Vector3$1();

  		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

  			vertex.x = vertexBuffer[ i + 0 ];
  			vertex.y = vertexBuffer[ i + 1 ];
  			vertex.z = vertexBuffer[ i + 2 ];

  			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
  			var v = inclination( vertex ) / Math.PI + 0.5;
  			uvBuffer.push( u, 1 - v );

  		}

  		correctUVs();

  		correctSeam();

  	}

  	function correctSeam() {

  		// handle case when face straddles the seam, see #3269

  		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

  			// uv data of a single face

  			var x0 = uvBuffer[ i + 0 ];
  			var x1 = uvBuffer[ i + 2 ];
  			var x2 = uvBuffer[ i + 4 ];

  			var max = Math.max( x0, x1, x2 );
  			var min = Math.min( x0, x1, x2 );

  			// 0.9 is somewhat arbitrary

  			if ( max > 0.9 && min < 0.1 ) {

  				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
  				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
  				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

  			}

  		}

  	}

  	function pushVertex( vertex ) {

  		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

  	}

  	function getVertexByIndex( index, vertex ) {

  		var stride = index * 3;

  		vertex.x = vertices[ stride + 0 ];
  		vertex.y = vertices[ stride + 1 ];
  		vertex.z = vertices[ stride + 2 ];

  	}

  	function correctUVs() {

  		var a = new Vector3$1();
  		var b = new Vector3$1();
  		var c = new Vector3$1();

  		var centroid = new Vector3$1();

  		var uvA = new Vector2$1();
  		var uvB = new Vector2$1();
  		var uvC = new Vector2$1();

  		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

  			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
  			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
  			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

  			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
  			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
  			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

  			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

  			var azi = azimuth( centroid );

  			correctUV( uvA, j + 0, a, azi );
  			correctUV( uvB, j + 2, b, azi );
  			correctUV( uvC, j + 4, c, azi );

  		}

  	}

  	function correctUV( uv, stride, vector, azimuth ) {

  		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

  			uvBuffer[ stride ] = uv.x - 1;

  		}

  		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

  			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

  		}

  	}

  	// Angle around the Y axis, counter-clockwise when looking from above.

  	function azimuth( vector ) {

  		return Math.atan2( vector.z, - vector.x );

  	}


  	// Angle above the XZ plane.

  	function inclination( vector ) {

  		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  	}

  }

  PolyhedronBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  PolyhedronBufferGeometry$1.prototype.constructor = PolyhedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TetrahedronGeometry

  function TetrahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'TetrahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new TetrahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  TetrahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TetrahedronGeometry$1.prototype.constructor = TetrahedronGeometry$1;

  // TetrahedronBufferGeometry

  function TetrahedronBufferGeometry$1( radius, detail ) {

  	var vertices = [
  		1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  	];

  	var indices = [
  		2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'TetrahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  TetrahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  TetrahedronBufferGeometry$1.prototype.constructor = TetrahedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // OctahedronGeometry

  function OctahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'OctahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new OctahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  OctahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  OctahedronGeometry$1.prototype.constructor = OctahedronGeometry$1;

  // OctahedronBufferGeometry

  function OctahedronBufferGeometry$1( radius, detail ) {

  	var vertices = [
  		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
  	];

  	var indices = [
  		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'OctahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  OctahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  OctahedronBufferGeometry$1.prototype.constructor = OctahedronBufferGeometry$1;

  /**
   * @author timothypratley / https://github.com/timothypratley
   * @author Mugen87 / https://github.com/Mugen87
   */

  // IcosahedronGeometry

  function IcosahedronGeometry$1( radius, detail ) {

   	Geometry$1.call( this );

  	this.type = 'IcosahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new IcosahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  IcosahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  IcosahedronGeometry$1.prototype.constructor = IcosahedronGeometry$1;

  // IcosahedronBufferGeometry

  function IcosahedronBufferGeometry$1( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  	var vertices = [
  		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
  		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
  		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  	];

  	var indices = [
  		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
  		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
  		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
  		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'IcosahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  IcosahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  IcosahedronBufferGeometry$1.prototype.constructor = IcosahedronBufferGeometry$1;

  /**
   * @author Abe Pazos / https://hamoid.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // DodecahedronGeometry

  function DodecahedronGeometry$1( radius, detail ) {

  	Geometry$1.call( this );

  	this.type = 'DodecahedronGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  	this.fromBufferGeometry( new DodecahedronBufferGeometry$1( radius, detail ) );
  	this.mergeVertices();

  }

  DodecahedronGeometry$1.prototype = Object.create( Geometry$1.prototype );
  DodecahedronGeometry$1.prototype.constructor = DodecahedronGeometry$1;

  // DodecahedronBufferGeometry

  function DodecahedronBufferGeometry$1( radius, detail ) {

  	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  	var r = 1 / t;

  	var vertices = [

  		// (Â±1, Â±1, Â±1)
  		- 1, - 1, - 1,    - 1, - 1,  1,
  		- 1,  1, - 1,    - 1,  1,  1,
  		  1, - 1, - 1,     1, - 1,  1,
  		  1,  1, - 1,     1,  1,  1,

  		// (0, Â±1/Ï, Â±Ï)
  		 0, - r, - t,     0, - r,  t,
  		 0,  r, - t,     0,  r,  t,

  		// (Â±1/Ï, Â±Ï, 0)
  		- r, - t,  0,    - r,  t,  0,
  		 r, - t,  0,     r,  t,  0,

  		// (Â±Ï, 0, Â±1/Ï)
  		- t,  0, - r,     t,  0, - r,
  		- t,  0,  r,     t,  0,  r
  	];

  	var indices = [
  		 3, 11,  7,      3,  7, 15,      3, 15, 13,
  		 7, 19, 17,      7, 17,  6,      7,  6, 15,
  		17,  4,  8,     17,  8, 10,     17, 10,  6,
  		 8,  0, 16,      8, 16,  2,      8,  2, 10,
  		 0, 12,  1,      0,  1, 18,      0, 18, 16,
  		 6, 10,  2,      6,  2, 13,      6, 13, 15,
  		 2, 16, 18,      2, 18,  3,      2,  3, 13,
  		18,  1,  9,     18,  9, 11,     18, 11,  3,
  		 4, 14, 12,      4, 12,  0,      4,  0,  8,
  		11,  9,  5,     11,  5, 19,     11, 19,  7,
  		19,  5, 14,     19, 14,  4,     19,  4, 17,
  		 1, 12, 14,      1, 14,  5,      1,  5,  9
  	];

  	PolyhedronBufferGeometry$1.call( this, vertices, indices, radius, detail );

  	this.type = 'DodecahedronBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		detail: detail
  	};

  }

  DodecahedronBufferGeometry$1.prototype = Object.create( PolyhedronBufferGeometry$1.prototype );
  DodecahedronBufferGeometry$1.prototype.constructor = DodecahedronBufferGeometry$1;

  /**
   * @author oosmoxiecode / https://github.com/oosmoxiecode
   * @author WestLangley / https://github.com/WestLangley
   * @author zz85 / https://github.com/zz85
   * @author miningold / https://github.com/miningold
   * @author jonobr1 / https://github.com/jonobr1
   * @author Mugen87 / https://github.com/Mugen87
   *
   */

  // TubeGeometry

  function TubeGeometry$1( path, tubularSegments, radius, radialSegments, closed, taper ) {

  	Geometry$1.call( this );

  	this.type = 'TubeGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

  	var bufferGeometry = new TubeBufferGeometry$1( path, tubularSegments, radius, radialSegments, closed );

  	// expose internals

  	this.tangents = bufferGeometry.tangents;
  	this.normals = bufferGeometry.normals;
  	this.binormals = bufferGeometry.binormals;

  	// create geometry

  	this.fromBufferGeometry( bufferGeometry );
  	this.mergeVertices();

  }

  TubeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TubeGeometry$1.prototype.constructor = TubeGeometry$1;

  // TubeBufferGeometry

  function TubeBufferGeometry$1( path, tubularSegments, radius, radialSegments, closed ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TubeBufferGeometry';

  	this.parameters = {
  		path: path,
  		tubularSegments: tubularSegments,
  		radius: radius,
  		radialSegments: radialSegments,
  		closed: closed
  	};

  	tubularSegments = tubularSegments || 64;
  	radius = radius || 1;
  	radialSegments = radialSegments || 8;
  	closed = closed || false;

  	var frames = path.computeFrenetFrames( tubularSegments, closed );

  	// expose internals

  	this.tangents = frames.tangents;
  	this.normals = frames.normals;
  	this.binormals = frames.binormals;

  	// helper variables

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();
  	var uv = new Vector2$1();

  	var i, j;

  	// buffer

  	var vertices = [];
  	var normals = [];
  	var uvs = [];
  	var indices = [];

  	// create buffer data

  	generateBufferData();

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// functions

  	function generateBufferData() {

  		for ( i = 0; i < tubularSegments; i ++ ) {

  			generateSegment( i );

  		}

  		// if the geometry is not closed, generate the last row of vertices and normals
  		// at the regular position on the given path
  		//
  		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

  		generateSegment( ( closed === false ) ? tubularSegments : 0 );

  		// uvs are generated in a separate function.
  		// this makes it easy compute correct values for closed geometries

  		generateUVs();

  		// finally create faces

  		generateIndices();

  	}

  	function generateSegment( i ) {

  		// we use getPointAt to sample evenly distributed points from the given path

  		var P = path.getPointAt( i / tubularSegments );

  		// retrieve corresponding normal and binormal

  		var N = frames.normals[ i ];
  		var B = frames.binormals[ i ];

  		// generate normals and vertices for the current segment

  		for ( j = 0; j <= radialSegments; j ++ ) {

  			var v = j / radialSegments * Math.PI * 2;

  			var sin =   Math.sin( v );
  			var cos = - Math.cos( v );

  			// normal

  			normal.x = ( cos * N.x + sin * B.x );
  			normal.y = ( cos * N.y + sin * B.y );
  			normal.z = ( cos * N.z + sin * B.z );
  			normal.normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// vertex

  			vertex.x = P.x + radius * normal.x;
  			vertex.y = P.y + radius * normal.y;
  			vertex.z = P.z + radius * normal.z;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	function generateIndices() {

  		for ( j = 1; j <= tubularSegments; j ++ ) {

  			for ( i = 1; i <= radialSegments; i ++ ) {

  				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  				var b = ( radialSegments + 1 ) * j + ( i - 1 );
  				var c = ( radialSegments + 1 ) * j + i;
  				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  			}

  		}

  	}

  	function generateUVs() {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			for ( j = 0; j <= radialSegments; j ++ ) {

  				uv.x = i / tubularSegments;
  				uv.y = j / radialSegments;

  				uvs.push( uv.x, uv.y );

  			}

  		}

  	}

  }

  TubeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TubeBufferGeometry$1.prototype.constructor = TubeBufferGeometry$1;

  /**
   * @author oosmoxiecode
   * @author Mugen87 / https://github.com/Mugen87
   *
   * based on http://www.blackpawn.com/texts/pqtorus/
   */

  // TorusKnotGeometry

  function TorusKnotGeometry$1( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

  	Geometry$1.call( this );

  	this.type = 'TorusKnotGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

  	this.fromBufferGeometry( new TorusKnotBufferGeometry$1( radius, tube, tubularSegments, radialSegments, p, q ) );
  	this.mergeVertices();

  }

  TorusKnotGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TorusKnotGeometry$1.prototype.constructor = TorusKnotGeometry$1;

  // TorusKnotBufferGeometry

  function TorusKnotBufferGeometry$1( radius, tube, tubularSegments, radialSegments, p, q ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TorusKnotBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		tubularSegments: tubularSegments,
  		radialSegments: radialSegments,
  		p: p,
  		q: q
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	tubularSegments = Math.floor( tubularSegments ) || 64;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	p = p || 2;
  	q = q || 3;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, j;

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	var P1 = new Vector3$1();
  	var P2 = new Vector3$1();

  	var B = new Vector3$1();
  	var T = new Vector3$1();
  	var N = new Vector3$1();

  	// generate vertices, normals and uvs

  	for ( i = 0; i <= tubularSegments; ++ i ) {

  		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

  		var u = i / tubularSegments * p * Math.PI * 2;

  		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
  		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

  		calculatePositionOnCurve( u, p, q, radius, P1 );
  		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

  		// calculate orthonormal basis

  		T.subVectors( P2, P1 );
  		N.addVectors( P2, P1 );
  		B.crossVectors( T, N );
  		N.crossVectors( B, T );

  		// normalize B, N. T can be ignored, we don't use it

  		B.normalize();
  		N.normalize();

  		for ( j = 0; j <= radialSegments; ++ j ) {

  			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
  			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

  			var v = j / radialSegments * Math.PI * 2;
  			var cx = - tube * Math.cos( v );
  			var cy = tube * Math.sin( v );

  			// now calculate the final vertex position.
  			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

  			vertex.x = P1.x + ( cx * N.x + cy * B.x );
  			vertex.y = P1.y + ( cx * N.y + cy * B.y );
  			vertex.z = P1.z + ( cx * N.z + cy * B.z );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

  			normal.subVectors( vertex, P1 ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= tubularSegments; j ++ ) {

  		for ( i = 1; i <= radialSegments; i ++ ) {

  			// indices

  			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
  			var b = ( radialSegments + 1 ) * j + ( i - 1 );
  			var c = ( radialSegments + 1 ) * j + i;
  			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// this function calculates the current position on the torus curve

  	function calculatePositionOnCurve( u, p, q, radius, position ) {

  		var cu = Math.cos( u );
  		var su = Math.sin( u );
  		var quOverP = q / p * u;
  		var cs = Math.cos( quOverP );

  		position.x = radius * ( 2 + cs ) * 0.5 * cu;
  		position.y = radius * ( 2 + cs ) * su * 0.5;
  		position.z = radius * Math.sin( quOverP ) * 0.5;

  	}

  }

  TorusKnotBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TorusKnotBufferGeometry$1.prototype.constructor = TorusKnotBufferGeometry$1;

  /**
   * @author oosmoxiecode
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // TorusGeometry

  function TorusGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) {

  	Geometry$1.call( this );

  	this.type = 'TorusGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	this.fromBufferGeometry( new TorusBufferGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) );
  	this.mergeVertices();

  }

  TorusGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TorusGeometry$1.prototype.constructor = TorusGeometry$1;

  // TorusBufferGeometry

  function TorusBufferGeometry$1( radius, tube, radialSegments, tubularSegments, arc ) {

  	BufferGeometry$1.call( this );

  	this.type = 'TorusBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		tube: tube,
  		radialSegments: radialSegments,
  		tubularSegments: tubularSegments,
  		arc: arc
  	};

  	radius = radius || 100;
  	tube = tube || 40;
  	radialSegments = Math.floor( radialSegments ) || 8;
  	tubularSegments = Math.floor( tubularSegments ) || 6;
  	arc = arc || Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var center = new Vector3$1();
  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= radialSegments; j ++ ) {

  		for ( i = 0; i <= tubularSegments; i ++ ) {

  			var u = i / tubularSegments * arc;
  			var v = j / radialSegments * Math.PI * 2;

  			// vertex

  			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
  			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
  			vertex.z = tube * Math.sin( v );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			center.x = radius * Math.cos( u );
  			center.y = radius * Math.sin( u );
  			normal.subVectors( vertex, center ).normalize();

  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( i / tubularSegments );
  			uvs.push( j / radialSegments );

  		}

  	}

  	// generate indices

  	for ( j = 1; j <= radialSegments; j ++ ) {

  		for ( i = 1; i <= tubularSegments; i ++ ) {

  			// indices

  			var a = ( tubularSegments + 1 ) * j + i - 1;
  			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
  			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
  			var d = ( tubularSegments + 1 ) * j + i;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  TorusBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  TorusBufferGeometry$1.prototype.constructor = TorusBufferGeometry$1;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   */

  var ShapeUtils$1 = {

  	// calculate area of the contour polygon

  	area: function ( contour ) {

  		var n = contour.length;
  		var a = 0.0;

  		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

  			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

  		}

  		return a * 0.5;

  	},

  	triangulate: ( function () {

  		/**
  		 * This code is a quick port of code written in C++ which was submitted to
  		 * flipcode.com by John W. Ratcliff  // July 22, 2000
  		 * See original code and more information here:
  		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
  		 *
  		 * ported to actionscript by Zevan Rosser
  		 * www.actionsnippet.com
  		 *
  		 * ported to javascript by Joshua Koo
  		 * http://www.lab4games.net/zz85/blog
  		 *
  		 */

  		function snip( contour, u, v, w, n, verts ) {

  			var p;
  			var ax, ay, bx, by;
  			var cx, cy, px, py;

  			ax = contour[ verts[ u ] ].x;
  			ay = contour[ verts[ u ] ].y;

  			bx = contour[ verts[ v ] ].x;
  			by = contour[ verts[ v ] ].y;

  			cx = contour[ verts[ w ] ].x;
  			cy = contour[ verts[ w ] ].y;

  			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

  			var aX, aY, bX, bY, cX, cY;
  			var apx, apy, bpx, bpy, cpx, cpy;
  			var cCROSSap, bCROSScp, aCROSSbp;

  			aX = cx - bx;  aY = cy - by;
  			bX = ax - cx;  bY = ay - cy;
  			cX = bx - ax;  cY = by - ay;

  			for ( p = 0; p < n; p ++ ) {

  				px = contour[ verts[ p ] ].x;
  				py = contour[ verts[ p ] ].y;

  				if ( ( ( px === ax ) && ( py === ay ) ) ||
  					 ( ( px === bx ) && ( py === by ) ) ||
  					 ( ( px === cx ) && ( py === cy ) ) )	continue;

  				apx = px - ax;  apy = py - ay;
  				bpx = px - bx;  bpy = py - by;
  				cpx = px - cx;  cpy = py - cy;

  				// see if p is inside triangle abc

  				aCROSSbp = aX * bpy - aY * bpx;
  				cCROSSap = cX * apy - cY * apx;
  				bCROSScp = bX * cpy - bY * cpx;

  				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

  			}

  			return true;

  		}

  		// takes in an contour array and returns

  		return function triangulate( contour, indices ) {

  			var n = contour.length;

  			if ( n < 3 ) return null;

  			var result = [],
  				verts = [],
  				vertIndices = [];

  			/* we want a counter-clockwise polygon in verts */

  			var u, v, w;

  			if ( ShapeUtils$1.area( contour ) > 0.0 ) {

  				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

  			} else {

  				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

  			}

  			var nv = n;

  			/*  remove nv - 2 vertices, creating 1 triangle every time */

  			var count = 2 * nv;   /* error detection */

  			for ( v = nv - 1; nv > 2; ) {

  				/* if we loop, it is probably a non-simple polygon */

  				if ( ( count -- ) <= 0 ) {

  					//** Triangulate: ERROR - probable bad polygon!

  					//throw ( "Warning, unable to triangulate polygon!" );
  					//return null;
  					// Sometimes warning is fine, especially polygons are triangulated in reverse.
  					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

  					if ( indices ) return vertIndices;
  					return result;

  				}

  				/* three consecutive vertices in current polygon, <u,v,w> */

  				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
  				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
  				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

  				if ( snip( contour, u, v, w, nv, verts ) ) {

  					var a, b, c, s, t;

  					/* true names of the vertices */

  					a = verts[ u ];
  					b = verts[ v ];
  					c = verts[ w ];

  					/* output Triangle */

  					result.push( [ contour[ a ],
  						contour[ b ],
  						contour[ c ] ] );


  					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

  					/* remove v from the remaining polygon */

  					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

  						verts[ s ] = verts[ t ];

  					}

  					nv --;

  					/* reset error detection counter */

  					count = 2 * nv;

  				}

  			}

  			if ( indices ) return vertIndices;
  			return result;

  		}

  	} )(),

  	triangulateShape: function ( contour, holes ) {

  		function removeDupEndPts(points) {

  			var l = points.length;

  			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

  				points.pop();

  			}

  		}

  		removeDupEndPts( contour );
  		holes.forEach( removeDupEndPts );

  		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

  			// inOtherPt needs to be collinear to the inSegment
  			if ( inSegPt1.x !== inSegPt2.x ) {

  				if ( inSegPt1.x < inSegPt2.x ) {

  					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

  				} else {

  					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

  				}

  			} else {

  				if ( inSegPt1.y < inSegPt2.y ) {

  					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

  				} else {

  					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

  				}

  			}

  		}

  		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

  			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
  			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

  			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
  			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

  			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
  			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

  			if ( Math.abs( limit ) > Number.EPSILON ) {

  				// not parallel

  				var perpSeg2;
  				if ( limit > 0 ) {

  					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

  				} else {

  					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
  					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
  					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

  				}

  				// i.e. to reduce rounding errors
  				// intersection at endpoint of segment#1?
  				if ( perpSeg2 === 0 ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
  					return [ inSeg1Pt1 ];

  				}
  				if ( perpSeg2 === limit ) {

  					if ( ( inExcludeAdjacentSegs ) &&
  						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
  					return [ inSeg1Pt2 ];

  				}
  				// intersection at endpoint of segment#2?
  				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
  				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

  				// return real intersection point
  				var factorSeg1 = perpSeg2 / limit;
  				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
  							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

  			} else {

  				// parallel or collinear
  				if ( ( perpSeg1 !== 0 ) ||
  					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

  				// they are collinear or degenerate
  				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
  				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
  				// both segments are points
  				if ( seg1Pt && seg2Pt ) {

  					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
  						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
  					return [ inSeg1Pt1 ];                 						// they are the same point

  				}
  				// segment#1  is a single point
  				if ( seg1Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
  					return [ inSeg1Pt1 ];

  				}
  				// segment#2  is a single point
  				if ( seg2Pt ) {

  					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
  					return [ inSeg2Pt1 ];

  				}

  				// they are collinear segments, which might overlap
  				var seg1min, seg1max, seg1minVal, seg1maxVal;
  				var seg2min, seg2max, seg2minVal, seg2maxVal;
  				if ( seg1dx !== 0 ) {

  					// the segments are NOT on a vertical line
  					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

  					}
  					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

  					}

  				} else {

  					// the segments are on a vertical line
  					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

  						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
  						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

  					} else {

  						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
  						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

  					}
  					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

  						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
  						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

  					} else {

  						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
  						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

  					}

  				}
  				if ( seg1minVal <= seg2minVal ) {

  					if ( seg1maxVal <  seg2minVal )	return [];
  					if ( seg1maxVal === seg2minVal )	{

  						if ( inExcludeAdjacentSegs )		return [];
  						return [ seg2min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
  					return	[ seg2min, seg2max ];

  				} else {

  					if ( seg1minVal >  seg2maxVal )	return [];
  					if ( seg1minVal === seg2maxVal )	{

  						if ( inExcludeAdjacentSegs )		return [];
  						return [ seg1min ];

  					}
  					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
  					return	[ seg1min, seg2max ];

  				}

  			}

  		}

  		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

  			// The order of legs is important

  			// translation of all points, so that Vertex is at (0,0)
  			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
  			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
  			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

  			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
  			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
  			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

  			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

  				// angle != 180 deg.

  				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
  				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

  				if ( from2toAngle > 0 ) {

  					// main angle < 180 deg.
  					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

  				} else {

  					// main angle > 180 deg.
  					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

  				}

  			} else {

  				// angle == 180 deg.
  				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
  				return	( from2otherAngle > 0 );

  			}

  		}


  		function removeHoles( contour, holes ) {

  			var shape = contour.concat(); // work on this shape
  			var hole;

  			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

  				// Check if hole point lies within angle around shape point
  				var lastShapeIdx = shape.length - 1;

  				var prevShapeIdx = inShapeIdx - 1;
  				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

  				var nextShapeIdx = inShapeIdx + 1;
  				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

  				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
  					return	false;

  				}

  				// Check if shape point lies within angle around hole point
  				var lastHoleIdx = hole.length - 1;

  				var prevHoleIdx = inHoleIdx - 1;
  				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

  				var nextHoleIdx = inHoleIdx + 1;
  				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

  				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
  				if ( ! insideAngle ) {

  					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
  					return	false;

  				}

  				return	true;

  			}

  			function intersectsShapeEdge( inShapePt, inHolePt ) {

  				// checks for intersections with shape edges
  				var sIdx, nextIdx, intersection;
  				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

  					nextIdx = sIdx + 1; nextIdx %= shape.length;
  					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
  					if ( intersection.length > 0 )		return	true;

  				}

  				return	false;

  			}

  			var indepHoles = [];

  			function intersectsHoleEdge( inShapePt, inHolePt ) {

  				// checks for intersections with hole edges
  				var ihIdx, chkHole,
  					hIdx, nextIdx, intersection;
  				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

  					chkHole = holes[ indepHoles[ ihIdx ]];
  					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

  						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
  						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
  						if ( intersection.length > 0 )		return	true;

  					}

  				}
  				return	false;

  			}

  			var holeIndex, shapeIndex,
  				shapePt, holePt,
  				holeIdx, cutKey, failedCuts = [],
  				tmpShape1, tmpShape2,
  				tmpHole1, tmpHole2;

  			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  				indepHoles.push( h );

  			}

  			var minShapeIndex = 0;
  			var counter = indepHoles.length * 2;
  			while ( indepHoles.length > 0 ) {

  				counter --;
  				if ( counter < 0 ) {

  					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
  					break;

  				}

  				// search for shape-vertex and hole-vertex,
  				// which can be connected without intersections
  				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

  					shapePt = shape[ shapeIndex ];
  					holeIndex	= - 1;

  					// search for hole which can be reached without intersections
  					for ( var h = 0; h < indepHoles.length; h ++ ) {

  						holeIdx = indepHoles[ h ];

  						// prevent multiple checks
  						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
  						if ( failedCuts[ cutKey ] !== undefined )			continue;

  						hole = holes[ holeIdx ];
  						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

  							holePt = hole[ h2 ];
  							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
  							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
  							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

  							holeIndex = h2;
  							indepHoles.splice( h, 1 );

  							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
  							tmpShape2 = shape.slice( shapeIndex );
  							tmpHole1 = hole.slice( holeIndex );
  							tmpHole2 = hole.slice( 0, holeIndex + 1 );

  							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

  							minShapeIndex = shapeIndex;

  							// Debug only, to show the selected cuts
  							// glob_CutLines.push( [ shapePt, holePt ] );

  							break;

  						}
  						if ( holeIndex >= 0 )	break;		// hole-vertex found

  						failedCuts[ cutKey ] = true;			// remember failure

  					}
  					if ( holeIndex >= 0 )	break;		// hole-vertex found

  				}

  			}

  			return shape; 			/* shape with no holes */

  		}


  		var i, il, f, face,
  			key, index,
  			allPointsMap = {};

  		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

  		var allpoints = contour.concat();

  		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

  			Array.prototype.push.apply( allpoints, holes[ h ] );

  		}

  		//console.log( "allpoints",allpoints, allpoints.length );

  		// prepare all points map

  		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

  			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

  			if ( allPointsMap[ key ] !== undefined ) {

  				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

  			}

  			allPointsMap[ key ] = i;

  		}

  		// remove holes by cutting paths to holes and adding them to the shape
  		var shapeWithoutHoles = removeHoles( contour, holes );

  		var triangles = ShapeUtils$1.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
  		//console.log( "triangles",triangles, triangles.length );

  		// check all face vertices against all points map

  		for ( i = 0, il = triangles.length; i < il; i ++ ) {

  			face = triangles[ i ];

  			for ( f = 0; f < 3; f ++ ) {

  				key = face[ f ].x + ":" + face[ f ].y;

  				index = allPointsMap[ key ];

  				if ( index !== undefined ) {

  					face[ f ] = index;

  				}

  			}

  		}

  		return triangles.concat();

  	},

  	isClockWise: function ( pts ) {

  		return ShapeUtils$1.area( pts ) < 0;

  	}

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  amount: <int>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline is bevel
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *  frames: <Object> // containing arrays of tangents, normals, binormals
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */

  // ExtrudeGeometry

  function ExtrudeGeometry$1( shapes, options ) {

  	Geometry$1.call( this );

  	this.type = 'ExtrudeGeometry';

  	this.parameters = {
  		shapes: shapes,
  		options: options
  	};

  	this.fromBufferGeometry( new ExtrudeBufferGeometry$1( shapes, options ) );
  	this.mergeVertices();

  }

  ExtrudeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ExtrudeGeometry$1.prototype.constructor = ExtrudeGeometry$1;

  // ExtrudeBufferGeometry

  function ExtrudeBufferGeometry$1( shapes, options ) {

  	if ( typeof ( shapes ) === "undefined" ) {

  		shapes = [];
  		return;

  	}

  	BufferGeometry$1.call( this );

  	this.type = 'ExtrudeBufferGeometry';

  	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  	this.addShapeList( shapes, options );

  	this.computeVertexNormals();

  	// can't really use automatic vertex normals
  	// as then front and back sides get smoothed too
  	// should do separate smoothing just for sides

  	//this.computeVertexNormals();

  	//console.log( "took", ( Date.now() - startTime ) );

  }

  ExtrudeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ExtrudeBufferGeometry$1.prototype.constructor = ExtrudeBufferGeometry$1;

  ExtrudeBufferGeometry$1.prototype.getArrays = function () {

  	var positionAttribute = this.getAttribute( "position" );
  	var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];

  	var uvAttribute = this.getAttribute( "uv" );
  	var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];

  	var IndexAttribute = this.index;
  	var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];

  	return {
  		position: verticesArray,
  		uv: uvArray,
  		index: indicesArray
  	};

  };

  ExtrudeBufferGeometry$1.prototype.addShapeList = function ( shapes, options ) {

  	var sl = shapes.length;
  	options.arrays = this.getArrays();

  	for ( var s = 0; s < sl; s ++ ) {

  		var shape = shapes[ s ];
  		this.addShape( shape, options );

  	}

  	this.setIndex( options.arrays.index );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( options.arrays.position, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( options.arrays.uv, 2 ) );

  };

  ExtrudeBufferGeometry$1.prototype.addShape = function ( shape, options ) {

  	var arrays = options.arrays ? options.arrays : this.getArrays();
  	var verticesArray = arrays.position;
  	var indicesArray = arrays.index;
  	var uvArray = arrays.uv;

  	var placeholder = [];


  	var amount = options.amount !== undefined ? options.amount : 100;

  	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  	var steps = options.steps !== undefined ? options.steps : 1;

  	var extrudePath = options.extrudePath;
  	var extrudePts, extrudeByPath = false;

  	// Use default WorldUVGenerator if no UV generators are specified.
  	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry$1.WorldUVGenerator;

  	var splineTube, binormal, normal, position2;
  	if ( extrudePath ) {

  		extrudePts = extrudePath.getSpacedPoints( steps );

  		extrudeByPath = true;
  		bevelEnabled = false; // bevels not supported for path extrusion

  		// SETUP TNB variables

  		// TODO1 - have a .isClosed in spline?

  		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

  		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

  		binormal = new Vector3$1();
  		normal = new Vector3$1();
  		position2 = new Vector3$1();

  	}

  	// Safeguards if bevels are not enabled

  	if ( ! bevelEnabled ) {

  		bevelSegments = 0;
  		bevelThickness = 0;
  		bevelSize = 0;

  	}

  	// Variables initialization

  	var ahole, h, hl; // looping of holes
  	var scope = this;

  	var shapePoints = shape.extractPoints( curveSegments );

  	var vertices = shapePoints.shape;
  	var holes = shapePoints.holes;

  	var reverse = ! ShapeUtils$1.isClockWise( vertices );

  	if ( reverse ) {

  		vertices = vertices.reverse();

  		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];

  			if ( ShapeUtils$1.isClockWise( ahole ) ) {

  				holes[ h ] = ahole.reverse();

  			}

  		}

  		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  	}


  	var faces = ShapeUtils$1.triangulateShape( vertices, holes );

  	/* Vertices */

  	var contour = vertices; // vertices has all points but contour has only points of circumference

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		vertices = vertices.concat( ahole );

  	}


  	function scalePt2( pt, vec, size ) {

  		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

  		return vec.clone().multiplyScalar( size ).add( pt );

  	}

  	var b, bs, t, z,
  		vert, vlen = vertices.length,
  		face, flen = faces.length;


  	// Find directions for point movement


  	function getBevelVec( inPt, inPrev, inNext ) {

  		// computes for inPt the corresponding point inPt' on a new contour
  		//   shifted by 1 unit (length of normalized vector) to the left
  		// if we walk along contour clockwise, this new contour is outside the old one
  		//
  		// inPt' is the intersection of the two lines parallel to the two
  		//  adjacent edges of inPt at a distance of 1 unit on the left side.

  		var v_trans_x, v_trans_y, shrink_by = 1; // resulting translation vector for inPt

  		// good reading for geometry algorithms (here: line-line intersection)
  		// http://geomalgorithms.com/a05-_intersect-1.html

  		var v_prev_x = inPt.x - inPrev.x,
  			v_prev_y = inPt.y - inPrev.y;
  		var v_next_x = inNext.x - inPt.x,
  			v_next_y = inNext.y - inPt.y;

  		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

  		// check for collinear edges
  		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

  		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

  			// not collinear

  			// length of vectors for normalizing

  			var v_prev_len = Math.sqrt( v_prev_lensq );
  			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

  			// shift adjacent points by unit vectors to the left

  			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
  			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

  			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
  			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

  			// scaling factor for v_prev to intersection point

  			var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
  					( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
  				( v_prev_x * v_next_y - v_prev_y * v_next_x );

  			// vector from inPt to intersection point

  			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
  			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

  			// Don't normalize!, otherwise sharp corners become ugly
  			//  but prevent crazy spikes
  			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
  			if ( v_trans_lensq <= 2 ) {

  				return new Vector2$1( v_trans_x, v_trans_y );

  			} else {

  				shrink_by = Math.sqrt( v_trans_lensq / 2 );

  			}

  		} else {

  			// handle special case of collinear edges

  			var direction_eq = false; // assumes: opposite
  			if ( v_prev_x > Number.EPSILON ) {

  				if ( v_next_x > Number.EPSILON ) {

  					direction_eq = true;

  				}

  			} else {

  				if ( v_prev_x < - Number.EPSILON ) {

  					if ( v_next_x < - Number.EPSILON ) {

  						direction_eq = true;

  					}

  				} else {

  					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

  						direction_eq = true;

  					}

  				}

  			}

  			if ( direction_eq ) {

  				// console.log("Warning: lines are a straight sequence");
  				v_trans_x = - v_prev_y;
  				v_trans_y = v_prev_x;
  				shrink_by = Math.sqrt( v_prev_lensq );

  			} else {

  				// console.log("Warning: lines are a straight spike");
  				v_trans_x = v_prev_x;
  				v_trans_y = v_prev_y;
  				shrink_by = Math.sqrt( v_prev_lensq / 2 );

  			}

  		}

  		return new Vector2$1( v_trans_x / shrink_by, v_trans_y / shrink_by );

  	}


  	var contourMovements = [];

  	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  		if ( j === il ) j = 0;
  		if ( k === il ) k = 0;

  		//  (j)---(i)---(k)
  		// console.log('i,j,k', i, j , k)

  		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  	}

  	var holesMovements = [],
  		oneHoleMovements, verticesMovements = contourMovements.concat();

  	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  		ahole = holes[ h ];

  		oneHoleMovements = [];

  		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

  			if ( j === il ) j = 0;
  			if ( k === il ) k = 0;

  			//  (j)---(i)---(k)
  			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

  		}

  		holesMovements.push( oneHoleMovements );
  		verticesMovements = verticesMovements.concat( oneHoleMovements );

  	}


  	// Loop bevelSegments, 1 for the front, 1 for the back

  	for ( b = 0; b < bevelSegments; b ++ ) {

  		//for ( b = bevelSegments; b > 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

  			v( vert.x, vert.y, - z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				v( vert.x, vert.y, - z );

  			}

  		}

  	}

  	bs = bevelSize;

  	// Back facing vertices

  	for ( i = 0; i < vlen; i ++ ) {

  		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  		if ( ! extrudeByPath ) {

  			v( vert.x, vert.y, 0 );

  		} else {

  			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

  			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
  			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

  			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

  			v( position2.x, position2.y, position2.z );

  		}

  	}

  	// Add stepped vertices...
  	// Including front facing vertices

  	var s;

  	for ( s = 1; s <= steps; s ++ ) {

  		for ( i = 0; i < vlen; i ++ ) {

  			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

  			if ( ! extrudeByPath ) {

  				v( vert.x, vert.y, amount / steps * s );

  			} else {

  				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

  				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
  				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

  				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

  				v( position2.x, position2.y, position2.z );

  			}

  		}

  	}


  	// Add bevel segments planes

  	//for ( b = 1; b <= bevelSegments; b ++ ) {
  	for ( b = bevelSegments - 1; b >= 0; b -- ) {

  		t = b / bevelSegments;
  		z = bevelThickness * Math.cos( t * Math.PI / 2 );
  		bs = bevelSize * Math.sin( t * Math.PI / 2 );

  		// contract shape

  		for ( i = 0, il = contour.length; i < il; i ++ ) {

  			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
  			v( vert.x, vert.y, amount + z );

  		}

  		// expand holes

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			oneHoleMovements = holesMovements[ h ];

  			for ( i = 0, il = ahole.length; i < il; i ++ ) {

  				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

  				if ( ! extrudeByPath ) {

  					v( vert.x, vert.y, amount + z );

  				} else {

  					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

  				}

  			}

  		}

  	}

  	/* Faces */

  	// Top and bottom faces

  	buildLidFaces();

  	// Sides faces

  	buildSideFaces();


  	/////  Internal functions

  	function buildLidFaces() {

  		var start = verticesArray.length/3;

  		if ( bevelEnabled ) {

  			var layer = 0; // steps + 1
  			var offset = vlen * layer;

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

  			}

  			layer = steps + bevelSegments * 2;
  			offset = vlen * layer;

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

  			}

  		} else {

  			// Bottom faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

  			}

  			// Top faces

  			for ( i = 0; i < flen; i ++ ) {

  				face = faces[ i ];
  				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

  			}

  		}

  		scope.addGroup( start, verticesArray.length/3 -start, options.material !== undefined ? options.material : 0);

  	}

  	// Create faces for the z-sides of the shape

  	function buildSideFaces() {

  		var start = verticesArray.length/3;
  		var layeroffset = 0;
  		sidewalls( contour, layeroffset );
  		layeroffset += contour.length;

  		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

  			ahole = holes[ h ];
  			sidewalls( ahole, layeroffset );

  			//, true
  			layeroffset += ahole.length;

  		}


  		scope.addGroup( start, verticesArray.length/3 -start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);


  	}

  	function sidewalls( contour, layeroffset ) {

  		var j, k;
  		i = contour.length;

  		while ( -- i >= 0 ) {

  			j = i;
  			k = i - 1;
  			if ( k < 0 ) k = contour.length - 1;

  			//console.log('b', i,j, i-1, k,vertices.length);

  			var s = 0,
  				sl = steps + bevelSegments * 2;

  			for ( s = 0; s < sl; s ++ ) {

  				var slen1 = vlen * s;
  				var slen2 = vlen * ( s + 1 );

  				var a = layeroffset + j + slen1,
  					b = layeroffset + k + slen1,
  					c = layeroffset + k + slen2,
  					d = layeroffset + j + slen2;

  				f4( a, b, c, d, contour, s, sl, j, k );

  			}

  		}

  	}

  	function v( x, y, z ) {

  		placeholder.push( x );
  		placeholder.push( y );
  		placeholder.push( z );

  	}


  	function f3( a, b, c ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( c );

  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );

  	}

  	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

  		addVertex( a );
  		addVertex( b );
  		addVertex( d );

  		addVertex( b );
  		addVertex( c );
  		addVertex( d );


  		var nextIndex = verticesArray.length / 3;
  		var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

  		addUV( uvs[ 0 ] );
  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 3 ] );

  		addUV( uvs[ 1 ] );
  		addUV( uvs[ 2 ] );
  		addUV( uvs[ 3 ] );

  	}

  	function addVertex( index ) {

  		indicesArray.push( verticesArray.length / 3 );
  		verticesArray.push( placeholder[ index * 3 + 0 ] );
  		verticesArray.push( placeholder[ index * 3 + 1 ] );
  		verticesArray.push( placeholder[ index * 3 + 2 ] );

  	}


  	function addUV( vector2 ) {

  		uvArray.push( vector2.x );
  		uvArray.push( vector2.y );

  	}

  	if ( ! options.arrays ) {

  		this.setIndex( indicesArray );
  		this.addAttribute( 'position', new Float32BufferAttribute$1( verticesArray, 3 ) );
  		this.addAttribute( 'uv', new Float32BufferAttribute$1( options.arrays.uv, 2 ) );

  	}

  };

  ExtrudeGeometry$1.WorldUVGenerator = {

  	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];

  		return [
  			new Vector2$1( a_x, a_y ),
  			new Vector2$1( b_x, b_y ),
  			new Vector2$1( c_x, c_y )
  		];

  	},

  	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

  		var a_x = vertices[ indexA * 3 ];
  		var a_y = vertices[ indexA * 3 + 1 ];
  		var a_z = vertices[ indexA * 3 + 2 ];
  		var b_x = vertices[ indexB * 3 ];
  		var b_y = vertices[ indexB * 3 + 1 ];
  		var b_z = vertices[ indexB * 3 + 2 ];
  		var c_x = vertices[ indexC * 3 ];
  		var c_y = vertices[ indexC * 3 + 1 ];
  		var c_z = vertices[ indexC * 3 + 2 ];
  		var d_x = vertices[ indexD * 3 ];
  		var d_y = vertices[ indexD * 3 + 1 ];
  		var d_z = vertices[ indexD * 3 + 2 ];

  		if ( Math.abs( a_y - b_y ) < 0.01 ) {

  			return [
  				new Vector2$1( a_x, 1 - a_z ),
  				new Vector2$1( b_x, 1 - b_z ),
  				new Vector2$1( c_x, 1 - c_z ),
  				new Vector2$1( d_x, 1 - d_z )
  			];

  		} else {

  			return [
  				new Vector2$1( a_y, 1 - a_z ),
  				new Vector2$1( b_y, 1 - b_z ),
  				new Vector2$1( c_y, 1 - c_z ),
  				new Vector2$1( d_y, 1 - d_z )
  			];

  		}

  	}
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author alteredq / http://alteredqualia.com/
   *
   * Text = 3D Text
   *
   * parameters = {
   *  font: <THREE.Font>, // font
   *
   *  size: <float>, // size of the text
   *  height: <float>, // thickness to extrude text
   *  curveSegments: <int>, // number of points on the curves
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into text bevel goes
   *  bevelSize: <float> // how far from text outline is bevel
   * }
   */

  // TextGeometry

  function TextGeometry$1(  text, parameters ) {

  	Geometry$1.call( this );

  	this.type = 'TextGeometry';

  	this.parameters = {
  		text: text,
  		parameters: parameters
  	};

  	this.fromBufferGeometry( new TextBufferGeometry$1( text, parameters ) );
  	this.mergeVertices();

  }

  TextGeometry$1.prototype = Object.create( Geometry$1.prototype );
  TextGeometry$1.prototype.constructor = TextGeometry$1;

  // TextBufferGeometry

  function TextBufferGeometry$1( text, parameters ) {

  	parameters = parameters || {};

  	var font = parameters.font;

  	if ( ( font && font.isFont ) === false ) {

  		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
  		return new Geometry$1();

  	}

  	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

  	// translate parameters to ExtrudeGeometry API

  	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  	// defaults

  	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  	ExtrudeBufferGeometry$1.call( this, shapes, parameters );

  	this.type = 'TextBufferGeometry';

  }

  TextBufferGeometry$1.prototype = Object.create( ExtrudeBufferGeometry$1.prototype );
  TextBufferGeometry$1.prototype.constructor = TextBufferGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   */

  // SphereGeometry

  function SphereGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'SphereGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new SphereBufferGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  SphereGeometry$1.prototype = Object.create( Geometry$1.prototype );
  SphereGeometry$1.prototype.constructor = SphereGeometry$1;

  // SphereBufferGeometry

  function SphereBufferGeometry$1( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'SphereBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		widthSegments: widthSegments,
  		heightSegments: heightSegments,
  		phiStart: phiStart,
  		phiLength: phiLength,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;

  	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  	phiStart = phiStart !== undefined ? phiStart : 0;
  	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  	var thetaEnd = thetaStart + thetaLength;

  	var ix, iy;

  	var index = 0;
  	var grid = [];

  	var vertex = new Vector3$1();
  	var normal = new Vector3$1();

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// generate vertices, normals and uvs

  	for ( iy = 0; iy <= heightSegments; iy ++ ) {

  		var verticesRow = [];

  		var v = iy / heightSegments;

  		for ( ix = 0; ix <= widthSegments; ix ++ ) {

  			var u = ix / widthSegments;

  			// vertex

  			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
  			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
  			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normal.set( vertex.x, vertex.y, vertex.z ).normalize();
  			normals.push( normal.x, normal.y, normal.z );

  			// uv

  			uvs.push( u, 1 - v );

  			verticesRow.push( index ++ );

  		}

  		grid.push( verticesRow );

  	}

  	// indices

  	for ( iy = 0; iy < heightSegments; iy ++ ) {

  		for ( ix = 0; ix < widthSegments; ix ++ ) {

  			var a = grid[ iy ][ ix + 1 ];
  			var b = grid[ iy ][ ix ];
  			var c = grid[ iy + 1 ][ ix ];
  			var d = grid[ iy + 1 ][ ix + 1 ];

  			if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
  			if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  SphereBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  SphereBufferGeometry$1.prototype.constructor = SphereBufferGeometry$1;

  /**
   * @author Kaleb Murphy
   * @author Mugen87 / https://github.com/Mugen87
   */

  // RingGeometry

  function RingGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'RingGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new RingBufferGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  RingGeometry$1.prototype = Object.create( Geometry$1.prototype );
  RingGeometry$1.prototype.constructor = RingGeometry$1;

  // RingBufferGeometry

  function RingBufferGeometry$1( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'RingBufferGeometry';

  	this.parameters = {
  		innerRadius: innerRadius,
  		outerRadius: outerRadius,
  		thetaSegments: thetaSegments,
  		phiSegments: phiSegments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	innerRadius = innerRadius || 20;
  	outerRadius = outerRadius || 50;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// some helper variables

  	var segment;
  	var radius = innerRadius;
  	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
  	var vertex = new Vector3$1();
  	var uv = new Vector2$1();
  	var j, i;

  	// generate vertices, normals and uvs

  	for ( j = 0; j <= phiSegments; j ++ ) {

  		for ( i = 0; i <= thetaSegments; i ++ ) {

  			// values are generate from the inside of the ring to the outside

  			segment = thetaStart + i / thetaSegments * thetaLength;

  			// vertex

  			vertex.x = radius * Math.cos( segment );
  			vertex.y = radius * Math.sin( segment );

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, 0, 1 );

  			// uv

  			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
  			uv.y = ( vertex.y / outerRadius + 1 ) / 2;

  			uvs.push( uv.x, uv.y );

  		}

  		// increase the radius for next row of vertices

  		radius += radiusStep;

  	}

  	// indices

  	for ( j = 0; j < phiSegments; j ++ ) {

  		var thetaSegmentLevel = j * ( thetaSegments + 1 );

  		for ( i = 0; i < thetaSegments; i ++ ) {

  			segment = i + thetaSegmentLevel;

  			var a = segment;
  			var b = segment + thetaSegments + 1;
  			var c = segment + thetaSegments + 2;
  			var d = segment + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  RingBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  RingBufferGeometry$1.prototype.constructor = RingBufferGeometry$1;

  /**
   * @author astrodud / http://astrodud.isgreat.org/
   * @author zz85 / https://github.com/zz85
   * @author bhouston / http://clara.io
   * @author Mugen87 / https://github.com/Mugen87
   */

  // LatheGeometry

  function LatheGeometry$1( points, segments, phiStart, phiLength ) {

  	Geometry$1.call( this );

  	this.type = 'LatheGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	this.fromBufferGeometry( new LatheBufferGeometry$1( points, segments, phiStart, phiLength ) );
  	this.mergeVertices();

  }

  LatheGeometry$1.prototype = Object.create( Geometry$1.prototype );
  LatheGeometry$1.prototype.constructor = LatheGeometry$1;

  // LatheBufferGeometry

  function LatheBufferGeometry$1( points, segments, phiStart, phiLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'LatheBufferGeometry';

  	this.parameters = {
  		points: points,
  		segments: segments,
  		phiStart: phiStart,
  		phiLength: phiLength
  	};

  	segments = Math.floor( segments ) || 12;
  	phiStart = phiStart || 0;
  	phiLength = phiLength || Math.PI * 2;

  	// clamp phiLength so it's in range of [ 0, 2PI ]

  	phiLength = _Math$1.clamp( phiLength, 0, Math.PI * 2 );


  	// buffers

  	var indices = [];
  	var vertices = [];
  	var uvs = [];

  	// helper variables

  	var base;
  	var inverseSegments = 1.0 / segments;
  	var vertex = new Vector3$1();
  	var uv = new Vector2$1();
  	var i, j;

  	// generate vertices and uvs

  	for ( i = 0; i <= segments; i ++ ) {

  		var phi = phiStart + i * inverseSegments * phiLength;

  		var sin = Math.sin( phi );
  		var cos = Math.cos( phi );

  		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

  			// vertex

  			vertex.x = points[ j ].x * sin;
  			vertex.y = points[ j ].y;
  			vertex.z = points[ j ].x * cos;

  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// uv

  			uv.x = i / segments;
  			uv.y = j / ( points.length - 1 );

  			uvs.push( uv.x, uv.y );


  		}

  	}

  	// indices

  	for ( i = 0; i < segments; i ++ ) {

  		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

  			base = j + i * points.length;

  			var a = base;
  			var b = base + points.length;
  			var c = base + points.length + 1;
  			var d = base + 1;

  			// faces

  			indices.push( a, b, d );
  			indices.push( b, c, d );

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	// generate normals

  	this.computeVertexNormals();

  	// if the geometry is closed, we need to average the normals along the seam.
  	// because the corresponding vertices are identical (but still have different UVs).

  	if ( phiLength === Math.PI * 2 ) {

  		var normals = this.attributes.normal.array;
  		var n1 = new Vector3$1();
  		var n2 = new Vector3$1();
  		var n = new Vector3$1();

  		// this is the buffer offset for the last line of vertices

  		base = segments * points.length * 3;

  		for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

  			// select the normal of the vertex in the first line

  			n1.x = normals[ j + 0 ];
  			n1.y = normals[ j + 1 ];
  			n1.z = normals[ j + 2 ];

  			// select the normal of the vertex in the last line

  			n2.x = normals[ base + j + 0 ];
  			n2.y = normals[ base + j + 1 ];
  			n2.z = normals[ base + j + 2 ];

  			// average normals

  			n.addVectors( n1, n2 ).normalize();

  			// assign the new values to both normals

  			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
  			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
  			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

  		}

  	}

  }

  LatheBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  LatheBufferGeometry$1.prototype.constructor = LatheBufferGeometry$1;

  /**
   * @author jonobr1 / http://jonobr1.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  // ShapeGeometry

  function ShapeGeometry$1( shapes, curveSegments ) {

  	Geometry$1.call( this );

  	this.type = 'ShapeGeometry';

  	if ( typeof curveSegments === 'object' ) {

  		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

  		curveSegments = curveSegments.curveSegments;

  	}

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	this.fromBufferGeometry( new ShapeBufferGeometry$1( shapes, curveSegments ) );
  	this.mergeVertices();

  }

  ShapeGeometry$1.prototype = Object.create( Geometry$1.prototype );
  ShapeGeometry$1.prototype.constructor = ShapeGeometry$1;

  // ShapeBufferGeometry

  function ShapeBufferGeometry$1( shapes, curveSegments ) {

  	BufferGeometry$1.call( this );

  	this.type = 'ShapeBufferGeometry';

  	this.parameters = {
  		shapes: shapes,
  		curveSegments: curveSegments
  	};

  	curveSegments = curveSegments || 12;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var groupStart = 0;
  	var groupCount = 0;

  	// allow single and array values for "shapes" parameter

  	if ( Array.isArray( shapes ) === false ) {

  		addShape( shapes );

  	} else {

  		for ( var i = 0; i < shapes.length; i ++ ) {

  			addShape( shapes[ i ] );

  			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

  			groupStart += groupCount;
  			groupCount = 0;

  		}

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );


  	// helper functions

  	function addShape( shape ) {

  		var i, l, shapeHole;

  		var indexOffset = vertices.length / 3;
  		var points = shape.extractPoints( curveSegments );

  		var shapeVertices = points.shape;
  		var shapeHoles = points.holes;

  		// check direction of vertices

  		if ( ShapeUtils$1.isClockWise( shapeVertices ) === false ) {

  			shapeVertices = shapeVertices.reverse();

  			// also check if holes are in the opposite direction

  			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  				shapeHole = shapeHoles[ i ];

  				if ( ShapeUtils$1.isClockWise( shapeHole ) === true ) {

  					shapeHoles[ i ] = shapeHole.reverse();

  				}

  			}

  		}

  		var faces = ShapeUtils$1.triangulateShape( shapeVertices, shapeHoles );

  		// join vertices of inner and outer paths to a single array

  		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

  			shapeHole = shapeHoles[ i ];
  			shapeVertices = shapeVertices.concat( shapeHole );

  		}

  		// vertices, normals, uvs

  		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

  			var vertex = shapeVertices[ i ];

  			vertices.push( vertex.x, vertex.y, 0 );
  			normals.push( 0, 0, 1 );
  			uvs.push( vertex.x, vertex.y ); // world uvs

  		}

  		// incides

  		for ( i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var a = face[ 0 ] + indexOffset;
  			var b = face[ 1 ] + indexOffset;
  			var c = face[ 2 ] + indexOffset;

  			indices.push( a, b, c );
  			groupCount += 3;

  		}

  	}

  }

  ShapeBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  ShapeBufferGeometry$1.prototype.constructor = ShapeBufferGeometry$1;

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author Mugen87 / https://github.com/Mugen87
   */

  function EdgesGeometry$1( geometry, thresholdAngle ) {

  	BufferGeometry$1.call( this );

  	this.type = 'EdgesGeometry';

  	this.parameters = {
  		thresholdAngle: thresholdAngle
  	};

  	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  	// buffer

  	var vertices = [];

  	// helper variables

  	var thresholdDot = Math.cos( _Math$1.DEG2RAD * thresholdAngle );
  	var edge = [ 0, 0 ], edges = {}, edge1, edge2;
  	var key, keys = [ 'a', 'b', 'c' ];

  	// prepare source geometry

  	var geometry2;

  	if ( geometry.isBufferGeometry ) {

  		geometry2 = new Geometry$1();
  		geometry2.fromBufferGeometry( geometry );

  	} else {

  		geometry2 = geometry.clone();

  	}

  	geometry2.mergeVertices();
  	geometry2.computeFaceNormals();

  	var sourceVertices = geometry2.vertices;
  	var faces = geometry2.faces;

  	// now create a data structure where each entry represents an edge with its adjoining faces

  	for ( var i = 0, l = faces.length; i < l; i ++ ) {

  		var face = faces[ i ];

  		for ( var j = 0; j < 3; j ++ ) {

  			edge1 = face[ keys[ j ] ];
  			edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
  			edge[ 0 ] = Math.min( edge1, edge2 );
  			edge[ 1 ] = Math.max( edge1, edge2 );

  			key = edge[ 0 ] + ',' + edge[ 1 ];

  			if ( edges[ key ] === undefined ) {

  				edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

  			} else {

  				edges[ key ].face2 = i;

  			}

  		}

  	}

  	// generate vertices

  	for ( key in edges ) {

  		var e = edges[ key ];

  		// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

  		if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

  			var vertex = sourceVertices[ e.index1 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			vertex = sourceVertices[ e.index2 ];
  			vertices.push( vertex.x, vertex.y, vertex.z );

  		}

  	}

  	// build geometry

  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );

  }

  EdgesGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  EdgesGeometry$1.prototype.constructor = EdgesGeometry$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  // CylinderGeometry

  function CylinderGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'CylinderGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CylinderBufferGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CylinderGeometry$1.prototype = Object.create( Geometry$1.prototype );
  CylinderGeometry$1.prototype.constructor = CylinderGeometry$1;

  // CylinderBufferGeometry

  function CylinderBufferGeometry$1( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'CylinderBufferGeometry';

  	this.parameters = {
  		radiusTop: radiusTop,
  		radiusBottom: radiusBottom,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	var scope = this;

  	radiusTop = radiusTop !== undefined ? radiusTop : 20;
  	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  	height = height !== undefined ? height : 100;

  	radialSegments = Math.floor( radialSegments ) || 8;
  	heightSegments = Math.floor( heightSegments ) || 1;

  	openEnded = openEnded !== undefined ? openEnded : false;
  	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var index = 0;
  	var indexArray = [];
  	var halfHeight = height / 2;
  	var groupStart = 0;

  	// generate geometry

  	generateTorso();

  	if ( openEnded === false ) {

  		if ( radiusTop > 0 ) generateCap( true );
  		if ( radiusBottom > 0 ) generateCap( false );

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  	function generateTorso() {

  		var x, y;
  		var normal = new Vector3$1();
  		var vertex = new Vector3$1();

  		var groupCount = 0;

  		// this will be used to calculate the normal
  		var slope = ( radiusBottom - radiusTop ) / height;

  		// generate vertices, normals and uvs

  		for ( y = 0; y <= heightSegments; y ++ ) {

  			var indexRow = [];

  			var v = y / heightSegments;

  			// calculate the radius of the current row

  			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

  			for ( x = 0; x <= radialSegments; x ++ ) {

  				var u = x / radialSegments;

  				var theta = u * thetaLength + thetaStart;

  				var sinTheta = Math.sin( theta );
  				var cosTheta = Math.cos( theta );

  				// vertex

  				vertex.x = radius * sinTheta;
  				vertex.y = - v * height + halfHeight;
  				vertex.z = radius * cosTheta;
  				vertices.push( vertex.x, vertex.y, vertex.z );

  				// normal

  				normal.set( sinTheta, slope, cosTheta ).normalize();
  				normals.push( normal.x, normal.y, normal.z );

  				// uv

  				uvs.push( u, 1 - v );

  				// save index of vertex in respective row

  				indexRow.push( index ++ );

  			}

  			// now save vertices of the row in our index array

  			indexArray.push( indexRow );

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			for ( y = 0; y < heightSegments; y ++ ) {

  				// we use the index array to access the correct indices

  				var a = indexArray[ y ][ x ];
  				var b = indexArray[ y + 1 ][ x ];
  				var c = indexArray[ y + 1 ][ x + 1 ];
  				var d = indexArray[ y ][ x + 1 ];

  				// faces

  				indices.push( a, b, d );
  				indices.push( b, c, d );

  				// update group counter

  				groupCount += 6;

  			}

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, 0 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  	function generateCap( top ) {

  		var x, centerIndexStart, centerIndexEnd;

  		var uv = new Vector2$1();
  		var vertex = new Vector3$1();

  		var groupCount = 0;

  		var radius = ( top === true ) ? radiusTop : radiusBottom;
  		var sign = ( top === true ) ? 1 : - 1;

  		// save the index of the first center vertex
  		centerIndexStart = index;

  		// first we generate the center vertex data of the cap.
  		// because the geometry needs one set of uvs per face,
  		// we must generate a center vertex per face/segment

  		for ( x = 1; x <= radialSegments; x ++ ) {

  			// vertex

  			vertices.push( 0, halfHeight * sign, 0 );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uvs.push( 0.5, 0.5 );

  			// increase index

  			index ++;

  		}

  		// save the index of the last center vertex

  		centerIndexEnd = index;

  		// now we generate the surrounding vertices, normals and uvs

  		for ( x = 0; x <= radialSegments; x ++ ) {

  			var u = x / radialSegments;
  			var theta = u * thetaLength + thetaStart;

  			var cosTheta = Math.cos( theta );
  			var sinTheta = Math.sin( theta );

  			// vertex

  			vertex.x = radius * sinTheta;
  			vertex.y = halfHeight * sign;
  			vertex.z = radius * cosTheta;
  			vertices.push( vertex.x, vertex.y, vertex.z );

  			// normal

  			normals.push( 0, sign, 0 );

  			// uv

  			uv.x = ( cosTheta * 0.5 ) + 0.5;
  			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
  			uvs.push( uv.x, uv.y );

  			// increase index

  			index ++;

  		}

  		// generate indices

  		for ( x = 0; x < radialSegments; x ++ ) {

  			var c = centerIndexStart + x;
  			var i = centerIndexEnd + x;

  			if ( top === true ) {

  				// face top

  				indices.push( i, i + 1, c );

  			} else {

  				// face bottom

  				indices.push( i + 1, i, c );

  			}

  			groupCount += 3;

  		}

  		// add a group to the geometry. this will ensure multi material support

  		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

  		// calculate new start value for groups

  		groupStart += groupCount;

  	}

  }

  CylinderBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  CylinderBufferGeometry$1.prototype.constructor = CylinderBufferGeometry$1;

  /**
   * @author abelnation / http://github.com/abelnation
   */

  // ConeGeometry

  function ConeGeometry$1( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderGeometry$1.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeGeometry$1.prototype = Object.create( CylinderGeometry$1.prototype );
  ConeGeometry$1.prototype.constructor = ConeGeometry$1;

  // ConeBufferGeometry

  function ConeBufferGeometry$1( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  	CylinderBufferGeometry$1.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

  	this.type = 'ConeBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		height: height,
  		radialSegments: radialSegments,
  		heightSegments: heightSegments,
  		openEnded: openEnded,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  }

  ConeBufferGeometry$1.prototype = Object.create( CylinderBufferGeometry$1.prototype );
  ConeBufferGeometry$1.prototype.constructor = ConeBufferGeometry$1;

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   * @author Mugen87 / https://github.com/Mugen87
   * @author hughes
   */

  // CircleGeometry

  function CircleGeometry$1( radius, segments, thetaStart, thetaLength ) {

  	Geometry$1.call( this );

  	this.type = 'CircleGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	this.fromBufferGeometry( new CircleBufferGeometry$1( radius, segments, thetaStart, thetaLength ) );
  	this.mergeVertices();

  }

  CircleGeometry$1.prototype = Object.create( Geometry$1.prototype );
  CircleGeometry$1.prototype.constructor = CircleGeometry$1;

  // CircleBufferGeometry

  function CircleBufferGeometry$1( radius, segments, thetaStart, thetaLength ) {

  	BufferGeometry$1.call( this );

  	this.type = 'CircleBufferGeometry';

  	this.parameters = {
  		radius: radius,
  		segments: segments,
  		thetaStart: thetaStart,
  		thetaLength: thetaLength
  	};

  	radius = radius || 50;
  	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  	thetaStart = thetaStart !== undefined ? thetaStart : 0;
  	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  	// buffers

  	var indices = [];
  	var vertices = [];
  	var normals = [];
  	var uvs = [];

  	// helper variables

  	var i, s;
  	var vertex = new Vector3$1();
  	var uv = new Vector2$1();

  	// center point

  	vertices.push( 0, 0, 0 );
  	normals.push( 0, 0, 1 );
  	uvs.push( 0.5, 0.5 );

  	for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

  		var segment = thetaStart + s / segments * thetaLength;

  		// vertex

  		vertex.x = radius * Math.cos( segment );
  		vertex.y = radius * Math.sin( segment );

  		vertices.push( vertex.x, vertex.y, vertex.z );

  		// normal

  		normals.push( 0, 0, 1 );

  		// uvs

  		uv.x = ( vertices[ i ] / radius + 1 ) / 2;
  		uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

  		uvs.push( uv.x, uv.y );

  	}

  	// indices

  	for ( i = 1; i <= segments; i ++ ) {

  		indices.push( i, i + 1, 0 );

  	}

  	// build geometry

  	this.setIndex( indices );
  	this.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	this.addAttribute( 'normal', new Float32BufferAttribute$1( normals, 3 ) );
  	this.addAttribute( 'uv', new Float32BufferAttribute$1( uvs, 2 ) );

  }

  CircleBufferGeometry$1.prototype = Object.create( BufferGeometry$1.prototype );
  CircleBufferGeometry$1.prototype.constructor = CircleBufferGeometry$1;



  var Geometries$1 = Object.freeze({
  	WireframeGeometry: WireframeGeometry$1,
  	ParametricGeometry: ParametricGeometry$1,
  	ParametricBufferGeometry: ParametricBufferGeometry$1,
  	TetrahedronGeometry: TetrahedronGeometry$1,
  	TetrahedronBufferGeometry: TetrahedronBufferGeometry$1,
  	OctahedronGeometry: OctahedronGeometry$1,
  	OctahedronBufferGeometry: OctahedronBufferGeometry$1,
  	IcosahedronGeometry: IcosahedronGeometry$1,
  	IcosahedronBufferGeometry: IcosahedronBufferGeometry$1,
  	DodecahedronGeometry: DodecahedronGeometry$1,
  	DodecahedronBufferGeometry: DodecahedronBufferGeometry$1,
  	PolyhedronGeometry: PolyhedronGeometry$1,
  	PolyhedronBufferGeometry: PolyhedronBufferGeometry$1,
  	TubeGeometry: TubeGeometry$1,
  	TubeBufferGeometry: TubeBufferGeometry$1,
  	TorusKnotGeometry: TorusKnotGeometry$1,
  	TorusKnotBufferGeometry: TorusKnotBufferGeometry$1,
  	TorusGeometry: TorusGeometry$1,
  	TorusBufferGeometry: TorusBufferGeometry$1,
  	TextGeometry: TextGeometry$1,
  	TextBufferGeometry: TextBufferGeometry$1,
  	SphereGeometry: SphereGeometry$1,
  	SphereBufferGeometry: SphereBufferGeometry$1,
  	RingGeometry: RingGeometry$1,
  	RingBufferGeometry: RingBufferGeometry$1,
  	PlaneGeometry: PlaneGeometry$1,
  	PlaneBufferGeometry: PlaneBufferGeometry$1,
  	LatheGeometry: LatheGeometry$1,
  	LatheBufferGeometry: LatheBufferGeometry$1,
  	ShapeGeometry: ShapeGeometry$1,
  	ShapeBufferGeometry: ShapeBufferGeometry$1,
  	ExtrudeGeometry: ExtrudeGeometry$1,
  	ExtrudeBufferGeometry: ExtrudeBufferGeometry$1,
  	EdgesGeometry: EdgesGeometry$1,
  	ConeGeometry: ConeGeometry$1,
  	ConeBufferGeometry: ConeBufferGeometry$1,
  	CylinderGeometry: CylinderGeometry$1,
  	CylinderBufferGeometry: CylinderBufferGeometry$1,
  	CircleGeometry: CircleGeometry$1,
  	CircleBufferGeometry: CircleBufferGeometry$1,
  	BoxGeometry: BoxGeometry$1,
  	BoxBufferGeometry: BoxBufferGeometry$1
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * parameters = {
   *  opacity: <float>
   * }
   */

  function ShadowMaterial$1( parameters ) {

  	ShaderMaterial$1.call( this, {
  		uniforms: UniformsUtils$1.merge( [
  			UniformsLib$1.lights,
  			{
  				opacity: { value: 1.0 }
  			}
  		] ),
  		vertexShader: ShaderChunk$1[ 'shadow_vert' ],
  		fragmentShader: ShaderChunk$1[ 'shadow_frag' ]
  	} );

  	this.lights = true;
  	this.transparent = true;

  	Object.defineProperties( this, {
  		opacity: {
  			enumerable: true,
  			get: function () {
  				return this.uniforms.opacity.value;
  			},
  			set: function ( value ) {
  				this.uniforms.opacity.value = value;
  			}
  		}
  	} );

  	this.setValues( parameters );

  }

  ShadowMaterial$1.prototype = Object.create( ShaderMaterial$1.prototype );
  ShadowMaterial$1.prototype.constructor = ShadowMaterial$1;

  ShadowMaterial$1.prototype.isShadowMaterial = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function RawShaderMaterial$1( parameters ) {

  	ShaderMaterial$1.call( this, parameters );

  	this.type = 'RawShaderMaterial';

  }

  RawShaderMaterial$1.prototype = Object.create( ShaderMaterial$1.prototype );
  RawShaderMaterial$1.prototype.constructor = RawShaderMaterial$1;

  RawShaderMaterial$1.prototype.isRawShaderMaterial = true;

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  color: <hex>,
   *  roughness: <float>,
   *  metalness: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  roughnessMap: new THREE.Texture( <Image> ),
   *
   *  metalnessMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
   *  envMapIntensity: <float>
   *
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshStandardMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.defines = { 'STANDARD': '' };

  	this.type = 'MeshStandardMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse
  	this.roughness = 0.5;
  	this.metalness = 0.5;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.roughnessMap = null;

  	this.metalnessMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.envMapIntensity = 1.0;

  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshStandardMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshStandardMaterial$1.prototype.constructor = MeshStandardMaterial$1;

  MeshStandardMaterial$1.prototype.isMeshStandardMaterial = true;

  MeshStandardMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.defines = { 'STANDARD': '' };

  	this.color.copy( source.color );
  	this.roughness = source.roughness;
  	this.metalness = source.metalness;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.roughnessMap = source.roughnessMap;

  	this.metalnessMap = source.metalnessMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.envMapIntensity = source.envMapIntensity;

  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  reflectivity: <float>
   * }
   */

  function MeshPhysicalMaterial$1( parameters ) {

  	MeshStandardMaterial$1.call( this );

  	this.defines = { 'PHYSICAL': '' };

  	this.type = 'MeshPhysicalMaterial';

  	this.reflectivity = 0.5; // maps to F0 = 0.04

  	this.clearCoat = 0.0;
  	this.clearCoatRoughness = 0.0;

  	this.setValues( parameters );

  }

  MeshPhysicalMaterial$1.prototype = Object.create( MeshStandardMaterial$1.prototype );
  MeshPhysicalMaterial$1.prototype.constructor = MeshPhysicalMaterial$1;

  MeshPhysicalMaterial$1.prototype.isMeshPhysicalMaterial = true;

  MeshPhysicalMaterial$1.prototype.copy = function ( source ) {

  	MeshStandardMaterial$1.prototype.copy.call( this, source );

  	this.defines = { 'PHYSICAL': '' };

  	this.reflectivity = source.reflectivity;

  	this.clearCoat = source.clearCoat;
  	this.clearCoatRoughness = source.clearCoatRoughness;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  specular: <hex>,
   *  shininess: <float>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshPhongMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshPhongMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse
  	this.specular = new Color$1( 0x111111 );
  	this.shininess = 30;

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshPhongMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshPhongMaterial$1.prototype.constructor = MeshPhongMaterial$1;

  MeshPhongMaterial$1.prototype.isMeshPhongMaterial = true;

  MeshPhongMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );
  	this.specular.copy( source.specular );
  	this.shininess = source.shininess;

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author takahirox / http://github.com/takahirox
   *
   * parameters = {
   *  gradientMap: new THREE.Texture( <Image> )
   * }
   */

  function MeshToonMaterial$1( parameters ) {

  	MeshPhongMaterial$1.call( this );

  	this.defines = { 'TOON': '' };

  	this.type = 'MeshToonMaterial';

  	this.gradientMap = null;

  	this.setValues( parameters );

  }

  MeshToonMaterial$1.prototype = Object.create( MeshPhongMaterial$1.prototype );
  MeshToonMaterial$1.prototype.constructor = MeshToonMaterial$1;

  MeshToonMaterial$1.prototype.isMeshToonMaterial = true;

  MeshToonMaterial$1.prototype.copy = function ( source ) {

  	MeshPhongMaterial$1.prototype.copy.call( this, source );

  	this.gradientMap = source.gradientMap;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   *
   * parameters = {
   *  opacity: <float>,
   *
   *  bumpMap: new THREE.Texture( <Image> ),
   *  bumpScale: <float>,
   *
   *  normalMap: new THREE.Texture( <Image> ),
   *  normalScale: <Vector2>,
   *
   *  displacementMap: new THREE.Texture( <Image> ),
   *  displacementScale: <float>,
   *  displacementBias: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshNormalMaterial$1( parameters ) {

  	Material$1.call( this, parameters );

  	this.type = 'MeshNormalMaterial';

  	this.bumpMap = null;
  	this.bumpScale = 1;

  	this.normalMap = null;
  	this.normalScale = new Vector2$1( 1, 1 );

  	this.displacementMap = null;
  	this.displacementScale = 1;
  	this.displacementBias = 0;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;

  	this.fog = false;
  	this.lights = false;

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshNormalMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshNormalMaterial$1.prototype.constructor = MeshNormalMaterial$1;

  MeshNormalMaterial$1.prototype.isMeshNormalMaterial = true;

  MeshNormalMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.bumpMap = source.bumpMap;
  	this.bumpScale = source.bumpScale;

  	this.normalMap = source.normalMap;
  	this.normalScale.copy( source.normalScale );

  	this.displacementMap = source.displacementMap;
  	this.displacementScale = source.displacementScale;
  	this.displacementBias = source.displacementBias;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  map: new THREE.Texture( <Image> ),
   *
   *  lightMap: new THREE.Texture( <Image> ),
   *  lightMapIntensity: <float>
   *
   *  aoMap: new THREE.Texture( <Image> ),
   *  aoMapIntensity: <float>
   *
   *  emissive: <hex>,
   *  emissiveIntensity: <float>
   *  emissiveMap: new THREE.Texture( <Image> ),
   *
   *  specularMap: new THREE.Texture( <Image> ),
   *
   *  alphaMap: new THREE.Texture( <Image> ),
   *
   *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
   *  combine: THREE.Multiply,
   *  reflectivity: <float>,
   *  refractionRatio: <float>,
   *
   *  wireframe: <boolean>,
   *  wireframeLinewidth: <float>,
   *
   *  skinning: <bool>,
   *  morphTargets: <bool>,
   *  morphNormals: <bool>
   * }
   */

  function MeshLambertMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'MeshLambertMaterial';

  	this.color = new Color$1( 0xffffff ); // diffuse

  	this.map = null;

  	this.lightMap = null;
  	this.lightMapIntensity = 1.0;

  	this.aoMap = null;
  	this.aoMapIntensity = 1.0;

  	this.emissive = new Color$1( 0x000000 );
  	this.emissiveIntensity = 1.0;
  	this.emissiveMap = null;

  	this.specularMap = null;

  	this.alphaMap = null;

  	this.envMap = null;
  	this.combine = MultiplyOperation$1;
  	this.reflectivity = 1;
  	this.refractionRatio = 0.98;

  	this.wireframe = false;
  	this.wireframeLinewidth = 1;
  	this.wireframeLinecap = 'round';
  	this.wireframeLinejoin = 'round';

  	this.skinning = false;
  	this.morphTargets = false;
  	this.morphNormals = false;

  	this.setValues( parameters );

  }

  MeshLambertMaterial$1.prototype = Object.create( Material$1.prototype );
  MeshLambertMaterial$1.prototype.constructor = MeshLambertMaterial$1;

  MeshLambertMaterial$1.prototype.isMeshLambertMaterial = true;

  MeshLambertMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.map = source.map;

  	this.lightMap = source.lightMap;
  	this.lightMapIntensity = source.lightMapIntensity;

  	this.aoMap = source.aoMap;
  	this.aoMapIntensity = source.aoMapIntensity;

  	this.emissive.copy( source.emissive );
  	this.emissiveMap = source.emissiveMap;
  	this.emissiveIntensity = source.emissiveIntensity;

  	this.specularMap = source.specularMap;

  	this.alphaMap = source.alphaMap;

  	this.envMap = source.envMap;
  	this.combine = source.combine;
  	this.reflectivity = source.reflectivity;
  	this.refractionRatio = source.refractionRatio;

  	this.wireframe = source.wireframe;
  	this.wireframeLinewidth = source.wireframeLinewidth;
  	this.wireframeLinecap = source.wireframeLinecap;
  	this.wireframeLinejoin = source.wireframeLinejoin;

  	this.skinning = source.skinning;
  	this.morphTargets = source.morphTargets;
  	this.morphNormals = source.morphNormals;

  	return this;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   *
   * parameters = {
   *  color: <hex>,
   *  opacity: <float>,
   *
   *  linewidth: <float>,
   *
   *  scale: <float>,
   *  dashSize: <float>,
   *  gapSize: <float>
   * }
   */

  function LineDashedMaterial$1( parameters ) {

  	Material$1.call( this );

  	this.type = 'LineDashedMaterial';

  	this.color = new Color$1( 0xffffff );

  	this.linewidth = 1;

  	this.scale = 1;
  	this.dashSize = 3;
  	this.gapSize = 1;

  	this.lights = false;

  	this.setValues( parameters );

  }

  LineDashedMaterial$1.prototype = Object.create( Material$1.prototype );
  LineDashedMaterial$1.prototype.constructor = LineDashedMaterial$1;

  LineDashedMaterial$1.prototype.isLineDashedMaterial = true;

  LineDashedMaterial$1.prototype.copy = function ( source ) {

  	Material$1.prototype.copy.call( this, source );

  	this.color.copy( source.color );

  	this.linewidth = source.linewidth;

  	this.scale = source.scale;
  	this.dashSize = source.dashSize;
  	this.gapSize = source.gapSize;

  	return this;

  };



  var Materials$1 = Object.freeze({
  	ShadowMaterial: ShadowMaterial$1,
  	SpriteMaterial: SpriteMaterial$1,
  	RawShaderMaterial: RawShaderMaterial$1,
  	ShaderMaterial: ShaderMaterial$1,
  	PointsMaterial: PointsMaterial$1,
  	MeshPhysicalMaterial: MeshPhysicalMaterial$1,
  	MeshStandardMaterial: MeshStandardMaterial$1,
  	MeshPhongMaterial: MeshPhongMaterial$1,
  	MeshToonMaterial: MeshToonMaterial$1,
  	MeshNormalMaterial: MeshNormalMaterial$1,
  	MeshLambertMaterial: MeshLambertMaterial$1,
  	MeshDepthMaterial: MeshDepthMaterial$1,
  	MeshBasicMaterial: MeshBasicMaterial$1,
  	LineDashedMaterial: LineDashedMaterial$1,
  	LineBasicMaterial: LineBasicMaterial$1,
  	Material: Material$1
  });

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var Cache$1 = {

  	enabled: false,

  	files: {},

  	add: function ( key, file ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Adding key:', key );

  		this.files[ key ] = file;

  	},

  	get: function ( key ) {

  		if ( this.enabled === false ) return;

  		// console.log( 'THREE.Cache', 'Checking key:', key );

  		return this.files[ key ];

  	},

  	remove: function ( key ) {

  		delete this.files[ key ];

  	},

  	clear: function () {

  		this.files = {};

  	}

  };

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LoadingManager$1( onLoad, onProgress, onError ) {

  	var scope = this;

  	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

  	this.onStart = undefined;
  	this.onLoad = onLoad;
  	this.onProgress = onProgress;
  	this.onError = onError;

  	this.itemStart = function ( url ) {

  		itemsTotal ++;

  		if ( isLoading === false ) {

  			if ( scope.onStart !== undefined ) {

  				scope.onStart( url, itemsLoaded, itemsTotal );

  			}

  		}

  		isLoading = true;

  	};

  	this.itemEnd = function ( url ) {

  		itemsLoaded ++;

  		if ( scope.onProgress !== undefined ) {

  			scope.onProgress( url, itemsLoaded, itemsTotal );

  		}

  		if ( itemsLoaded === itemsTotal ) {

  			isLoading = false;

  			if ( scope.onLoad !== undefined ) {

  				scope.onLoad();

  			}

  		}

  	};

  	this.itemError = function ( url ) {

  		if ( scope.onError !== undefined ) {

  			scope.onError( url );

  		}

  	};

  }

  var DefaultLoadingManager$1 = new LoadingManager$1();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FileLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( FileLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		var scope = this;

  		var cached = Cache$1.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		// Check for data: URI
  		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
  		var dataUriRegexResult = url.match( dataUriRegex );

  		// Safari can not handle Data URIs through XMLHttpRequest so process manually
  		if ( dataUriRegexResult ) {

  			var mimeType = dataUriRegexResult[ 1 ];
  			var isBase64 = !! dataUriRegexResult[ 2 ];
  			var data = dataUriRegexResult[ 3 ];

  			data = window.decodeURIComponent( data );

  			if ( isBase64 ) data = window.atob( data );

  			try {

  				var response;
  				var responseType = ( this.responseType || '' ).toLowerCase();

  				switch ( responseType ) {

  					case 'arraybuffer':
  					case 'blob':

  					 	response = new ArrayBuffer( data.length );

  						var view = new Uint8Array( response );

  						for ( var i = 0; i < data.length; i ++ ) {

  							view[ i ] = data.charCodeAt( i );

  						}

  						if ( responseType === 'blob' ) {

  							response = new Blob( [ response ], { type: mimeType } );

  						}

  						break;

  					case 'document':

  						var parser = new DOMParser();
  						response = parser.parseFromString( data, mimeType );

  						break;

  					case 'json':

  						response = JSON.parse( data );

  						break;

  					default: // 'text' or other

  						response = data;

  						break;

  				}

  				// Wait for next browser tick
  				window.setTimeout( function () {

  					if ( onLoad ) onLoad( response );

  					scope.manager.itemEnd( url );

  				}, 0 );

  			} catch ( error ) {

  				// Wait for next browser tick
  				window.setTimeout( function () {

  					if ( onError ) onError( error );

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}, 0 );

  			}

  		} else {

  			var request = new XMLHttpRequest();
  			request.open( 'GET', url, true );

  			request.addEventListener( 'load', function ( event ) {

  				var response = event.target.response;

  				Cache$1.add( url, response );

  				if ( this.status === 200 ) {

  					if ( onLoad ) onLoad( response );

  					scope.manager.itemEnd( url );

  				} else if ( this.status === 0 ) {

  					// Some browsers return HTTP Status 0 when using non-http protocol
  					// e.g. 'file://' or 'data://'. Handle as success.

  					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

  					if ( onLoad ) onLoad( response );

  					scope.manager.itemEnd( url );

  				} else {

  					if ( onError ) onError( event );

  					scope.manager.itemEnd( url );
  					scope.manager.itemError( url );

  				}

  			}, false );

  			if ( onProgress !== undefined ) {

  				request.addEventListener( 'progress', function ( event ) {

  					onProgress( event );

  				}, false );

  			}

  			request.addEventListener( 'error', function ( event ) {

  				if ( onError ) onError( event );

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			}, false );

  			if ( this.responseType !== undefined ) request.responseType = this.responseType;
  			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

  			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

  			for ( var header in this.requestHeader ) {

  				request.setRequestHeader( header, this.requestHeader[ header ] );

  			}

  			request.send( null );

  		}

  		scope.manager.itemStart( url );

  		return request;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	},

  	setResponseType: function ( value ) {

  		this.responseType = value;
  		return this;

  	},

  	setWithCredentials: function ( value ) {

  		this.withCredentials = value;
  		return this;

  	},

  	setMimeType: function ( value ) {

  		this.mimeType = value;
  		return this;

  	},

  	setRequestHeader: function ( value ) {

  		this.requestHeader = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   *
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   */

  function CompressedTextureLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( CompressedTextureLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var images = [];

  		var texture = new CompressedTexture$1();
  		texture.image = images;

  		var loader = new FileLoader$1( this.manager );
  		loader.setPath( this.path );
  		loader.setResponseType( 'arraybuffer' );

  		function loadTexture( i ) {

  			loader.load( url[ i ], function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				images[ i ] = {
  					width: texDatas.width,
  					height: texDatas.height,
  					format: texDatas.format,
  					mipmaps: texDatas.mipmaps
  				};

  				loaded += 1;

  				if ( loaded === 6 ) {

  					if ( texDatas.mipmapCount === 1 )
  						texture.minFilter = LinearFilter$1;

  					texture.format = texDatas.format;
  					texture.needsUpdate = true;

  					if ( onLoad ) onLoad( texture );

  				}

  			}, onProgress, onError );

  		}

  		if ( Array.isArray( url ) ) {

  			var loaded = 0;

  			for ( var i = 0, il = url.length; i < il; ++ i ) {

  				loadTexture( i );

  			}

  		} else {

  			// compressed cubemap texture stored in a single DDS file

  			loader.load( url, function ( buffer ) {

  				var texDatas = scope._parser( buffer, true );

  				if ( texDatas.isCubemap ) {

  					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

  					for ( var f = 0; f < faces; f ++ ) {

  						images[ f ] = { mipmaps : [] };

  						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

  							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
  							images[ f ].format = texDatas.format;
  							images[ f ].width = texDatas.width;
  							images[ f ].height = texDatas.height;

  						}

  					}

  				} else {

  					texture.image.width = texDatas.width;
  					texture.image.height = texDatas.height;
  					texture.mipmaps = texDatas.mipmaps;

  				}

  				if ( texDatas.mipmapCount === 1 ) {

  					texture.minFilter = LinearFilter$1;

  				}

  				texture.format = texDatas.format;
  				texture.needsUpdate = true;

  				if ( onLoad ) onLoad( texture );

  			}, onProgress, onError );

  		}

  		return texture;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author Nikos M. / https://github.com/foo123/
   *
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   */

  function DataTextureLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	// override in sub classes
  	this._parser = null;

  }

  Object.assign( DataTextureLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texture = new DataTexture$1();

  		var loader = new FileLoader$1( this.manager );
  		loader.setResponseType( 'arraybuffer' );

  		loader.load( url, function ( buffer ) {

  			var texData = scope._parser( buffer );

  			if ( ! texData ) return;

  			if ( undefined !== texData.image ) {

  				texture.image = texData.image;

  			} else if ( undefined !== texData.data ) {

  				texture.image.width = texData.width;
  				texture.image.height = texData.height;
  				texture.image.data = texData.data;

  			}

  			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping$1;
  			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping$1;

  			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter$1;
  			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter$1;

  			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

  			if ( undefined !== texData.format ) {

  				texture.format = texData.format;

  			}
  			if ( undefined !== texData.type ) {

  				texture.type = texData.type;

  			}

  			if ( undefined !== texData.mipmaps ) {

  				texture.mipmaps = texData.mipmaps;

  			}

  			if ( 1 === texData.mipmapCount ) {

  				texture.minFilter = LinearFilter$1;

  			}

  			texture.needsUpdate = true;

  			if ( onLoad ) onLoad( texture, texData );

  		}, onProgress, onError );


  		return texture;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ImageLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( ImageLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( url === undefined ) url = '';

  		if ( this.path !== undefined ) url = this.path + url;

  		var scope = this;

  		var cached = Cache$1.get( url );

  		if ( cached !== undefined ) {

  			scope.manager.itemStart( url );

  			setTimeout( function () {

  				if ( onLoad ) onLoad( cached );

  				scope.manager.itemEnd( url );

  			}, 0 );

  			return cached;

  		}

  		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

  		image.addEventListener( 'load', function () {

  			Cache$1.add( url, this );

  			if ( onLoad ) onLoad( this );

  			scope.manager.itemEnd( url );

  		}, false );

  		/*
  		image.addEventListener( 'progress', function ( event ) {

  			if ( onProgress ) onProgress( event );

  		}, false );
  		*/

  		image.addEventListener( 'error', function ( event ) {

  			if ( onError ) onError( event );

  			scope.manager.itemEnd( url );
  			scope.manager.itemError( url );

  		}, false );

  		if ( url.substr( 0, 5 ) !== 'data:' ) {

  			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

  		}

  		scope.manager.itemStart( url );

  		image.src = url;

  		return image;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function CubeTextureLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( CubeTextureLoader$1.prototype, {

  	load: function ( urls, onLoad, onProgress, onError ) {

  		var texture = new CubeTexture$1();

  		var loader = new ImageLoader$1( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var loaded = 0;

  		function loadTexture( i ) {

  			loader.load( urls[ i ], function ( image ) {

  				texture.images[ i ] = image;

  				loaded ++;

  				if ( loaded === 6 ) {

  					texture.needsUpdate = true;

  					if ( onLoad ) onLoad( texture );

  				}

  			}, undefined, onError );

  		}

  		for ( var i = 0; i < urls.length; ++ i ) {

  			loadTexture( i );

  		}

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function TextureLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( TextureLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new ImageLoader$1( this.manager );
  		loader.setCrossOrigin( this.crossOrigin );
  		loader.setPath( this.path );

  		var texture = new Texture$1();
  		texture.image = loader.load( url, function () {

  			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
  			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

  			texture.format = isJPEG ? RGBFormat$1 : RGBAFormat$1;
  			texture.needsUpdate = true;

  			if ( onLoad !== undefined ) {

  				onLoad( texture );

  			}

  		}, onProgress, onError );

  		return texture;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;
  		return this;

  	},

  	setPath: function ( value ) {

  		this.path = value;
  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function Light$1( color, intensity ) {

  	Object3D$1.call( this );

  	this.type = 'Light';

  	this.color = new Color$1( color );
  	this.intensity = intensity !== undefined ? intensity : 1;

  	this.receiveShadow = undefined;

  }

  Light$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Light$1,

  	isLight: true,

  	copy: function ( source ) {

  		Object3D$1.prototype.copy.call( this, source );

  		this.color.copy( source.color );
  		this.intensity = source.intensity;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Object3D$1.prototype.toJSON.call( this, meta );

  		data.object.color = this.color.getHex();
  		data.object.intensity = this.intensity;

  		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  		if ( this.distance !== undefined ) data.object.distance = this.distance;
  		if ( this.angle !== undefined ) data.object.angle = this.angle;
  		if ( this.decay !== undefined ) data.object.decay = this.decay;
  		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

  		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

  		return data;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function HemisphereLight$2( skyColor, groundColor, intensity ) {

  	Light$1.call( this, skyColor, intensity );

  	this.type = 'HemisphereLight';

  	this.castShadow = undefined;

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.groundColor = new Color$1( groundColor );

  }

  HemisphereLight$2.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: HemisphereLight$2,

  	isHemisphereLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.groundColor.copy( source.groundColor );

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function LightShadow$1( camera ) {

  	this.camera = camera;

  	this.bias = 0;
  	this.radius = 1;

  	this.mapSize = new Vector2$1( 512, 512 );

  	this.map = null;
  	this.matrix = new Matrix4$1();

  }

  Object.assign( LightShadow$1.prototype, {

  	copy: function ( source ) {

  		this.camera = source.camera.clone();

  		this.bias = source.bias;
  		this.radius = source.radius;

  		this.mapSize.copy( source.mapSize );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	toJSON: function () {

  		var object = {};

  		if ( this.bias !== 0 ) object.bias = this.bias;
  		if ( this.radius !== 1 ) object.radius = this.radius;
  		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

  		object.camera = this.camera.toJSON( false ).object;
  		delete object.camera.matrix;

  		return object;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function SpotLightShadow$1() {

  	LightShadow$1.call( this, new PerspectiveCamera$2( 50, 1, 0.5, 500 ) );

  }

  SpotLightShadow$1.prototype = Object.assign( Object.create( LightShadow$1.prototype ), {

  	constructor: SpotLightShadow$1,

  	isSpotLightShadow: true,

  	update: function ( light ) {

  		var camera = this.camera;

  		var fov = _Math$1.RAD2DEG * 2 * light.angle;
  		var aspect = this.mapSize.width / this.mapSize.height;
  		var far = light.distance || camera.far;

  		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

  			camera.fov = fov;
  			camera.aspect = aspect;
  			camera.far = far;
  			camera.updateProjectionMatrix();

  		}

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function SpotLight$2( color, intensity, distance, angle, penumbra, decay ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'SpotLight';

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D$1();

  	Object.defineProperty( this, 'power', {
  		get: function () {
  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * Math.PI;
  		},
  		set: function ( power ) {
  			// intensity = power per solid angle.
  			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / Math.PI;
  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new SpotLightShadow$1();

  }

  SpotLight$2.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: SpotLight$2,

  	isSpotLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.angle = source.angle;
  		this.penumbra = source.penumbra;
  		this.decay = source.decay;

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */


  function PointLight$2( color, intensity, distance, decay ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'PointLight';

  	Object.defineProperty( this, 'power', {
  		get: function () {
  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			return this.intensity * 4 * Math.PI;

  		},
  		set: function ( power ) {
  			// intensity = power per solid angle.
  			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
  			this.intensity = power / ( 4 * Math.PI );
  		}
  	} );

  	this.distance = ( distance !== undefined ) ? distance : 0;
  	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

  	this.shadow = new LightShadow$1( new PerspectiveCamera$2( 90, 1, 0.5, 500 ) );

  }

  PointLight$2.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: PointLight$2,

  	isPointLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.distance = source.distance;
  		this.decay = source.decay;

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function DirectionalLightShadow$1( ) {

  	LightShadow$1.call( this, new OrthographicCamera$2( - 5, 5, 5, - 5, 0.5, 500 ) );

  }

  DirectionalLightShadow$1.prototype = Object.assign( Object.create( LightShadow$1.prototype ), {

  	constructor: DirectionalLightShadow$1

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function DirectionalLight$2( color, intensity ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'DirectionalLight';

  	this.position.copy( Object3D$1.DefaultUp );
  	this.updateMatrix();

  	this.target = new Object3D$1();

  	this.shadow = new DirectionalLightShadow$1();

  }

  DirectionalLight$2.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: DirectionalLight$2,

  	isDirectionalLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.target = source.target.clone();

  		this.shadow = source.shadow.clone();

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AmbientLight$2( color, intensity ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'AmbientLight';

  	this.castShadow = undefined;

  }

  AmbientLight$2.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: AmbientLight$2,

  	isAmbientLight: true

  } );

  /**
   * @author abelnation / http://github.com/abelnation
   */

  function RectAreaLight$1( color, intensity, width, height ) {

  	Light$1.call( this, color, intensity );

  	this.type = 'RectAreaLight';

  	this.position.set( 0, 1, 0 );
  	this.updateMatrix();

  	this.width = ( width !== undefined ) ? width : 10;
  	this.height = ( height !== undefined ) ? height : 10;

  	// TODO (abelnation): distance/decay

  	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

  	// TODO (abelnation): shadows

  }

  // TODO (abelnation): RectAreaLight update when light shape is changed
  RectAreaLight$1.prototype = Object.assign( Object.create( Light$1.prototype ), {

  	constructor: RectAreaLight$1,

  	isRectAreaLight: true,

  	copy: function ( source ) {

  		Light$1.prototype.copy.call( this, source );

  		this.width = source.width;
  		this.height = source.height;

  		return this;

  	},

  	toJSON: function ( meta ) {

  		var data = Light$1.prototype.toJSON.call( this, meta );

  		data.object.width = this.width;
  		data.object.height = this.height;

  		return data;

  	}

  } );

  /**
   * @author tschw
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  var AnimationUtils$1 = {

  	// same as Array.prototype.slice, but also works on typed arrays
  	arraySlice: function ( array, from, to ) {

  		if ( AnimationUtils$1.isTypedArray( array ) ) {

  			// in ios9 array.subarray(from, undefined) will return empty array
  			// but array.subarray(from) or array.subarray(from, len) is correct
  			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

  		}

  		return array.slice( from, to );

  	},

  	// converts an array to a specific type
  	convertArray: function ( array, type, forceClone ) {

  		if ( ! array || // let 'undefined' and 'null' pass
  				! forceClone && array.constructor === type ) return array;

  		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

  			return new type( array ); // create typed array

  		}

  		return Array.prototype.slice.call( array ); // create Array

  	},

  	isTypedArray: function ( object ) {

  		return ArrayBuffer.isView( object ) &&
  				! ( object instanceof DataView );

  	},

  	// returns an array by which times and values can be sorted
  	getKeyframeOrder: function ( times ) {

  		function compareTime( i, j ) {

  			return times[ i ] - times[ j ];

  		}

  		var n = times.length;
  		var result = new Array( n );
  		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

  		result.sort( compareTime );

  		return result;

  	},

  	// uses the array previously returned by 'getKeyframeOrder' to sort data
  	sortedArray: function ( values, stride, order ) {

  		var nValues = values.length;
  		var result = new values.constructor( nValues );

  		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

  			var srcOffset = order[ i ] * stride;

  			for ( var j = 0; j !== stride; ++ j ) {

  				result[ dstOffset ++ ] = values[ srcOffset + j ];

  			}

  		}

  		return result;

  	},

  	// function for parsing AOS keyframe formats
  	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

  		var i = 1, key = jsonKeys[ 0 ];

  		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

  			key = jsonKeys[ i ++ ];

  		}

  		if ( key === undefined ) return; // no data

  		var value = key[ valuePropertyName ];
  		if ( value === undefined ) return; // no data

  		if ( Array.isArray( value ) ) {

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push.apply( values, value ); // push all elements

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else if ( value.toArray !== undefined ) {

  			// ...assume THREE.Math-ish

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					value.toArray( values, values.length );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		} else {

  			// otherwise push as-is

  			do {

  				value = key[ valuePropertyName ];

  				if ( value !== undefined ) {

  					times.push( key.time );
  					values.push( value );

  				}

  				key = jsonKeys[ i ++ ];

  			} while ( key !== undefined );

  		}

  	}

  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   * @author tschw
   */

  function Interpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	this.parameterPositions = parameterPositions;
  	this._cachedIndex = 0;

  	this.resultBuffer = resultBuffer !== undefined ?
  			resultBuffer : new sampleValues.constructor( sampleSize );
  	this.sampleValues = sampleValues;
  	this.valueSize = sampleSize;

  }

  Object.assign( Interpolant$1.prototype, {

  	evaluate: function( t ) {

  		var pp = this.parameterPositions,
  			i1 = this._cachedIndex,

  			t1 = pp[   i1   ],
  			t0 = pp[ i1 - 1 ];

  		validate_interval: {

  			seek: {

  				var right;

  				linear_scan: {
  					//- See http://jsperf.com/comparison-to-undefined/3
  					//- slower code:
  					//-
  					//- 				if ( t >= t1 || t1 === undefined ) {
  					forward_scan: if ( ! ( t < t1 ) ) {

  						for ( var giveUpAt = i1 + 2; ;) {

  							if ( t1 === undefined ) {

  								if ( t < t0 ) break forward_scan;

  								// after end

  								i1 = pp.length;
  								this._cachedIndex = i1;
  								return this.afterEnd_( i1 - 1, t, t0 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t0 = t1;
  							t1 = pp[ ++ i1 ];

  							if ( t < t1 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the right side of the index
  						right = pp.length;
  						break linear_scan;

  					}

  					//- slower code:
  					//-					if ( t < t0 || t0 === undefined ) {
  					if ( ! ( t >= t0 ) ) {

  						// looping?

  						var t1global = pp[ 1 ];

  						if ( t < t1global ) {

  							i1 = 2; // + 1, using the scan for the details
  							t0 = t1global;

  						}

  						// linear reverse scan

  						for ( var giveUpAt = i1 - 2; ;) {

  							if ( t0 === undefined ) {

  								// before start

  								this._cachedIndex = 0;
  								return this.beforeStart_( 0, t, t1 );

  							}

  							if ( i1 === giveUpAt ) break; // this loop

  							t1 = t0;
  							t0 = pp[ -- i1 - 1 ];

  							if ( t >= t0 ) {

  								// we have arrived at the sought interval
  								break seek;

  							}

  						}

  						// prepare binary search on the left side of the index
  						right = i1;
  						i1 = 0;
  						break linear_scan;

  					}

  					// the interval is valid

  					break validate_interval;

  				} // linear scan

  				// binary search

  				while ( i1 < right ) {

  					var mid = ( i1 + right ) >>> 1;

  					if ( t < pp[ mid ] ) {

  						right = mid;

  					} else {

  						i1 = mid + 1;

  					}

  				}

  				t1 = pp[   i1   ];
  				t0 = pp[ i1 - 1 ];

  				// check boundary cases, again

  				if ( t0 === undefined ) {

  					this._cachedIndex = 0;
  					return this.beforeStart_( 0, t, t1 );

  				}

  				if ( t1 === undefined ) {

  					i1 = pp.length;
  					this._cachedIndex = i1;
  					return this.afterEnd_( i1 - 1, t0, t );

  				}

  			} // seek

  			this._cachedIndex = i1;

  			this.intervalChanged_( i1, t0, t1 );

  		} // validate_interval

  		return this.interpolate_( i1, t0, t, t1 );

  	},

  	settings: null, // optional, subclass-specific settings structure
  	// Note: The indirection allows central control of many interpolants.

  	// --- Protected interface

  	DefaultSettings_: {},

  	getSettings_: function() {

  		return this.settings || this.DefaultSettings_;

  	},

  	copySampleValue_: function( index ) {

  		// copies a sample value to the result buffer

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,
  			offset = index * stride;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] = values[ offset + i ];

  		}

  		return result;

  	},

  	// Template methods for derived classes:

  	interpolate_: function( i1, t0, t, t1 ) {

  		throw new Error( "call to abstract method" );
  		// implementations shall return this.resultBuffer

  	},

  	intervalChanged_: function( i1, t0, t1 ) {

  		// empty

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( Interpolant$1.prototype, {

  	//( 0, t, t0 ), returns this.resultBuffer
  	beforeStart_: Interpolant$1.prototype.copySampleValue_,

  	//( N-1, tN-1, t ), returns this.resultBuffer
  	afterEnd_: Interpolant$1.prototype.copySampleValue_,

  } );

  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   *
   * @author tschw
   */

  function CubicInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call(
  			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  	this._weightPrev = -0;
  	this._offsetPrev = -0;
  	this._weightNext = -0;
  	this._offsetNext = -0;

  }

  CubicInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: CubicInterpolant$1,

  	DefaultSettings_: {

  		endingStart: 	ZeroCurvatureEnding$1,
  		endingEnd:		ZeroCurvatureEnding$1

  	},

  	intervalChanged_: function( i1, t0, t1 ) {

  		var pp = this.parameterPositions,
  			iPrev = i1 - 2,
  			iNext = i1 + 1,

  			tPrev = pp[ iPrev ],
  			tNext = pp[ iNext ];

  		if ( tPrev === undefined ) {

  			switch ( this.getSettings_().endingStart ) {

  				case ZeroSlopeEnding$1:

  					// f'(t0) = 0
  					iPrev = i1;
  					tPrev = 2 * t0 - t1;

  					break;

  				case WrapAroundEnding$1:

  					// use the other end of the curve
  					iPrev = pp.length - 2;
  					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(t0) = 0 a.k.a. Natural Spline
  					iPrev = i1;
  					tPrev = t1;

  			}

  		}

  		if ( tNext === undefined ) {

  			switch ( this.getSettings_().endingEnd ) {

  				case ZeroSlopeEnding$1:

  					// f'(tN) = 0
  					iNext = i1;
  					tNext = 2 * t1 - t0;

  					break;

  				case WrapAroundEnding$1:

  					// use the other end of the curve
  					iNext = 1;
  					tNext = t1 + pp[ 1 ] - pp[ 0 ];

  					break;

  				default: // ZeroCurvatureEnding

  					// f''(tN) = 0, a.k.a. Natural Spline
  					iNext = i1 - 1;
  					tNext = t0;

  			}

  		}

  		var halfDt = ( t1 - t0 ) * 0.5,
  			stride = this.valueSize;

  		this._weightPrev = halfDt / ( t0 - tPrev );
  		this._weightNext = halfDt / ( tNext - t1 );
  		this._offsetPrev = iPrev * stride;
  		this._offsetNext = iNext * stride;

  	},

  	interpolate_: function( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			o1 = i1 * stride,		o0 = o1 - stride,
  			oP = this._offsetPrev, 	oN = this._offsetNext,
  			wP = this._weightPrev,	wN = this._weightNext,

  			p = ( t - t0 ) / ( t1 - t0 ),
  			pp = p * p,
  			ppp = pp * p;

  		// evaluate polynomials

  		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
  		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
  		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
  		var sN =       wN   * ppp   -           wN      * pp;

  		// combine data linearly

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					sP * values[ oP + i ] +
  					s0 * values[ o0 + i ] +
  					s1 * values[ o1 + i ] +
  					sN * values[ oN + i ];

  		}

  		return result;

  	}

  } );

  /**
   * @author tschw
   */

  function LinearInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  LinearInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: LinearInterpolant$1,

  	interpolate_: function( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset1 = i1 * stride,
  			offset0 = offset1 - stride,

  			weight1 = ( t - t0 ) / ( t1 - t0 ),
  			weight0 = 1 - weight1;

  		for ( var i = 0; i !== stride; ++ i ) {

  			result[ i ] =
  					values[ offset0 + i ] * weight0 +
  					values[ offset1 + i ] * weight1;

  		}

  		return result;

  	}

  } );

  /**
   *
   * Interpolant that evaluates to the sample value at the position preceeding
   * the parameter.
   *
   * @author tschw
   */

  function DiscreteInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  DiscreteInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: DiscreteInterpolant$1,

  	interpolate_: function( i1, t0, t, t1 ) {

  		return this.copySampleValue_( i1 - 1 );

  	}

  } );

  var KeyframeTrackPrototype;

  KeyframeTrackPrototype = {

  	TimeBufferType: Float32Array,
  	ValueBufferType: Float32Array,

  	DefaultInterpolation: InterpolateLinear$1,

  	InterpolantFactoryMethodDiscrete: function ( result ) {

  		return new DiscreteInterpolant$1(
  				this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodLinear: function ( result ) {

  		return new LinearInterpolant$1(
  				this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: function ( result ) {

  		return new CubicInterpolant$1(
  				this.times, this.values, this.getValueSize(), result );

  	},

  	setInterpolation: function ( interpolation ) {

  		var factoryMethod;

  		switch ( interpolation ) {

  			case InterpolateDiscrete$1:

  				factoryMethod = this.InterpolantFactoryMethodDiscrete;

  				break;

  			case InterpolateLinear$1:

  				factoryMethod = this.InterpolantFactoryMethodLinear;

  				break;

  			case InterpolateSmooth$1:

  				factoryMethod = this.InterpolantFactoryMethodSmooth;

  				break;

  		}

  		if ( factoryMethod === undefined ) {

  			var message = "unsupported interpolation for " +
  					this.ValueTypeName + " keyframe track named " + this.name;

  			if ( this.createInterpolant === undefined ) {

  				// fall back to default, unless the default itself is messed up
  				if ( interpolation !== this.DefaultInterpolation ) {

  					this.setInterpolation( this.DefaultInterpolation );

  				} else {

  					throw new Error( message ); // fatal, in this case

  				}

  			}

  			console.warn( message );
  			return;

  		}

  		this.createInterpolant = factoryMethod;

  	},

  	getInterpolation: function () {

  		switch ( this.createInterpolant ) {

  			case this.InterpolantFactoryMethodDiscrete:

  				return InterpolateDiscrete$1;

  			case this.InterpolantFactoryMethodLinear:

  				return InterpolateLinear$1;

  			case this.InterpolantFactoryMethodSmooth:

  				return InterpolateSmooth$1;

  		}

  	},

  	getValueSize: function () {

  		return this.values.length / this.times.length;

  	},

  	// move all keyframes either forwards or backwards in time
  	shift: function ( timeOffset ) {

  		if ( timeOffset !== 0.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] += timeOffset;

  			}

  		}

  		return this;

  	},

  	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  	scale: function ( timeScale ) {

  		if ( timeScale !== 1.0 ) {

  			var times = this.times;

  			for ( var i = 0, n = times.length; i !== n; ++ i ) {

  				times[ i ] *= timeScale;

  			}

  		}

  		return this;

  	},

  	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  	trim: function ( startTime, endTime ) {

  		var times = this.times,
  			nKeys = times.length,
  			from = 0,
  			to = nKeys - 1;

  		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
  		while ( to !== - 1 && times[ to ] > endTime ) -- to;

  		++ to; // inclusive -> exclusive bound

  		if ( from !== 0 || to !== nKeys ) {

  			// empty tracks are forbidden, so keep at least one keyframe
  			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

  			var stride = this.getValueSize();
  			this.times = AnimationUtils$1.arraySlice( times, from, to );
  			this.values = AnimationUtils$1.
  					arraySlice( this.values, from * stride, to * stride );

  		}

  		return this;

  	},

  	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  	validate: function () {

  		var valid = true;

  		var valueSize = this.getValueSize();
  		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

  			console.error( "invalid value size in track", this );
  			valid = false;

  		}

  		var times = this.times,
  			values = this.values,

  			nKeys = times.length;

  		if ( nKeys === 0 ) {

  			console.error( "track is empty", this );
  			valid = false;

  		}

  		var prevTime = null;

  		for ( var i = 0; i !== nKeys; i ++ ) {

  			var currTime = times[ i ];

  			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

  				console.error( "time is not a valid number", this, i, currTime );
  				valid = false;
  				break;

  			}

  			if ( prevTime !== null && prevTime > currTime ) {

  				console.error( "out of order keys", this, i, currTime, prevTime );
  				valid = false;
  				break;

  			}

  			prevTime = currTime;

  		}

  		if ( values !== undefined ) {

  			if ( AnimationUtils$1.isTypedArray( values ) ) {

  				for ( var i = 0, n = values.length; i !== n; ++ i ) {

  					var value = values[ i ];

  					if ( isNaN( value ) ) {

  						console.error( "value is not a valid number", this, i, value );
  						valid = false;
  						break;

  					}

  				}

  			}

  		}

  		return valid;

  	},

  	// removes equivalent sequential keys as common in morph target sequences
  	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  	optimize: function () {

  		var times = this.times,
  			values = this.values,
  			stride = this.getValueSize(),

  			smoothInterpolation = this.getInterpolation() === InterpolateSmooth$1,

  			writeIndex = 1,
  			lastIndex = times.length - 1;

  		for ( var i = 1; i < lastIndex; ++ i ) {

  			var keep = false;

  			var time = times[ i ];
  			var timeNext = times[ i + 1 ];

  			// remove adjacent keyframes scheduled at the same time

  			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

  				if ( ! smoothInterpolation ) {

  					// remove unnecessary keyframes same as their neighbors

  					var offset = i * stride,
  						offsetP = offset - stride,
  						offsetN = offset + stride;

  					for ( var j = 0; j !== stride; ++ j ) {

  						var value = values[ offset + j ];

  						if ( value !== values[ offsetP + j ] ||
  								value !== values[ offsetN + j ] ) {

  							keep = true;
  							break;

  						}

  					}

  				} else keep = true;

  			}

  			// in-place compaction

  			if ( keep ) {

  				if ( i !== writeIndex ) {

  					times[ writeIndex ] = times[ i ];

  					var readOffset = i * stride,
  						writeOffset = writeIndex * stride;

  					for ( var j = 0; j !== stride; ++ j )

  						values[ writeOffset + j ] = values[ readOffset + j ];

  				}

  				++ writeIndex;

  			}

  		}

  		// flush last keyframe (compaction looks ahead)

  		if ( lastIndex > 0 ) {

  			times[ writeIndex ] = times[ lastIndex ];

  			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

  				values[ writeOffset + j ] = values[ readOffset + j ];

  			++ writeIndex;

  		}

  		if ( writeIndex !== times.length ) {

  			this.times = AnimationUtils$1.arraySlice( times, 0, writeIndex );
  			this.values = AnimationUtils$1.arraySlice( values, 0, writeIndex * stride );

  		}

  		return this;

  	}

  };

  function KeyframeTrackConstructor( name, times, values, interpolation ) {

  	if ( name === undefined ) throw new Error( "track name is undefined" );

  	if ( times === undefined || times.length === 0 ) {

  		throw new Error( "no keyframes in track named " + name );

  	}

  	this.name = name;

  	this.times = AnimationUtils$1.convertArray( times, this.TimeBufferType );
  	this.values = AnimationUtils$1.convertArray( values, this.ValueBufferType );

  	this.setInterpolation( interpolation || this.DefaultInterpolation );

  	this.validate();
  	this.optimize();

  }

  /**
   *
   * A Track of vectored keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function VectorKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  VectorKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: VectorKeyframeTrack$1,

  	ValueTypeName: 'vector'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   * Spherical linear unit quaternion interpolant.
   *
   * @author tschw
   */

  function QuaternionLinearInterpolant$1( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  	Interpolant$1.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  }

  QuaternionLinearInterpolant$1.prototype = Object.assign( Object.create( Interpolant$1.prototype ), {

  	constructor: QuaternionLinearInterpolant$1,

  	interpolate_: function( i1, t0, t, t1 ) {

  		var result = this.resultBuffer,
  			values = this.sampleValues,
  			stride = this.valueSize,

  			offset = i1 * stride,

  			alpha = ( t - t0 ) / ( t1 - t0 );

  		for ( var end = offset + stride; offset !== end; offset += 4 ) {

  			Quaternion$1.slerpFlat( result, 0,
  					values, offset - stride, values, offset, alpha );

  		}

  		return result;

  	}

  } );

  /**
   *
   * A Track of quaternion keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function QuaternionKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  QuaternionKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: QuaternionKeyframeTrack$1,

  	ValueTypeName: 'quaternion',

  	// ValueBufferType is inherited

  	DefaultInterpolation: InterpolateLinear$1,

  	InterpolantFactoryMethodLinear: function( result ) {

  		return new QuaternionLinearInterpolant$1(
  				this.times, this.values, this.getValueSize(), result );

  	},

  	InterpolantFactoryMethodSmooth: undefined // not yet implemented

  } );

  /**
   *
   * A Track of numeric keyframe values.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function NumberKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  NumberKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: NumberKeyframeTrack$1,

  	ValueTypeName: 'number'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited

  } );

  /**
   *
   * A Track that interpolates Strings
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function StringKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  StringKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: StringKeyframeTrack$1,

  	ValueTypeName: 'string',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete$1,

  	InterpolantFactoryMethodLinear: undefined,

  	InterpolantFactoryMethodSmooth: undefined

  } );

  /**
   *
   * A Track of Boolean keyframe values.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function BooleanKeyframeTrack$1( name, times, values ) {

  	KeyframeTrackConstructor.call( this, name, times, values );

  }

  BooleanKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: BooleanKeyframeTrack$1,

  	ValueTypeName: 'bool',
  	ValueBufferType: Array,

  	DefaultInterpolation: InterpolateDiscrete$1,

  	InterpolantFactoryMethodLinear: undefined,
  	InterpolantFactoryMethodSmooth: undefined

  	// Note: Actually this track could have a optimized / compressed
  	// representation of a single value and a custom interpolant that
  	// computes "firstValue ^ isOdd( index )".

  } );

  /**
   *
   * A Track of keyframe values that represent color.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function ColorKeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

  }

  ColorKeyframeTrack$1.prototype =
  		Object.assign( Object.create( KeyframeTrackPrototype ), {

  	constructor: ColorKeyframeTrack$1,

  	ValueTypeName: 'color'

  	// ValueBufferType is inherited

  	// DefaultInterpolation is inherited


  	// Note: Very basic implementation and nothing special yet.
  	// However, this is the place for color space parameterization.

  } );

  /**
   *
   * A timed sequence of keyframes for a specific property.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function KeyframeTrack$1( name, times, values, interpolation ) {

  	KeyframeTrackConstructor.apply( this, arguments );

  }

  KeyframeTrack$1.prototype = KeyframeTrackPrototype;
  KeyframeTrackPrototype.constructor = KeyframeTrack$1;

  // Static methods:

  Object.assign( KeyframeTrack$1, {

  	// Serialization (in static context, because of constructor invocation
  	// and automatic invocation of .toJSON):

  	parse: function( json ) {

  		if( json.type === undefined ) {

  			throw new Error( "track type undefined, can not parse" );

  		}

  		var trackType = KeyframeTrack$1._getTrackTypeForValueTypeName( json.type );

  		if ( json.times === undefined ) {

  			var times = [], values = [];

  			AnimationUtils$1.flattenJSON( json.keys, times, values, 'value' );

  			json.times = times;
  			json.values = values;

  		}

  		// derived classes can define a static parse method
  		if ( trackType.parse !== undefined ) {

  			return trackType.parse( json );

  		} else {

  			// by default, we asssume a constructor compatible with the base
  			return new trackType(
  					json.name, json.times, json.values, json.interpolation );

  		}

  	},

  	toJSON: function( track ) {

  		var trackType = track.constructor;

  		var json;

  		// derived classes can define a static toJSON method
  		if ( trackType.toJSON !== undefined ) {

  			json = trackType.toJSON( track );

  		} else {

  			// by default, we assume the data can be serialized as-is
  			json = {

  				'name': track.name,
  				'times': AnimationUtils$1.convertArray( track.times, Array ),
  				'values': AnimationUtils$1.convertArray( track.values, Array )

  			};

  			var interpolation = track.getInterpolation();

  			if ( interpolation !== track.DefaultInterpolation ) {

  				json.interpolation = interpolation;

  			}

  		}

  		json.type = track.ValueTypeName; // mandatory

  		return json;

  	},

  	_getTrackTypeForValueTypeName: function( typeName ) {

  		switch( typeName.toLowerCase() ) {

  			case "scalar":
  			case "double":
  			case "float":
  			case "number":
  			case "integer":

  				return NumberKeyframeTrack$1;

  			case "vector":
  			case "vector2":
  			case "vector3":
  			case "vector4":

  				return VectorKeyframeTrack$1;

  			case "color":

  				return ColorKeyframeTrack$1;

  			case "quaternion":

  				return QuaternionKeyframeTrack$1;

  			case "bool":
  			case "boolean":

  				return BooleanKeyframeTrack$1;

  			case "string":

  				return StringKeyframeTrack$1;

  		}

  		throw new Error( "Unsupported typeName: " + typeName );

  	}

  } );

  /**
   *
   * Reusable set of Tracks that represent an animation.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   */

  function AnimationClip$1( name, duration, tracks ) {

  	this.name = name;
  	this.tracks = tracks;
  	this.duration = ( duration !== undefined ) ? duration : - 1;

  	this.uuid = _Math$1.generateUUID();

  	// this means it should figure out its duration by scanning the tracks
  	if ( this.duration < 0 ) {

  		this.resetDuration();

  	}

  	this.optimize();

  }

  Object.assign( AnimationClip$1, {

  	parse: function ( json ) {

  		var tracks = [],
  			jsonTracks = json.tracks,
  			frameTime = 1.0 / ( json.fps || 1.0 );

  		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack$1.parse( jsonTracks[ i ] ).scale( frameTime ) );

  		}

  		return new AnimationClip$1( json.name, json.duration, tracks );

  	},

  	toJSON: function ( clip ) {

  		var tracks = [],
  			clipTracks = clip.tracks;

  		var json = {

  			'name': clip.name,
  			'duration': clip.duration,
  			'tracks': tracks

  		};

  		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

  			tracks.push( KeyframeTrack$1.toJSON( clipTracks[ i ] ) );

  		}

  		return json;

  	},

  	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

  		var numMorphTargets = morphTargetSequence.length;
  		var tracks = [];

  		for ( var i = 0; i < numMorphTargets; i ++ ) {

  			var times = [];
  			var values = [];

  			times.push(
  					( i + numMorphTargets - 1 ) % numMorphTargets,
  					i,
  					( i + 1 ) % numMorphTargets );

  			values.push( 0, 1, 0 );

  			var order = AnimationUtils$1.getKeyframeOrder( times );
  			times = AnimationUtils$1.sortedArray( times, 1, order );
  			values = AnimationUtils$1.sortedArray( values, 1, order );

  			// if there is a key at the first frame, duplicate it as the
  			// last frame as well for perfect loop.
  			if ( ! noLoop && times[ 0 ] === 0 ) {

  				times.push( numMorphTargets );
  				values.push( values[ 0 ] );

  			}

  			tracks.push(
  					new NumberKeyframeTrack$1(
  						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
  						times, values
  					).scale( 1.0 / fps ) );

  		}

  		return new AnimationClip$1( name, - 1, tracks );

  	},

  	findByName: function ( objectOrClipArray, name ) {

  		var clipArray = objectOrClipArray;

  		if ( ! Array.isArray( objectOrClipArray ) ) {

  			var o = objectOrClipArray;
  			clipArray = o.geometry && o.geometry.animations || o.animations;

  		}

  		for ( var i = 0; i < clipArray.length; i ++ ) {

  			if ( clipArray[ i ].name === name ) {

  				return clipArray[ i ];

  			}

  		}

  		return null;

  	},

  	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

  		var animationToMorphTargets = {};

  		// tested with https://regex101.com/ on trick sequences
  		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
  		var pattern = /^([\w-]*?)([\d]+)$/;

  		// sort morph target names into animation groups based
  		// patterns like Walk_001, Walk_002, Run_001, Run_002
  		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

  			var morphTarget = morphTargets[ i ];
  			var parts = morphTarget.name.match( pattern );

  			if ( parts && parts.length > 1 ) {

  				var name = parts[ 1 ];

  				var animationMorphTargets = animationToMorphTargets[ name ];
  				if ( ! animationMorphTargets ) {

  					animationToMorphTargets[ name ] = animationMorphTargets = [];

  				}

  				animationMorphTargets.push( morphTarget );

  			}

  		}

  		var clips = [];

  		for ( var name in animationToMorphTargets ) {

  			clips.push( AnimationClip$1.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

  		}

  		return clips;

  	},

  	// parse the animation.hierarchy format
  	parseAnimation: function ( animation, bones ) {

  		if ( ! animation ) {

  			console.error( "  no animation in JSONLoader data" );
  			return null;

  		}

  		var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

  			// only return track if there are actually keys.
  			if ( animationKeys.length !== 0 ) {

  				var times = [];
  				var values = [];

  				AnimationUtils$1.flattenJSON( animationKeys, times, values, propertyName );

  				// empty keys are filtered out, so check again
  				if ( times.length !== 0 ) {

  					destTracks.push( new trackType( trackName, times, values ) );

  				}

  			}

  		};

  		var tracks = [];

  		var clipName = animation.name || 'default';
  		// automatic length determination in AnimationClip.
  		var duration = animation.length || - 1;
  		var fps = animation.fps || 30;

  		var hierarchyTracks = animation.hierarchy || [];

  		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

  			var animationKeys = hierarchyTracks[ h ].keys;

  			// skip empty tracks
  			if ( ! animationKeys || animationKeys.length === 0 ) continue;

  			// process morph targets in a way exactly compatible
  			// with AnimationHandler.init( animation )
  			if ( animationKeys[ 0 ].morphTargets ) {

  				// figure out all morph targets used in this track
  				var morphTargetNames = {};

  				for ( var k = 0; k < animationKeys.length; k ++ ) {

  					if ( animationKeys[ k ].morphTargets ) {

  						for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

  							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

  						}

  					}

  				}

  				// create a track for each morph target with all zero
  				// morphTargetInfluences except for the keys in which
  				// the morphTarget is named.
  				for ( var morphTargetName in morphTargetNames ) {

  					var times = [];
  					var values = [];

  					for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

  						var animationKey = animationKeys[ k ];

  						times.push( animationKey.time );
  						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

  					}

  					tracks.push( new NumberKeyframeTrack$1( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

  				}

  				duration = morphTargetNames.length * ( fps || 1.0 );

  			} else {

  				// ...assume skeletal animation

  				var boneName = '.bones[' + bones[ h ].name + ']';

  				addNonemptyTrack(
  						VectorKeyframeTrack$1, boneName + '.position',
  						animationKeys, 'pos', tracks );

  				addNonemptyTrack(
  						QuaternionKeyframeTrack$1, boneName + '.quaternion',
  						animationKeys, 'rot', tracks );

  				addNonemptyTrack(
  						VectorKeyframeTrack$1, boneName + '.scale',
  						animationKeys, 'scl', tracks );

  			}

  		}

  		if ( tracks.length === 0 ) {

  			return null;

  		}

  		var clip = new AnimationClip$1( clipName, duration, tracks );

  		return clip;

  	}

  } );

  Object.assign( AnimationClip$1.prototype, {

  	resetDuration: function () {

  		var tracks = this.tracks, duration = 0;

  		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

  			var track = this.tracks[ i ];

  			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

  		}

  		this.duration = duration;

  	},

  	trim: function () {

  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].trim( 0, this.duration );

  		}

  		return this;

  	},

  	optimize: function () {

  		for ( var i = 0; i < this.tracks.length; i ++ ) {

  			this.tracks[ i ].optimize();

  		}

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function MaterialLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;
  	this.textures = {};

  }

  Object.assign( MaterialLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.setResponseType( 'json' );
  		loader.load( url, function ( json ) {

  			onLoad( scope.parse( json ) );

  		}, onProgress, onError );

  	},

  	setTextures: function ( value ) {

  		this.textures = value;

  	},

  	parse: function ( json ) {

  		var textures = this.textures;

  		function getTexture( name ) {

  			if ( textures[ name ] === undefined ) {

  				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

  			}

  			return textures[ name ];

  		}

  		var material = new Materials$1[ json.type ]();

  		if ( json.uuid !== undefined ) material.uuid = json.uuid;
  		if ( json.name !== undefined ) material.name = json.name;
  		if ( json.color !== undefined ) material.color.setHex( json.color );
  		if ( json.roughness !== undefined ) material.roughness = json.roughness;
  		if ( json.metalness !== undefined ) material.metalness = json.metalness;
  		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
  		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
  		if ( json.shininess !== undefined ) material.shininess = json.shininess;
  		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
  		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
  		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
  		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
  		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
  		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
  		if ( json.fog !== undefined ) material.fog = json.fog;
  		if ( json.shading !== undefined ) material.shading = json.shading;
  		if ( json.blending !== undefined ) material.blending = json.blending;
  		if ( json.side !== undefined ) material.side = json.side;
  		if ( json.opacity !== undefined ) material.opacity = json.opacity;
  		if ( json.transparent !== undefined ) material.transparent = json.transparent;
  		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
  		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
  		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
  		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
  		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
  		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
  		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
  		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
  		if ( json.skinning !== undefined ) material.skinning = json.skinning;
  		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

  		// for PointsMaterial

  		if ( json.size !== undefined ) material.size = json.size;
  		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

  		// maps

  		if ( json.map !== undefined ) material.map = getTexture( json.map );

  		if ( json.alphaMap !== undefined ) {

  			material.alphaMap = getTexture( json.alphaMap );
  			material.transparent = true;

  		}

  		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
  		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

  		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
  		if ( json.normalScale !== undefined ) {

  			var normalScale = json.normalScale;

  			if ( Array.isArray( normalScale ) === false ) {

  				// Blender exporter used to export a scalar. See #7459

  				normalScale = [ normalScale, normalScale ];

  			}

  			material.normalScale = new Vector2$1().fromArray( normalScale );

  		}

  		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
  		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
  		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

  		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
  		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

  		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
  		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

  		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

  		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

  		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

  		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
  		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

  		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
  		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

  		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

  		return material;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function BufferGeometryLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( BufferGeometryLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.setResponseType( 'json' );
  		loader.load( url, function ( json ) {

  			onLoad( scope.parse( json ) );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		var geometry = new BufferGeometry$1();

  		var index = json.data.index;

  		if ( index !== undefined ) {

  			var typedArray = new TYPED_ARRAYS$1[ index.type ]( index.array );
  			geometry.setIndex( new BufferAttribute$1( typedArray, 1 ) );

  		}

  		var attributes = json.data.attributes;

  		for ( var key in attributes ) {

  			var attribute = attributes[ key ];
  			var typedArray = new TYPED_ARRAYS$1[ attribute.type ]( attribute.array );

  			geometry.addAttribute( key, new BufferAttribute$1( typedArray, attribute.itemSize, attribute.normalized ) );

  		}

  		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

  		if ( groups !== undefined ) {

  			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

  				var group = groups[ i ];

  				geometry.addGroup( group.start, group.count, group.materialIndex );

  			}

  		}

  		var boundingSphere = json.data.boundingSphere;

  		if ( boundingSphere !== undefined ) {

  			var center = new Vector3$1();

  			if ( boundingSphere.center !== undefined ) {

  				center.fromArray( boundingSphere.center );

  			}

  			geometry.boundingSphere = new Sphere$2( center, boundingSphere.radius );

  		}

  		return geometry;

  	}

  } );

  var TYPED_ARRAYS$1 = {
  	Int8Array: Int8Array,
  	Uint8Array: Uint8Array,
  	Uint8ClampedArray: Uint8ClampedArray,
  	Int16Array: Int16Array,
  	Uint16Array: Uint16Array,
  	Int32Array: Int32Array,
  	Uint32Array: Uint32Array,
  	Float32Array: Float32Array,
  	Float64Array: Float64Array
  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Loader$1() {

  	this.onLoadStart = function () {};
  	this.onLoadProgress = function () {};
  	this.onLoadComplete = function () {};

  }

  Loader$1.Handlers = {

  	handlers: [],

  	add: function ( regex, loader ) {

  		this.handlers.push( regex, loader );

  	},

  	get: function ( file ) {

  		var handlers = this.handlers;

  		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

  			var regex = handlers[ i ];
  			var loader = handlers[ i + 1 ];

  			if ( regex.test( file ) ) {

  				return loader;

  			}

  		}

  		return null;

  	}

  };

  Object.assign( Loader$1.prototype, {

  	crossOrigin: undefined,

  	extractUrlBase: function ( url ) {

  		var parts = url.split( '/' );

  		if ( parts.length === 1 ) return './';

  		parts.pop();

  		return parts.join( '/' ) + '/';

  	},

  	initMaterials: function ( materials, texturePath, crossOrigin ) {

  		var array = [];

  		for ( var i = 0; i < materials.length; ++ i ) {

  			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

  		}

  		return array;

  	},

  	createMaterial: ( function () {

  		var BlendingMode = {
  			NoBlending: NoBlending$1,
  			NormalBlending: NormalBlending$1,
  			AdditiveBlending: AdditiveBlending$1,
  			SubtractiveBlending: SubtractiveBlending$1,
  			MultiplyBlending: MultiplyBlending$1,
  			CustomBlending: CustomBlending$1
  		};

  		var color = new Color$1();
  		var textureLoader = new TextureLoader$1();
  		var materialLoader = new MaterialLoader$1();

  		return function createMaterial( m, texturePath, crossOrigin ) {

  			// convert from old material format

  			var textures = {};

  			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

  				var fullPath = texturePath + path;
  				var loader = Loader$1.Handlers.get( fullPath );

  				var texture;

  				if ( loader !== null ) {

  					texture = loader.load( fullPath );

  				} else {

  					textureLoader.setCrossOrigin( crossOrigin );
  					texture = textureLoader.load( fullPath );

  				}

  				if ( repeat !== undefined ) {

  					texture.repeat.fromArray( repeat );

  					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping$1;
  					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping$1;

  				}

  				if ( offset !== undefined ) {

  					texture.offset.fromArray( offset );

  				}

  				if ( wrap !== undefined ) {

  					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping$1;
  					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping$1;

  					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping$1;
  					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping$1;

  				}

  				if ( anisotropy !== undefined ) {

  					texture.anisotropy = anisotropy;

  				}

  				var uuid = _Math$1.generateUUID();

  				textures[ uuid ] = texture;

  				return uuid;

  			}

  			//

  			var json = {
  				uuid: _Math$1.generateUUID(),
  				type: 'MeshLambertMaterial'
  			};

  			for ( var name in m ) {

  				var value = m[ name ];

  				switch ( name ) {

  					case 'DbgColor':
  					case 'DbgIndex':
  					case 'opticalDensity':
  					case 'illumination':
  						break;
  					case 'DbgName':
  						json.name = value;
  						break;
  					case 'blending':
  						json.blending = BlendingMode[ value ];
  						break;
  					case 'colorAmbient':
  					case 'mapAmbient':
  						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
  						break;
  					case 'colorDiffuse':
  						json.color = color.fromArray( value ).getHex();
  						break;
  					case 'colorSpecular':
  						json.specular = color.fromArray( value ).getHex();
  						break;
  					case 'colorEmissive':
  						json.emissive = color.fromArray( value ).getHex();
  						break;
  					case 'specularCoef':
  						json.shininess = value;
  						break;
  					case 'shading':
  						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
  						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
  						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
  						break;
  					case 'mapDiffuse':
  						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
  						break;
  					case 'mapDiffuseRepeat':
  					case 'mapDiffuseOffset':
  					case 'mapDiffuseWrap':
  					case 'mapDiffuseAnisotropy':
  						break;
  					case 'mapEmissive':
  						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
  						break;
  					case 'mapEmissiveRepeat':
  					case 'mapEmissiveOffset':
  					case 'mapEmissiveWrap':
  					case 'mapEmissiveAnisotropy':
  						break;
  					case 'mapLight':
  						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
  						break;
  					case 'mapLightRepeat':
  					case 'mapLightOffset':
  					case 'mapLightWrap':
  					case 'mapLightAnisotropy':
  						break;
  					case 'mapAO':
  						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
  						break;
  					case 'mapAORepeat':
  					case 'mapAOOffset':
  					case 'mapAOWrap':
  					case 'mapAOAnisotropy':
  						break;
  					case 'mapBump':
  						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
  						break;
  					case 'mapBumpScale':
  						json.bumpScale = value;
  						break;
  					case 'mapBumpRepeat':
  					case 'mapBumpOffset':
  					case 'mapBumpWrap':
  					case 'mapBumpAnisotropy':
  						break;
  					case 'mapNormal':
  						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
  						break;
  					case 'mapNormalFactor':
  						json.normalScale = [ value, value ];
  						break;
  					case 'mapNormalRepeat':
  					case 'mapNormalOffset':
  					case 'mapNormalWrap':
  					case 'mapNormalAnisotropy':
  						break;
  					case 'mapSpecular':
  						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
  						break;
  					case 'mapSpecularRepeat':
  					case 'mapSpecularOffset':
  					case 'mapSpecularWrap':
  					case 'mapSpecularAnisotropy':
  						break;
  					case 'mapMetalness':
  						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
  						break;
  					case 'mapMetalnessRepeat':
  					case 'mapMetalnessOffset':
  					case 'mapMetalnessWrap':
  					case 'mapMetalnessAnisotropy':
  						break;
  					case 'mapRoughness':
  						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
  						break;
  					case 'mapRoughnessRepeat':
  					case 'mapRoughnessOffset':
  					case 'mapRoughnessWrap':
  					case 'mapRoughnessAnisotropy':
  						break;
  					case 'mapAlpha':
  						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
  						break;
  					case 'mapAlphaRepeat':
  					case 'mapAlphaOffset':
  					case 'mapAlphaWrap':
  					case 'mapAlphaAnisotropy':
  						break;
  					case 'flipSided':
  						json.side = BackSide$1;
  						break;
  					case 'doubleSided':
  						json.side = DoubleSide$1;
  						break;
  					case 'transparency':
  						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
  						json.opacity = value;
  						break;
  					case 'depthTest':
  					case 'depthWrite':
  					case 'colorWrite':
  					case 'opacity':
  					case 'reflectivity':
  					case 'transparent':
  					case 'visible':
  					case 'wireframe':
  						json[ name ] = value;
  						break;
  					case 'vertexColors':
  						if ( value === true ) json.vertexColors = VertexColors$1;
  						if ( value === 'face' ) json.vertexColors = FaceColors$1;
  						break;
  					default:
  						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
  						break;

  				}

  			}

  			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
  			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

  			if ( json.opacity < 1 ) json.transparent = true;

  			materialLoader.setTextures( textures );

  			return materialLoader.parse( json );

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author alteredq / http://alteredqualia.com/
   */

  function JSONLoader$1( manager ) {

  	if ( typeof manager === 'boolean' ) {

  		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
  		manager = undefined;

  	}

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  	this.withCredentials = false;

  }

  Object.assign( JSONLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader$1.prototype.extractUrlBase( url );

  		var loader = new FileLoader$1( this.manager );
  		loader.setResponseType( 'json' );
  		loader.setWithCredentials( this.withCredentials );
  		loader.load( url, function ( json ) {

  			var metadata = json.metadata;

  			if ( metadata !== undefined ) {

  				var type = metadata.type;

  				if ( type !== undefined ) {

  					if ( type.toLowerCase() === 'object' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
  						return;

  					}

  					if ( type.toLowerCase() === 'scene' ) {

  						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
  						return;

  					}

  				}

  			}

  			var object = scope.parse( json, texturePath );
  			onLoad( object.geometry, object.materials );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	parse: ( function () {

  		function parseModel( json, geometry ) {

  			function isBitSet( value, position ) {

  				return value & ( 1 << position );

  			}

  			var i, j, fi,

  				offset, zLength,

  				colorIndex, normalIndex, uvIndex, materialIndex,

  				type,
  				isQuad,
  				hasMaterial,
  				hasFaceVertexUv,
  				hasFaceNormal, hasFaceVertexNormal,
  				hasFaceColor, hasFaceVertexColor,

  				vertex, face, faceA, faceB, hex, normal,

  				uvLayer, uv, u, v,

  				faces = json.faces,
  				vertices = json.vertices,
  				normals = json.normals,
  				colors = json.colors,

  				scale = json.scale,

  				nUvLayers = 0;


  			if ( json.uvs !== undefined ) {

  				// disregard empty arrays

  				for ( i = 0; i < json.uvs.length; i ++ ) {

  					if ( json.uvs[ i ].length ) nUvLayers ++;

  				}

  				for ( i = 0; i < nUvLayers; i ++ ) {

  					geometry.faceVertexUvs[ i ] = [];

  				}

  			}

  			offset = 0;
  			zLength = vertices.length;

  			while ( offset < zLength ) {

  				vertex = new Vector3$1();

  				vertex.x = vertices[ offset ++ ] * scale;
  				vertex.y = vertices[ offset ++ ] * scale;
  				vertex.z = vertices[ offset ++ ] * scale;

  				geometry.vertices.push( vertex );

  			}

  			offset = 0;
  			zLength = faces.length;

  			while ( offset < zLength ) {

  				type = faces[ offset ++ ];

  				isQuad = isBitSet( type, 0 );
  				hasMaterial = isBitSet( type, 1 );
  				hasFaceVertexUv = isBitSet( type, 3 );
  				hasFaceNormal = isBitSet( type, 4 );
  				hasFaceVertexNormal = isBitSet( type, 5 );
  				hasFaceColor = isBitSet( type, 6 );
  				hasFaceVertexColor = isBitSet( type, 7 );

  				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

  				if ( isQuad ) {

  					faceA = new Face3$1();
  					faceA.a = faces[ offset ];
  					faceA.b = faces[ offset + 1 ];
  					faceA.c = faces[ offset + 3 ];

  					faceB = new Face3$1();
  					faceB.a = faces[ offset + 1 ];
  					faceB.b = faces[ offset + 2 ];
  					faceB.c = faces[ offset + 3 ];

  					offset += 4;

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						faceA.materialIndex = materialIndex;
  						faceB.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];
  							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

  							for ( j = 0; j < 4; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2$1( u, v );

  								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
  								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						faceA.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  						faceB.normal.copy( faceA.normal );

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 4; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$1(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);


  							if ( i !== 2 ) faceA.vertexNormals.push( normal );
  							if ( i !== 0 ) faceB.vertexNormals.push( normal );

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						hex = colors[ colorIndex ];

  						faceA.color.setHex( hex );
  						faceB.color.setHex( hex );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 4; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							hex = colors[ colorIndex ];

  							if ( i !== 2 ) faceA.vertexColors.push( new Color$1( hex ) );
  							if ( i !== 0 ) faceB.vertexColors.push( new Color$1( hex ) );

  						}

  					}

  					geometry.faces.push( faceA );
  					geometry.faces.push( faceB );

  				} else {

  					face = new Face3$1();
  					face.a = faces[ offset ++ ];
  					face.b = faces[ offset ++ ];
  					face.c = faces[ offset ++ ];

  					if ( hasMaterial ) {

  						materialIndex = faces[ offset ++ ];
  						face.materialIndex = materialIndex;

  					}

  					// to get face <=> uv index correspondence

  					fi = geometry.faces.length;

  					if ( hasFaceVertexUv ) {

  						for ( i = 0; i < nUvLayers; i ++ ) {

  							uvLayer = json.uvs[ i ];

  							geometry.faceVertexUvs[ i ][ fi ] = [];

  							for ( j = 0; j < 3; j ++ ) {

  								uvIndex = faces[ offset ++ ];

  								u = uvLayer[ uvIndex * 2 ];
  								v = uvLayer[ uvIndex * 2 + 1 ];

  								uv = new Vector2$1( u, v );

  								geometry.faceVertexUvs[ i ][ fi ].push( uv );

  							}

  						}

  					}

  					if ( hasFaceNormal ) {

  						normalIndex = faces[ offset ++ ] * 3;

  						face.normal.set(
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ++ ],
  							normals[ normalIndex ]
  						);

  					}

  					if ( hasFaceVertexNormal ) {

  						for ( i = 0; i < 3; i ++ ) {

  							normalIndex = faces[ offset ++ ] * 3;

  							normal = new Vector3$1(
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ++ ],
  								normals[ normalIndex ]
  							);

  							face.vertexNormals.push( normal );

  						}

  					}


  					if ( hasFaceColor ) {

  						colorIndex = faces[ offset ++ ];
  						face.color.setHex( colors[ colorIndex ] );

  					}


  					if ( hasFaceVertexColor ) {

  						for ( i = 0; i < 3; i ++ ) {

  							colorIndex = faces[ offset ++ ];
  							face.vertexColors.push( new Color$1( colors[ colorIndex ] ) );

  						}

  					}

  					geometry.faces.push( face );

  				}

  			}

  		}

  		function parseSkin( json, geometry ) {

  			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

  			if ( json.skinWeights ) {

  				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

  					var x = json.skinWeights[ i ];
  					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
  					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
  					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

  					geometry.skinWeights.push( new Vector4$1( x, y, z, w ) );

  				}

  			}

  			if ( json.skinIndices ) {

  				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

  					var a = json.skinIndices[ i ];
  					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
  					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
  					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

  					geometry.skinIndices.push( new Vector4$1( a, b, c, d ) );

  				}

  			}

  			geometry.bones = json.bones;

  			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

  				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
  					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

  			}

  		}

  		function parseMorphing( json, geometry ) {

  			var scale = json.scale;

  			if ( json.morphTargets !== undefined ) {

  				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

  					geometry.morphTargets[ i ] = {};
  					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
  					geometry.morphTargets[ i ].vertices = [];

  					var dstVertices = geometry.morphTargets[ i ].vertices;
  					var srcVertices = json.morphTargets[ i ].vertices;

  					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

  						var vertex = new Vector3$1();
  						vertex.x = srcVertices[ v ] * scale;
  						vertex.y = srcVertices[ v + 1 ] * scale;
  						vertex.z = srcVertices[ v + 2 ] * scale;

  						dstVertices.push( vertex );

  					}

  				}

  			}

  			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

  				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

  				var faces = geometry.faces;
  				var morphColors = json.morphColors[ 0 ].colors;

  				for ( var i = 0, l = faces.length; i < l; i ++ ) {

  					faces[ i ].color.fromArray( morphColors, i * 3 );

  				}

  			}

  		}

  		function parseAnimations( json, geometry ) {

  			var outputAnimations = [];

  			// parse old style Bone/Hierarchy animations
  			var animations = [];

  			if ( json.animation !== undefined ) {

  				animations.push( json.animation );

  			}

  			if ( json.animations !== undefined ) {

  				if ( json.animations.length ) {

  					animations = animations.concat( json.animations );

  				} else {

  					animations.push( json.animations );

  				}

  			}

  			for ( var i = 0; i < animations.length; i ++ ) {

  				var clip = AnimationClip$1.parseAnimation( animations[ i ], geometry.bones );
  				if ( clip ) outputAnimations.push( clip );

  			}

  			// parse implicit morph animations
  			if ( geometry.morphTargets ) {

  				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
  				var morphAnimationClips = AnimationClip$1.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
  				outputAnimations = outputAnimations.concat( morphAnimationClips );

  			}

  			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

  		}

  		return function ( json, texturePath ) {

  			if ( json.data !== undefined ) {

  				// Geometry 4.0 spec
  				json = json.data;

  			}

  			if ( json.scale !== undefined ) {

  				json.scale = 1.0 / json.scale;

  			} else {

  				json.scale = 1.0;

  			}

  			var geometry = new Geometry$1();

  			parseModel( json, geometry );
  			parseSkin( json, geometry );
  			parseMorphing( json, geometry );
  			parseAnimations( json, geometry );

  			geometry.computeFaceNormals();
  			geometry.computeBoundingSphere();

  			if ( json.materials === undefined || json.materials.length === 0 ) {

  				return { geometry: geometry };

  			} else {

  				var materials = Loader$1.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

  				return { geometry: geometry, materials: materials };

  			}

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ObjectLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;
  	this.texturePath = '';

  }

  Object.assign( ObjectLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		if ( this.texturePath === '' ) {

  			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

  		}

  		var scope = this;

  		var loader = new FileLoader$1( scope.manager );
  		loader.load( url, function ( text ) {

  			var json = null;

  			try {

  				json = JSON.parse( text );

  			} catch ( error ) {

  				if ( onError !== undefined ) onError( error );

  				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

  				return;

  			}

  			var metadata = json.metadata;

  			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

  				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
  				return;

  			}

  			scope.parse( json, onLoad );

  		}, onProgress, onError );

  	},

  	setTexturePath: function ( value ) {

  		this.texturePath = value;

  	},

  	setCrossOrigin: function ( value ) {

  		this.crossOrigin = value;

  	},

  	parse: function ( json, onLoad ) {

  		var geometries = this.parseGeometries( json.geometries );

  		var images = this.parseImages( json.images, function () {

  			if ( onLoad !== undefined ) onLoad( object );

  		} );

  		var textures = this.parseTextures( json.textures, images );
  		var materials = this.parseMaterials( json.materials, textures );

  		var object = this.parseObject( json.object, geometries, materials );

  		if ( json.animations ) {

  			object.animations = this.parseAnimations( json.animations );

  		}

  		if ( json.images === undefined || json.images.length === 0 ) {

  			if ( onLoad !== undefined ) onLoad( object );

  		}

  		return object;

  	},

  	parseGeometries: function ( json ) {

  		var geometries = {};

  		if ( json !== undefined ) {

  			var geometryLoader = new JSONLoader$1();
  			var bufferGeometryLoader = new BufferGeometryLoader$1();

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var geometry;
  				var data = json[ i ];

  				switch ( data.type ) {

  					case 'PlaneGeometry':
  					case 'PlaneBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.width,
  							data.height,
  							data.widthSegments,
  							data.heightSegments
  						);

  						break;

  					case 'BoxGeometry':
  					case 'BoxBufferGeometry':
  					case 'CubeGeometry': // backwards compatible

  						geometry = new Geometries$1[ data.type ](
  							data.width,
  							data.height,
  							data.depth,
  							data.widthSegments,
  							data.heightSegments,
  							data.depthSegments
  						);

  						break;

  					case 'CircleGeometry':
  					case 'CircleBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.segments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'CylinderGeometry':
  					case 'CylinderBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radiusTop,
  							data.radiusBottom,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'ConeGeometry':
  					case 'ConeBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.height,
  							data.radialSegments,
  							data.heightSegments,
  							data.openEnded,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'SphereGeometry':
  					case 'SphereBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.widthSegments,
  							data.heightSegments,
  							data.phiStart,
  							data.phiLength,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'DodecahedronGeometry':
  					case 'IcosahedronGeometry':
  					case 'OctahedronGeometry':
  					case 'TetrahedronGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.detail
  						);

  						break;

  					case 'RingGeometry':
  					case 'RingBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.innerRadius,
  							data.outerRadius,
  							data.thetaSegments,
  							data.phiSegments,
  							data.thetaStart,
  							data.thetaLength
  						);

  						break;

  					case 'TorusGeometry':
  					case 'TorusBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.tube,
  							data.radialSegments,
  							data.tubularSegments,
  							data.arc
  						);

  						break;

  					case 'TorusKnotGeometry':
  					case 'TorusKnotBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.radius,
  							data.tube,
  							data.tubularSegments,
  							data.radialSegments,
  							data.p,
  							data.q
  						);

  						break;

  					case 'LatheGeometry':
  					case 'LatheBufferGeometry':

  						geometry = new Geometries$1[ data.type ](
  							data.points,
  							data.segments,
  							data.phiStart,
  							data.phiLength
  						);

  						break;

  					case 'BufferGeometry':

  						geometry = bufferGeometryLoader.parse( data );

  						break;

  					case 'Geometry':

  						geometry = geometryLoader.parse( data, this.texturePath ).geometry;

  						break;

  					default:

  						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

  						continue;

  				}

  				geometry.uuid = data.uuid;

  				if ( data.name !== undefined ) geometry.name = data.name;

  				geometries[ data.uuid ] = geometry;

  			}

  		}

  		return geometries;

  	},

  	parseMaterials: function ( json, textures ) {

  		var materials = {};

  		if ( json !== undefined ) {

  			var loader = new MaterialLoader$1();
  			loader.setTextures( textures );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.type === 'MultiMaterial' ) {

  					// Deprecated

  					var array = [];

  					for ( var j = 0; j < data.materials.length; j ++ ) {

  						array.push( loader.parse( data.materials[ j ] ) );

  					}

  					materials[ data.uuid ] = array;

  				} else {

  					materials[ data.uuid ] = loader.parse( data );

  				}

  			}

  		}

  		return materials;

  	},

  	parseAnimations: function ( json ) {

  		var animations = [];

  		for ( var i = 0; i < json.length; i ++ ) {

  			var clip = AnimationClip$1.parse( json[ i ] );

  			animations.push( clip );

  		}

  		return animations;

  	},

  	parseImages: function ( json, onLoad ) {

  		var scope = this;
  		var images = {};

  		function loadImage( url ) {

  			scope.manager.itemStart( url );

  			return loader.load( url, function () {

  				scope.manager.itemEnd( url );

  			}, undefined, function () {

  				scope.manager.itemEnd( url );
  				scope.manager.itemError( url );

  			} );

  		}

  		if ( json !== undefined && json.length > 0 ) {

  			var manager = new LoadingManager$1( onLoad );

  			var loader = new ImageLoader$1( manager );
  			loader.setCrossOrigin( this.crossOrigin );

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var image = json[ i ];
  				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

  				images[ image.uuid ] = loadImage( path );

  			}

  		}

  		return images;

  	},

  	parseTextures: function ( json, images ) {

  		function parseConstant( value, type ) {

  			if ( typeof( value ) === 'number' ) return value;

  			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

  			return type[ value ];

  		}

  		var textures = {};

  		if ( json !== undefined ) {

  			for ( var i = 0, l = json.length; i < l; i ++ ) {

  				var data = json[ i ];

  				if ( data.image === undefined ) {

  					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

  				}

  				if ( images[ data.image ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

  				}

  				var texture = new Texture$1( images[ data.image ] );
  				texture.needsUpdate = true;

  				texture.uuid = data.uuid;

  				if ( data.name !== undefined ) texture.name = data.name;

  				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING$1 );

  				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
  				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
  				if ( data.wrap !== undefined ) {

  					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING$1 );
  					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING$1 );

  				}

  				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER$1 );
  				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER$1 );
  				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

  				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

  				textures[ data.uuid ] = texture;

  			}

  		}

  		return textures;

  	},

  	parseObject: function () {

  		var matrix = new Matrix4$1();

  		return function parseObject( data, geometries, materials ) {

  			var object;

  			function getGeometry( name ) {

  				if ( geometries[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

  				}

  				return geometries[ name ];

  			}

  			function getMaterial( name ) {

  				if ( name === undefined ) return undefined;

  				if ( Array.isArray( name ) ) {

  					var array = [];

  					for ( var i = 0, l = name.length; i < l; i ++ ) {

  						var uuid = name[ i ];

  						if ( materials[ uuid ] === undefined ) {

  							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

  						}

  						array.push( materials[ uuid ] );

  					}

  					return array;

  				}

  				if ( materials[ name ] === undefined ) {

  					console.warn( 'THREE.ObjectLoader: Undefined material', name );

  				}

  				return materials[ name ];

  			}

  			switch ( data.type ) {

  				case 'Scene':

  					object = new Scene$1();

  					if ( data.background !== undefined ) {

  						if ( Number.isInteger( data.background ) ) {

  							object.background = new Color$1( data.background );

  						}

  					}

  					if ( data.fog !== undefined ) {

  						if ( data.fog.type === 'Fog' ) {

  							object.fog = new Fog$1( data.fog.color, data.fog.near, data.fog.far );

  						} else if ( data.fog.type === 'FogExp2' ) {

  							object.fog = new FogExp2$1( data.fog.color, data.fog.density );

  						}

  					}

  					break;

  				case 'PerspectiveCamera':

  					object = new PerspectiveCamera$2( data.fov, data.aspect, data.near, data.far );

  					if ( data.focus !== undefined ) object.focus = data.focus;
  					if ( data.zoom !== undefined ) object.zoom = data.zoom;
  					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
  					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
  					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

  					break;

  				case 'OrthographicCamera':

  					object = new OrthographicCamera$2( data.left, data.right, data.top, data.bottom, data.near, data.far );

  					break;

  				case 'AmbientLight':

  					object = new AmbientLight$2( data.color, data.intensity );

  					break;

  				case 'DirectionalLight':

  					object = new DirectionalLight$2( data.color, data.intensity );

  					break;

  				case 'PointLight':

  					object = new PointLight$2( data.color, data.intensity, data.distance, data.decay );

  					break;

  				case 'RectAreaLight':

  					object = new RectAreaLight$1( data.color, data.intensity, data.width, data.height );

  					break;

  				case 'SpotLight':

  					object = new SpotLight$2( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

  					break;

  				case 'HemisphereLight':

  					object = new HemisphereLight$2( data.color, data.groundColor, data.intensity );

  					break;

  				case 'SkinnedMesh':

  					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

  				case 'Mesh':

  					var geometry = getGeometry( data.geometry );
  					var material = getMaterial( data.material );

  					if ( geometry.bones && geometry.bones.length > 0 ) {

  						object = new SkinnedMesh$1( geometry, material );

  					} else {

  						object = new Mesh$1( geometry, material );

  					}

  					break;

  				case 'LOD':

  					object = new LOD$1();

  					break;

  				case 'Line':

  					object = new Line$2( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

  					break;

  				case 'LineLoop':

  					object = new LineLoop$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'LineSegments':

  					object = new LineSegments$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'PointCloud':
  				case 'Points':

  					object = new Points$1( getGeometry( data.geometry ), getMaterial( data.material ) );

  					break;

  				case 'Sprite':

  					object = new Sprite$1( getMaterial( data.material ) );

  					break;

  				case 'Group':

  					object = new Group$2();

  					break;

  				default:

  					object = new Object3D$1();

  			}

  			object.uuid = data.uuid;

  			if ( data.name !== undefined ) object.name = data.name;
  			if ( data.matrix !== undefined ) {

  				matrix.fromArray( data.matrix );
  				matrix.decompose( object.position, object.quaternion, object.scale );

  			} else {

  				if ( data.position !== undefined ) object.position.fromArray( data.position );
  				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
  				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
  				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

  			}

  			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
  			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

  			if ( data.shadow ) {

  				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
  				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
  				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
  				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

  			}

  			if ( data.visible !== undefined ) object.visible = data.visible;
  			if ( data.userData !== undefined ) object.userData = data.userData;

  			if ( data.children !== undefined ) {

  				for ( var child in data.children ) {

  					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

  				}

  			}

  			if ( data.type === 'LOD' ) {

  				var levels = data.levels;

  				for ( var l = 0; l < levels.length; l ++ ) {

  					var level = levels[ l ];
  					var child = object.getObjectByProperty( 'uuid', level.object );

  					if ( child !== undefined ) {

  						object.addLevel( child, level.distance );

  					}

  				}

  			}

  			return object;

  		};

  	}()

  } );

  var TEXTURE_MAPPING$1 = {
  	UVMapping: UVMapping$1,
  	CubeReflectionMapping: CubeReflectionMapping$1,
  	CubeRefractionMapping: CubeRefractionMapping$1,
  	EquirectangularReflectionMapping: EquirectangularReflectionMapping$1,
  	EquirectangularRefractionMapping: EquirectangularRefractionMapping$1,
  	SphericalReflectionMapping: SphericalReflectionMapping$1,
  	CubeUVReflectionMapping: CubeUVReflectionMapping$1,
  	CubeUVRefractionMapping: CubeUVRefractionMapping$1
  };

  var TEXTURE_WRAPPING$1 = {
  	RepeatWrapping: RepeatWrapping$1,
  	ClampToEdgeWrapping: ClampToEdgeWrapping$1,
  	MirroredRepeatWrapping: MirroredRepeatWrapping$1
  };

  var TEXTURE_FILTER$1 = {
  	NearestFilter: NearestFilter$1,
  	NearestMipMapNearestFilter: NearestMipMapNearestFilter$1,
  	NearestMipMapLinearFilter: NearestMipMapLinearFilter$1,
  	LinearFilter: LinearFilter$1,
  	LinearMipMapNearestFilter: LinearMipMapNearestFilter$1,
  	LinearMipMapLinearFilter: LinearMipMapLinearFilter$1
  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   * Bezier Curves formulas obtained from
   * http://en.wikipedia.org/wiki/BÃ©zier_curve
   */

  function CatmullRom$1( t, p0, p1, p2, p3 ) {

  	var v0 = ( p2 - p0 ) * 0.5;
  	var v1 = ( p3 - p1 ) * 0.5;
  	var t2 = t * t;
  	var t3 = t * t2;
  	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

  //

  function QuadraticBezierP0$1( t, p ) {

  	var k = 1 - t;
  	return k * k * p;

  }

  function QuadraticBezierP1$1( t, p ) {

  	return 2 * ( 1 - t ) * t * p;

  }

  function QuadraticBezierP2$1( t, p ) {

  	return t * t * p;

  }

  function QuadraticBezier$1( t, p0, p1, p2 ) {

  	return QuadraticBezierP0$1( t, p0 ) + QuadraticBezierP1$1( t, p1 ) +
  		QuadraticBezierP2$1( t, p2 );

  }

  //

  function CubicBezierP0$1( t, p ) {

  	var k = 1 - t;
  	return k * k * k * p;

  }

  function CubicBezierP1$1( t, p ) {

  	var k = 1 - t;
  	return 3 * k * k * t * p;

  }

  function CubicBezierP2$1( t, p ) {

  	return 3 * ( 1 - t ) * t * t * p;

  }

  function CubicBezierP3$1( t, p ) {

  	return t * t * t * p;

  }

  function CubicBezier$1( t, p0, p1, p2, p3 ) {

  	return CubicBezierP0$1( t, p0 ) + CubicBezierP1$1( t, p1 ) + CubicBezierP2$1( t, p2 ) +
  		CubicBezierP3$1( t, p3 );

  }

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Extensible curve object
   *
   * Some common of curve methods:
   * .getPoint(t), getTangent(t)
   * .getPointAt(u), getTangentAt(u)
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/

  /**************************************************************
   *	Abstract Curve base class
   **************************************************************/

  function Curve$1() {

  	this.arcLengthDivisions = 200;

  }

  Object.assign( Curve$1.prototype, {

  	// Virtual base class method to overwrite and implement in subclasses
  	//	- t [0 .. 1]

  	getPoint: function () {

  		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
  		return null;

  	},

  	// Get point at relative position in curve according to arc length
  	// - u [0 .. 1]

  	getPointAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getPoint( t );

  	},

  	// Get sequence of points using getPoint( t )

  	getPoints: function ( divisions ) {

  		if ( divisions === undefined ) divisions = 5;

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPoint( d / divisions ) );

  		}

  		return points;

  	},

  	// Get sequence of points using getPointAt( u )

  	getSpacedPoints: function ( divisions ) {

  		if ( divisions === undefined ) divisions = 5;

  		var points = [];

  		for ( var d = 0; d <= divisions; d ++ ) {

  			points.push( this.getPointAt( d / divisions ) );

  		}

  		return points;

  	},

  	// Get total curve arc length

  	getLength: function () {

  		var lengths = this.getLengths();
  		return lengths[ lengths.length - 1 ];

  	},

  	// Get list of cumulative segment lengths

  	getLengths: function ( divisions ) {

  		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

  		if ( this.cacheArcLengths &&
  			( this.cacheArcLengths.length === divisions + 1 ) &&
  			! this.needsUpdate ) {

  			return this.cacheArcLengths;

  		}

  		this.needsUpdate = false;

  		var cache = [];
  		var current, last = this.getPoint( 0 );
  		var p, sum = 0;

  		cache.push( 0 );

  		for ( p = 1; p <= divisions; p ++ ) {

  			current = this.getPoint( p / divisions );
  			sum += current.distanceTo( last );
  			cache.push( sum );
  			last = current;

  		}

  		this.cacheArcLengths = cache;

  		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

  	},

  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.getLengths();

  	},

  	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  	getUtoTmapping: function ( u, distance ) {

  		var arcLengths = this.getLengths();

  		var i = 0, il = arcLengths.length;

  		var targetArcLength; // The targeted u distance value to get

  		if ( distance ) {

  			targetArcLength = distance;

  		} else {

  			targetArcLength = u * arcLengths[ il - 1 ];

  		}

  		// binary search for the index with largest value smaller than target u distance

  		var low = 0, high = il - 1, comparison;

  		while ( low <= high ) {

  			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

  			comparison = arcLengths[ i ] - targetArcLength;

  			if ( comparison < 0 ) {

  				low = i + 1;

  			} else if ( comparison > 0 ) {

  				high = i - 1;

  			} else {

  				high = i;
  				break;

  				// DONE

  			}

  		}

  		i = high;

  		if ( arcLengths[ i ] === targetArcLength ) {

  			return i / ( il - 1 );

  		}

  		// we could get finer grain at lengths, or use simple interpolation between two points

  		var lengthBefore = arcLengths[ i ];
  		var lengthAfter = arcLengths[ i + 1 ];

  		var segmentLength = lengthAfter - lengthBefore;

  		// determine where we are between the 'before' and 'after' points

  		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

  		// add that fractional amount to t

  		var t = ( i + segmentFraction ) / ( il - 1 );

  		return t;

  	},

  	// Returns a unit vector tangent at t
  	// In case any sub curve does not implement its tangent derivation,
  	// 2 points a small delta apart will be used to find its gradient
  	// which seems to give a reasonable approximation

  	getTangent: function ( t ) {

  		var delta = 0.0001;
  		var t1 = t - delta;
  		var t2 = t + delta;

  		// Capping in case of danger

  		if ( t1 < 0 ) t1 = 0;
  		if ( t2 > 1 ) t2 = 1;

  		var pt1 = this.getPoint( t1 );
  		var pt2 = this.getPoint( t2 );

  		var vec = pt2.clone().sub( pt1 );
  		return vec.normalize();

  	},

  	getTangentAt: function ( u ) {

  		var t = this.getUtoTmapping( u );
  		return this.getTangent( t );

  	},

  	computeFrenetFrames: function ( segments, closed ) {

  		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

  		var normal = new Vector3$1();

  		var tangents = [];
  		var normals = [];
  		var binormals = [];

  		var vec = new Vector3$1();
  		var mat = new Matrix4$1();

  		var i, u, theta;

  		// compute the tangent vectors for each segment on the curve

  		for ( i = 0; i <= segments; i ++ ) {

  			u = i / segments;

  			tangents[ i ] = this.getTangentAt( u );
  			tangents[ i ].normalize();

  		}

  		// select an initial normal vector perpendicular to the first tangent vector,
  		// and in the direction of the minimum tangent xyz component

  		normals[ 0 ] = new Vector3$1();
  		binormals[ 0 ] = new Vector3$1();
  		var min = Number.MAX_VALUE;
  		var tx = Math.abs( tangents[ 0 ].x );
  		var ty = Math.abs( tangents[ 0 ].y );
  		var tz = Math.abs( tangents[ 0 ].z );

  		if ( tx <= min ) {

  			min = tx;
  			normal.set( 1, 0, 0 );

  		}

  		if ( ty <= min ) {

  			min = ty;
  			normal.set( 0, 1, 0 );

  		}

  		if ( tz <= min ) {

  			normal.set( 0, 0, 1 );

  		}

  		vec.crossVectors( tangents[ 0 ], normal ).normalize();

  		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
  		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


  		// compute the slowly-varying normal and binormal vectors for each segment on the curve

  		for ( i = 1; i <= segments; i ++ ) {

  			normals[ i ] = normals[ i - 1 ].clone();

  			binormals[ i ] = binormals[ i - 1 ].clone();

  			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

  			if ( vec.length() > Number.EPSILON ) {

  				vec.normalize();

  				theta = Math.acos( _Math$1.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

  				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

  			}

  			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  		}

  		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  		if ( closed === true ) {

  			theta = Math.acos( _Math$1.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
  			theta /= segments;

  			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

  				theta = - theta;

  			}

  			for ( i = 1; i <= segments; i ++ ) {

  				// twist a little...
  				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
  				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  			}

  		}

  		return {
  			tangents: tangents,
  			normals: normals,
  			binormals: binormals
  		};

  	}

  } );

  function LineCurve$1( v1, v2 ) {

  	Curve$1.call( this );

  	this.v1 = v1;
  	this.v2 = v2;

  }

  LineCurve$1.prototype = Object.create( Curve$1.prototype );
  LineCurve$1.prototype.constructor = LineCurve$1;

  LineCurve$1.prototype.isLineCurve = true;

  LineCurve$1.prototype.getPoint = function ( t ) {

  	if ( t === 1 ) {

  		return this.v2.clone();

  	}

  	var point = this.v2.clone().sub( this.v1 );
  	point.multiplyScalar( t ).add( this.v1 );

  	return point;

  };

  // Line curve is linear, so we can overwrite default getPointAt

  LineCurve$1.prototype.getPointAt = function ( u ) {

  	return this.getPoint( u );

  };

  LineCurve$1.prototype.getTangent = function ( t ) {

  	var tangent = this.v2.clone().sub( this.v1 );

  	return tangent.normalize();

  };

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   *
   **/

  /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/

  function CurvePath$1() {

  	Curve$1.call( this );

  	this.curves = [];

  	this.autoClose = false; // Automatically closes the path

  }

  CurvePath$1.prototype = Object.assign( Object.create( Curve$1.prototype ), {

  	constructor: CurvePath$1,

  	add: function ( curve ) {

  		this.curves.push( curve );

  	},

  	closePath: function () {

  		// Add a line curve if start and end of lines are not connected
  		var startPoint = this.curves[ 0 ].getPoint( 0 );
  		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  		if ( ! startPoint.equals( endPoint ) ) {

  			this.curves.push( new LineCurve$1( endPoint, startPoint ) );

  		}

  	},

  	// To get accurate point with reference to
  	// entire path distance at time t,
  	// following has to be done:

  	// 1. Length of each sub path have to be known
  	// 2. Locate and identify type of curve
  	// 3. Get t for the curve
  	// 4. Return curve.getPointAt(t')

  	getPoint: function ( t ) {

  		var d = t * this.getLength();
  		var curveLengths = this.getCurveLengths();
  		var i = 0;

  		// To think about boundaries points.

  		while ( i < curveLengths.length ) {

  			if ( curveLengths[ i ] >= d ) {

  				var diff = curveLengths[ i ] - d;
  				var curve = this.curves[ i ];

  				var segmentLength = curve.getLength();
  				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

  				return curve.getPointAt( u );

  			}

  			i ++;

  		}

  		return null;

  		// loop where sum != 0, sum > d , sum+1 <d

  	},

  	// We cannot use the default THREE.Curve getPoint() with getLength() because in
  	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  	// getPoint() depends on getLength

  	getLength: function () {

  		var lens = this.getCurveLengths();
  		return lens[ lens.length - 1 ];

  	},

  	// cacheLengths must be recalculated.
  	updateArcLengths: function () {

  		this.needsUpdate = true;
  		this.cacheLengths = null;
  		this.getCurveLengths();

  	},

  	// Compute lengths and cache them
  	// We cannot overwrite getLengths() because UtoT mapping uses it.

  	getCurveLengths: function () {

  		// We use cache values if curves and cache array are same length

  		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

  			return this.cacheLengths;

  		}

  		// Get length of sub-curve
  		// Push sums into cached array

  		var lengths = [], sums = 0;

  		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

  			sums += this.curves[ i ].getLength();
  			lengths.push( sums );

  		}

  		this.cacheLengths = lengths;

  		return lengths;

  	},

  	getSpacedPoints: function ( divisions ) {

  		if ( divisions === undefined ) divisions = 40;

  		var points = [];

  		for ( var i = 0; i <= divisions; i ++ ) {

  			points.push( this.getPoint( i / divisions ) );

  		}

  		if ( this.autoClose ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	getPoints: function ( divisions ) {

  		divisions = divisions || 12;

  		var points = [], last;

  		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

  			var curve = curves[ i ];
  			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
  				: (curve && curve.isLineCurve) ? 1
  				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
  				: divisions;

  			var pts = curve.getPoints( resolution );

  			for ( var j = 0; j < pts.length; j++ ) {

  				var point = pts[ j ];

  				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

  				points.push( point );
  				last = point;

  			}

  		}

  		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

  			points.push( points[ 0 ] );

  		}

  		return points;

  	},

  	/**************************************************************
  	 *	Create Geometries Helpers
  	 **************************************************************/

  	/// Generate geometry from path points (for Line or Points objects)

  	createPointsGeometry: function ( divisions ) {

  		var pts = this.getPoints( divisions );
  		return this.createGeometry( pts );

  	},

  	// Generate geometry from equidistant sampling along the path

  	createSpacedPointsGeometry: function ( divisions ) {

  		var pts = this.getSpacedPoints( divisions );
  		return this.createGeometry( pts );

  	},

  	createGeometry: function ( points ) {

  		var geometry = new Geometry$1();

  		for ( var i = 0, l = points.length; i < l; i ++ ) {

  			var point = points[ i ];
  			geometry.vertices.push( new Vector3$1( point.x, point.y, point.z || 0 ) );

  		}

  		return geometry;

  	}

  } );

  function EllipseCurve$1( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  	Curve$1.call( this );

  	this.aX = aX;
  	this.aY = aY;

  	this.xRadius = xRadius;
  	this.yRadius = yRadius;

  	this.aStartAngle = aStartAngle;
  	this.aEndAngle = aEndAngle;

  	this.aClockwise = aClockwise;

  	this.aRotation = aRotation || 0;

  }

  EllipseCurve$1.prototype = Object.create( Curve$1.prototype );
  EllipseCurve$1.prototype.constructor = EllipseCurve$1;

  EllipseCurve$1.prototype.isEllipseCurve = true;

  EllipseCurve$1.prototype.getPoint = function ( t ) {

  	var twoPi = Math.PI * 2;
  	var deltaAngle = this.aEndAngle - this.aStartAngle;
  	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

  	// ensures that deltaAngle is 0 .. 2 PI
  	while ( deltaAngle < 0 ) deltaAngle += twoPi;
  	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

  	if ( deltaAngle < Number.EPSILON ) {

  		if ( samePoints ) {

  			deltaAngle = 0;

  		} else {

  			deltaAngle = twoPi;

  		}

  	}

  	if ( this.aClockwise === true && ! samePoints ) {

  		if ( deltaAngle === twoPi ) {

  			deltaAngle = - twoPi;

  		} else {

  			deltaAngle = deltaAngle - twoPi;

  		}

  	}

  	var angle = this.aStartAngle + t * deltaAngle;
  	var x = this.aX + this.xRadius * Math.cos( angle );
  	var y = this.aY + this.yRadius * Math.sin( angle );

  	if ( this.aRotation !== 0 ) {

  		var cos = Math.cos( this.aRotation );
  		var sin = Math.sin( this.aRotation );

  		var tx = x - this.aX;
  		var ty = y - this.aY;

  		// Rotate the point about the center of the ellipse.
  		x = tx * cos - ty * sin + this.aX;
  		y = tx * sin + ty * cos + this.aY;

  	}

  	return new Vector2$1( x, y );

  };

  function SplineCurve$1( points /* array of Vector2 */ ) {

  	Curve$1.call( this );

  	this.points = ( points === undefined ) ? [] : points;

  }

  SplineCurve$1.prototype = Object.create( Curve$1.prototype );
  SplineCurve$1.prototype.constructor = SplineCurve$1;

  SplineCurve$1.prototype.isSplineCurve = true;

  SplineCurve$1.prototype.getPoint = function ( t ) {

  	var points = this.points;
  	var point = ( points.length - 1 ) * t;

  	var intPoint = Math.floor( point );
  	var weight = point - intPoint;

  	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  	var point1 = points[ intPoint ];
  	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  	return new Vector2$1(
  		CatmullRom$1( weight, point0.x, point1.x, point2.x, point3.x ),
  		CatmullRom$1( weight, point0.y, point1.y, point2.y, point3.y )
  	);

  };

  function CubicBezierCurve$1( v0, v1, v2, v3 ) {

  	Curve$1.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;
  	this.v3 = v3;

  }

  CubicBezierCurve$1.prototype = Object.create( Curve$1.prototype );
  CubicBezierCurve$1.prototype.constructor = CubicBezierCurve$1;

  CubicBezierCurve$1.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	return new Vector2$1(
  		CubicBezier$1( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier$1( t, v0.y, v1.y, v2.y, v3.y )
  	);

  };

  function QuadraticBezierCurve$1( v0, v1, v2 ) {

  	Curve$1.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;

  }

  QuadraticBezierCurve$1.prototype = Object.create( Curve$1.prototype );
  QuadraticBezierCurve$1.prototype.constructor = QuadraticBezierCurve$1;

  QuadraticBezierCurve$1.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	return new Vector2$1(
  		QuadraticBezier$1( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier$1( t, v0.y, v1.y, v2.y )
  	);

  };

  var PathPrototype = Object.assign( Object.create( CurvePath$1.prototype ), {

  	fromPoints: function ( vectors ) {

  		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

  			this.lineTo( vectors[ i ].x, vectors[ i ].y );

  		}

  	},

  	moveTo: function ( x, y ) {

  		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

  	},

  	lineTo: function ( x, y ) {

  		var curve = new LineCurve$1( this.currentPoint.clone(), new Vector2$1( x, y ) );
  		this.curves.push( curve );

  		this.currentPoint.set( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		var curve = new QuadraticBezierCurve$1(
  			this.currentPoint.clone(),
  			new Vector2$1( aCPx, aCPy ),
  			new Vector2$1( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		var curve = new CubicBezierCurve$1(
  			this.currentPoint.clone(),
  			new Vector2$1( aCP1x, aCP1y ),
  			new Vector2$1( aCP2x, aCP2y ),
  			new Vector2$1( aX, aY )
  		);

  		this.curves.push( curve );

  		this.currentPoint.set( aX, aY );

  	},

  	splineThru: function ( pts /*Array of Vector*/ ) {

  		var npts = [ this.currentPoint.clone() ].concat( pts );

  		var curve = new SplineCurve$1( npts );
  		this.curves.push( curve );

  		this.currentPoint.copy( pts[ pts.length - 1 ] );

  	},

  	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absarc( aX + x0, aY + y0, aRadius,
  			aStartAngle, aEndAngle, aClockwise );

  	},

  	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  	},

  	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var x0 = this.currentPoint.x;
  		var y0 = this.currentPoint.y;

  		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  	},

  	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  		var curve = new EllipseCurve$1( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

  		if ( this.curves.length > 0 ) {

  			// if a previous curve is present, attempt to join
  			var firstPoint = curve.getPoint( 0 );

  			if ( ! firstPoint.equals( this.currentPoint ) ) {

  				this.lineTo( firstPoint.x, firstPoint.y );

  			}

  		}

  		this.curves.push( curve );

  		var lastPoint = curve.getPoint( 1 );
  		this.currentPoint.copy( lastPoint );

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Creates free form 2d path using series of points, lines or curves.
   **/

  function Path$1( points ) {

  	CurvePath$1.call( this );
  	this.currentPoint = new Vector2$1();

  	if ( points ) {

  		this.fromPoints( points );

  	}

  }

  Path$1.prototype = PathPrototype;
  PathPrototype.constructor = Path$1;

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * Defines a 2d shape plane using paths.
   **/

  // STEP 1 Create a path.
  // STEP 2 Turn path into shape.
  // STEP 3 ExtrudeGeometry takes in Shape/Shapes
  // STEP 3a - Extract points from each shape, turn to vertices
  // STEP 3b - Triangulate each shape, add faces.

  function Shape$2() {

  	Path$1.apply( this, arguments );

  	this.holes = [];

  }

  Shape$2.prototype = Object.assign( Object.create( PathPrototype ), {

  	constructor: Shape$2,

  	getPointsHoles: function ( divisions ) {

  		var holesPts = [];

  		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

  			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

  		}

  		return holesPts;

  	},

  	// Get points of shape and holes (keypoints based on segments parameter)

  	extractAllPoints: function ( divisions ) {

  		return {

  			shape: this.getPoints( divisions ),
  			holes: this.getPointsHoles( divisions )

  		};

  	},

  	extractPoints: function ( divisions ) {

  		return this.extractAllPoints( divisions );

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
   **/

  function ShapePath$1() {

  	this.subPaths = [];
  	this.currentPath = null;

  }

  Object.assign( ShapePath$1.prototype, {

  	moveTo: function ( x, y ) {

  		this.currentPath = new Path$1();
  		this.subPaths.push( this.currentPath );
  		this.currentPath.moveTo( x, y );

  	},

  	lineTo: function ( x, y ) {

  		this.currentPath.lineTo( x, y );

  	},

  	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

  		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

  	},

  	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

  	},

  	splineThru: function ( pts ) {

  		this.currentPath.splineThru( pts );

  	},

  	toShapes: function ( isCCW, noHoles ) {

  		function toShapesNoHoles( inSubpaths ) {

  			var shapes = [];

  			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

  				var tmpPath = inSubpaths[ i ];

  				var tmpShape = new Shape$2();
  				tmpShape.curves = tmpPath.curves;

  				shapes.push( tmpShape );

  			}

  			return shapes;

  		}

  		function isPointInsidePolygon( inPt, inPolygon ) {

  			var polyLen = inPolygon.length;

  			// inPt on polygon contour => immediate success    or
  			// toggling of inside/outside at every single! intersection point of an edge
  			//  with the horizontal line through inPt, left of inPt
  			//  not counting lowerY endpoints of edges and whole edges on that line
  			var inside = false;
  			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

  				var edgeLowPt  = inPolygon[ p ];
  				var edgeHighPt = inPolygon[ q ];

  				var edgeDx = edgeHighPt.x - edgeLowPt.x;
  				var edgeDy = edgeHighPt.y - edgeLowPt.y;

  				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

  					// not parallel
  					if ( edgeDy < 0 ) {

  						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
  						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

  					}
  					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

  					if ( inPt.y === edgeLowPt.y ) {

  						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
  						// continue;				// no intersection or edgeLowPt => doesn't count !!!

  					} else {

  						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
  						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
  						if ( perpEdge < 0 ) 				continue;
  						inside = ! inside;		// true intersection left of inPt

  					}

  				} else {

  					// parallel or collinear
  					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
  					// edge lies on the same horizontal line as inPt
  					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
  						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
  					// continue;

  				}

  			}

  			return	inside;

  		}

  		var isClockWise = ShapeUtils$1.isClockWise;

  		var subPaths = this.subPaths;
  		if ( subPaths.length === 0 ) return [];

  		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


  		var solid, tmpPath, tmpShape, shapes = [];

  		if ( subPaths.length === 1 ) {

  			tmpPath = subPaths[ 0 ];
  			tmpShape = new Shape$2();
  			tmpShape.curves = tmpPath.curves;
  			shapes.push( tmpShape );
  			return shapes;

  		}

  		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  		holesFirst = isCCW ? ! holesFirst : holesFirst;

  		// console.log("Holes first", holesFirst);

  		var betterShapeHoles = [];
  		var newShapes = [];
  		var newShapeHoles = [];
  		var mainIdx = 0;
  		var tmpPoints;

  		newShapes[ mainIdx ] = undefined;
  		newShapeHoles[ mainIdx ] = [];

  		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

  			tmpPath = subPaths[ i ];
  			tmpPoints = tmpPath.getPoints();
  			solid = isClockWise( tmpPoints );
  			solid = isCCW ? ! solid : solid;

  			if ( solid ) {

  				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

  				newShapes[ mainIdx ] = { s: new Shape$2(), p: tmpPoints };
  				newShapes[ mainIdx ].s.curves = tmpPath.curves;

  				if ( holesFirst )	mainIdx ++;
  				newShapeHoles[ mainIdx ] = [];

  				//console.log('cw', i);

  			} else {

  				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

  				//console.log('ccw', i);

  			}

  		}

  		// only Holes? -> probably all Shapes with wrong orientation
  		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


  		if ( newShapes.length > 1 ) {

  			var ambiguous = false;
  			var toChange = [];

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				betterShapeHoles[ sIdx ] = [];

  			}

  			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

  				var sho = newShapeHoles[ sIdx ];

  				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

  					var ho = sho[ hIdx ];
  					var hole_unassigned = true;

  					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

  						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

  							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
  							if ( hole_unassigned ) {

  								hole_unassigned = false;
  								betterShapeHoles[ s2Idx ].push( ho );

  							} else {

  								ambiguous = true;

  							}

  						}

  					}
  					if ( hole_unassigned ) {

  						betterShapeHoles[ sIdx ].push( ho );

  					}

  				}

  			}
  			// console.log("ambiguous: ", ambiguous);
  			if ( toChange.length > 0 ) {

  				// console.log("to change: ", toChange);
  				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

  			}

  		}

  		var tmpHoles;

  		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

  			tmpShape = newShapes[ i ].s;
  			shapes.push( tmpShape );
  			tmpHoles = newShapeHoles[ i ];

  			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

  				tmpShape.holes.push( tmpHoles[ j ].h );

  			}

  		}

  		//console.log("shape", shapes);

  		return shapes;

  	}

  } );

  /**
   * @author zz85 / http://www.lab4games.net/zz85/blog
   * @author mrdoob / http://mrdoob.com/
   */

  function Font$1( data ) {

  	this.data = data;

  }

  Object.assign( Font$1.prototype, {

  	isFont: true,

  	generateShapes: function ( text, size, divisions ) {

  		function createPaths( text ) {

  			var chars = String( text ).split( '' );
  			var scale = size / data.resolution;
  			var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

  			var offsetX = 0, offsetY = 0;

  			var paths = [];

  			for ( var i = 0; i < chars.length; i ++ ) {

  				var char = chars[ i ];

  				if ( char === '\n' ) {

  					offsetX = 0;
  					offsetY -= line_height;

  				} else {

  					var ret = createPath( char, scale, offsetX, offsetY );
  					offsetX += ret.offsetX;
  					paths.push( ret.path );

  				}

  			}

  			return paths;

  		}

  		function createPath( c, scale, offsetX, offsetY ) {

  			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

  			if ( ! glyph ) return;

  			var path = new ShapePath$1();

  			var pts = [];
  			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

  			if ( glyph.o ) {

  				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

  				for ( var i = 0, l = outline.length; i < l; ) {

  					var action = outline[ i ++ ];

  					switch ( action ) {

  						case 'm': // moveTo

  							x = outline[ i ++ ] * scale + offsetX;
  							y = outline[ i ++ ] * scale + offsetY;

  							path.moveTo( x, y );

  							break;

  						case 'l': // lineTo

  							x = outline[ i ++ ] * scale + offsetX;
  							y = outline[ i ++ ] * scale + offsetY;

  							path.lineTo( x, y );

  							break;

  						case 'q': // quadraticCurveTo

  							cpx  = outline[ i ++ ] * scale + offsetX;
  							cpy  = outline[ i ++ ] * scale + offsetY;
  							cpx1 = outline[ i ++ ] * scale + offsetX;
  							cpy1 = outline[ i ++ ] * scale + offsetY;

  							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

  							laste = pts[ pts.length - 1 ];

  							if ( laste ) {

  								cpx0 = laste.x;
  								cpy0 = laste.y;

  							}

  							break;

  						case 'b': // bezierCurveTo

  							cpx  = outline[ i ++ ] * scale + offsetX;
  							cpy  = outline[ i ++ ] * scale + offsetY;
  							cpx1 = outline[ i ++ ] * scale + offsetX;
  							cpy1 = outline[ i ++ ] * scale + offsetY;
  							cpx2 = outline[ i ++ ] * scale + offsetX;
  							cpy2 = outline[ i ++ ] * scale + offsetY;

  							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

  							laste = pts[ pts.length - 1 ];

  							if ( laste ) {

  								cpx0 = laste.x;
  								cpy0 = laste.y;

  							}

  							break;

  					}

  				}

  			}

  			return { offsetX: glyph.ha * scale, path: path };

  		}

  		//

  		if ( size === undefined ) size = 100;
  		if ( divisions === undefined ) divisions = 4;

  		var data = this.data;

  		var paths = createPaths( text );
  		var shapes = [];

  		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

  			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  		}

  		return shapes;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function FontLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( FontLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var scope = this;

  		var loader = new FileLoader$1( this.manager );
  		loader.load( url, function ( text ) {

  			var json;

  			try {

  				json = JSON.parse( text );

  			} catch ( e ) {

  				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
  				json = JSON.parse( text.substring( 65, text.length - 2 ) );

  			}

  			var font = scope.parse( json );

  			if ( onLoad ) onLoad( font );

  		}, onProgress, onError );

  	},

  	parse: function ( json ) {

  		return new Font$1( json );

  	}

  } );

  var context$1;

  var AudioContext$1 = {

  	getContext: function () {

  		if ( context$1 === undefined ) {

  			context$1 = new ( window.AudioContext || window.webkitAudioContext )();

  		}

  		return context$1;

  	},

  	setContext: function ( value ) {

  		context$1 = value;

  	}

  };

  /**
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function AudioLoader$1( manager ) {

  	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager$1;

  }

  Object.assign( AudioLoader$1.prototype, {

  	load: function ( url, onLoad, onProgress, onError ) {

  		var loader = new FileLoader$1( this.manager );
  		loader.setResponseType( 'arraybuffer' );
  		loader.load( url, function ( buffer ) {

  			var context = AudioContext$1.getContext();

  			context.decodeAudioData( buffer, function ( audioBuffer ) {

  				onLoad( audioBuffer );

  			} );

  		}, onProgress, onError );

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function StereoCamera$1() {

  	this.type = 'StereoCamera';

  	this.aspect = 1;

  	this.eyeSep = 0.064;

  	this.cameraL = new PerspectiveCamera$2();
  	this.cameraL.layers.enable( 1 );
  	this.cameraL.matrixAutoUpdate = false;

  	this.cameraR = new PerspectiveCamera$2();
  	this.cameraR.layers.enable( 2 );
  	this.cameraR.matrixAutoUpdate = false;

  }

  Object.assign( StereoCamera$1.prototype, {

  	update: ( function () {

  		var instance, focus, fov, aspect, near, far, zoom, eyeSep;

  		var eyeRight = new Matrix4$1();
  		var eyeLeft = new Matrix4$1();

  		return function update( camera ) {

  			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
  												aspect !== camera.aspect * this.aspect || near !== camera.near ||
  												far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

  			if ( needsUpdate ) {

  				instance = this;
  				focus = camera.focus;
  				fov = camera.fov;
  				aspect = camera.aspect * this.aspect;
  				near = camera.near;
  				far = camera.far;
  				zoom = camera.zoom;

  				// Off-axis stereoscopic effect based on
  				// http://paulbourke.net/stereographics/stereorender/

  				var projectionMatrix = camera.projectionMatrix.clone();
  				eyeSep = this.eyeSep / 2;
  				var eyeSepOnProjection = eyeSep * near / focus;
  				var ymax = ( near * Math.tan( _Math$1.DEG2RAD * fov * 0.5 ) ) / zoom;
  				var xmin, xmax;

  				// translate xOffset

  				eyeLeft.elements[ 12 ] = - eyeSep;
  				eyeRight.elements[ 12 ] = eyeSep;

  				// for left eye

  				xmin = - ymax * aspect + eyeSepOnProjection;
  				xmax = ymax * aspect + eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraL.projectionMatrix.copy( projectionMatrix );

  				// for right eye

  				xmin = - ymax * aspect - eyeSepOnProjection;
  				xmax = ymax * aspect - eyeSepOnProjection;

  				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
  				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

  				this.cameraR.projectionMatrix.copy( projectionMatrix );

  			}

  			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
  			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

  		};

  	} )()

  } );

  /**
   * Camera for rendering cube maps
   *	- renders scene into axis-aligned cube
   *
   * @author alteredq / http://alteredqualia.com/
   */

  function CubeCamera$2( near, far, cubeResolution ) {

  	Object3D$1.call( this );

  	this.type = 'CubeCamera';

  	var fov = 90, aspect = 1;

  	var cameraPX = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraPX.up.set( 0, - 1, 0 );
  	cameraPX.lookAt( new Vector3$1( 1, 0, 0 ) );
  	this.add( cameraPX );

  	var cameraNX = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraNX.up.set( 0, - 1, 0 );
  	cameraNX.lookAt( new Vector3$1( - 1, 0, 0 ) );
  	this.add( cameraNX );

  	var cameraPY = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraPY.up.set( 0, 0, 1 );
  	cameraPY.lookAt( new Vector3$1( 0, 1, 0 ) );
  	this.add( cameraPY );

  	var cameraNY = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraNY.up.set( 0, 0, - 1 );
  	cameraNY.lookAt( new Vector3$1( 0, - 1, 0 ) );
  	this.add( cameraNY );

  	var cameraPZ = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraPZ.up.set( 0, - 1, 0 );
  	cameraPZ.lookAt( new Vector3$1( 0, 0, 1 ) );
  	this.add( cameraPZ );

  	var cameraNZ = new PerspectiveCamera$2( fov, aspect, near, far );
  	cameraNZ.up.set( 0, - 1, 0 );
  	cameraNZ.lookAt( new Vector3$1( 0, 0, - 1 ) );
  	this.add( cameraNZ );

  	var options = { format: RGBFormat$1, magFilter: LinearFilter$1, minFilter: LinearFilter$1 };

  	this.renderTarget = new WebGLRenderTargetCube$1( cubeResolution, cubeResolution, options );
  	this.renderTarget.texture.name = "CubeCamera";

  	this.updateCubeMap = function ( renderer, scene ) {

  		if ( this.parent === null ) this.updateMatrixWorld();

  		var renderTarget = this.renderTarget;
  		var generateMipmaps = renderTarget.texture.generateMipmaps;

  		renderTarget.texture.generateMipmaps = false;

  		renderTarget.activeCubeFace = 0;
  		renderer.render( scene, cameraPX, renderTarget );

  		renderTarget.activeCubeFace = 1;
  		renderer.render( scene, cameraNX, renderTarget );

  		renderTarget.activeCubeFace = 2;
  		renderer.render( scene, cameraPY, renderTarget );

  		renderTarget.activeCubeFace = 3;
  		renderer.render( scene, cameraNY, renderTarget );

  		renderTarget.activeCubeFace = 4;
  		renderer.render( scene, cameraPZ, renderTarget );

  		renderTarget.texture.generateMipmaps = generateMipmaps;

  		renderTarget.activeCubeFace = 5;
  		renderer.render( scene, cameraNZ, renderTarget );

  		renderer.setRenderTarget( null );

  	};

  }

  CubeCamera$2.prototype = Object.create( Object3D$1.prototype );
  CubeCamera$2.prototype.constructor = CubeCamera$2;

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function ArrayCamera$1( array ) {

  	PerspectiveCamera$2.call( this );

  	this.enabled = false;
  	this.cameras = array || [];

  }

  ArrayCamera$1.prototype = Object.assign( Object.create( PerspectiveCamera$2.prototype ), {

  	constructor: ArrayCamera$1,

  	isArrayCamera: true

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioListener$1() {

  	Object3D$1.call( this );

  	this.type = 'AudioListener';

  	this.context = AudioContext$1.getContext();

  	this.gain = this.context.createGain();
  	this.gain.connect( this.context.destination );

  	this.filter = null;

  }

  AudioListener$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: AudioListener$1,

  	getInput: function () {

  		return this.gain;

  	},

  	removeFilter: function ( ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );
  			this.gain.connect( this.context.destination );
  			this.filter = null;

  		}

  	},

  	getFilter: function () {

  		return this.filter;

  	},

  	setFilter: function ( value ) {

  		if ( this.filter !== null ) {

  			this.gain.disconnect( this.filter );
  			this.filter.disconnect( this.context.destination );

  		} else {

  			this.gain.disconnect( this.context.destination );

  		}

  		this.filter = value;
  		this.gain.connect( this.filter );
  		this.filter.connect( this.context.destination );

  	},

  	getMasterVolume: function () {

  		return this.gain.gain.value;

  	},

  	setMasterVolume: function ( value ) {

  		this.gain.gain.value = value;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3$1();
  		var quaternion = new Quaternion$1();
  		var scale = new Vector3$1();

  		var orientation = new Vector3$1();

  		return function updateMatrixWorld( force ) {

  			Object3D$1.prototype.updateMatrixWorld.call( this, force );

  			var listener = this.context.listener;
  			var up = this.up;

  			this.matrixWorld.decompose( position, quaternion, scale );

  			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  			if ( listener.positionX ) {

  				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
  				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
  				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
  				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
  				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
  				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
  				listener.upX.setValueAtTime( up.x, this.context.currentTime );
  				listener.upY.setValueAtTime( up.y, this.context.currentTime );
  				listener.upZ.setValueAtTime( up.z, this.context.currentTime );

  			} else {

  				listener.setPosition( position.x, position.y, position.z );
  				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  			}

  		};

  	} )()

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Reece Aaron Lecrivain / http://reecenotes.com/
   */

  function Audio$1( listener ) {

  	Object3D$1.call( this );

  	this.type = 'Audio';

  	this.context = listener.context;

  	this.gain = this.context.createGain();
  	this.gain.connect( listener.getInput() );

  	this.autoplay = false;

  	this.buffer = null;
  	this.loop = false;
  	this.startTime = 0;
  	this.playbackRate = 1;
  	this.isPlaying = false;
  	this.hasPlaybackControl = true;
  	this.sourceType = 'empty';

  	this.filters = [];

  }

  Audio$1.prototype = Object.assign( Object.create( Object3D$1.prototype ), {

  	constructor: Audio$1,

  	getOutput: function () {

  		return this.gain;

  	},

  	setNodeSource: function ( audioNode ) {

  		this.hasPlaybackControl = false;
  		this.sourceType = 'audioNode';
  		this.source = audioNode;
  		this.connect();

  		return this;

  	},

  	setBuffer: function ( audioBuffer ) {

  		this.buffer = audioBuffer;
  		this.sourceType = 'buffer';

  		if ( this.autoplay ) this.play();

  		return this;

  	},

  	play: function () {

  		if ( this.isPlaying === true ) {

  			console.warn( 'THREE.Audio: Audio is already playing.' );
  			return;

  		}

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		var source = this.context.createBufferSource();

  		source.buffer = this.buffer;
  		source.loop = this.loop;
  		source.onended = this.onEnded.bind( this );
  		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
  		source.start( 0, this.startTime );

  		this.isPlaying = true;

  		this.source = source;

  		return this.connect();

  	},

  	pause: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.source.stop();
  		this.startTime = this.context.currentTime;
  		this.isPlaying = false;

  		return this;

  	},

  	stop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.source.stop();
  		this.startTime = 0;
  		this.isPlaying = false;

  		return this;

  	},

  	connect: function () {

  		if ( this.filters.length > 0 ) {

  			this.source.connect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this.filters[ i - 1 ].connect( this.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

  		} else {

  			this.source.connect( this.getOutput() );

  		}

  		return this;

  	},

  	disconnect: function () {

  		if ( this.filters.length > 0 ) {

  			this.source.disconnect( this.filters[ 0 ] );

  			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

  				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

  			}

  			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

  		} else {

  			this.source.disconnect( this.getOutput() );

  		}

  		return this;

  	},

  	getFilters: function () {

  		return this.filters;

  	},

  	setFilters: function ( value ) {

  		if ( ! value ) value = [];

  		if ( this.isPlaying === true ) {

  			this.disconnect();
  			this.filters = value;
  			this.connect();

  		} else {

  			this.filters = value;

  		}

  		return this;

  	},

  	getFilter: function () {

  		return this.getFilters()[ 0 ];

  	},

  	setFilter: function ( filter ) {

  		return this.setFilters( filter ? [ filter ] : [] );

  	},

  	setPlaybackRate: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.playbackRate = value;

  		if ( this.isPlaying === true ) {

  			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

  		}

  		return this;

  	},

  	getPlaybackRate: function () {

  		return this.playbackRate;

  	},

  	onEnded: function () {

  		this.isPlaying = false;

  	},

  	getLoop: function () {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return false;

  		}

  		return this.loop;

  	},

  	setLoop: function ( value ) {

  		if ( this.hasPlaybackControl === false ) {

  			console.warn( 'THREE.Audio: this Audio has no playback control.' );
  			return;

  		}

  		this.loop = value;

  		if ( this.isPlaying === true ) {

  			this.source.loop = this.loop;

  		}

  		return this;

  	},

  	getVolume: function () {

  		return this.gain.gain.value;

  	},
  	
  	setVolume: function ( value ) {

  		this.gain.gain.value = value;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function PositionalAudio$1( listener ) {

  	Audio$1.call( this, listener );

  	this.panner = this.context.createPanner();
  	this.panner.connect( this.gain );

  }

  PositionalAudio$1.prototype = Object.assign( Object.create( Audio$1.prototype ), {

  	constructor: PositionalAudio$1,

  	getOutput: function () {

  		return this.panner;

  	},

  	getRefDistance: function () {

  		return this.panner.refDistance;

  	},

  	setRefDistance: function ( value ) {

  		this.panner.refDistance = value;

  	},

  	getRolloffFactor: function () {

  		return this.panner.rolloffFactor;

  	},

  	setRolloffFactor: function ( value ) {

  		this.panner.rolloffFactor = value;

  	},

  	getDistanceModel: function () {

  		return this.panner.distanceModel;

  	},

  	setDistanceModel: function ( value ) {

  		this.panner.distanceModel = value;

  	},

  	getMaxDistance: function () {

  		return this.panner.maxDistance;

  	},

  	setMaxDistance: function ( value ) {

  		this.panner.maxDistance = value;

  	},

  	updateMatrixWorld: ( function () {

  		var position = new Vector3$1();

  		return function updateMatrixWorld( force ) {

  			Object3D$1.prototype.updateMatrixWorld.call( this, force );

  			position.setFromMatrixPosition( this.matrixWorld );

  			this.panner.setPosition( position.x, position.y, position.z );

  		};

  	} )()


  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function AudioAnalyser$1( audio, fftSize ) {

  	this.analyser = audio.context.createAnalyser();
  	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

  	this.data = new Uint8Array( this.analyser.frequencyBinCount );

  	audio.getOutput().connect( this.analyser );

  }

  Object.assign( AudioAnalyser$1.prototype, {

  	getFrequencyData: function () {

  		this.analyser.getByteFrequencyData( this.data );

  		return this.data;

  	},

  	getAverageFrequency: function () {

  		var value = 0, data = this.getFrequencyData();

  		for ( var i = 0; i < data.length; i ++ ) {

  			value += data[ i ];

  		}

  		return value / data.length;

  	}

  } );

  /**
   *
   * Buffered scene graph property that allows weighted accumulation.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function PropertyMixer$1( binding, typeName, valueSize ) {

  	this.binding = binding;
  	this.valueSize = valueSize;

  	var bufferType = Float64Array,
  		mixFunction;

  	switch ( typeName ) {

  		case 'quaternion':
  			mixFunction = this._slerp;
  			break;

  		case 'string':
  		case 'bool':
  			bufferType = Array;
  			mixFunction = this._select;
  			break;

  		default:
  			mixFunction = this._lerp;

  	}

  	this.buffer = new bufferType( valueSize * 4 );
  	// layout: [ incoming | accu0 | accu1 | orig ]
  	//
  	// interpolators can use .buffer as their .result
  	// the data then goes to 'incoming'
  	//
  	// 'accu0' and 'accu1' are used frame-interleaved for
  	// the cumulative result and are compared to detect
  	// changes
  	//
  	// 'orig' stores the original state of the property

  	this._mixBufferRegion = mixFunction;

  	this.cumulativeWeight = 0;

  	this.useCount = 0;
  	this.referenceCount = 0;

  }

  Object.assign( PropertyMixer$1.prototype, {

  	// accumulate data in the 'incoming' region into 'accu<i>'
  	accumulate: function ( accuIndex, weight ) {

  		// note: happily accumulating nothing when weight = 0, the caller knows
  		// the weight and shouldn't have made the call in the first place

  		var buffer = this.buffer,
  			stride = this.valueSize,
  			offset = accuIndex * stride + stride,

  			currentWeight = this.cumulativeWeight;

  		if ( currentWeight === 0 ) {

  			// accuN := incoming * weight

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ offset + i ] = buffer[ i ];

  			}

  			currentWeight = weight;

  		} else {

  			// accuN := accuN + incoming * weight

  			currentWeight += weight;
  			var mix = weight / currentWeight;
  			this._mixBufferRegion( buffer, offset, 0, mix, stride );

  		}

  		this.cumulativeWeight = currentWeight;

  	},

  	// apply the state of 'accu<i>' to the binding when accus differ
  	apply: function ( accuIndex ) {

  		var stride = this.valueSize,
  			buffer = this.buffer,
  			offset = accuIndex * stride + stride,

  			weight = this.cumulativeWeight,

  			binding = this.binding;

  		this.cumulativeWeight = 0;

  		if ( weight < 1 ) {

  			// accuN := accuN + original * ( 1 - cumulativeWeight )

  			var originalValueOffset = stride * 3;

  			this._mixBufferRegion(
  				buffer, offset, originalValueOffset, 1 - weight, stride );

  		}

  		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

  			if ( buffer[ i ] !== buffer[ i + stride ] ) {

  				// value has changed -> update scene graph

  				binding.setValue( buffer, offset );
  				break;

  			}

  		}

  	},

  	// remember the state of the bound property and copy it to both accus
  	saveOriginalState: function () {

  		var binding = this.binding;

  		var buffer = this.buffer,
  			stride = this.valueSize,

  			originalValueOffset = stride * 3;

  		binding.getValue( buffer, originalValueOffset );

  		// accu[0..1] := orig -- initially detect changes against the original
  		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

  			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

  		}

  		this.cumulativeWeight = 0;

  	},

  	// apply the state previously taken via 'saveOriginalState' to the binding
  	restoreOriginalState: function () {

  		var originalValueOffset = this.valueSize * 3;
  		this.binding.setValue( this.buffer, originalValueOffset );

  	},


  	// mix functions

  	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		if ( t >= 0.5 ) {

  			for ( var i = 0; i !== stride; ++ i ) {

  				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

  			}

  		}

  	},

  	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

  		Quaternion$1.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

  	},

  	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

  		var s = 1 - t;

  		for ( var i = 0; i !== stride; ++ i ) {

  			var j = dstOffset + i;

  			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

  		}

  	}

  } );

  /**
   *
   * A reference to a real property in the scene graph.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function Composite$1( targetGroup, path, optionalParsedPath ) {

  	var parsedPath = optionalParsedPath || PropertyBinding$1.parseTrackName( path );

  	this._targetGroup = targetGroup;
  	this._bindings = targetGroup.subscribe_( path, parsedPath );

  }

  Object.assign( Composite$1.prototype, {

  	getValue: function ( array, offset ) {

  		this.bind(); // bind all binding

  		var firstValidIndex = this._targetGroup.nCachedObjects_,
  			binding = this._bindings[ firstValidIndex ];

  		// and only call .getValue on the first
  		if ( binding !== undefined ) binding.getValue( array, offset );

  	},

  	setValue: function ( array, offset ) {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].setValue( array, offset );

  		}

  	},

  	bind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].bind();

  		}

  	},

  	unbind: function () {

  		var bindings = this._bindings;

  		for ( var i = this._targetGroup.nCachedObjects_,
  				  n = bindings.length; i !== n; ++ i ) {

  			bindings[ i ].unbind();

  		}

  	}

  } );


  function PropertyBinding$1( rootNode, path, parsedPath ) {

  	this.path = path;
  	this.parsedPath = parsedPath || PropertyBinding$1.parseTrackName( path );

  	this.node = PropertyBinding$1.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

  	this.rootNode = rootNode;

  }

  Object.assign( PropertyBinding$1, {

  	Composite: Composite$1,

  	create: function ( root, path, parsedPath ) {

  		if ( ! ( root && root.isAnimationObjectGroup ) ) {

  			return new PropertyBinding$1( root, path, parsedPath );

  		} else {

  			return new PropertyBinding$1.Composite( root, path, parsedPath );

  		}

  	},

  	parseTrackName: function () {

  		// Parent directories, delimited by '/' or ':'. Currently unused, but must
  		// be matched to parse the rest of the track name.
  		var directoryRe = /((?:[\w-]+[\/:])*)/;

  		// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  		var nodeRe = /([\w-\.]+)?/;

  		// Object on target node, and accessor. Name may contain only word
  		// characters. Accessor may contain any character except closing bracket.
  		var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;

  		// Property and accessor. May contain only word characters. Accessor may
  		// contain any non-bracket characters.
  		var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;

  		var trackRe = new RegExp(''
  			+ '^'
  			+ directoryRe.source
  			+ nodeRe.source
  			+ objectRe.source
  			+ propertyRe.source
  			+ '$'
  		);

  		var supportedObjectNames = [ 'material', 'materials', 'bones' ];

  		return function ( trackName ) {

  				var matches = trackRe.exec( trackName );

  				if ( ! matches ) {

  					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

  				}

  				var results = {
  					// directoryName: matches[ 1 ], // (tschw) currently unused
  					nodeName: matches[ 2 ],
  					objectName: matches[ 3 ],
  					objectIndex: matches[ 4 ],
  					propertyName: matches[ 5 ],     // required
  					propertyIndex: matches[ 6 ]
  				};

  				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

  				if ( lastDot !== undefined && lastDot !== -1 ) {

  					var objectName = results.nodeName.substring( lastDot + 1 );

  					// Object names must be checked against a whitelist. Otherwise, there
  					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
  					// 'bar' could be the objectName, or part of a nodeName (which can
  					// include '.' characters).
  					if ( supportedObjectNames.indexOf( objectName ) !== -1 ) {

  						results.nodeName = results.nodeName.substring( 0, lastDot );
  						results.objectName = objectName;

  					}

  				}

  				if ( results.propertyName === null || results.propertyName.length === 0 ) {

  					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

  				}

  				return results;

  			};

  	}(),

  	findNode: function ( root, nodeName ) {

  		if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

  			return root;

  		}

  		// search into skeleton bones.
  		if ( root.skeleton ) {

  			var searchSkeleton = function ( skeleton ) {

  				for ( var i = 0; i < skeleton.bones.length; i ++ ) {

  					var bone = skeleton.bones[ i ];

  					if ( bone.name === nodeName ) {

  						return bone;

  					}

  				}

  				return null;

  			};

  			var bone = searchSkeleton( root.skeleton );

  			if ( bone ) {

  				return bone;

  			}

  		}

  		// search into node subtree.
  		if ( root.children ) {

  			var searchNodeSubtree = function ( children ) {

  				for ( var i = 0; i < children.length; i ++ ) {

  					var childNode = children[ i ];

  					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

  						return childNode;

  					}

  					var result = searchNodeSubtree( childNode.children );

  					if ( result ) return result;

  				}

  				return null;

  			};

  			var subTreeNode = searchNodeSubtree( root.children );

  			if ( subTreeNode ) {

  				return subTreeNode;

  			}

  		}

  		return null;

  	}

  } );

  Object.assign( PropertyBinding$1.prototype, { // prototype, continued

  	// these are used to "bind" a nonexistent property
  	_getValue_unavailable: function () {},
  	_setValue_unavailable: function () {},

  	BindingType: {
  		Direct: 0,
  		EntireArray: 1,
  		ArrayElement: 2,
  		HasFromToArray: 3
  	},

  	Versioning: {
  		None: 0,
  		NeedsUpdate: 1,
  		MatrixWorldNeedsUpdate: 2
  	},

  	GetterByBindingType: [

  		function getValue_direct( buffer, offset ) {

  			buffer[ offset ] = this.node[ this.propertyName ];

  		},

  		function getValue_array( buffer, offset ) {

  			var source = this.resolvedProperty;

  			for ( var i = 0, n = source.length; i !== n; ++ i ) {

  				buffer[ offset ++ ] = source[ i ];

  			}

  		},

  		function getValue_arrayElement( buffer, offset ) {

  			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

  		},

  		function getValue_toArray( buffer, offset ) {

  			this.resolvedProperty.toArray( buffer, offset );

  		}

  	],

  	SetterByBindingTypeAndVersioning: [

  		[
  			// Direct

  			function setValue_direct( buffer, offset ) {

  				this.node[ this.propertyName ] = buffer[ offset ];

  			},

  			function setValue_direct_setNeedsUpdate( buffer, offset ) {

  				this.node[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.node[ this.propertyName ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// EntireArray

  			function setValue_array( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  			},

  			function setValue_array_setNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				var dest = this.resolvedProperty;

  				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

  					dest[ i ] = buffer[ offset ++ ];

  				}

  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// ArrayElement

  			function setValue_arrayElement( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

  			},

  			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		], [

  			// HasToFromArray

  			function setValue_fromArray( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );

  			},

  			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.needsUpdate = true;

  			},

  			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

  				this.resolvedProperty.fromArray( buffer, offset );
  				this.targetObject.matrixWorldNeedsUpdate = true;

  			}

  		]

  	],

  	getValue: function getValue_unbound( targetArray, offset ) {

  		this.bind();
  		this.getValue( targetArray, offset );

  		// Note: This class uses a State pattern on a per-method basis:
  		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
  		// prototype version of these methods with one that represents
  		// the bound state. When the property is not found, the methods
  		// become no-ops.

  	},

  	setValue: function getValue_unbound( sourceArray, offset ) {

  		this.bind();
  		this.setValue( sourceArray, offset );

  	},

  	// create getter / setter pair for a property in the scene graph
  	bind: function () {

  		var targetObject = this.node,
  			parsedPath = this.parsedPath,

  			objectName = parsedPath.objectName,
  			propertyName = parsedPath.propertyName,
  			propertyIndex = parsedPath.propertyIndex;

  		if ( ! targetObject ) {

  			targetObject = PropertyBinding$1.findNode(
  					this.rootNode, parsedPath.nodeName ) || this.rootNode;

  			this.node = targetObject;

  		}

  		// set fail state so we can just 'return' on error
  		this.getValue = this._getValue_unavailable;
  		this.setValue = this._setValue_unavailable;

  		// ensure there is a value node
  		if ( ! targetObject ) {

  			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
  			return;

  		}

  		if ( objectName ) {

  			var objectIndex = parsedPath.objectIndex;

  			// special cases were we need to reach deeper into the hierarchy to get the face materials....
  			switch ( objectName ) {

  				case 'materials':

  					if ( ! targetObject.material ) {

  						console.error( '  can not bind to material as node does not have a material', this );
  						return;

  					}

  					if ( ! targetObject.material.materials ) {

  						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
  						return;

  					}

  					targetObject = targetObject.material.materials;

  					break;

  				case 'bones':

  					if ( ! targetObject.skeleton ) {

  						console.error( '  can not bind to bones as node does not have a skeleton', this );
  						return;

  					}

  					// potential future optimization: skip this if propertyIndex is already an integer
  					// and convert the integer string to a true integer.

  					targetObject = targetObject.skeleton.bones;

  					// support resolving morphTarget names into indices.
  					for ( var i = 0; i < targetObject.length; i ++ ) {

  						if ( targetObject[ i ].name === objectIndex ) {

  							objectIndex = i;
  							break;

  						}

  					}

  					break;

  				default:

  					if ( targetObject[ objectName ] === undefined ) {

  						console.error( '  can not bind to objectName of node, undefined', this );
  						return;

  					}

  					targetObject = targetObject[ objectName ];

  			}


  			if ( objectIndex !== undefined ) {

  				if ( targetObject[ objectIndex ] === undefined ) {

  					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
  					return;

  				}

  				targetObject = targetObject[ objectIndex ];

  			}

  		}

  		// resolve property
  		var nodeProperty = targetObject[ propertyName ];

  		if ( nodeProperty === undefined ) {

  			var nodeName = parsedPath.nodeName;

  			console.error( "  trying to update property for track: " + nodeName +
  				'.' + propertyName + " but it wasn't found.", targetObject );
  			return;

  		}

  		// determine versioning scheme
  		var versioning = this.Versioning.None;

  		if ( targetObject.needsUpdate !== undefined ) { // material

  			versioning = this.Versioning.NeedsUpdate;
  			this.targetObject = targetObject;

  		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

  			versioning = this.Versioning.MatrixWorldNeedsUpdate;
  			this.targetObject = targetObject;

  		}

  		// determine how the property gets bound
  		var bindingType = this.BindingType.Direct;

  		if ( propertyIndex !== undefined ) {

  			// access a sub element of the property array (only primitives are supported right now)

  			if ( propertyName === "morphTargetInfluences" ) {

  				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

  				// support resolving morphTarget names into indices.
  				if ( ! targetObject.geometry ) {

  					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
  					return;

  				}

  				if ( ! targetObject.geometry.morphTargets ) {

  					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
  					return;

  				}

  				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

  					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

  						propertyIndex = i;
  						break;

  					}

  				}

  			}

  			bindingType = this.BindingType.ArrayElement;

  			this.resolvedProperty = nodeProperty;
  			this.propertyIndex = propertyIndex;

  		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

  			// must use copy for Object3D.Euler/Quaternion

  			bindingType = this.BindingType.HasFromToArray;

  			this.resolvedProperty = nodeProperty;

  		} else if ( Array.isArray( nodeProperty ) ) {

  			bindingType = this.BindingType.EntireArray;

  			this.resolvedProperty = nodeProperty;

  		} else {

  			this.propertyName = propertyName;

  		}

  		// select getter / setter
  		this.getValue = this.GetterByBindingType[ bindingType ];
  		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  	},

  	unbind: function () {

  		this.node = null;

  		// back to the prototype version of getValue / setValue
  		// note: avoiding to mutate the shape of 'this' via 'delete'
  		this.getValue = this._getValue_unbound;
  		this.setValue = this._setValue_unbound;

  	}

  } );

  //!\ DECLARE ALIAS AFTER assign prototype !
  Object.assign( PropertyBinding$1.prototype, {

  	// initial state of these methods that calls 'bind'
  	_getValue_unbound: PropertyBinding$1.prototype.getValue,
  	_setValue_unbound: PropertyBinding$1.prototype.setValue,

  } );

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   * 	-	Add objects you would otherwise pass as 'root' to the
   * 		constructor or the .clipAction method of AnimationMixer.
   *
   * 	-	Instead pass this object as 'root'.
   *
   * 	-	You can also add and remove objects later when the mixer
   * 		is running.
   *
   * Note:
   *
   *  	Objects of this class appear as one object to the mixer,
   *  	so cache control of the individual objects must be done
   *  	on the group.
   *
   * Limitation:
   *
   * 	- 	The animated properties must be compatible among the
   * 		all objects in the group.
   *
   *  -	A single property can either be controlled through a
   *  	target group or directly, but not both.
   *
   * @author tschw
   */

  function AnimationObjectGroup$1( var_args ) {

  	this.uuid = _Math$1.generateUUID();

  	// cached objects followed by the active ones
  	this._objects = Array.prototype.slice.call( arguments );

  	this.nCachedObjects_ = 0;			// threshold
  	// note: read by PropertyBinding.Composite

  	var indices = {};
  	this._indicesByUUID = indices;		// for bookkeeping

  	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  		indices[ arguments[ i ].uuid ] = i;

  	}

  	this._paths = [];					// inside: string
  	this._parsedPaths = [];				// inside: { we don't care, here }
  	this._bindings = []; 				// inside: Array< PropertyBinding >
  	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

  	var scope = this;

  	this.stats = {

  		objects: {
  			get total() { return scope._objects.length; },
  			get inUse() { return this.total - scope.nCachedObjects_; }
  		},

  		get bindingsPerObject() { return scope._bindings.length; }

  	};

  }

  Object.assign( AnimationObjectGroup$1.prototype, {

  	isAnimationObjectGroup: true,

  	add: function( var_args ) {

  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ],
  				knownObject = undefined;

  			if ( index === undefined ) {

  				// unknown object -> add it to the ACTIVE region

  				index = nObjects ++;
  				indicesByUUID[ uuid ] = index;
  				objects.push( object );

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					bindings[ j ].push(
  							new PropertyBinding$1(
  								object, paths[ j ], parsedPaths[ j ] ) );

  				}

  			} else if ( index < nCachedObjects ) {

  				knownObject = objects[ index ];

  				// move existing object to the ACTIVE region

  				var firstActiveIndex = -- nCachedObjects,
  					lastCachedObject = objects[ firstActiveIndex ];

  				indicesByUUID[ lastCachedObject.uuid ] = index;
  				objects[ index ] = lastCachedObject;

  				indicesByUUID[ uuid ] = firstActiveIndex;
  				objects[ firstActiveIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						lastCached = bindingsForPath[ firstActiveIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = lastCached;

  					if ( binding === undefined ) {

  						// since we do not bother to create new bindings
  						// for objects that are cached, the binding may
  						// or may not exist

  						binding = new PropertyBinding$1(
  								object, paths[ j ], parsedPaths[ j ] );

  					}

  					bindingsForPath[ firstActiveIndex ] = binding;

  				}

  			} else if ( objects[ index ] !== knownObject ) {

  				console.error( "Different objects with the same UUID " +
  						"detected. Clean the caches or recreate your " +
  						"infrastructure when reloading scenes..." );

  			} // else the object is already where we want it to be

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	remove: function( var_args ) {

  		var objects = this._objects,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined && index >= nCachedObjects ) {

  				// move existing object into the CACHED region

  				var lastCachedIndex = nCachedObjects ++,
  					firstActiveObject = objects[ lastCachedIndex ];

  				indicesByUUID[ firstActiveObject.uuid ] = index;
  				objects[ index ] = firstActiveObject;

  				indicesByUUID[ uuid ] = lastCachedIndex;
  				objects[ lastCachedIndex ] = object;

  				// accounting is done, now do the same for all bindings

  				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  					var bindingsForPath = bindings[ j ],
  						firstActive = bindingsForPath[ lastCachedIndex ],
  						binding = bindingsForPath[ index ];

  					bindingsForPath[ index ] = firstActive;
  					bindingsForPath[ lastCachedIndex ] = binding;

  				}

  			}

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// remove & forget
  	uncache: function( var_args ) {

  		var objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			indicesByUUID = this._indicesByUUID,
  			bindings = this._bindings,
  			nBindings = bindings.length;

  		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

  			var object = arguments[ i ],
  				uuid = object.uuid,
  				index = indicesByUUID[ uuid ];

  			if ( index !== undefined ) {

  				delete indicesByUUID[ uuid ];

  				if ( index < nCachedObjects ) {

  					// object is cached, shrink the CACHED region

  					var firstActiveIndex = -- nCachedObjects,
  						lastCachedObject = objects[ firstActiveIndex ],
  						lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					// last cached object takes this object's place
  					indicesByUUID[ lastCachedObject.uuid ] = index;
  					objects[ index ] = lastCachedObject;

  					// last object goes to the activated slot and pop
  					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
  					objects[ firstActiveIndex ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ],
  							lastCached = bindingsForPath[ firstActiveIndex ],
  							last = bindingsForPath[ lastIndex ];

  						bindingsForPath[ index ] = lastCached;
  						bindingsForPath[ firstActiveIndex ] = last;
  						bindingsForPath.pop();

  					}

  				} else {

  					// object is active, just swap with the last and pop

  					var lastIndex = -- nObjects,
  						lastObject = objects[ lastIndex ];

  					indicesByUUID[ lastObject.uuid ] = index;
  					objects[ index ] = lastObject;
  					objects.pop();

  					// accounting is done, now do the same for all bindings

  					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

  						var bindingsForPath = bindings[ j ];

  						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
  						bindingsForPath.pop();

  					}

  				} // cached or active

  			} // if object is known

  		} // for arguments

  		this.nCachedObjects_ = nCachedObjects;

  	},

  	// Internal interface used by befriended PropertyBinding.Composite:

  	subscribe_: function ( path, parsedPath ) {

  		// returns an array of bindings for the given path that is changed
  		// according to the contained objects in the group

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ],
  			bindings = this._bindings;

  		if ( index !== undefined ) return bindings[ index ];

  		var paths = this._paths,
  			parsedPaths = this._parsedPaths,
  			objects = this._objects,
  			nObjects = objects.length,
  			nCachedObjects = this.nCachedObjects_,
  			bindingsForPath = new Array( nObjects );

  		index = bindings.length;

  		indicesByPath[ path ] = index;

  		paths.push( path );
  		parsedPaths.push( parsedPath );
  		bindings.push( bindingsForPath );

  		for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

  			var object = objects[ i ];
  			bindingsForPath[ i ] = new PropertyBinding$1( object, path, parsedPath );

  		}

  		return bindingsForPath;

  	},

  	unsubscribe_: function ( path ) {

  		// tells the group to forget about a property path and no longer
  		// update the array previously obtained with 'subscribe_'

  		var indicesByPath = this._bindingsIndicesByPath,
  			index = indicesByPath[ path ];

  		if ( index !== undefined ) {

  			var paths = this._paths,
  				parsedPaths = this._parsedPaths,
  				bindings = this._bindings,
  				lastBindingsIndex = bindings.length - 1,
  				lastBindings = bindings[ lastBindingsIndex ],
  				lastBindingsPath = path[ lastBindingsIndex ];

  			indicesByPath[ lastBindingsPath ] = index;

  			bindings[ index ] = lastBindings;
  			bindings.pop();

  			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
  			parsedPaths.pop();

  			paths[ index ] = paths[ lastBindingsIndex ];
  			paths.pop();

  		}

  	}

  } );

  /**
   *
   * Action provided by AnimationMixer for scheduling clip playback on specific
   * objects.
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   *
   */

  function AnimationAction$1( mixer, clip, localRoot ) {

  	this._mixer = mixer;
  	this._clip = clip;
  	this._localRoot = localRoot || null;

  	var tracks = clip.tracks,
  		nTracks = tracks.length,
  		interpolants = new Array( nTracks );

  	var interpolantSettings = {
  			endingStart: 	ZeroCurvatureEnding$1,
  			endingEnd:		ZeroCurvatureEnding$1
  	};

  	for ( var i = 0; i !== nTracks; ++ i ) {

  		var interpolant = tracks[ i ].createInterpolant( null );
  		interpolants[ i ] = interpolant;
  		interpolant.settings = interpolantSettings;

  	}

  	this._interpolantSettings = interpolantSettings;

  	this._interpolants = interpolants;	// bound by the mixer

  	// inside: PropertyMixer (managed by the mixer)
  	this._propertyBindings = new Array( nTracks );

  	this._cacheIndex = null;			// for the memory manager
  	this._byClipCacheIndex = null;		// for the memory manager

  	this._timeScaleInterpolant = null;
  	this._weightInterpolant = null;

  	this.loop = LoopRepeat$1;
  	this._loopCount = -1;

  	// global mixer time when the action is to be started
  	// it's set back to 'null' upon start of the action
  	this._startTime = null;

  	// scaled local time of the action
  	// gets clamped or wrapped to 0..clip.duration according to loop
  	this.time = 0;

  	this.timeScale = 1;
  	this._effectiveTimeScale = 1;

  	this.weight = 1;
  	this._effectiveWeight = 1;

  	this.repetitions = Infinity; 		// no. of repetitions when looping

  	this.paused = false;				// true -> zero effective time scale
  	this.enabled = true;				// false -> zero effective weight

  	this.clampWhenFinished 	= false;	// keep feeding the last frame?

  	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
  	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

  }

  Object.assign( AnimationAction$1.prototype, {

  	// State & Scheduling

  	play: function() {

  		this._mixer._activateAction( this );

  		return this;

  	},

  	stop: function() {

  		this._mixer._deactivateAction( this );

  		return this.reset();

  	},

  	reset: function() {

  		this.paused = false;
  		this.enabled = true;

  		this.time = 0;			// restart clip
  		this._loopCount = -1;	// forget previous loops
  		this._startTime = null;	// forget scheduling

  		return this.stopFading().stopWarping();

  	},

  	isRunning: function() {

  		return this.enabled && ! this.paused && this.timeScale !== 0 &&
  				this._startTime === null && this._mixer._isActiveAction( this );

  	},

  	// return true when play has been called
  	isScheduled: function() {

  		return this._mixer._isActiveAction( this );

  	},

  	startAt: function( time ) {

  		this._startTime = time;

  		return this;

  	},

  	setLoop: function( mode, repetitions ) {

  		this.loop = mode;
  		this.repetitions = repetitions;

  		return this;

  	},

  	// Weight

  	// set the weight stopping any scheduled fading
  	// although .enabled = false yields an effective weight of zero, this
  	// method does *not* change .enabled, because it would be confusing
  	setEffectiveWeight: function( weight ) {

  		this.weight = weight;

  		// note: same logic as when updated at runtime
  		this._effectiveWeight = this.enabled ? weight : 0;

  		return this.stopFading();

  	},

  	// return the weight considering fading and .enabled
  	getEffectiveWeight: function() {

  		return this._effectiveWeight;

  	},

  	fadeIn: function( duration ) {

  		return this._scheduleFading( duration, 0, 1 );

  	},

  	fadeOut: function( duration ) {

  		return this._scheduleFading( duration, 1, 0 );

  	},

  	crossFadeFrom: function( fadeOutAction, duration, warp ) {

  		fadeOutAction.fadeOut( duration );
  		this.fadeIn( duration );

  		if( warp ) {

  			var fadeInDuration = this._clip.duration,
  				fadeOutDuration = fadeOutAction._clip.duration,

  				startEndRatio = fadeOutDuration / fadeInDuration,
  				endStartRatio = fadeInDuration / fadeOutDuration;

  			fadeOutAction.warp( 1.0, startEndRatio, duration );
  			this.warp( endStartRatio, 1.0, duration );

  		}

  		return this;

  	},

  	crossFadeTo: function( fadeInAction, duration, warp ) {

  		return fadeInAction.crossFadeFrom( this, duration, warp );

  	},

  	stopFading: function() {

  		var weightInterpolant = this._weightInterpolant;

  		if ( weightInterpolant !== null ) {

  			this._weightInterpolant = null;
  			this._mixer._takeBackControlInterpolant( weightInterpolant );

  		}

  		return this;

  	},

  	// Time Scale Control

  	// set the time scale stopping any scheduled warping
  	// although .paused = true yields an effective time scale of zero, this
  	// method does *not* change .paused, because it would be confusing
  	setEffectiveTimeScale: function( timeScale ) {

  		this.timeScale = timeScale;
  		this._effectiveTimeScale = this.paused ? 0 :timeScale;

  		return this.stopWarping();

  	},

  	// return the time scale considering warping and .paused
  	getEffectiveTimeScale: function() {

  		return this._effectiveTimeScale;

  	},

  	setDuration: function( duration ) {

  		this.timeScale = this._clip.duration / duration;

  		return this.stopWarping();

  	},

  	syncWith: function( action ) {

  		this.time = action.time;
  		this.timeScale = action.timeScale;

  		return this.stopWarping();

  	},

  	halt: function( duration ) {

  		return this.warp( this._effectiveTimeScale, 0, duration );

  	},

  	warp: function( startTimeScale, endTimeScale, duration ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._timeScaleInterpolant,

  			timeScale = this.timeScale;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._timeScaleInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now;
  		times[ 1 ] = now + duration;

  		values[ 0 ] = startTimeScale / timeScale;
  		values[ 1 ] = endTimeScale / timeScale;

  		return this;

  	},

  	stopWarping: function() {

  		var timeScaleInterpolant = this._timeScaleInterpolant;

  		if ( timeScaleInterpolant !== null ) {

  			this._timeScaleInterpolant = null;
  			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

  		}

  		return this;

  	},

  	// Object Accessors

  	getMixer: function() {

  		return this._mixer;

  	},

  	getClip: function() {

  		return this._clip;

  	},

  	getRoot: function() {

  		return this._localRoot || this._mixer._root;

  	},

  	// Interna

  	_update: function( time, deltaTime, timeDirection, accuIndex ) {

  		// called by the mixer

  		if ( ! this.enabled ) {

  			// call ._updateWeight() to update ._effectiveWeight

  			this._updateWeight( time );
  			return;

  		}

  		var startTime = this._startTime;

  		if ( startTime !== null ) {

  			// check for scheduled start of action

  			var timeRunning = ( time - startTime ) * timeDirection;
  			if ( timeRunning < 0 || timeDirection === 0 ) {

  				return; // yet to come / don't decide when delta = 0

  			}

  			// start

  			this._startTime = null; // unschedule
  			deltaTime = timeDirection * timeRunning;

  		}

  		// apply time scale and advance time

  		deltaTime *= this._updateTimeScale( time );
  		var clipTime = this._updateTime( deltaTime );

  		// note: _updateTime may disable the action resulting in
  		// an effective weight of 0

  		var weight = this._updateWeight( time );

  		if ( weight > 0 ) {

  			var interpolants = this._interpolants;
  			var propertyMixers = this._propertyBindings;

  			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

  				interpolants[ j ].evaluate( clipTime );
  				propertyMixers[ j ].accumulate( accuIndex, weight );

  			}

  		}

  	},

  	_updateWeight: function( time ) {

  		var weight = 0;

  		if ( this.enabled ) {

  			weight = this.weight;
  			var interpolant = this._weightInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				weight *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopFading();

  					if ( interpolantValue === 0 ) {

  						// faded out, disable
  						this.enabled = false;

  					}

  				}

  			}

  		}

  		this._effectiveWeight = weight;
  		return weight;

  	},

  	_updateTimeScale: function( time ) {

  		var timeScale = 0;

  		if ( ! this.paused ) {

  			timeScale = this.timeScale;

  			var interpolant = this._timeScaleInterpolant;

  			if ( interpolant !== null ) {

  				var interpolantValue = interpolant.evaluate( time )[ 0 ];

  				timeScale *= interpolantValue;

  				if ( time > interpolant.parameterPositions[ 1 ] ) {

  					this.stopWarping();

  					if ( timeScale === 0 ) {

  						// motion has halted, pause
  						this.paused = true;

  					} else {

  						// warp done - apply final time scale
  						this.timeScale = timeScale;

  					}

  				}

  			}

  		}

  		this._effectiveTimeScale = timeScale;
  		return timeScale;

  	},

  	_updateTime: function( deltaTime ) {

  		var time = this.time + deltaTime;

  		if ( deltaTime === 0 ) return time;

  		var duration = this._clip.duration,

  			loop = this.loop,
  			loopCount = this._loopCount;

  		if ( loop === LoopOnce$1 ) {

  			if ( loopCount === -1 ) {
  				// just started

  				this._loopCount = 0;
  				this._setEndings( true, true, false );

  			}

  			handle_stop: {

  				if ( time >= duration ) {

  					time = duration;

  				} else if ( time < 0 ) {

  					time = 0;

  				} else break handle_stop;

  				if ( this.clampWhenFinished ) this.paused = true;
  				else this.enabled = false;

  				this._mixer.dispatchEvent( {
  					type: 'finished', action: this,
  					direction: deltaTime < 0 ? -1 : 1
  				} );

  			}

  		} else { // repetitive Repeat or PingPong

  			var pingPong = ( loop === LoopPingPong$1 );

  			if ( loopCount === -1 ) {
  				// just started

  				if ( deltaTime >= 0 ) {

  					loopCount = 0;

  					this._setEndings(
  							true, this.repetitions === 0, pingPong );

  				} else {

  					// when looping in reverse direction, the initial
  					// transition through zero counts as a repetition,
  					// so leave loopCount at -1

  					this._setEndings(
  							this.repetitions === 0, true, pingPong );

  				}

  			}

  			if ( time >= duration || time < 0 ) {
  				// wrap around

  				var loopDelta = Math.floor( time / duration ); // signed
  				time -= duration * loopDelta;

  				loopCount += Math.abs( loopDelta );

  				var pending = this.repetitions - loopCount;

  				if ( pending < 0 ) {
  					// have to stop (switch state, clamp time, fire event)

  					if ( this.clampWhenFinished ) this.paused = true;
  					else this.enabled = false;

  					time = deltaTime > 0 ? duration : 0;

  					this._mixer.dispatchEvent( {
  						type: 'finished', action: this,
  						direction: deltaTime > 0 ? 1 : -1
  					} );

  				} else {
  					// keep running

  					if ( pending === 0 ) {
  						// entering the last round

  						var atStart = deltaTime < 0;
  						this._setEndings( atStart, ! atStart, pingPong );

  					} else {

  						this._setEndings( false, false, pingPong );

  					}

  					this._loopCount = loopCount;

  					this._mixer.dispatchEvent( {
  						type: 'loop', action: this, loopDelta: loopDelta
  					} );

  				}

  			}

  			if ( pingPong && ( loopCount & 1 ) === 1 ) {
  				// invert time for the "pong round"

  				this.time = time;
  				return duration - time;

  			}

  		}

  		this.time = time;
  		return time;

  	},

  	_setEndings: function( atStart, atEnd, pingPong ) {

  		var settings = this._interpolantSettings;

  		if ( pingPong ) {

  			settings.endingStart 	= ZeroSlopeEnding$1;
  			settings.endingEnd		= ZeroSlopeEnding$1;

  		} else {

  			// assuming for LoopOnce atStart == atEnd == true

  			if ( atStart ) {

  				settings.endingStart = this.zeroSlopeAtStart ?
  						ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

  			} else {

  				settings.endingStart = WrapAroundEnding$1;

  			}

  			if ( atEnd ) {

  				settings.endingEnd = this.zeroSlopeAtEnd ?
  						ZeroSlopeEnding$1 : ZeroCurvatureEnding$1;

  			} else {

  				settings.endingEnd 	 = WrapAroundEnding$1;

  			}

  		}

  	},

  	_scheduleFading: function( duration, weightNow, weightThen ) {

  		var mixer = this._mixer, now = mixer.time,
  			interpolant = this._weightInterpolant;

  		if ( interpolant === null ) {

  			interpolant = mixer._lendControlInterpolant();
  			this._weightInterpolant = interpolant;

  		}

  		var times = interpolant.parameterPositions,
  			values = interpolant.sampleValues;

  		times[ 0 ] = now; 				values[ 0 ] = weightNow;
  		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

  		return this;

  	}

  } );

  /**
   *
   * Player for AnimationClips.
   *
   *
   * @author Ben Houston / http://clara.io/
   * @author David Sarno / http://lighthaus.us/
   * @author tschw
   */

  function AnimationMixer$1( root ) {

  	this._root = root;
  	this._initMemoryManager();
  	this._accuIndex = 0;

  	this.time = 0;

  	this.timeScale = 1.0;

  }

  Object.assign( AnimationMixer$1.prototype, EventDispatcher$1.prototype, {

  	_bindAction: function ( action, prototypeAction ) {

  		var root = action._localRoot || this._root,
  			tracks = action._clip.tracks,
  			nTracks = tracks.length,
  			bindings = action._propertyBindings,
  			interpolants = action._interpolants,
  			rootUuid = root.uuid,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingsByName = bindingsByRoot[ rootUuid ];

  		if ( bindingsByName === undefined ) {

  			bindingsByName = {};
  			bindingsByRoot[ rootUuid ] = bindingsByName;

  		}

  		for ( var i = 0; i !== nTracks; ++ i ) {

  			var track = tracks[ i ],
  				trackName = track.name,
  				binding = bindingsByName[ trackName ];

  			if ( binding !== undefined ) {

  				bindings[ i ] = binding;

  			} else {

  				binding = bindings[ i ];

  				if ( binding !== undefined ) {

  					// existing binding, make sure the cache knows

  					if ( binding._cacheIndex === null ) {

  						++ binding.referenceCount;
  						this._addInactiveBinding( binding, rootUuid, trackName );

  					}

  					continue;

  				}

  				var path = prototypeAction && prototypeAction.
  						_propertyBindings[ i ].binding.parsedPath;

  				binding = new PropertyMixer$1(
  					PropertyBinding$1.create( root, trackName, path ),
  					track.ValueTypeName, track.getValueSize() );

  				++ binding.referenceCount;
  				this._addInactiveBinding( binding, rootUuid, trackName );

  				bindings[ i ] = binding;

  			}

  			interpolants[ i ].resultBuffer = binding.buffer;

  		}

  	},

  	_activateAction: function ( action ) {

  		if ( ! this._isActiveAction( action ) ) {

  			if ( action._cacheIndex === null ) {

  				// this action has been forgotten by the cache, but the user
  				// appears to be still using it -> rebind

  				var rootUuid = ( action._localRoot || this._root ).uuid,
  					clipUuid = action._clip.uuid,
  					actionsForClip = this._actionsByClip[ clipUuid ];

  				this._bindAction( action,
  					actionsForClip && actionsForClip.knownActions[ 0 ] );

  				this._addInactiveAction( action, clipUuid, rootUuid );

  			}

  			var bindings = action._propertyBindings;

  			// increment reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( binding.useCount ++ === 0 ) {

  					this._lendBinding( binding );
  					binding.saveOriginalState();

  				}

  			}

  			this._lendAction( action );

  		}

  	},

  	_deactivateAction: function ( action ) {

  		if ( this._isActiveAction( action ) ) {

  			var bindings = action._propertyBindings;

  			// decrement reference counts / sort out state
  			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  				var binding = bindings[ i ];

  				if ( -- binding.useCount === 0 ) {

  					binding.restoreOriginalState();
  					this._takeBackBinding( binding );

  				}

  			}

  			this._takeBackAction( action );

  		}

  	},

  	// Memory manager

  	_initMemoryManager: function () {

  		this._actions = []; // 'nActiveActions' followed by inactive ones
  		this._nActiveActions = 0;

  		this._actionsByClip = {};
  		// inside:
  		// {
  		// 		knownActions: Array< AnimationAction >	- used as prototypes
  		// 		actionByRoot: AnimationAction			- lookup
  		// }


  		this._bindings = []; // 'nActiveBindings' followed by inactive ones
  		this._nActiveBindings = 0;

  		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


  		this._controlInterpolants = []; // same game as above
  		this._nActiveControlInterpolants = 0;

  		var scope = this;

  		this.stats = {

  			actions: {
  				get total() { return scope._actions.length; },
  				get inUse() { return scope._nActiveActions; }
  			},
  			bindings: {
  				get total() { return scope._bindings.length; },
  				get inUse() { return scope._nActiveBindings; }
  			},
  			controlInterpolants: {
  				get total() { return scope._controlInterpolants.length; },
  				get inUse() { return scope._nActiveControlInterpolants; }
  			}

  		};

  	},

  	// Memory management for AnimationAction objects

  	_isActiveAction: function ( action ) {

  		var index = action._cacheIndex;
  		return index !== null && index < this._nActiveActions;

  	},

  	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

  		var actions = this._actions,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip === undefined ) {

  			actionsForClip = {

  				knownActions: [ action ],
  				actionByRoot: {}

  			};

  			action._byClipCacheIndex = 0;

  			actionsByClip[ clipUuid ] = actionsForClip;

  		} else {

  			var knownActions = actionsForClip.knownActions;

  			action._byClipCacheIndex = knownActions.length;
  			knownActions.push( action );

  		}

  		action._cacheIndex = actions.length;
  		actions.push( action );

  		actionsForClip.actionByRoot[ rootUuid ] = action;

  	},

  	_removeInactiveAction: function ( action ) {

  		var actions = this._actions,
  			lastInactiveAction = actions[ actions.length - 1 ],
  			cacheIndex = action._cacheIndex;

  		lastInactiveAction._cacheIndex = cacheIndex;
  		actions[ cacheIndex ] = lastInactiveAction;
  		actions.pop();

  		action._cacheIndex = null;


  		var clipUuid = action._clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ],
  			knownActionsForClip = actionsForClip.knownActions,

  			lastKnownAction =
  				knownActionsForClip[ knownActionsForClip.length - 1 ],

  			byClipCacheIndex = action._byClipCacheIndex;

  		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
  		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
  		knownActionsForClip.pop();

  		action._byClipCacheIndex = null;


  		var actionByRoot = actionsForClip.actionByRoot,
  			rootUuid = ( action._localRoot || this._root ).uuid;

  		delete actionByRoot[ rootUuid ];

  		if ( knownActionsForClip.length === 0 ) {

  			delete actionsByClip[ clipUuid ];

  		}

  		this._removeInactiveBindingsForAction( action );

  	},

  	_removeInactiveBindingsForAction: function ( action ) {

  		var bindings = action._propertyBindings;
  		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

  			var binding = bindings[ i ];

  			if ( -- binding.referenceCount === 0 ) {

  				this._removeInactiveBinding( binding );

  			}

  		}

  	},

  	_lendAction: function ( action ) {

  		// [ active actions |  inactive actions  ]
  		// [  active actions >| inactive actions ]
  		//                 s        a
  		//                  <-swap->
  		//                 a        s

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			lastActiveIndex = this._nActiveActions ++,

  			firstInactiveAction = actions[ lastActiveIndex ];

  		action._cacheIndex = lastActiveIndex;
  		actions[ lastActiveIndex ] = action;

  		firstInactiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = firstInactiveAction;

  	},

  	_takeBackAction: function ( action ) {

  		// [  active actions  | inactive actions ]
  		// [ active actions |< inactive actions  ]
  		//        a        s
  		//         <-swap->
  		//        s        a

  		var actions = this._actions,
  			prevIndex = action._cacheIndex,

  			firstInactiveIndex = -- this._nActiveActions,

  			lastActiveAction = actions[ firstInactiveIndex ];

  		action._cacheIndex = firstInactiveIndex;
  		actions[ firstInactiveIndex ] = action;

  		lastActiveAction._cacheIndex = prevIndex;
  		actions[ prevIndex ] = lastActiveAction;

  	},

  	// Memory management for PropertyMixer objects

  	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			bindings = this._bindings;

  		if ( bindingByName === undefined ) {

  			bindingByName = {};
  			bindingsByRoot[ rootUuid ] = bindingByName;

  		}

  		bindingByName[ trackName ] = binding;

  		binding._cacheIndex = bindings.length;
  		bindings.push( binding );

  	},

  	_removeInactiveBinding: function ( binding ) {

  		var bindings = this._bindings,
  			propBinding = binding.binding,
  			rootUuid = propBinding.rootNode.uuid,
  			trackName = propBinding.path,
  			bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ],

  			lastInactiveBinding = bindings[ bindings.length - 1 ],
  			cacheIndex = binding._cacheIndex;

  		lastInactiveBinding._cacheIndex = cacheIndex;
  		bindings[ cacheIndex ] = lastInactiveBinding;
  		bindings.pop();

  		delete bindingByName[ trackName ];

  		remove_empty_map: {

  			for ( var _ in bindingByName ) break remove_empty_map;

  			delete bindingsByRoot[ rootUuid ];

  		}

  	},

  	_lendBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			lastActiveIndex = this._nActiveBindings ++,

  			firstInactiveBinding = bindings[ lastActiveIndex ];

  		binding._cacheIndex = lastActiveIndex;
  		bindings[ lastActiveIndex ] = binding;

  		firstInactiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = firstInactiveBinding;

  	},

  	_takeBackBinding: function ( binding ) {

  		var bindings = this._bindings,
  			prevIndex = binding._cacheIndex,

  			firstInactiveIndex = -- this._nActiveBindings,

  			lastActiveBinding = bindings[ firstInactiveIndex ];

  		binding._cacheIndex = firstInactiveIndex;
  		bindings[ firstInactiveIndex ] = binding;

  		lastActiveBinding._cacheIndex = prevIndex;
  		bindings[ prevIndex ] = lastActiveBinding;

  	},


  	// Memory management of Interpolants for weight and time scale

  	_lendControlInterpolant: function () {

  		var interpolants = this._controlInterpolants,
  			lastActiveIndex = this._nActiveControlInterpolants ++,
  			interpolant = interpolants[ lastActiveIndex ];

  		if ( interpolant === undefined ) {

  			interpolant = new LinearInterpolant$1(
  				new Float32Array( 2 ), new Float32Array( 2 ),
  				1, this._controlInterpolantsResultBuffer );

  			interpolant.__cacheIndex = lastActiveIndex;
  			interpolants[ lastActiveIndex ] = interpolant;

  		}

  		return interpolant;

  	},

  	_takeBackControlInterpolant: function ( interpolant ) {

  		var interpolants = this._controlInterpolants,
  			prevIndex = interpolant.__cacheIndex,

  			firstInactiveIndex = -- this._nActiveControlInterpolants,

  			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

  		interpolant.__cacheIndex = firstInactiveIndex;
  		interpolants[ firstInactiveIndex ] = interpolant;

  		lastActiveInterpolant.__cacheIndex = prevIndex;
  		interpolants[ prevIndex ] = lastActiveInterpolant;

  	},

  	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

  	// return an action for a clip optionally using a custom root target
  	// object (this method allocates a lot of dynamic memory in case a
  	// previously unknown clip/root combination is specified)
  	clipAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip$1.findByName( root, clip ) : clip,

  			clipUuid = clipObject !== null ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ],
  			prototypeAction = null;

  		if ( actionsForClip !== undefined ) {

  			var existingAction =
  					actionsForClip.actionByRoot[ rootUuid ];

  			if ( existingAction !== undefined ) {

  				return existingAction;

  			}

  			// we know the clip, so we don't have to parse all
  			// the bindings again but can just copy
  			prototypeAction = actionsForClip.knownActions[ 0 ];

  			// also, take the clip from the prototype action
  			if ( clipObject === null )
  				clipObject = prototypeAction._clip;

  		}

  		// clip must be known when specified via string
  		if ( clipObject === null ) return null;

  		// allocate all resources required to run it
  		var newAction = new AnimationAction$1( this, clipObject, optionalRoot );

  		this._bindAction( newAction, prototypeAction );

  		// and make the action known to the memory manager
  		this._addInactiveAction( newAction, clipUuid, rootUuid );

  		return newAction;

  	},

  	// get an existing action
  	existingAction: function ( clip, optionalRoot ) {

  		var root = optionalRoot || this._root,
  			rootUuid = root.uuid,

  			clipObject = typeof clip === 'string' ?
  				AnimationClip$1.findByName( root, clip ) : clip,

  			clipUuid = clipObject ? clipObject.uuid : clip,

  			actionsForClip = this._actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			return actionsForClip.actionByRoot[ rootUuid ] || null;

  		}

  		return null;

  	},

  	// deactivates all previously scheduled actions
  	stopAllAction: function () {

  		var actions = this._actions,
  			nActions = this._nActiveActions,
  			bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		this._nActiveActions = 0;
  		this._nActiveBindings = 0;

  		for ( var i = 0; i !== nActions; ++ i ) {

  			actions[ i ].reset();

  		}

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].useCount = 0;

  		}

  		return this;

  	},

  	// advance the time and update apply the animation
  	update: function ( deltaTime ) {

  		deltaTime *= this.timeScale;

  		var actions = this._actions,
  			nActions = this._nActiveActions,

  			time = this.time += deltaTime,
  			timeDirection = Math.sign( deltaTime ),

  			accuIndex = this._accuIndex ^= 1;

  		// run active actions

  		for ( var i = 0; i !== nActions; ++ i ) {

  			var action = actions[ i ];

  			action._update( time, deltaTime, timeDirection, accuIndex );

  		}

  		// update scene graph

  		var bindings = this._bindings,
  			nBindings = this._nActiveBindings;

  		for ( var i = 0; i !== nBindings; ++ i ) {

  			bindings[ i ].apply( accuIndex );

  		}

  		return this;

  	},

  	// return this mixer's root target object
  	getRoot: function () {

  		return this._root;

  	},

  	// free all resources specific to a particular clip
  	uncacheClip: function ( clip ) {

  		var actions = this._actions,
  			clipUuid = clip.uuid,
  			actionsByClip = this._actionsByClip,
  			actionsForClip = actionsByClip[ clipUuid ];

  		if ( actionsForClip !== undefined ) {

  			// note: just calling _removeInactiveAction would mess up the
  			// iteration state and also require updating the state we can
  			// just throw away

  			var actionsToRemove = actionsForClip.knownActions;

  			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

  				var action = actionsToRemove[ i ];

  				this._deactivateAction( action );

  				var cacheIndex = action._cacheIndex,
  					lastInactiveAction = actions[ actions.length - 1 ];

  				action._cacheIndex = null;
  				action._byClipCacheIndex = null;

  				lastInactiveAction._cacheIndex = cacheIndex;
  				actions[ cacheIndex ] = lastInactiveAction;
  				actions.pop();

  				this._removeInactiveBindingsForAction( action );

  			}

  			delete actionsByClip[ clipUuid ];

  		}

  	},

  	// free all resources specific to a particular root target object
  	uncacheRoot: function ( root ) {

  		var rootUuid = root.uuid,
  			actionsByClip = this._actionsByClip;

  		for ( var clipUuid in actionsByClip ) {

  			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
  				action = actionByRoot[ rootUuid ];

  			if ( action !== undefined ) {

  				this._deactivateAction( action );
  				this._removeInactiveAction( action );

  			}

  		}

  		var bindingsByRoot = this._bindingsByRootAndName,
  			bindingByName = bindingsByRoot[ rootUuid ];

  		if ( bindingByName !== undefined ) {

  			for ( var trackName in bindingByName ) {

  				var binding = bindingByName[ trackName ];
  				binding.restoreOriginalState();
  				this._removeInactiveBinding( binding );

  			}

  		}

  	},

  	// remove a targeted clip from the cache
  	uncacheAction: function ( clip, optionalRoot ) {

  		var action = this.existingAction( clip, optionalRoot );

  		if ( action !== null ) {

  			this._deactivateAction( action );
  			this._removeInactiveAction( action );

  		}

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function Uniform$1( value ) {

  	if ( typeof value === 'string' ) {

  		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
  		value = arguments[ 1 ];

  	}

  	this.value = value;

  }

  Uniform$1.prototype.clone = function () {

  	return new Uniform$1( this.value.clone === undefined ? this.value : this.value.clone() );

  };

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferGeometry$1() {

  	BufferGeometry$1.call( this );

  	this.type = 'InstancedBufferGeometry';
  	this.maxInstancedCount = undefined;

  }

  InstancedBufferGeometry$1.prototype = Object.assign( Object.create( BufferGeometry$1.prototype ), {

  	constructor: InstancedBufferGeometry$1,

  	isInstancedBufferGeometry: true,

  	addGroup: function ( start, count, materialIndex ) {

  		this.groups.push( {

  			start: start,
  			count: count,
  			materialIndex: materialIndex

  		} );

  	},

  	copy: function ( source ) {

  		var index = source.index;

  		if ( index !== null ) {

  			this.setIndex( index.clone() );

  		}

  		var attributes = source.attributes;

  		for ( var name in attributes ) {

  			var attribute = attributes[ name ];
  			this.addAttribute( name, attribute.clone() );

  		}

  		var groups = source.groups;

  		for ( var i = 0, l = groups.length; i < l; i ++ ) {

  			var group = groups[ i ];
  			this.addGroup( group.start, group.count, group.materialIndex );

  		}

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBufferAttribute$1( interleavedBuffer, itemSize, offset, normalized ) {

  	this.uuid = _Math$1.generateUUID();

  	this.data = interleavedBuffer;
  	this.itemSize = itemSize;
  	this.offset = offset;

  	this.normalized = normalized === true;

  }

  Object.defineProperties( InterleavedBufferAttribute$1.prototype, {

  	count: {

  		get: function () {

  			return this.data.count;

  		}

  	},

  	array: {

  		get: function () {

  			return this.data.array;

  		}

  	}

  } );

  Object.assign( InterleavedBufferAttribute$1.prototype, {

  	isInterleavedBufferAttribute: true,

  	setX: function ( index, x ) {

  		this.data.array[ index * this.data.stride + this.offset ] = x;

  		return this;

  	},

  	setY: function ( index, y ) {

  		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

  		return this;

  	},

  	setZ: function ( index, z ) {

  		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

  		return this;

  	},

  	setW: function ( index, w ) {

  		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

  		return this;

  	},

  	getX: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset ];

  	},

  	getY: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 1 ];

  	},

  	getZ: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 2 ];

  	},

  	getW: function ( index ) {

  		return this.data.array[ index * this.data.stride + this.offset + 3 ];

  	},

  	setXY: function ( index, x, y ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;

  		return this;

  	},

  	setXYZ: function ( index, x, y, z ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;

  		return this;

  	},

  	setXYZW: function ( index, x, y, z, w ) {

  		index = index * this.data.stride + this.offset;

  		this.data.array[ index + 0 ] = x;
  		this.data.array[ index + 1 ] = y;
  		this.data.array[ index + 2 ] = z;
  		this.data.array[ index + 3 ] = w;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InterleavedBuffer$1( array, stride ) {

  	this.uuid = _Math$1.generateUUID();

  	this.array = array;
  	this.stride = stride;
  	this.count = array !== undefined ? array.length / stride : 0;

  	this.dynamic = false;
  	this.updateRange = { offset: 0, count: - 1 };

  	this.onUploadCallback = function () {};

  	this.version = 0;

  }

  Object.defineProperty( InterleavedBuffer$1.prototype, 'needsUpdate', {

  	set: function ( value ) {

  		if ( value === true ) this.version ++;

  	}

  } );

  Object.assign( InterleavedBuffer$1.prototype, {

  	isInterleavedBuffer: true,

  	setArray: function ( array ) {

  		if ( Array.isArray( array ) ) {

  			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

  		}

  		this.count = array !== undefined ? array.length / this.stride : 0;
  		this.array = array;

  	},

  	setDynamic: function ( value ) {

  		this.dynamic = value;

  		return this;

  	},

  	copy: function ( source ) {

  		this.array = new source.array.constructor( source.array );
  		this.count = source.count;
  		this.stride = source.stride;
  		this.dynamic = source.dynamic;

  		return this;

  	},

  	copyAt: function ( index1, attribute, index2 ) {

  		index1 *= this.stride;
  		index2 *= attribute.stride;

  		for ( var i = 0, l = this.stride; i < l; i ++ ) {

  			this.array[ index1 + i ] = attribute.array[ index2 + i ];

  		}

  		return this;

  	},

  	set: function ( value, offset ) {

  		if ( offset === undefined ) offset = 0;

  		this.array.set( value, offset );

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	onUpload: function ( callback ) {

  		this.onUploadCallback = callback;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedInterleavedBuffer$1( array, stride, meshPerAttribute ) {

  	InterleavedBuffer$1.call( this, array, stride );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedInterleavedBuffer$1.prototype = Object.assign( Object.create( InterleavedBuffer$1.prototype ), {

  	constructor: InstancedInterleavedBuffer$1,

  	isInstancedInterleavedBuffer: true,

  	copy: function ( source ) {

  		InterleavedBuffer$1.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  /**
   * @author benaadams / https://twitter.com/ben_a_adams
   */

  function InstancedBufferAttribute$1( array, itemSize, meshPerAttribute ) {

  	BufferAttribute$1.call( this, array, itemSize );

  	this.meshPerAttribute = meshPerAttribute || 1;

  }

  InstancedBufferAttribute$1.prototype = Object.assign( Object.create( BufferAttribute$1.prototype ), {

  	constructor: InstancedBufferAttribute$1,

  	isInstancedBufferAttribute: true,

  	copy: function ( source ) {

  		BufferAttribute$1.prototype.copy.call( this, source );

  		this.meshPerAttribute = source.meshPerAttribute;

  		return this;

  	}

  } );

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author bhouston / http://clara.io/
   * @author stephomi / http://stephaneginier.com/
   */

  function Raycaster$1( origin, direction, near, far ) {

  	this.ray = new Ray$1( origin, direction );
  	// direction is assumed to be normalized (for accurate distance calculations)

  	this.near = near || 0;
  	this.far = far || Infinity;

  	this.params = {
  		Mesh: {},
  		Line: {},
  		LOD: {},
  		Points: { threshold: 1 },
  		Sprite: {}
  	};

  	Object.defineProperties( this.params, {
  		PointCloud: {
  			get: function () {
  				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
  				return this.Points;
  			}
  		}
  	} );

  }

  function ascSort$1( a, b ) {

  	return a.distance - b.distance;

  }

  function intersectObject$1( object, raycaster, intersects, recursive ) {

  	if ( object.visible === false ) return;

  	object.raycast( raycaster, intersects );

  	if ( recursive === true ) {

  		var children = object.children;

  		for ( var i = 0, l = children.length; i < l; i ++ ) {

  			intersectObject$1( children[ i ], raycaster, intersects, true );

  		}

  	}

  }

  Object.assign( Raycaster$1.prototype, {

  	linePrecision: 1,

  	set: function ( origin, direction ) {

  		// direction is assumed to be normalized (for accurate distance calculations)

  		this.ray.set( origin, direction );

  	},

  	setFromCamera: function ( coords, camera ) {

  		if ( ( camera && camera.isPerspectiveCamera ) ) {

  			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
  			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

  		} else if ( ( camera && camera.isOrthographicCamera ) ) {

  			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
  			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

  		} else {

  			console.error( 'THREE.Raycaster: Unsupported camera type.' );

  		}

  	},

  	intersectObject: function ( object, recursive ) {

  		var intersects = [];

  		intersectObject$1( object, this, intersects, recursive );

  		intersects.sort( ascSort$1 );

  		return intersects;

  	},

  	intersectObjects: function ( objects, recursive ) {

  		var intersects = [];

  		if ( Array.isArray( objects ) === false ) {

  			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
  			return intersects;

  		}

  		for ( var i = 0, l = objects.length; i < l; i ++ ) {

  			intersectObject$1( objects[ i ], this, intersects, recursive );

  		}

  		intersects.sort( ascSort$1 );

  		return intersects;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function Clock$1( autoStart ) {

  	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  	this.startTime = 0;
  	this.oldTime = 0;
  	this.elapsedTime = 0;

  	this.running = false;

  }

  Object.assign( Clock$1.prototype, {

  	start: function () {

  		this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

  		this.oldTime = this.startTime;
  		this.elapsedTime = 0;
  		this.running = true;

  	},

  	stop: function () {

  		this.getElapsedTime();
  		this.running = false;

  	},

  	getElapsedTime: function () {

  		this.getDelta();
  		return this.elapsedTime;

  	},

  	getDelta: function () {

  		var diff = 0;

  		if ( this.autoStart && ! this.running ) {

  			this.start();
  			return 0;

  		}

  		if ( this.running ) {

  			var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

  			diff = ( newTime - this.oldTime ) / 1000;
  			this.oldTime = newTime;

  			this.elapsedTime += diff;

  		}

  		return diff;

  	}

  } );

  /**
   * @author bhouston / http://clara.io
   * @author WestLangley / http://github.com/WestLangley
   *
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * The poles (phi) are at the positive and negative y axis.
   * The equator starts at positive z.
   */

  function Spherical$1( radius, phi, theta ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0;
  	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
  	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

  	return this;

  }

  Object.assign( Spherical$1.prototype, {

  	set: function ( radius, phi, theta ) {

  		this.radius = radius;
  		this.phi = phi;
  		this.theta = theta;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.phi = other.phi;
  		this.theta = other.theta;

  		return this;

  	},

  	// restrict phi to be betwee EPS and PI-EPS
  	makeSafe: function() {

  		var EPS = 0.000001;
  		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

  		return this;

  	},

  	setFromVector3: function( vec3 ) {

  		this.radius = vec3.length();

  		if ( this.radius === 0 ) {

  			this.theta = 0;
  			this.phi = 0;

  		} else {

  			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
  			this.phi = Math.acos( _Math$1.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

  		}

  		return this;

  	}

  } );

  /**
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   *
   */

  function Cylindrical$1( radius, theta, y ) {

  	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
  	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
  	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

  	return this;

  }

  Object.assign( Cylindrical$1.prototype, {

  	set: function ( radius, theta, y ) {

  		this.radius = radius;
  		this.theta = theta;
  		this.y = y;

  		return this;

  	},

  	clone: function () {

  		return new this.constructor().copy( this );

  	},

  	copy: function ( other ) {

  		this.radius = other.radius;
  		this.theta = other.theta;
  		this.y = other.y;

  		return this;

  	},

  	setFromVector3: function( vec3 ) {

  		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
  		this.theta = Math.atan2( vec3.x, vec3.z );
  		this.y = vec3.y;

  		return this;

  	}

  } );

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function MorphBlendMesh( geometry, material ) {

  	Mesh$1.call( this, geometry, material );

  	this.animationsMap = {};
  	this.animationsList = [];

  	// prepare default animation
  	// (all frames played together in 1 second)

  	var numFrames = this.geometry.morphTargets.length;

  	var name = "__default";

  	var startFrame = 0;
  	var endFrame = numFrames - 1;

  	var fps = numFrames / 1;

  	this.createAnimation( name, startFrame, endFrame, fps );
  	this.setAnimationWeight( name, 1 );

  }

  MorphBlendMesh.prototype = Object.create( Mesh$1.prototype );
  MorphBlendMesh.prototype.constructor = MorphBlendMesh;

  MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  	var animation = {

  		start: start,
  		end: end,

  		length: end - start + 1,

  		fps: fps,
  		duration: ( end - start ) / fps,

  		lastFrame: 0,
  		currentFrame: 0,

  		active: false,

  		time: 0,
  		direction: 1,
  		weight: 1,

  		directionBackwards: false,
  		mirroredLoop: false

  	};

  	this.animationsMap[ name ] = animation;
  	this.animationsList.push( animation );

  };

  MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  	var pattern = /([a-z]+)_?(\d+)/i;

  	var firstAnimation, frameRanges = {};

  	var geometry = this.geometry;

  	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

  		var morph = geometry.morphTargets[ i ];
  		var chunks = morph.name.match( pattern );

  		if ( chunks && chunks.length > 1 ) {

  			var name = chunks[ 1 ];

  			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

  			var range = frameRanges[ name ];

  			if ( i < range.start ) range.start = i;
  			if ( i > range.end ) range.end = i;

  			if ( ! firstAnimation ) firstAnimation = name;

  		}

  	}

  	for ( var name in frameRanges ) {

  		var range = frameRanges[ name ];
  		this.createAnimation( name, range.start, range.end, fps );

  	}

  	this.firstAnimation = firstAnimation;

  };

  MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.direction = 1;
  		animation.directionBackwards = false;

  	}

  };

  MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.direction = - 1;
  		animation.directionBackwards = true;

  	}

  };

  MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.fps = fps;
  		animation.duration = ( animation.end - animation.start ) / animation.fps;

  	}

  };

  MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.duration = duration;
  		animation.fps = ( animation.end - animation.start ) / animation.duration;

  	}

  };

  MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.weight = weight;

  	}

  };

  MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.time = time;

  	}

  };

  MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  	var time = 0;

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		time = animation.time;

  	}

  	return time;

  };

  MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  	var duration = - 1;

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		duration = animation.duration;

  	}

  	return duration;

  };

  MorphBlendMesh.prototype.playAnimation = function ( name ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.time = 0;
  		animation.active = true;

  	} else {

  		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  	}

  };

  MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  	var animation = this.animationsMap[ name ];

  	if ( animation ) {

  		animation.active = false;

  	}

  };

  MorphBlendMesh.prototype.update = function ( delta ) {

  	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

  		var animation = this.animationsList[ i ];

  		if ( ! animation.active ) continue;

  		var frameTime = animation.duration / animation.length;

  		animation.time += animation.direction * delta;

  		if ( animation.mirroredLoop ) {

  			if ( animation.time > animation.duration || animation.time < 0 ) {

  				animation.direction *= - 1;

  				if ( animation.time > animation.duration ) {

  					animation.time = animation.duration;
  					animation.directionBackwards = true;

  				}

  				if ( animation.time < 0 ) {

  					animation.time = 0;
  					animation.directionBackwards = false;

  				}

  			}

  		} else {

  			animation.time = animation.time % animation.duration;

  			if ( animation.time < 0 ) animation.time += animation.duration;

  		}

  		var keyframe = animation.start + _Math$1.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
  		var weight = animation.weight;

  		if ( keyframe !== animation.currentFrame ) {

  			this.morphTargetInfluences[ animation.lastFrame ] = 0;
  			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

  			this.morphTargetInfluences[ keyframe ] = 0;

  			animation.lastFrame = animation.currentFrame;
  			animation.currentFrame = keyframe;

  		}

  		var mix = ( animation.time % frameTime ) / frameTime;

  		if ( animation.directionBackwards ) mix = 1 - mix;

  		if ( animation.currentFrame !== animation.lastFrame ) {

  			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
  			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

  		} else {

  			this.morphTargetInfluences[ animation.currentFrame ] = weight;

  		}

  	}

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   */

  function ImmediateRenderObject$1( material ) {

  	Object3D$1.call( this );

  	this.material = material;
  	this.render = function ( renderCallback ) {};

  }

  ImmediateRenderObject$1.prototype = Object.create( Object3D$1.prototype );
  ImmediateRenderObject$1.prototype.constructor = ImmediateRenderObject$1;

  ImmediateRenderObject$1.prototype.isImmediateRenderObject = true;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
  */

  function VertexNormalsHelper$1( object, size, hex, linewidth ) {

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xff0000;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length * 3;

  	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  		nNormals = objGeometry.attributes.normal.count;

  	}

  	//

  	var geometry = new BufferGeometry$1();

  	var positions = new Float32BufferAttribute$1( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  VertexNormalsHelper$1.prototype = Object.create( LineSegments$1.prototype );
  VertexNormalsHelper$1.prototype.constructor = VertexNormalsHelper$1;

  VertexNormalsHelper$1.prototype.update = ( function () {

  	var v1 = new Vector3$1();
  	var v2 = new Vector3$1();
  	var normalMatrix = new Matrix3$1();

  	return function update() {

  		var keys = [ 'a', 'b', 'c' ];

  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		if ( objGeometry && objGeometry.isGeometry ) {

  			var vertices = objGeometry.vertices;

  			var faces = objGeometry.faces;

  			var idx = 0;

  			for ( var i = 0, l = faces.length; i < l; i ++ ) {

  				var face = faces[ i ];

  				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

  					var vertex = vertices[ face[ keys[ j ] ] ];

  					var normal = face.vertexNormals[ j ];

  					v1.copy( vertex ).applyMatrix4( matrixWorld );

  					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  					position.setXYZ( idx, v1.x, v1.y, v1.z );

  					idx = idx + 1;

  					position.setXYZ( idx, v2.x, v2.y, v2.z );

  					idx = idx + 1;

  				}

  			}

  		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

  			var objPos = objGeometry.attributes.position;

  			var objNorm = objGeometry.attributes.normal;

  			var idx = 0;

  			// for simplicity, ignore index and drawcalls, and render every normal

  			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

  				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

  				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

  				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  				position.setXYZ( idx, v1.x, v1.y, v1.z );

  				idx = idx + 1;

  				position.setXYZ( idx, v2.x, v2.y, v2.z );

  				idx = idx + 1;

  			}

  		}

  		position.needsUpdate = true;

  	};

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
  */

  function SpotLightHelper$1( light ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	var geometry = new BufferGeometry$1();

  	var positions = [
  		0, 0, 0,   0,   0,   1,
  		0, 0, 0,   1,   0,   1,
  		0, 0, 0, - 1,   0,   1,
  		0, 0, 0,   0,   1,   1,
  		0, 0, 0,   0, - 1,   1
  	];

  	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

  		var p1 = ( i / l ) * Math.PI * 2;
  		var p2 = ( j / l ) * Math.PI * 2;

  		positions.push(
  			Math.cos( p1 ), Math.sin( p1 ), 1,
  			Math.cos( p2 ), Math.sin( p2 ), 1
  		);

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( positions, 3 ) );

  	var material = new LineBasicMaterial$1( { fog: false } );

  	this.cone = new LineSegments$1( geometry, material );
  	this.add( this.cone );

  	this.update();

  }

  SpotLightHelper$1.prototype = Object.create( Object3D$1.prototype );
  SpotLightHelper$1.prototype.constructor = SpotLightHelper$1;

  SpotLightHelper$1.prototype.dispose = function () {

  	this.cone.geometry.dispose();
  	this.cone.material.dispose();

  };

  SpotLightHelper$1.prototype.update = function () {

  	var vector = new Vector3$1();
  	var vector2 = new Vector3$1();

  	return function update() {

  		var coneLength = this.light.distance ? this.light.distance : 1000;
  		var coneWidth = coneLength * Math.tan( this.light.angle );

  		this.cone.scale.set( coneWidth, coneWidth, coneLength );

  		vector.setFromMatrixPosition( this.light.matrixWorld );
  		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

  		this.cone.lookAt( vector2.sub( vector ) );

  		this.cone.material.color.copy( this.light.color );

  	};

  }();

  /**
   * @author Sean Griffin / http://twitter.com/sgrif
   * @author Michael Guerrero / http://realitymeltdown.com
   * @author mrdoob / http://mrdoob.com/
   * @author ikerr / http://verold.com
   * @author Mugen87 / https://github.com/Mugen87
   */

  function SkeletonHelper$1( object ) {

  	this.bones = this.getBoneList( object );

  	var geometry = new BufferGeometry$1();

  	var vertices = [];
  	var colors = [];

  	var color1 = new Color$1( 0, 0, 1 );
  	var color2 = new Color$1( 0, 1, 0 );

  	for ( var i = 0; i < this.bones.length; i ++ ) {

  		var bone = this.bones[ i ];

  		if ( bone.parent && bone.parent.isBone ) {

  			vertices.push( 0, 0, 0 );
  			vertices.push( 0, 0, 0 );
  			colors.push( color1.r, color1.g, color1.b );
  			colors.push( color2.r, color2.g, color2.b );

  		}

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1, depthTest: false, depthWrite: false, transparent: true } );

  	LineSegments$1.call( this, geometry, material );

  	this.root = object;

  	this.matrix = object.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.update();

  }


  SkeletonHelper$1.prototype = Object.create( LineSegments$1.prototype );
  SkeletonHelper$1.prototype.constructor = SkeletonHelper$1;

  SkeletonHelper$1.prototype.getBoneList = function( object ) {

  	var boneList = [];

  	if ( object && object.isBone ) {

  		boneList.push( object );

  	}

  	for ( var i = 0; i < object.children.length; i ++ ) {

  		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  	}

  	return boneList;

  };

  SkeletonHelper$1.prototype.update = function () {

  	var vector = new Vector3$1();

  	var boneMatrix = new Matrix4$1();
  	var matrixWorldInv = new Matrix4$1();

  	return function update() {

  		var geometry = this.geometry;
  		var position = geometry.getAttribute( 'position' );

  		matrixWorldInv.getInverse( this.root.matrixWorld );

  		for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {

  			var bone = this.bones[ i ];

  			if ( bone.parent && bone.parent.isBone ) {

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j, vector.x, vector.y, vector.z );

  				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
  				vector.setFromMatrixPosition( boneMatrix );
  				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

  				j += 2;

  			}

  		}

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  	};

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   */

  function PointLightHelper$1( light, sphereSize ) {

  	this.light = light;
  	this.light.updateMatrixWorld();

  	var geometry = new SphereBufferGeometry$1( sphereSize, 4, 2 );
  	var material = new MeshBasicMaterial$1( { wireframe: true, fog: false } );
  	material.color.copy( this.light.color );

  	Mesh$1.call( this, geometry, material );

  	this.matrix = this.light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	/*
  	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  	var d = light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.scale.set( d, d, d );

  	}

  	this.add( this.lightDistance );
  	*/

  }

  PointLightHelper$1.prototype = Object.create( Mesh$1.prototype );
  PointLightHelper$1.prototype.constructor = PointLightHelper$1;

  PointLightHelper$1.prototype.dispose = function () {

  	this.geometry.dispose();
  	this.material.dispose();

  };

  PointLightHelper$1.prototype.update = function () {

  	this.material.color.copy( this.light.color );

  	/*
  	var d = this.light.distance;

  	if ( d === 0.0 ) {

  		this.lightDistance.visible = false;

  	} else {

  		this.lightDistance.visible = true;
  		this.lightDistance.scale.set( d, d, d );

  	}
  	*/

  };

  /**
   * @author abelnation / http://github.com/abelnation
   * @author Mugen87 / http://github.com/Mugen87
   * @author WestLangley / http://github.com/WestLangley
   */

  function RectAreaLightHelper$1( light ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	var material = new LineBasicMaterial$1( { color: light.color } );

  	var geometry = new BufferGeometry$1();

  	geometry.addAttribute( 'position', new BufferAttribute$1( new Float32Array( 5 * 3 ), 3 ) );

  	this.add( new Line$2( geometry, material ) );

  	this.update();

  }

  RectAreaLightHelper$1.prototype = Object.create( Object3D$1.prototype );
  RectAreaLightHelper$1.prototype.constructor = RectAreaLightHelper$1;

  RectAreaLightHelper$1.prototype.dispose = function () {

  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  RectAreaLightHelper$1.prototype.update = function () {

  	var line = this.children[ 0 ];

  	// update material

  	line.material.color.copy( this.light.color );

  	// calculate new dimensions of the helper

  	var hx = this.light.width * 0.5;
  	var hy = this.light.height * 0.5;

  	var position = line.geometry.attributes.position;
  	var array = position.array;

  	// update vertices

  	array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
  	array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
  	array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;
  	array[  9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
  	array[ 12 ] =   hx; array[ 13 ] = - hy; array[ 14 ] = 0;

  	position.needsUpdate = true;

  };

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / https://github.com/Mugen87
   */

  function HemisphereLightHelper$1( light, size ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	var geometry = new OctahedronBufferGeometry$1( size );
  	geometry.rotateY( Math.PI * 0.5 );

  	var material = new MeshBasicMaterial$1( { vertexColors: VertexColors$1, wireframe: true } );

  	var position = geometry.getAttribute( 'position' );
  	var colors = new Float32Array( position.count * 3 );

  	geometry.addAttribute( 'color', new BufferAttribute$1( colors, 3 ) );

  	this.add( new Mesh$1( geometry, material ) );

  	this.update();

  }

  HemisphereLightHelper$1.prototype = Object.create( Object3D$1.prototype );
  HemisphereLightHelper$1.prototype.constructor = HemisphereLightHelper$1;

  HemisphereLightHelper$1.prototype.dispose = function () {

  	this.children[ 0 ].geometry.dispose();
  	this.children[ 0 ].material.dispose();

  };

  HemisphereLightHelper$1.prototype.update = function () {

  	var vector = new Vector3$1();

  	var color1 = new Color$1();
  	var color2 = new Color$1();

  	return function update() {

  		var mesh = this.children[ 0 ];

  		var colors = mesh.geometry.getAttribute( 'color' );

  		color1.copy( this.light.color );
  		color2.copy( this.light.groundColor );

  		for ( var i = 0, l = colors.count; i < l; i ++ ) {

  			var color = ( i < ( l / 2 ) ) ? color1 : color2;

  			colors.setXYZ( i, color.r, color.g, color.b );

  		}

  		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

  		colors.needsUpdate = true;

  	};

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   */

  function GridHelper$1( size, divisions, color1, color2 ) {

  	size = size || 10;
  	divisions = divisions || 10;
  	color1 = new Color$1( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color$1( color2 !== undefined ? color2 : 0x888888 );

  	var center = divisions / 2;
  	var step = size / divisions;
  	var halfSize = size / 2;

  	var vertices = [], colors = [];

  	for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

  		vertices.push( - halfSize, 0, k, halfSize, 0, k );
  		vertices.push( k, 0, - halfSize, k, 0, halfSize );

  		var color = i === center ? color1 : color2;

  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;
  		color.toArray( colors, j ); j += 3;

  	}

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  GridHelper$1.prototype = Object.create( LineSegments$1.prototype );
  GridHelper$1.prototype.constructor = GridHelper$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   * @author Hectate / http://www.github.com/Hectate
   */

  function PolarGridHelper$1( radius, radials, circles, divisions, color1, color2 ) {

  	radius = radius || 10;
  	radials = radials || 16;
  	circles = circles || 8;
  	divisions = divisions || 64;
  	color1 = new Color$1( color1 !== undefined ? color1 : 0x444444 );
  	color2 = new Color$1( color2 !== undefined ? color2 : 0x888888 );

  	var vertices = [];
  	var colors = [];

  	var x, z;
  	var v, i, j, r, color;

  	// create the radials

  	for ( i = 0; i <= radials; i ++ ) {

  		v = ( i / radials ) * ( Math.PI * 2 );

  		x = Math.sin( v ) * radius;
  		z = Math.cos( v ) * radius;

  		vertices.push( 0, 0, 0 );
  		vertices.push( x, 0, z );

  		color = ( i & 1 ) ? color1 : color2;

  		colors.push( color.r, color.g, color.b );
  		colors.push( color.r, color.g, color.b );

  	}

  	// create the circles

  	for ( i = 0; i <= circles; i ++ ) {

  		color = ( i & 1 ) ? color1 : color2;

  		r = radius - ( radius / circles * i );

  		for ( j = 0; j < divisions; j ++ ) {

  			// first vertex

  			v = ( j / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  			// second vertex

  			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

  			x = Math.sin( v ) * r;
  			z = Math.cos( v ) * r;

  			vertices.push( x, 0, z );
  			colors.push( color.r, color.g, color.b );

  		}

  	}

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  PolarGridHelper$1.prototype = Object.create( LineSegments$1.prototype );
  PolarGridHelper$1.prototype.constructor = PolarGridHelper$1;

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
  */

  function FaceNormalsHelper$1( object, size, hex, linewidth ) {

  	// FaceNormalsHelper only supports THREE.Geometry

  	this.object = object;

  	this.size = ( size !== undefined ) ? size : 1;

  	var color = ( hex !== undefined ) ? hex : 0xffff00;

  	var width = ( linewidth !== undefined ) ? linewidth : 1;

  	//

  	var nNormals = 0;

  	var objGeometry = this.object.geometry;

  	if ( objGeometry && objGeometry.isGeometry ) {

  		nNormals = objGeometry.faces.length;

  	} else {

  		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

  	}

  	//

  	var geometry = new BufferGeometry$1();

  	var positions = new Float32BufferAttribute$1( nNormals * 2 * 3, 3 );

  	geometry.addAttribute( 'position', positions );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color, linewidth: width } ) );

  	//

  	this.matrixAutoUpdate = false;
  	this.update();

  }

  FaceNormalsHelper$1.prototype = Object.create( LineSegments$1.prototype );
  FaceNormalsHelper$1.prototype.constructor = FaceNormalsHelper$1;

  FaceNormalsHelper$1.prototype.update = ( function () {

  	var v1 = new Vector3$1();
  	var v2 = new Vector3$1();
  	var normalMatrix = new Matrix3$1();

  	return function update() {

  		this.object.updateMatrixWorld( true );

  		normalMatrix.getNormalMatrix( this.object.matrixWorld );

  		var matrixWorld = this.object.matrixWorld;

  		var position = this.geometry.attributes.position;

  		//

  		var objGeometry = this.object.geometry;

  		var vertices = objGeometry.vertices;

  		var faces = objGeometry.faces;

  		var idx = 0;

  		for ( var i = 0, l = faces.length; i < l; i ++ ) {

  			var face = faces[ i ];

  			var normal = face.normal;

  			v1.copy( vertices[ face.a ] )
  				.add( vertices[ face.b ] )
  				.add( vertices[ face.c ] )
  				.divideScalar( 3 )
  				.applyMatrix4( matrixWorld );

  			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

  			position.setXYZ( idx, v1.x, v1.y, v1.z );

  			idx = idx + 1;

  			position.setXYZ( idx, v2.x, v2.y, v2.z );

  			idx = idx + 1;

  		}

  		position.needsUpdate = true;

  	};

  }() );

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author mrdoob / http://mrdoob.com/
   * @author WestLangley / http://github.com/WestLangley
   */

  function DirectionalLightHelper$1( light, size ) {

  	Object3D$1.call( this );

  	this.light = light;
  	this.light.updateMatrixWorld();

  	this.matrix = light.matrixWorld;
  	this.matrixAutoUpdate = false;

  	if ( size === undefined ) size = 1;

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( [
  		- size,   size, 0,
  		  size,   size, 0,
  		  size, - size, 0,
  		- size, - size, 0,
  		- size,   size, 0
  	], 3 ) );

  	var material = new LineBasicMaterial$1( { fog: false } );

  	this.add( new Line$2( geometry, material ) );

  	geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

  	this.add( new Line$2( geometry, material ));

  	this.update();

  }

  DirectionalLightHelper$1.prototype = Object.create( Object3D$1.prototype );
  DirectionalLightHelper$1.prototype.constructor = DirectionalLightHelper$1;

  DirectionalLightHelper$1.prototype.dispose = function () {

  	var lightPlane = this.children[ 0 ];
  	var targetLine = this.children[ 1 ];

  	lightPlane.geometry.dispose();
  	lightPlane.material.dispose();
  	targetLine.geometry.dispose();
  	targetLine.material.dispose();

  };

  DirectionalLightHelper$1.prototype.update = function () {

  	var v1 = new Vector3$1();
  	var v2 = new Vector3$1();
  	var v3 = new Vector3$1();

  	return function update() {

  		v1.setFromMatrixPosition( this.light.matrixWorld );
  		v2.setFromMatrixPosition( this.light.target.matrixWorld );
  		v3.subVectors( v2, v1 );

  		var lightPlane = this.children[ 0 ];
  		var targetLine = this.children[ 1 ];

  		lightPlane.lookAt( v3 );
  		lightPlane.material.color.copy( this.light.color );

  		targetLine.lookAt( v3 );
  		targetLine.scale.z = v3.length();

  	};

  }();

  /**
   * @author alteredq / http://alteredqualia.com/
   * @author Mugen87 / https://github.com/Mugen87
   *
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
   */

  function CameraHelper$1( camera ) {

  	var geometry = new BufferGeometry$1();
  	var material = new LineBasicMaterial$1( { color: 0xffffff, vertexColors: FaceColors$1 } );

  	var vertices = [];
  	var colors = [];

  	var pointMap = {};

  	// colors

  	var colorFrustum = new Color$1( 0xffaa00 );
  	var colorCone = new Color$1( 0xff0000 );
  	var colorUp = new Color$1( 0x00aaff );
  	var colorTarget = new Color$1( 0xffffff );
  	var colorCross = new Color$1( 0x333333 );

  	// near

  	addLine( "n1", "n2", colorFrustum );
  	addLine( "n2", "n4", colorFrustum );
  	addLine( "n4", "n3", colorFrustum );
  	addLine( "n3", "n1", colorFrustum );

  	// far

  	addLine( "f1", "f2", colorFrustum );
  	addLine( "f2", "f4", colorFrustum );
  	addLine( "f4", "f3", colorFrustum );
  	addLine( "f3", "f1", colorFrustum );

  	// sides

  	addLine( "n1", "f1", colorFrustum );
  	addLine( "n2", "f2", colorFrustum );
  	addLine( "n3", "f3", colorFrustum );
  	addLine( "n4", "f4", colorFrustum );

  	// cone

  	addLine( "p", "n1", colorCone );
  	addLine( "p", "n2", colorCone );
  	addLine( "p", "n3", colorCone );
  	addLine( "p", "n4", colorCone );

  	// up

  	addLine( "u1", "u2", colorUp );
  	addLine( "u2", "u3", colorUp );
  	addLine( "u3", "u1", colorUp );

  	// target

  	addLine( "c", "t", colorTarget );
  	addLine( "p", "c", colorCross );

  	// cross

  	addLine( "cn1", "cn2", colorCross );
  	addLine( "cn3", "cn4", colorCross );

  	addLine( "cf1", "cf2", colorCross );
  	addLine( "cf3", "cf4", colorCross );

  	function addLine( a, b, color ) {

  		addPoint( a, color );
  		addPoint( b, color );

  	}

  	function addPoint( id, color ) {

  		vertices.push( 0, 0, 0 );
  		colors.push( color.r, color.g, color.b );

  		if ( pointMap[ id ] === undefined ) {

  			pointMap[ id ] = [];

  		}

  		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

  	}

  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	LineSegments$1.call( this, geometry, material );

  	this.camera = camera;
  	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

  	this.matrix = camera.matrixWorld;
  	this.matrixAutoUpdate = false;

  	this.pointMap = pointMap;

  	this.update();

  }

  CameraHelper$1.prototype = Object.create( LineSegments$1.prototype );
  CameraHelper$1.prototype.constructor = CameraHelper$1;

  CameraHelper$1.prototype.update = function () {

  	var geometry, pointMap;

  	var vector = new Vector3$1();
  	var camera = new Camera$1();

  	function setPoint( point, x, y, z ) {

  		vector.set( x, y, z ).unproject( camera );

  		var points = pointMap[ point ];

  		if ( points !== undefined ) {

  			var position = geometry.getAttribute( 'position' );

  			for ( var i = 0, l = points.length; i < l; i ++ ) {

  				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

  			}

  		}

  	}

  	return function update() {

  		geometry = this.geometry;
  		pointMap = this.pointMap;

  		var w = 1, h = 1;

  		// we need just camera projection matrix
  		// world matrix must be identity

  		camera.projectionMatrix.copy( this.camera.projectionMatrix );

  		// center / target

  		setPoint( "c", 0, 0, - 1 );
  		setPoint( "t", 0, 0,  1 );

  		// near

  		setPoint( "n1", - w, - h, - 1 );
  		setPoint( "n2",   w, - h, - 1 );
  		setPoint( "n3", - w,   h, - 1 );
  		setPoint( "n4",   w,   h, - 1 );

  		// far

  		setPoint( "f1", - w, - h, 1 );
  		setPoint( "f2",   w, - h, 1 );
  		setPoint( "f3", - w,   h, 1 );
  		setPoint( "f4",   w,   h, 1 );

  		// up

  		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
  		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
  		setPoint( "u3",         0, h * 2,   - 1 );

  		// cross

  		setPoint( "cf1", - w,   0, 1 );
  		setPoint( "cf2",   w,   0, 1 );
  		setPoint( "cf3",   0, - h, 1 );
  		setPoint( "cf4",   0,   h, 1 );

  		setPoint( "cn1", - w,   0, - 1 );
  		setPoint( "cn2",   w,   0, - 1 );
  		setPoint( "cn3",   0, - h, - 1 );
  		setPoint( "cn4",   0,   h, - 1 );

  		geometry.getAttribute( 'position' ).needsUpdate = true;

  	};

  }();

  /**
   * @author mrdoob / http://mrdoob.com/
   * @author Mugen87 / http://github.com/Mugen87
   */

  function BoxHelper$1( object, color ) {

  	this.object = object;

  	if ( color === undefined ) color = 0xffff00;

  	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  	var positions = new Float32Array( 8 * 3 );

  	var geometry = new BufferGeometry$1();
  	geometry.setIndex( new BufferAttribute$1( indices, 1 ) );
  	geometry.addAttribute( 'position', new BufferAttribute$1( positions, 3 ) );

  	LineSegments$1.call( this, geometry, new LineBasicMaterial$1( { color: color } ) );

  	this.matrixAutoUpdate = false;

  	this.update();

  }

  BoxHelper$1.prototype = Object.create( LineSegments$1.prototype );
  BoxHelper$1.prototype.constructor = BoxHelper$1;

  BoxHelper$1.prototype.update = ( function () {

  	var box = new Box3$1();

  	return function update( object ) {

  		if ( object !== undefined ) {

  			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

  		}

  		if ( this.object !== undefined ) {

  			box.setFromObject( this.object );

  		}

  		if ( box.isEmpty() ) return;

  		var min = box.min;
  		var max = box.max;

  		/*
  		  5____4
  		1/___0/|
  		| 6__|_7
  		2/___3/

  		0: max.x, max.y, max.z
  		1: min.x, max.y, max.z
  		2: min.x, min.y, max.z
  		3: max.x, min.y, max.z
  		4: max.x, max.y, min.z
  		5: min.x, max.y, min.z
  		6: min.x, min.y, min.z
  		7: max.x, min.y, min.z
  		*/

  		var position = this.geometry.attributes.position;
  		var array = position.array;

  		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
  		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
  		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
  		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
  		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
  		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
  		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
  		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

  		position.needsUpdate = true;

  		this.geometry.computeBoundingSphere();

  	};

  } )();

  BoxHelper$1.prototype.setFromObject = function ( object ) {

  	this.object = object;
  	this.update();

  	return this;

  };

  /**
   * @author WestLangley / http://github.com/WestLangley
   * @author zz85 / http://github.com/zz85
   * @author bhouston / http://clara.io
   *
   * Creates an arrow for visualizing directions
   *
   * Parameters:
   *  dir - Vector3
   *  origin - Vector3
   *  length - Number
   *  color - color in hex value
   *  headLength - Number
   *  headWidth - Number
   */

  var lineGeometry$1;
  var coneGeometry$1;

  function ArrowHelper$1( dir, origin, length, color, headLength, headWidth ) {

  	// dir is assumed to be normalized

  	Object3D$1.call( this );

  	if ( color === undefined ) color = 0xffff00;
  	if ( length === undefined ) length = 1;
  	if ( headLength === undefined ) headLength = 0.2 * length;
  	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  	if ( lineGeometry$1 === undefined ) {

  		lineGeometry$1 = new BufferGeometry$1();
  		lineGeometry$1.addAttribute( 'position', new Float32BufferAttribute$1( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

  		coneGeometry$1 = new CylinderBufferGeometry$1( 0, 0.5, 1, 5, 1 );
  		coneGeometry$1.translate( 0, - 0.5, 0 );

  	}

  	this.position.copy( origin );

  	this.line = new Line$2( lineGeometry$1, new LineBasicMaterial$1( { color: color } ) );
  	this.line.matrixAutoUpdate = false;
  	this.add( this.line );

  	this.cone = new Mesh$1( coneGeometry$1, new MeshBasicMaterial$1( { color: color } ) );
  	this.cone.matrixAutoUpdate = false;
  	this.add( this.cone );

  	this.setDirection( dir );
  	this.setLength( length, headLength, headWidth );

  }

  ArrowHelper$1.prototype = Object.create( Object3D$1.prototype );
  ArrowHelper$1.prototype.constructor = ArrowHelper$1;

  ArrowHelper$1.prototype.setDirection = ( function () {

  	var axis = new Vector3$1();
  	var radians;

  	return function setDirection( dir ) {

  		// dir is assumed to be normalized

  		if ( dir.y > 0.99999 ) {

  			this.quaternion.set( 0, 0, 0, 1 );

  		} else if ( dir.y < - 0.99999 ) {

  			this.quaternion.set( 1, 0, 0, 0 );

  		} else {

  			axis.set( dir.z, 0, - dir.x ).normalize();

  			radians = Math.acos( dir.y );

  			this.quaternion.setFromAxisAngle( axis, radians );

  		}

  	};

  }() );

  ArrowHelper$1.prototype.setLength = function ( length, headLength, headWidth ) {

  	if ( headLength === undefined ) headLength = 0.2 * length;
  	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
  	this.line.updateMatrix();

  	this.cone.scale.set( headWidth, headLength, headWidth );
  	this.cone.position.y = length;
  	this.cone.updateMatrix();

  };

  ArrowHelper$1.prototype.setColor = function ( color ) {

  	this.line.material.color.copy( color );
  	this.cone.material.color.copy( color );

  };

  /**
   * @author sroucheray / http://sroucheray.org/
   * @author mrdoob / http://mrdoob.com/
   */

  function AxisHelper( size ) {

  	size = size || 1;

  	var vertices = [
  		0, 0, 0,  size, 0, 0,
  		0, 0, 0,  0, size, 0,
  		0, 0, 0,  0, 0, size
  	];

  	var colors = [
  		1, 0, 0,  1, 0.6, 0,
  		0, 1, 0,  0.6, 1, 0,
  		0, 0, 1,  0, 0.6, 1
  	];

  	var geometry = new BufferGeometry$1();
  	geometry.addAttribute( 'position', new Float32BufferAttribute$1( vertices, 3 ) );
  	geometry.addAttribute( 'color', new Float32BufferAttribute$1( colors, 3 ) );

  	var material = new LineBasicMaterial$1( { vertexColors: VertexColors$1 } );

  	LineSegments$1.call( this, geometry, material );

  }

  AxisHelper.prototype = Object.create( LineSegments$1.prototype );
  AxisHelper.prototype.constructor = AxisHelper;

  /**
   * @author zz85 https://github.com/zz85
   *
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */


  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly$1() {

  	var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

  	/*
  	 * Compute coefficients for a cubic polynomial
  	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
  	 * such that
  	 *   p(0) = x0, p(1) = x1
  	 *  and
  	 *   p'(0) = t0, p'(1) = t1.
  	 */
  	function init( x0, x1, t0, t1 ) {

  		c0 = x0;
  		c1 = t0;
  		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
  		c3 = 2 * x0 - 2 * x1 + t0 + t1;

  	}

  	return {

  		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

  			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  		},

  		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

  			// compute tangents when parameterized in [t1,t2]
  			var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
  			var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

  			// rescale tangents for parametrization in [0,1]
  			t1 *= dt1;
  			t2 *= dt1;

  			init( x1, x2, t1, t2 );

  		},

  		calc: function ( t ) {

  			var t2 = t * t;
  			var t3 = t2 * t;
  			return c0 + c1 * t + c2 * t2 + c3 * t3;

  		}

  	};

  }

  //

  var tmp$1 = new Vector3$1();
  var px$2 = new CubicPoly$1();
  var py$1 = new CubicPoly$1();
  var pz$1 = new CubicPoly$1();

  function CatmullRomCurve3$1( p /* array of Vector3 */ ) {

  	Curve$1.call( this );

  	this.points = p || [];
  	this.closed = false;

  }

  CatmullRomCurve3$1.prototype = Object.create( Curve$1.prototype );
  CatmullRomCurve3$1.prototype.constructor = CatmullRomCurve3$1;

  CatmullRomCurve3$1.prototype.getPoint = function ( t ) {

  	var points = this.points;
  	var l = points.length;

  	if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

  	var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
  	var intPoint = Math.floor( point );
  	var weight = point - intPoint;

  	if ( this.closed ) {

  		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

  	} else if ( weight === 0 && intPoint === l - 1 ) {

  		intPoint = l - 2;
  		weight = 1;

  	}

  	var p0, p1, p2, p3; // 4 points

  	if ( this.closed || intPoint > 0 ) {

  		p0 = points[ ( intPoint - 1 ) % l ];

  	} else {

  		// extrapolate first point
  		tmp$1.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
  		p0 = tmp$1;

  	}

  	p1 = points[ intPoint % l ];
  	p2 = points[ ( intPoint + 1 ) % l ];

  	if ( this.closed || intPoint + 2 < l ) {

  		p3 = points[ ( intPoint + 2 ) % l ];

  	} else {

  		// extrapolate last point
  		tmp$1.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
  		p3 = tmp$1;

  	}

  	if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

  		// init Centripetal / Chordal Catmull-Rom
  		var pow = this.type === 'chordal' ? 0.5 : 0.25;
  		var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
  		var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
  		var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

  		// safety check for repeated points
  		if ( dt1 < 1e-4 ) dt1 = 1.0;
  		if ( dt0 < 1e-4 ) dt0 = dt1;
  		if ( dt2 < 1e-4 ) dt2 = dt1;

  		px$2.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
  		py$1.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
  		pz$1.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

  	} else if ( this.type === 'catmullrom' ) {

  		var tension = this.tension !== undefined ? this.tension : 0.5;
  		px$2.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
  		py$1.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
  		pz$1.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

  	}

  	return new Vector3$1( px$2.calc( weight ), py$1.calc( weight ), pz$1.calc( weight ) );

  };

  function CubicBezierCurve3$1( v0, v1, v2, v3 ) {

  	Curve$1.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;
  	this.v3 = v3;

  }

  CubicBezierCurve3$1.prototype = Object.create( Curve$1.prototype );
  CubicBezierCurve3$1.prototype.constructor = CubicBezierCurve3$1;

  CubicBezierCurve3$1.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

  	return new Vector3$1(
  		CubicBezier$1( t, v0.x, v1.x, v2.x, v3.x ),
  		CubicBezier$1( t, v0.y, v1.y, v2.y, v3.y ),
  		CubicBezier$1( t, v0.z, v1.z, v2.z, v3.z )
  	);

  };

  function QuadraticBezierCurve3$1( v0, v1, v2 ) {

  	Curve$1.call( this );

  	this.v0 = v0;
  	this.v1 = v1;
  	this.v2 = v2;

  }

  QuadraticBezierCurve3$1.prototype = Object.create( Curve$1.prototype );
  QuadraticBezierCurve3$1.prototype.constructor = QuadraticBezierCurve3$1;

  QuadraticBezierCurve3$1.prototype.getPoint = function ( t ) {

  	var v0 = this.v0, v1 = this.v1, v2 = this.v2;

  	return new Vector3$1(
  		QuadraticBezier$1( t, v0.x, v1.x, v2.x ),
  		QuadraticBezier$1( t, v0.y, v1.y, v2.y ),
  		QuadraticBezier$1( t, v0.z, v1.z, v2.z )
  	);

  };

  function LineCurve3$1( v1, v2 ) {

  	Curve$1.call( this );

  	this.v1 = v1;
  	this.v2 = v2;

  }

  LineCurve3$1.prototype = Object.create( Curve$1.prototype );
  LineCurve3$1.prototype.constructor = LineCurve3$1;

  LineCurve3$1.prototype.getPoint = function ( t ) {

  	if ( t === 1 ) {

  		return this.v2.clone();

  	}

  	var vector = new Vector3$1();

  	vector.subVectors( this.v2, this.v1 ); // diff
  	vector.multiplyScalar( t );
  	vector.add( this.v1 );

  	return vector;

  };

  function ArcCurve$1( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  	EllipseCurve$1.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

  }

  ArcCurve$1.prototype = Object.create( EllipseCurve$1.prototype );
  ArcCurve$1.prototype.constructor = ArcCurve$1;

  //

  Curve$1.create = function ( construct, getPoint ) {

  	console.log( 'THREE.Curve.create() has been deprecated' );

  	construct.prototype = Object.create( Curve$1.prototype );
  	construct.prototype.constructor = construct;
  	construct.prototype.getPoint = getPoint;

  	return construct;

  };

  //

  function Spline$1( points ) {

  	console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

  	CatmullRomCurve3$1.call( this, points );
  	this.type = 'catmullrom';

  }

  Spline$1.prototype = Object.create( CatmullRomCurve3$1.prototype );

  Object.assign( Spline$1.prototype, {

  	initFromArray: function ( a ) {

  		console.error( 'THREE.Spline: .initFromArray() has been removed.' );

  	},
  	getControlPointsArray: function ( optionalTarget ) {

  		console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

  	},
  	reparametrizeByArcLength: function ( samplingCoef ) {

  		console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

  	}

  } );

  GridHelper$1.prototype.setColors = function () {

  	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

  };

  //

  Object.assign( Box2$1.prototype, {

  	center: function ( optionalTarget ) {

  		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
  		return this.getCenter( optionalTarget );

  	},
  	empty: function () {

  		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
  		return this.isEmpty();

  	},
  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	size: function ( optionalTarget ) {

  		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
  		return this.getSize( optionalTarget );

  	}
  } );

  Object.assign( Box3$1.prototype, {

  	center: function ( optionalTarget ) {

  		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
  		return this.getCenter( optionalTarget );

  	},
  	empty: function () {

  		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
  		return this.isEmpty();

  	},
  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	isIntersectionSphere: function ( sphere ) {

  		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  		return this.intersectsSphere( sphere );

  	},
  	size: function ( optionalTarget ) {

  		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
  		return this.getSize( optionalTarget );

  	}
  } );

  Line3$1.prototype.center = function ( optionalTarget ) {

  	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
  	return this.getCenter( optionalTarget );

  };

  _Math$1.random16 = function () {

  	console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
  	return Math.random();

  };

  Object.assign( Matrix3$1.prototype, {

  	flattenToArrayOffset: function ( array, offset ) {

  		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  		return this.toArray( array, offset );

  	},
  	multiplyVector3: function ( vector ) {

  		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
  		return vector.applyMatrix3( this );

  	},
  	multiplyVector3Array: function ( a ) {

  		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
  		return this.applyToVector3Array( a );

  	},
  	applyToBuffer: function( buffer, offset, length ) {

  		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  		return this.applyToBufferAttribute( buffer );

  	},
  	applyToVector3Array: function( array, offset, length ) {

  		console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

  	}

  } );

  Object.assign( Matrix4$1.prototype, {

  	extractPosition: function ( m ) {

  		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
  		return this.copyPosition( m );

  	},
  	flattenToArrayOffset: function ( array, offset ) {

  		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
  		return this.toArray( array, offset );

  	},
  	getPosition: function () {

  		var v1;

  		return function getPosition() {

  			if ( v1 === undefined ) v1 = new Vector3$1();
  			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
  			return v1.setFromMatrixColumn( this, 3 );

  		};

  	}(),
  	setRotationFromQuaternion: function ( q ) {

  		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
  		return this.makeRotationFromQuaternion( q );

  	},
  	multiplyToArray: function () {

  		console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

  	},
  	multiplyVector3: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	multiplyVector4: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	multiplyVector3Array: function ( a ) {

  		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
  		return this.applyToVector3Array( a );

  	},
  	rotateAxis: function ( v ) {

  		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
  		v.transformDirection( this );

  	},
  	crossVector: function ( vector ) {

  		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
  		return vector.applyMatrix4( this );

  	},
  	translate: function () {

  		console.error( 'THREE.Matrix4: .translate() has been removed.' );

  	},
  	rotateX: function () {

  		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  	},
  	rotateY: function () {

  		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  	},
  	rotateZ: function () {

  		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  	},
  	rotateByAxis: function () {

  		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  	},
  	applyToBuffer: function( buffer, offset, length ) {

  		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
  		return this.applyToBufferAttribute( buffer );

  	},
  	applyToVector3Array: function( array, offset, length ) {

  		console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

  	},
  	makeFrustum: function( left, right, bottom, top, near, far ) {

  		console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
  		return this.makePerspective( left, right, top, bottom, near, far );

  	}

  } );

  Plane$2.prototype.isIntersectionLine = function ( line ) {

  	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
  	return this.intersectsLine( line );

  };

  Quaternion$1.prototype.multiplyVector3 = function ( vector ) {

  	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
  	return vector.applyQuaternion( this );

  };

  Object.assign( Ray$1.prototype, {

  	isIntersectionBox: function ( box ) {

  		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
  		return this.intersectsBox( box );

  	},
  	isIntersectionPlane: function ( plane ) {

  		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
  		return this.intersectsPlane( plane );

  	},
  	isIntersectionSphere: function ( sphere ) {

  		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
  		return this.intersectsSphere( sphere );

  	}

  } );

  Object.assign( Shape$2.prototype, {

  	extrude: function ( options ) {

  		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
  		return new ExtrudeGeometry$1( this, options );

  	},
  	makeGeometry: function ( options ) {

  		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
  		return new ShapeGeometry$1( this, options );

  	}

  } );

  Object.assign( Vector2$1.prototype, {

  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  Object.assign( Vector3$1.prototype, {

  	setEulerFromRotationMatrix: function () {

  		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  	},
  	setEulerFromQuaternion: function () {

  		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  	},
  	getPositionFromMatrix: function ( m ) {

  		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
  		return this.setFromMatrixPosition( m );

  	},
  	getScaleFromMatrix: function ( m ) {

  		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
  		return this.setFromMatrixScale( m );

  	},
  	getColumnFromMatrix: function ( index, matrix ) {

  		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
  		return this.setFromMatrixColumn( matrix, index );

  	},
  	applyProjection: function ( m ) {

  		console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
  		return this.applyMatrix4( m );

  	},
  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  Object.assign( Vector4$1.prototype, {

  	fromAttribute: function ( attribute, index, offset ) {

  		console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
  		return this.fromBufferAttribute( attribute, index, offset );

  	}

  } );

  //

  Geometry$1.prototype.computeTangents = function () {

  	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

  };

  Object.assign( Object3D$1.prototype, {

  	getChildByName: function ( name ) {

  		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
  		return this.getObjectByName( name );

  	},
  	renderDepth: function () {

  		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

  	},
  	translate: function ( distance, axis ) {

  		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
  		return this.translateOnAxis( axis, distance );

  	}

  } );

  Object.defineProperties( Object3D$1.prototype, {

  	eulerOrder: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			return this.rotation.order;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
  			this.rotation.order = value;

  		}
  	},
  	useQuaternion: {
  		get: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  		}
  	}

  } );

  Object.defineProperties( LOD$1.prototype, {

  	objects: {
  		get: function () {

  			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
  			return this.levels;

  		}
  	}

  } );

  Object.defineProperty( Skeleton$1.prototype, 'useVertexTexture', {

  	get: function () {

  		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  	},
  	set: function () {

  		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

  	}

  } );

  Object.defineProperty( Curve$1.prototype, '__arcLengthDivisions', {

  	get: function () {

  		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  		return this.arcLengthDivisions;

  	},
  	set: function ( value ) {

  		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
  		this.arcLengthDivisions = value;

  	}

  } );

  //

  PerspectiveCamera$2.prototype.setLens = function ( focalLength, filmGauge ) {

  	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
  			"Use .setFocalLength and .filmGauge for a photographic setup." );

  	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
  	this.setFocalLength( focalLength );

  };

  //

  Object.defineProperties( Light$1.prototype, {
  	onlyShadow: {
  		set: function () {

  			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

  		}
  	},
  	shadowCameraFov: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
  			this.shadow.camera.fov = value;

  		}
  	},
  	shadowCameraLeft: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
  			this.shadow.camera.left = value;

  		}
  	},
  	shadowCameraRight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
  			this.shadow.camera.right = value;

  		}
  	},
  	shadowCameraTop: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
  			this.shadow.camera.top = value;

  		}
  	},
  	shadowCameraBottom: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
  			this.shadow.camera.bottom = value;

  		}
  	},
  	shadowCameraNear: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
  			this.shadow.camera.near = value;

  		}
  	},
  	shadowCameraFar: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
  			this.shadow.camera.far = value;

  		}
  	},
  	shadowCameraVisible: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

  		}
  	},
  	shadowBias: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
  			this.shadow.bias = value;

  		}
  	},
  	shadowDarkness: {
  		set: function () {

  			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

  		}
  	},
  	shadowMapWidth: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
  			this.shadow.mapSize.width = value;

  		}
  	},
  	shadowMapHeight: {
  		set: function ( value ) {

  			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
  			this.shadow.mapSize.height = value;

  		}
  	}
  } );

  //

  Object.defineProperties( BufferAttribute$1.prototype, {

  	length: {
  		get: function () {

  			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
  			return this.array.length;

  		}
  	}

  } );

  Object.assign( BufferGeometry$1.prototype, {

  	addIndex: function ( index ) {

  		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
  		this.setIndex( index );

  	},
  	addDrawCall: function ( start, count, indexOffset ) {

  		if ( indexOffset !== undefined ) {

  			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

  		}
  		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
  		this.addGroup( start, count );

  	},
  	clearDrawCalls: function () {

  		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
  		this.clearGroups();

  	},
  	computeTangents: function () {

  		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

  	},
  	computeOffsets: function () {

  		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

  	}

  } );

  Object.defineProperties( BufferGeometry$1.prototype, {

  	drawcalls: {
  		get: function () {

  			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
  			return this.groups;

  		}
  	},
  	offsets: {
  		get: function () {

  			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
  			return this.groups;

  		}
  	}

  } );

  //

  Object.defineProperties( Uniform$1.prototype, {

  	dynamic: {
  		set: function () {

  			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

  		}
  	},
  	onUpdate: {
  		value: function () {

  			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
  			return this;

  		}
  	}

  } );

  //

  Object.defineProperties( Material$1.prototype, {

  	wrapAround: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		},
  		set: function () {

  			console.warn( 'THREE.Material: .wrapAround has been removed.' );

  		}
  	},
  	wrapRGB: {
  		get: function () {

  			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
  			return new Color$1();

  		}
  	}

  } );

  Object.defineProperties( MeshPhongMaterial$1.prototype, {

  	metal: {
  		get: function () {

  			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
  			return false;

  		},
  		set: function () {

  			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

  		}
  	}

  } );

  Object.defineProperties( ShaderMaterial$1.prototype, {

  	derivatives: {
  		get: function () {

  			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			return this.extensions.derivatives;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
  			this.extensions.derivatives = value;

  		}
  	}

  } );

  //

  Object.assign( WebGLRenderer$1.prototype, {

  	getCurrentRenderTarget: function () {

  		console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
  		return this.getRenderTarget();

  	},

  	supportsFloatTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
  		return this.extensions.get( 'OES_texture_float' );

  	},
  	supportsHalfFloatTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
  		return this.extensions.get( 'OES_texture_half_float' );

  	},
  	supportsStandardDerivatives: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
  		return this.extensions.get( 'OES_standard_derivatives' );

  	},
  	supportsCompressedTextureS3TC: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
  		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

  	},
  	supportsCompressedTexturePVRTC: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
  		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  	},
  	supportsBlendMinMax: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
  		return this.extensions.get( 'EXT_blend_minmax' );

  	},
  	supportsVertexTextures: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
  		return this.capabilities.vertexTextures;

  	},
  	supportsInstancedArrays: function () {

  		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
  		return this.extensions.get( 'ANGLE_instanced_arrays' );

  	},
  	enableScissorTest: function ( boolean ) {

  		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
  		this.setScissorTest( boolean );

  	},
  	initMaterial: function () {

  		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  	},
  	addPrePlugin: function () {

  		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  	},
  	addPostPlugin: function () {

  		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  	},
  	updateShadowMap: function () {

  		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  	}

  } );

  Object.defineProperties( WebGLRenderer$1.prototype, {

  	shadowMapEnabled: {
  		get: function () {

  			return this.shadowMap.enabled;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
  			this.shadowMap.enabled = value;

  		}
  	},
  	shadowMapType: {
  		get: function () {

  			return this.shadowMap.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
  			this.shadowMap.type = value;

  		}
  	},
  	shadowMapCullFace: {
  		get: function () {

  			return this.shadowMap.cullFace;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
  			this.shadowMap.cullFace = value;

  		}
  	}
  } );

  Object.defineProperties( WebGLShadowMap$1.prototype, {

  	cullFace: {
  		get: function () {

  			return this.renderReverseSided ? CullFaceFront$1 : CullFaceBack$1;

  		},
  		set: function ( cullFace ) {

  			var value = ( cullFace !== CullFaceBack$1 );
  			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
  			this.renderReverseSided = value;

  		}
  	}

  } );

  //

  Object.defineProperties( WebGLRenderTarget$1.prototype, {

  	wrapS: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			return this.texture.wrapS;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
  			this.texture.wrapS = value;

  		}
  	},
  	wrapT: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			return this.texture.wrapT;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
  			this.texture.wrapT = value;

  		}
  	},
  	magFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			return this.texture.magFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
  			this.texture.magFilter = value;

  		}
  	},
  	minFilter: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			return this.texture.minFilter;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
  			this.texture.minFilter = value;

  		}
  	},
  	anisotropy: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			return this.texture.anisotropy;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
  			this.texture.anisotropy = value;

  		}
  	},
  	offset: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			return this.texture.offset;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
  			this.texture.offset = value;

  		}
  	},
  	repeat: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			return this.texture.repeat;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
  			this.texture.repeat = value;

  		}
  	},
  	format: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			return this.texture.format;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
  			this.texture.format = value;

  		}
  	},
  	type: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			return this.texture.type;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
  			this.texture.type = value;

  		}
  	},
  	generateMipmaps: {
  		get: function () {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			return this.texture.generateMipmaps;

  		},
  		set: function ( value ) {

  			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
  			this.texture.generateMipmaps = value;

  		}
  	}

  } );

  //

  Audio$1.prototype.load = function ( file ) {

  	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
  	var scope = this;
  	var audioLoader = new AudioLoader$1();
  	audioLoader.load( file, function ( buffer ) {

  		scope.setBuffer( buffer );

  	} );
  	return this;

  };

  AudioAnalyser$1.prototype.getData = function () {

  	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
  	return this.getFrequencyData();

  };

  /**
   * @author dmarcos / https://github.com/dmarcos
   * @author mrdoob / http://mrdoob.com
   *
   * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
   *
   * Firefox: http://mozvr.com/downloads/
   * Chromium: https://webvr.info/get-chrome
   *
   */
  var VREffect = function VREffect(renderer, onError) {
    var vrDisplay, vrDisplays;
    var eyeTranslationL = new Vector3$1();
    var eyeTranslationR = new Vector3$1();
    var renderRectL, renderRectR;
    var frameData = null;

    if ('VRFrameData' in window) {
      frameData = new VRFrameData();
    }

    function gotVRDisplays(displays) {
      vrDisplays = displays;

      if (displays.length > 0) {
        vrDisplay = displays[0];
      } else {
        if (onError) onError('HMD not available');
      }
    }

    if (navigator.getVRDisplays) {
      navigator.getVRDisplays().then(gotVRDisplays).catch(function () {
        console.warn('THREE.VREffect: Unable to get VR Displays');
      });
    } //


    this.isPresenting = false;
    this.scale = 1;
    var scope = this;
    var rendererSize = renderer.getSize();
    var rendererUpdateStyle = false;
    var rendererPixelRatio = renderer.getPixelRatio();

    this.getVRDisplay = function () {
      return vrDisplay;
    };

    this.setVRDisplay = function (value) {
      vrDisplay = value;
    };

    this.getVRDisplays = function () {
      console.warn('THREE.VREffect: getVRDisplays() is being deprecated.');
      return vrDisplays;
    };

    this.setSize = function (width, height, updateStyle) {
      rendererSize = {
        width: width,
        height: height
      };
      rendererUpdateStyle = updateStyle;

      if (scope.isPresenting) {
        var eyeParamsL = vrDisplay.getEyeParameters('left');
        renderer.setPixelRatio(1);
        renderer.setSize(eyeParamsL.renderWidth * 2, eyeParamsL.renderHeight, false);
      } else {
        renderer.setPixelRatio(rendererPixelRatio);
        renderer.setSize(width, height, updateStyle);
      }
    }; // fullscreen


    var canvas = renderer.domElement;
    var defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
    var defaultRightBounds = [0.5, 0.0, 0.5, 1.0];

    function onVRDisplayPresentChange() {
      var wasPresenting = scope.isPresenting;
      scope.isPresenting = vrDisplay !== undefined && vrDisplay.isPresenting;

      if (scope.isPresenting) {
        var eyeParamsL = vrDisplay.getEyeParameters('left');
        var eyeWidth = eyeParamsL.renderWidth;
        var eyeHeight = eyeParamsL.renderHeight;

        if (!wasPresenting) {
          rendererPixelRatio = renderer.getPixelRatio();
          rendererSize = renderer.getSize();
          renderer.setPixelRatio(1);
          renderer.setSize(eyeWidth * 2, eyeHeight, false);
        }
      } else if (wasPresenting) {
        renderer.setPixelRatio(rendererPixelRatio);
        renderer.setSize(rendererSize.width, rendererSize.height, rendererUpdateStyle);
      }
    }

    window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);

    this.setFullScreen = function (boolean) {
      return new Promise(function (resolve, reject) {
        if (vrDisplay === undefined) {
          reject(new Error('No VR hardware found.'));
          return;
        }

        if (scope.isPresenting === boolean) {
          resolve();
          return;
        }

        if (boolean) {
          resolve(vrDisplay.requestPresent([{
            source: canvas
          }]));
        } else {
          resolve(vrDisplay.exitPresent());
        }
      });
    };

    this.requestPresent = function () {
      return this.setFullScreen(true);
    };

    this.exitPresent = function () {
      return this.setFullScreen(false);
    };

    this.requestAnimationFrame = function (f) {
      if (vrDisplay !== undefined) {
        return vrDisplay.requestAnimationFrame(f);
      } else {
        return window.requestAnimationFrame(f);
      }
    };

    this.cancelAnimationFrame = function (h) {
      if (vrDisplay !== undefined) {
        vrDisplay.cancelAnimationFrame(h);
      } else {
        window.cancelAnimationFrame(h);
      }
    };

    this.submitFrame = function () {
      if (vrDisplay !== undefined && scope.isPresenting) {
        vrDisplay.submitFrame();
      }
    };

    this.autoSubmitFrame = true; // render

    var cameraL = new PerspectiveCamera$2();
    cameraL.layers.enable(1);
    var cameraR = new PerspectiveCamera$2();
    cameraR.layers.enable(2);

    this.render = function (scene, camera, renderTarget, forceClear) {
      if (vrDisplay && scope.isPresenting) {
        var autoUpdate = scene.autoUpdate;

        if (autoUpdate) {
          scene.updateMatrixWorld();
          scene.autoUpdate = false;
        }

        var eyeParamsL = vrDisplay.getEyeParameters('left');
        var eyeParamsR = vrDisplay.getEyeParameters('right');
        eyeTranslationL.fromArray(eyeParamsL.offset);
        eyeTranslationR.fromArray(eyeParamsR.offset);

        if (Array.isArray(scene)) {
          console.warn('THREE.VREffect.render() no longer supports arrays. Use object.layers instead.');
          scene = scene[0];
        } // When rendering we don't care what the recommended size is, only what the actual size
        // of the backbuffer is.


        var size = renderer.getSize();
        var layers = vrDisplay.getLayers();
        var leftBounds;
        var rightBounds;

        if (layers.length) {
          var layer = layers[0];
          leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ? layer.leftBounds : defaultLeftBounds;
          rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ? layer.rightBounds : defaultRightBounds;
        } else {
          leftBounds = defaultLeftBounds;
          rightBounds = defaultRightBounds;
        }

        renderRectL = {
          x: Math.round(size.width * leftBounds[0]),
          y: Math.round(size.height * leftBounds[1]),
          width: Math.round(size.width * leftBounds[2]),
          height: Math.round(size.height * leftBounds[3])
        };
        renderRectR = {
          x: Math.round(size.width * rightBounds[0]),
          y: Math.round(size.height * rightBounds[1]),
          width: Math.round(size.width * rightBounds[2]),
          height: Math.round(size.height * rightBounds[3])
        };

        if (renderTarget) {
          renderer.setRenderTarget(renderTarget);
          renderTarget.scissorTest = true;
        } else {
          renderer.setRenderTarget(null);
          renderer.setScissorTest(true);
        }

        if (renderer.autoClear || forceClear) renderer.clear();
        if (camera.parent === null) camera.updateMatrixWorld();
        camera.matrixWorld.decompose(cameraL.position, cameraL.quaternion, cameraL.scale);
        camera.matrixWorld.decompose(cameraR.position, cameraR.quaternion, cameraR.scale);
        var scale = this.scale;
        cameraL.translateOnAxis(eyeTranslationL, scale);
        cameraR.translateOnAxis(eyeTranslationR, scale);

        if (vrDisplay.getFrameData) {
          vrDisplay.depthNear = camera.near;
          vrDisplay.depthFar = camera.far;
          vrDisplay.getFrameData(frameData);
          cameraL.projectionMatrix.elements = frameData.leftProjectionMatrix;
          cameraR.projectionMatrix.elements = frameData.rightProjectionMatrix;
        } else {
          cameraL.projectionMatrix = fovToProjection(eyeParamsL.fieldOfView, true, camera.near, camera.far);
          cameraR.projectionMatrix = fovToProjection(eyeParamsR.fieldOfView, true, camera.near, camera.far);
        } // render left eye


        if (renderTarget) {
          renderTarget.viewport.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
          renderTarget.scissor.set(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
        } else {
          renderer.setViewport(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
          renderer.setScissor(renderRectL.x, renderRectL.y, renderRectL.width, renderRectL.height);
        }

        renderer.render(scene, cameraL, renderTarget, forceClear); // render right eye

        if (renderTarget) {
          renderTarget.viewport.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
          renderTarget.scissor.set(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
        } else {
          renderer.setViewport(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
          renderer.setScissor(renderRectR.x, renderRectR.y, renderRectR.width, renderRectR.height);
        }

        renderer.render(scene, cameraR, renderTarget, forceClear);

        if (renderTarget) {
          renderTarget.viewport.set(0, 0, size.width, size.height);
          renderTarget.scissor.set(0, 0, size.width, size.height);
          renderTarget.scissorTest = false;
          renderer.setRenderTarget(null);
        } else {
          renderer.setViewport(0, 0, size.width, size.height);
          renderer.setScissorTest(false);
        }

        if (autoUpdate) {
          scene.autoUpdate = true;
        }

        if (scope.autoSubmitFrame) {
          scope.submitFrame();
        }

        return;
      } // Regular render mode if not HMD


      renderer.render(scene, camera, renderTarget, forceClear);
    };

    this.dispose = function () {
      window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
    }; //


    function fovToNDCScaleOffset(fov) {
      var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
      var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
      var pyscale = 2.0 / (fov.upTan + fov.downTan);
      var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
      return {
        scale: [pxscale, pyscale],
        offset: [pxoffset, pyoffset]
      };
    }

    function fovPortToProjection(fov, rightHanded, zNear, zFar) {
      rightHanded = rightHanded === undefined ? true : rightHanded;
      zNear = zNear === undefined ? 0.01 : zNear;
      zFar = zFar === undefined ? 10000.0 : zFar;
      var handednessScale = rightHanded ? -1.0 : 1.0; // start with an identity matrix

      var mobj = new Matrix4$1();
      var m = mobj.elements; // and with scale/offset info for normalized device coords

      var scaleAndOffset = fovToNDCScaleOffset(fov); // X result, map clip edges to [-w,+w]

      m[0 * 4 + 0] = scaleAndOffset.scale[0];
      m[0 * 4 + 1] = 0.0;
      m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
      m[0 * 4 + 3] = 0.0; // Y result, map clip edges to [-w,+w]
      // Y offset is negated because this proj matrix transforms from world coords with Y=up,
      // but the NDC scaling has Y=down (thanks D3D?)

      m[1 * 4 + 0] = 0.0;
      m[1 * 4 + 1] = scaleAndOffset.scale[1];
      m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
      m[1 * 4 + 3] = 0.0; // Z result (up to the app)

      m[2 * 4 + 0] = 0.0;
      m[2 * 4 + 1] = 0.0;
      m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
      m[2 * 4 + 3] = zFar * zNear / (zNear - zFar); // W result (= Z in)

      m[3 * 4 + 0] = 0.0;
      m[3 * 4 + 1] = 0.0;
      m[3 * 4 + 2] = handednessScale;
      m[3 * 4 + 3] = 0.0;
      mobj.transpose();
      return mobj;
    }

    function fovToProjection(fov, rightHanded, zNear, zFar) {
      var DEG2RAD = Math.PI / 180.0;
      var fovPort = {
        upTan: Math.tan(fov.upDegrees * DEG2RAD),
        downTan: Math.tan(fov.downDegrees * DEG2RAD),
        leftTan: Math.tan(fov.leftDegrees * DEG2RAD),
        rightTan: Math.tan(fov.rightDegrees * DEG2RAD)
      };
      return fovPortToProjection(fovPort, rightHanded, zNear, zFar);
    }
  };

  /**
   * @author dmarcos / https://github.com/dmarcos
   * @author mrdoob / http://mrdoob.com
   * @author halvves / https://github.com/halvves (i only es6 moduled it)
   */

  class VRControls {
    constructor(camera, onError) {
      this.camera = camera;
      this.vrDisplay;
      this.vrDisplays;
      this.standingMatrix = new Matrix4$1();
      this.frameData = null;

      if ('VRFrameData' in window) {
        this.frameData = new VRFrameData();
      }

      if (navigator.getVRDisplays) {
        navigator
          .getVRDisplays()
          .then((displays) => {
            this.vrDisplays = displays;
            if (displays.length > 0) {
              this.vrDisplay = displays[0];
            } else {
              if (onError) onError('VR input not available.');
            }
          })
          .catch(() => {
            console.warn('VRControls: Unable to get VR Displays');
          });
      }

      // the Rift SDK returns the position in meters
      // this scale factor allows the user to define how meters
      // are converted to scene units.
      this.scale = 1;

      // If true will use "standing space" coordinate system where y=0 is the
      // floor and x=0, z=0 is the center of the room.
      this.standing = false;

      // Distance from the users eyes to the floor in meters. Used when
      // standing=true but the VRDisplay doesn't provide stageParameters.
      this.userHeight = 1.6;
    }

    getVRDisplay() {
      return this.vrDisplay;
    };

    setVRDisplay(value) {
      this.vrDisplay = value;
    };

    getVRDisplays() {
      console.warn('VRControls: getVRDisplays() is being deprecated.');
      return this.vrDisplays;
    };

    getStandingMatrix() {
      return this.standingMatrix;
    };

    update() {
      const camera = this.camera;

      if (this.vrDisplay) {
        let pose;
        if (this.vrDisplay.getFrameData) {
          this.vrDisplay.getFrameData(this.frameData);
          pose = this.frameData.pose;
        } else if (this.vrDisplay.getPose) {
          pose = this.vrDisplay.getPose();
        }
        if (pose.orientation !== null) {
          camera.quaternion.fromArray(pose.orientation);
        }
        if (pose.position !== null) {
          camera.position.fromArray(pose.position);
        } else {
          camera.position.set(0, 0, 0);
        }
        if (this.standing) {
          if (this.vrDisplay.stageParameters) {
            camera.updateMatrix();
            this.standingMatrix.fromArray(this.vrDisplay.stageParameters.sittingToStandingTransform);
            camera.applyMatrix(this.standingMatrix);
          } else {
            camera.position.setY(camera.position.y + this.userHeight);
          }
        }
        camera.position.multiplyScalar(this.scale);
      }
    };

    dispose() {
      this.vrDisplay = null;
    };
  }

  /**
   * @author mrdoob / http://mrdoob.com
   * @author Mugen87 / https://github.com/Mugen87
   *
   * Based on @tojiro's vr-samples-utils.js
   */
  var WEBVR = {
    isAvailable: function isAvailable() {
      console.warn('WEBVR: isAvailable() is being deprecated. Use .checkAvailability() instead.');
      return navigator.getVRDisplays !== undefined;
    },
    checkAvailability: function checkAvailability() {
      return new Promise(function (resolve, reject) {
        if (navigator.getVRDisplays !== undefined) {
          navigator.getVRDisplays().then(function (displays) {
            if (displays.length === 0) {
              reject('WebVR supported, but no VRDisplays found.');
            } else {
              resolve();
            }
          });
        } else {
          reject('Your browser does not support WebVR. See <a href="https://webvr.info">webvr.info</a> for assistance.');
        }
      });
    },
    getVRDisplay: function getVRDisplay(onDisplay) {
      if ('getVRDisplays' in navigator) {
        navigator.getVRDisplays().then(function (displays) {
          onDisplay(displays[0]);
        });
      }
    },
    getMessage: function getMessage() {
      console.warn('WEBVR: getMessage() is being deprecated. Use .getMessageContainer( message ) instead.');
      var message;

      if (navigator.getVRDisplays) {
        navigator.getVRDisplays().then(function (displays) {
          if (displays.length === 0) message = 'WebVR supported, but no VRDisplays found.';
        });
      } else {
        message = 'Your browser does not support WebVR. See <a href="http://webvr.info">webvr.info</a> for assistance.';
      }

      if (message !== undefined) {
        var container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.left = '0';
        container.style.top = '0';
        container.style.right = '0';
        container.style.zIndex = '999';
        container.align = 'center';
        var error = document.createElement('div');
        error.style.fontFamily = 'sans-serif';
        error.style.fontSize = '16px';
        error.style.fontStyle = 'normal';
        error.style.lineHeight = '26px';
        error.style.backgroundColor = '#fff';
        error.style.color = '#000';
        error.style.padding = '10px 20px';
        error.style.margin = '50px';
        error.style.display = 'inline-block';
        error.innerHTML = message;
        container.appendChild(error);
        return container;
      }
    },
    getMessageContainer: function getMessageContainer(message) {
      var container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.left = '0';
      container.style.top = '0';
      container.style.right = '0';
      container.style.zIndex = '999';
      container.align = 'center';
      var error = document.createElement('div');
      error.style.fontFamily = 'sans-serif';
      error.style.fontSize = '16px';
      error.style.fontStyle = 'normal';
      error.style.lineHeight = '26px';
      error.style.backgroundColor = '#fff';
      error.style.color = '#000';
      error.style.padding = '10px 20px';
      error.style.margin = '50px';
      error.style.display = 'inline-block';
      error.innerHTML = message;
      container.appendChild(error);
      return container;
    },
    getButton: function getButton(display, canvas) {
      if ('VREffect' in THREE && display instanceof THREE.VREffect) {
        console.error('WebVR.getButton() now expects a VRDisplay.');
        return document.createElement('button');
      }

      var button = document.createElement('button');
      button.style.position = 'absolute';
      button.style.left = 'calc(50% - 50px)';
      button.style.bottom = '20px';
      button.style.width = '100px';
      button.style.border = '0';
      button.style.padding = '8px';
      button.style.cursor = 'pointer';
      button.style.backgroundColor = '#000';
      button.style.color = '#fff';
      button.style.fontFamily = 'sans-serif';
      button.style.fontSize = '13px';
      button.style.fontStyle = 'normal';
      button.style.textAlign = 'center';
      button.style.zIndex = '999';

      if (display) {
        button.textContent = 'ENTER VR';

        button.onclick = function () {
          display.isPresenting ? display.exitPresent() : display.requestPresent([{
            source: canvas
          }]);
        };

        window.addEventListener('vrdisplaypresentchange', function () {
          button.textContent = display.isPresenting ? 'EXIT VR' : 'ENTER VR';
        }, false);
      } else {
        button.textContent = 'NO VR DISPLAY';
      }

      return button;
    }
  };

  var VRModule =
  /*#__PURE__*/
  function () {
    function VRModule() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, VRModule);
      this.params = Object.assign(params, {
        message: true,
        button: true
      });
      this.scene = null;
      this.camera = null;
      this.effect = null;
    }

    _createClass(VRModule, [{
      key: "manager",
      value: function manager(_manager) {
        var _this = this;

        _manager.define('vr');

        var rendering = _manager.use('rendering');

        var renderer = _manager.get('renderer');

        var resize = _manager.use('resize');

        this.effect = new VREffect(renderer);
        this.scene = _manager.get('scene');
        this.camera = _manager.get('camera');
        rendering.effect(this.effect); // TODO: Fix resize.

        resize.addCallback(function (width, height) {
          _this.effect.setSize(+width, +height);
        }); // WEBVR

        var _this$params = this.params,
            message = _this$params.message,
            button = _this$params.button;
        if (message) WEBVR.checkAvailability().catch(function (message) {
          document.body.appendChild(WEBVR.getMessageContainer(message));
        });
        if (button) WEBVR.getVRDisplay(function (display) {
          var vrbtn = WEBVR.getButton(display, renderer.domElement);
          vrbtn.className = 'vr-btn';
          document.body.appendChild(vrbtn);
        });
      }
    }]);
    return VRModule;
  }();
  var VR2Module =
  /*#__PURE__*/
  function () {
    function VR2Module() {
      _classCallCheck(this, VR2Module);
      this.display = new Promise(function (resolve) {
        return WEBVR.getVRDisplay(function (display) {
          return resolve(display);
        });
      });
    }

    _createClass(VR2Module, [{
      key: "manager",
      value: function manager(_manager2) {
        _manager2.define('vr');

        var renderer = _manager2.get('renderer');

        renderer.vr.enabled = true;
        console.log(REVISION$1);
        console.log(1);
        this.display.then(function (display) {
          renderer.vr.setDevice(display);
          var vrbtn = WEBVR.getButton(display, renderer.domElement);
          vrbtn.className = 'vr-btn';
          document.body.appendChild(vrbtn);
        });
      }
    }]);
    return VR2Module;
  }();
  var VRControls$1 =
  /*#__PURE__*/
  function (_ControlsModule) {
    function VRControls$$1(_ref) {
      var object = _ref.object,
          onError = _ref.onError,
          intensity = _ref.intensity;
      _classCallCheck(this, VRControls$$1);
      var controls = new VRControls(object.native, onError);
      controls.standing = true;
      controls.scale = intensity;
      return _possibleConstructorReturn(this, _getPrototypeOf(VRControls$$1).call(this, {
        controls: controls
      }));
    }

    _inherits(VRControls$$1, _ControlsModule);
    return VRControls$$1;
  }(ControlsModule);

  exports.WEBVR = WEBVR;
  exports.VRModule = VRModule;
  exports.VR2Module = VR2Module;
  exports.VRControls = VRControls$1;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=VRKit.js.map
