{"version":3,"sources":["physics/meshes/softMesh.js"],"names":[],"mappings":"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","file":"softMesh.js","sourcesContent":["import {Mesh} from '../core/mesh';\r\n\r\nexport class SoftMesh extends Mesh {\r\n  constructor(geometry, material, params = {}) {\r\n    console.log(geometry);\r\n    const tempGeometry = geometry.clone();\r\n\r\n    if (!(geometry instanceof THREE.BufferGeometry)) // Converts to BufferGeometry.\r\n      geometry = new THREE.BufferGeometry().fromGeometry(geometry);\r\n\r\n    super(geometry, material, params.mass);\r\n\r\n    tempGeometry.mergeVertices();\r\n    const idxGeometry = this.createIndexedBufferGeometryFromGeometry(tempGeometry);\r\n    if (!tempGeometry.boundingBox) tempGeometry.computeBoundingBox();\r\n    this.tempGeometry = tempGeometry;\r\n\r\n    const aVertices = idxGeometry.attributes.position.array;\r\n    const aIndices = idxGeometry.index.array;\r\n    const aIdxAssoc = [];\r\n    const vertices = geometry.attributes.position.array;\r\n\r\n    const numIdxVertices = aVertices.length / 3;\r\n    const numVertices = vertices.length / 3;\r\n\r\n    for (let i = 0; i < numIdxVertices; i++) {\r\n      const association = [];\r\n      aIdxAssoc.push(association);\r\n\r\n      const i3 = i * 3;\r\n\r\n      for (let j = 0; j < numVertices; j++) {\r\n        const j3 = j * 3;\r\n\r\n        if (this.isEqual(aVertices[i3], aVertices[i3 + 1], aVertices[i3 + 2], vertices[j3], vertices[j3 + 1], vertices[j3 + 2]))\r\n          association.push(j3);\r\n      }\r\n    }\r\n\r\n    const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;\r\n    const height = geometry.boundingBox.max.y - geometry.boundingBox.min.y;\r\n    const depth = geometry.boundingBox.max.z - geometry.boundingBox.min.z;\r\n\r\n    this._physijs.type = 'softbody';\r\n    this._physijs.aVertices = aVertices;\r\n    this._physijs.aIndices = aIndices;\r\n    this._physijs.aIdxAssoc = aIdxAssoc;\r\n\r\n    const physParams = params.physics;\r\n\r\n    this._physijs.params = {\r\n      friction: physParams.friction,\r\n      damping: physParams.damping,\r\n      pressure: physParams.pressure,\r\n      margin: physParams.margin\r\n    };\r\n\r\n    this._physijs.mass = (typeof params.mass === 'undefined') ? width * height * depth : params.mass;\r\n  }\r\n\r\n  createIndexedBufferGeometryFromGeometry(geometry) {\r\n    const numVertices = geometry.vertices.length;\r\n    const numFaces = geometry.faces.length;\r\n    const bufferGeom = new THREE.BufferGeometry();\r\n    const vertices = new Float32Array(numVertices * 3);\r\n    const indices = new (numFaces * 3 > 65535 ? Uint32Array : Uint16Array)(numFaces * 3);\r\n\r\n    for (let i = 0; i < numVertices; i++) {\r\n      const p = geometry.vertices[i];\r\n      const i3 = i * 3;\r\n\r\n      vertices[i3] = p.x;\r\n      vertices[i3 + 1] = p.y;\r\n      vertices[i3 + 2] = p.z;\r\n    }\r\n\r\n    for (let i = 0; i < numFaces; i++) {\r\n      const f = geometry.faces[i];\r\n      const i3 = i * 3;\r\n\r\n      indices[i3] = f.a;\r\n      indices[i3 + 1] = f.b;\r\n      indices[i3 + 2] = f.c;\r\n    }\r\n\r\n    bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));\r\n    bufferGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\r\n\r\n    return bufferGeom;\r\n  }\r\n\r\n  isEqual(x1, y1, z1, x2, y2, z2) {\r\n    const delta = 0.000001;\r\n\r\n    return Math.abs(x2 - x1) < delta\r\n      && Math.abs(y2 - y1) < delta\r\n      && Math.abs(z2 - z1) < delta;\r\n  }\r\n}\r\n"]}