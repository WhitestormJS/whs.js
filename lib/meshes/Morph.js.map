{"version":3,"sources":["meshes/Morph.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;IAAY,K;;AACZ;;IAAY,O;;AAEZ;;AACA;;AACA;;;;;;IAEM,K;;;AACJ,mBAAyB;AAAA,QAAb,MAAa,yDAAJ,EAAI;AAAA;;AAAA,uGACjB,MADiB,EACT,OADS;;AAGvB,qBAAO,OAAO,QAAd,EAAwB;AACtB,YAAM,EADgB;AAEtB;AAFsB,KAAxB;;AAKA,QAAI,OAAO,KAAX,EAAkB;AAChB,YAAK,KAAL,CAAW,MAAX;AACA,4FAAW,MAAX;AACD;AAXsB;AAYxB;;;;4BAEkB;AAAA;;AAAA,UAAb,MAAa,yDAAJ,EAAI;;AACjB,UAAM,UAAU,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAa;AACvC,YAAM,SAAS,OAAO,QAAP,CAAgB,MAA/B;;AAEA,eAAO,IAAP,CAAY,OAAO,QAAP,CAAgB,IAA5B,EAAkC,UAAC,IAAD,EAAO,SAAP,EAAqB;AACrD,cAAI,iBAAJ;AACA,cAAI,OAAO,QAAP,CAAgB,eAApB,EAAqC;AACnC,uBAAW,uBACT,iBAAO,OAAO,QAAd,EAAwB;AACtB,4BAAc,IADQ;AAEtB,4BAAc,MAAM;AAFE,aAAxB,CADS,EAKT,SALF;AAMD,WAPD,MAOO,IAAI,CAAC,SAAD,IAAc,OAAO,QAAP,CAAgB,iBAAlC,EAAqD;AAC1D,uBAAW,uBACT,OAAO,QADE,EAET,SAFF;AAGD,WAJM,MAIA,WAAW,IAAI,MAAM,aAAV,CAAwB,SAAxB,CAAX;;AAEP,eAAK,kBAAL;AACA,eAAK,oBAAL;;AAEA;AACA,cAAM,OAAO,IAAI,MAAM,IAAV,CAAe,IAAf,EAAqB,QAArB,CAAb;AACA,eAAK,KAAL,GAAa,OAAO,KAAP,CAAa,KAA1B;AACA,eAAK,KAAL,GAAa,IAAI,MAAM,cAAV,CAAyB,IAAzB,CAAb;;AAEA,eAAK,KAAL,CACG,UADH,CACc,KAAK,UAAL,CAAgB,CAAhB,CADd,EAEG,WAFH,CAEe,OAAO,KAAP,CAAa,QAF5B,EAGG,IAHH;;AAKA,iBAAK,SAAL,CAAe,IAAf;;AAEA;AACD,SA/BD;AAgCD,OAnCe,CAAhB;;AAqCA,0FAAW,OAAX;AACA,aAAO,OAAP;AACD;;;4BAEO;AACN,aAAO,IAAI,KAAJ,CAAU,EAAC,OAAO,KAAR,EAAV,EAA0B,IAA1B,CAA+B,IAA/B,CAAP;AACD;;;;;QAID,K,GAAA,K","file":"Morph.js","sourcesContent":["import * as THREE from 'three';\r\nimport * as Physijs from '../physics/index.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend, loadMaterial} from '../extras/api';\r\nimport {JSONLoader} from '../utils/loaders';\r\n\r\nclass Morph extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'morph');\r\n\r\n    extend(params.geometry, {\r\n      path: '',\r\n      loader: JSONLoader\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('wait');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const promise = new Promise((resolve) => {\r\n      const Loader = params.geometry.loader;\r\n\r\n      Loader.load(params.geometry.path, (data, materials) => {\r\n        let material;\r\n        if (params.material.useVertexColors) {\r\n          material = loadMaterial(\r\n            extend(params.material, {\r\n              morphTargets: true,\r\n              vertexColors: THREE.FaceColors\r\n            })\r\n          )._material;\r\n        } else if (!materials || params.material.useCustomMaterial) {\r\n          material = loadMaterial(\r\n            params.material\r\n          )._material;\r\n        } else material = new THREE.MultiMaterial(materials);\r\n\r\n        data.computeFaceNormals();\r\n        data.computeVertexNormals();\r\n\r\n        // Visualization.\r\n        const mesh = new THREE.Mesh(data, material);\r\n        mesh.speed = params.morph.speed;\r\n        mesh.mixer = new THREE.AnimationMixer(mesh);\r\n\r\n        mesh.mixer\r\n          .clipAction(data.animations[0])\r\n          .setDuration(params.morph.duration)\r\n          .play();\r\n\r\n        this.setNative(mesh);\r\n\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    super.wait(promise);\r\n    return promise;\r\n  }\r\n\r\n  clone() {\r\n    return new Morph({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Morph\r\n};\r\n"]}