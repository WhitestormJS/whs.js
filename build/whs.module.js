/* WhitestormJS Framework v2.1.8-vrfix.3 */
import { AdditiveBlending, AmbientLight, AnimationClip, AnimationMixer, BoxBufferGeometry, BoxGeometry, BufferAttribute, BufferGeometry, CircleBufferGeometry, CircleGeometry, Clock, Color, ConeBufferGeometry, ConeGeometry, CubeCamera, CylinderBufferGeometry, CylinderGeometry, DataTexture, DepthStencilFormat, DepthTexture, DirectionalLight, DodecahedronBufferGeometry, DodecahedronGeometry, EventDispatcher, ExtrudeGeometry, FloatType, Fog, FogExp2, Font, FontLoader, Geometry, HemisphereLight, IcosahedronBufferGeometry, IcosahedronGeometry, JSONLoader, LatheBufferGeometry, LatheGeometry, Line, LineCurve3, LinearFilter, LinearMipMapLinearFilter, MOUSE, Mesh, MeshBasicMaterial, NearestFilter, Object3D, OctahedronBufferGeometry, OctahedronGeometry, OrthographicCamera, ParametricBufferGeometry, ParametricGeometry, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PointLight, PolyhedronBufferGeometry, PolyhedronGeometry, Quaternion, REVISION, RGBAFormat, RGBFormat, Raycaster, RectAreaLight, RepeatWrapping, RingBufferGeometry, RingGeometry, Scene, ShaderMaterial, ShapeBufferGeometry, ShapeGeometry, SkinnedMesh, SphereBufferGeometry, SphereGeometry, Spherical, SpotLight, TetrahedronBufferGeometry, TetrahedronGeometry, TextGeometry, Texture, TextureLoader, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, TubeBufferGeometry, TubeGeometry, UVMapping, Uniform, UnsignedInt248Type, Vector2, Vector3, Vector4, WebGLRenderTarget, WebGLRenderer } from 'three';

var extend = function extend(object) {
  for (var _len = arguments.length, extensions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    extensions[_key - 1] = arguments[_key];
  }

  // $.extend alternative, ... is the spread operator.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var extension = _step.value;

      // console.log(extension);
      // console.log(typeof extension);

      if (!extension) continue; // Ignore null and undefined objects and parameters.

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Object.getOwnPropertyNames(extension)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var prop = _step2.value;
          // Do not traverse the prototype chain.
          if (object[prop] !== undefined && extension[prop] && object[prop].toString() === '[object Object]' && extension[prop].toString() === '[object Object]') {
            // Goes deep only if object[prop] and extension[prop] are both objects !
            if (object[prop].constructor === Object) extend(object[prop], extension[prop]);
          } else object[prop] = typeof object[prop] === 'undefined' ? extension[prop] : object[prop];

          if (typeof object[prop] === 'undefined' && Array.isArray(extension[prop])) object[prop] = extension[prop].slice(); // Add values that do not already exist.
          else if (typeof object[prop] === 'undefined' && Array.isArray(extension[prop])) object[prop] = extension[prop];
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return object;
};

var instruct = function instruct(array, instArray) {
  var tempObject = {};

  for (var i = 0, max = instArray.length; i < max; i++) {
    var guide = instArray[i];

    tempObject[guide] = array[i];
  }

  return tempObject;
};

var transformData = function transformData(object, instructions) {
  for (var key in instructions) {
    if (Array.isArray(object[key])) object[key] = instruct(object[key], instructions[key]);else if (object[key] instanceof Object && !Array.isArray(instructions[key])) object[key] = transformData(object[key], instructions[key]);
  }

  return object;
};

var toArray = function toArray(object, instruction) {
  var tempArray = [];

  for (var i = 0, max = instruction.length; i < max; i++) {
    var guide = instruction[i];

    tempArray[i] = object[guide];
  }

  return tempArray;
};

var minivents_commonjs = function Events(target){
  var events = {}, empty = [];
  target = target || this;
  /**
   *  On: listen to events
   */
  target.on = function(type, func, ctx){
    (events[type] = events[type] || []).push([func, ctx]);
  };
  /**
   *  Off: stop listening to event / specific callback
   */
  target.off = function(type, func){
    type || (events = {});
    var list = events[type] || empty,
        i = list.length = func ? list.length : 0;
    while(i--) func == list[i][0] && list.splice(i,1);
  };
  /** 
   * Emit: send event, callbacks will be triggered
   */
  target.emit = function(type){
    var e = events[type] || empty, list = e.length > 0 ? e.slice(0, e.length) : e, i=0, j;
    while(j=list[i++]) j[0].apply(j[1], empty.slice.call(arguments, 1));
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};





var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var CompositionError = function (_Error) {
  inherits(CompositionError, _Error);

  function CompositionError(classInstance, message, component) {
    classCallCheck(this, CompositionError);

    var _this = possibleConstructorReturn(this, (CompositionError.__proto__ || Object.getPrototypeOf(CompositionError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this.stack.split('\n');
    stackArray.splice(1, 2);

    _this.stack = stackArray.join('\n');

    if (console) console.error('Component:', component);

    _this.name = 'CompositionError';
    return _this;
  }

  return CompositionError;
}(Error);

var DependencyError = function (_Error2) {
  inherits(DependencyError, _Error2);

  function DependencyError(classInstance, message, activeModule) {
    var dependencyModule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    classCallCheck(this, DependencyError);

    var _this2 = possibleConstructorReturn(this, (DependencyError.__proto__ || Object.getPrototypeOf(DependencyError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this2.stack.split('\n');
    stackArray.splice(1, 2);

    _this2.stack = stackArray.join('\n');

    if (console) console.error('Active module:', activeModule);
    if (console && dependencyModule) console.error('Dependency published by module:', dependencyModule);

    _this2.name = 'DependencyError';
    return _this2;
  }

  return DependencyError;
}(Error);

var ManagerError = function (_Error3) {
  inherits(ManagerError, _Error3);

  function ManagerError(classInstance, message, component) {
    var activeModule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    classCallCheck(this, ManagerError);

    var _this3 = possibleConstructorReturn(this, (ManagerError.__proto__ || Object.getPrototypeOf(ManagerError)).call(this, '@' + classInstance + ': ' + message));

    var stackArray = _this3.stack.split('\n');
    stackArray.splice(1, 2);

    _this3.stack = stackArray.join('\n');

    if (console) console.error('Component:', component);
    if (console && activeModule) console.error('Active module:', activeModule);

    _this3.name = 'ManagerError';
    return _this3;
  }

  return ManagerError;
}(Error);

// Check for Three.js
var warnDeps = function warnDeps() {
  throw new Error('WhitestormJS Framework requires Three.js r84. https://threejs.org/');
};

try {
  if (!REVISION) warnDeps();
} catch (err) {
  warnDeps();
}

/**
 * @class ModuleSystem
 * @category core
 * @description  Provides API for classes that will use Modules.<br/>
 * This class includes basic event system with those supported methods:
 * <pre>.on()</pre><pre>.off()</pre><pre>.emit()</pre>
 * @extends Events
 * @memberof module:core
 */

var ModuleSystem = function (_Events) {
  inherits(ModuleSystem, _Events);

  function ModuleSystem() {
    classCallCheck(this, ModuleSystem);
    return possibleConstructorReturn(this, (ModuleSystem.__proto__ || Object.getPrototypeOf(ModuleSystem)).apply(this, arguments));
  }

  createClass(ModuleSystem, [{
    key: 'integrateModules',

    // INTEGRATING

    /**
     * @method integrateModules
     * @instance
     * @description This method applies all modules from .modules collection.
     * @param {Object} [source] If source (should be a component) is provided, will replace .modules with source's one before executing modules.
     * @memberof module:core.ModuleSystem
     */
    value: function integrateModules(source) {
      if (!this.modules && !source) return;
      if (source && source.modules) this.modules = source.modules.slice(0);

      if (this.modules) {
        for (var i = 0, max = this.modules.length; i < max; i++) {
          this.applyModule(this.modules[i], false);
        }
      }

      if (source) this.applyBridge({ onCopy: source });
    }

    // APPLYING MODULE (...and a "bridge" for module)

    /**
     * @method applyBridge
     * @instance
     * @description Makes component-specific API to work with modules.
     * @param {Object} bridgeMap
     * @return {Object} Returns object with modified values.
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyBridge',
    value: function applyBridge() {
      var bridgeMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var modules = this.modules;
      if (!modules) return bridgeMap;

      for (var i = 0, max = modules.length; i < max; i++) {
        for (var key in bridgeMap) {
          if (bridgeMap[key]) {
            var module = modules[i];

            if (module && module.bridge && module.bridge[key]) bridgeMap[key] = module.bridge[key].apply(this, [bridgeMap[key], module]);
          }
        }
      }

      return bridgeMap;
    }

    /**
     * @method applyCommand
     * @instance
     * @description .applyCommand runs a method called `name` on all modules.
     * @param {String} name the method name.
     * @param {Function} [cb=(func, moduleScope) => func.apply(this, [moduleScope])] How the function is wrapped/
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyCommand',
    value: function applyCommand(name) {
      var _this2 = this;

      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (func, moduleScope) {
        return func.apply(_this2, [moduleScope]);
      };

      var modules = this.modules;
      if (!modules) return;

      for (var i = 0, max = modules.length; i < max; i++) {
        var module = modules[i];
        if (name in module) cb(module[name], module);
      }
    }

    /**
     * @method applyModule
     * @instance
     * @description .applyModule is also used in .integrateModules() function.
     * It does exactly what its name says (applies module to component or app).
     * @param {Object} module the module to apply
     * @param {Boolean} [push=true]
     * @return {Object} Returns module that was applied.
     * @throws {ManagerError}
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'applyModule',
    value: function applyModule(module) {
      var push = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!module) return;
      if (push && this.modules) this.modules.push(module);else if (push) this.modules = [module];

      if (this.manager) this.manager.active(module);

      if (module.manager && this.manager) module.manager(this.manager);else if (module.manager) {
        throw new ManagerError('Component', 'Module requires ModuleManager that is turned off for this component', this, module);
      }

      if (module.integrate) module.integrate.bind(this)(module);

      return module;
    }

    /**
     * @method disposeModules
     * @instance
     * @description Disposes of all modules
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'disposeModules',
    value: function disposeModules() {
      while (this.modules.length) {
        this.disposeModule(this.modules[0]);
      }
    }

    /**
     * @method disposeModule
     * @instance
     * @description Disposes of the given module
     * @param {Object} module the module to dispose
     * @return {Module} Returns module that was removed.
     * @memberof module:core.ModuleSystem
     */

  }, {
    key: 'disposeModule',
    value: function disposeModule(module) {
      if (!module) return;

      this.modules.splice(this.modules.indexOf(module), 1);

      if (module.dispose) module.dispose.bind(this)(module);

      return module;
    }

    // PIPED METHOD

    /**
     * @method module
     * @instance
     * @description piped version of .applyModule().
     * @param {Object} module the module to apply
     * @return {this} returns this - app/component
     * @throws {ManagerError}
     * @memberof module:core.ModuleSystem
     * @example <caption>Piped modules</caption>
     * component
     *   .module(new Module1())
     *   .module(new Module2())
     *   .module(new Module3())
     */

  }, {
    key: 'module',
    value: function module(_module) {
      this.applyModule(_module);
      return this;
    }
  }]);
  return ModuleSystem;
}(minivents_commonjs);

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$2.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype;
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root$2;

if (typeof self !== 'undefined') {
  root$2 = self;
} else if (typeof window !== 'undefined') {
  root$2 = window;
} else if (typeof global !== 'undefined') {
  root$2 = global;
} else if (typeof module !== 'undefined') {
  root$2 = module;
} else {
  root$2 = Function('return this')();
}

var result = symbolObservablePonyfill(root$2);

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */
};function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[result] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[result] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if (undefined !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}

/**
 * @class ModuleManager
 * @category core
 * @param {Object} object handler
 * @description  Solves modules dependencies
 * @memberof module:core
 */
var ModuleManager = function () {
  function ModuleManager(object) {
    classCallCheck(this, ModuleManager);

    this.handler = object;
    this.currentModule = null;

    this.store = createStore(function () {
      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [{}, ''];
      var action = arguments[1];

      state[0][action.key] = action.data;
      state[1] = action.key;

      return state;
    });

    this.modules = {};
  }

  /**
   * @method active
   * @instance
   * @description Sets .currentModule to provided module.
   * @param {Object} module the module to make current
   * @memberof module:core.ModuleManager
   */


  createClass(ModuleManager, [{
    key: 'active',
    value: function active(module) {
      this.currentModule = module;
    }

    /**
     * @method reset
     * @instance
     * @description Set's .currentModule to null.
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.currentModule = null;
    }

    /**
     * @method define
     * @instance
     * @description Define the module in manager
     * @param name The module name
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'define',
    value: function define(name) {
      this.modules[name] = this.currentModule;
    }

    /**
     * @method use
     * @instance
     * @description Get the defined module from manager
     * @param name The module name
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'use',
    value: function use(name) {
      return this.modules[name];
    }

    /**
     * @method set
     * @instance
     * @description An alias for .add() <br/><br/>
     * Use this method if you know that you will overwrite existing dependency.<br/>
     * Use it in your app, but not in module that you provide to other people.
     * @param {String} key the key of the dependency
     * @param {Object} data the value of the dependency
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'set',
    value: function set$$1(key, data) {
      this.store.dispatch({
        type: 'ADD',
        key: key,
        data: data
      });
    }

    /**
     * @method get
     * @instance
     * @description Returns dependency in store object, by key.
     * @param {String} key the key of the dependency
     * @memberof module:core.ModuleManager
     * @return {Object|Module}
     * @throws {DependencyError} if dependency is not in the store
     * @example <caption>Get the 'hello' dependency</caption>
     * manager.get('hello'); // -> {world: true}
     */

  }, {
    key: 'get',
    value: function get$$1(key) {
      if (!this.store.getState()[0][key]) {
        throw new DependencyError('ModuleManager', 'Module requires \'' + key + '\' dependency', this.currentModule);
      }

      return this.store.getState()[0][key];
    }

    /**
     * @method has
     * @instance
     * @description Returns whether manager has a dependency with the given key
     * @param {String} key the key of the dependency
     * @memberof module:core.ModuleManager
     * @return {Boolean} Promise that is resolved when all promises completed.
     * @example <caption>Check whether the store has the 'hello' dependency</caption>
     * manager.has('hello'); // -> true
     */

  }, {
    key: 'has',
    value: function has(key) {
      return Boolean(this.store.getState()[0][key]);
    }

    /**
     * @method update
     * @instance
     * @description Updates deps
     * @param {Object} [depsMap={}]
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'update',
    value: function update() {
      var _this = this;

      var depsMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.store.subscribe(function () {
        var _store$getState = _this.store.getState(),
            _store$getState2 = slicedToArray(_store$getState, 2),
            data = _store$getState2[0],
            changedKey = _store$getState2[1];

        var callback = depsMap[changedKey];

        if (callback) callback(data[changedKey]);
      });
    }

    /**
     * @method add
     * @alias module:core.ModuleManager#set
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'add',
    value: function add() {
      console.warn('.add() method is deprecated. Use .set() instead');
      return this.set.apply(this, arguments);
    }

    /**
     * @method require
     * @instance
     * @description Require module
     * @param {String} name Defined name
     * @param {Function} moduleExecutor Function that returns applied module
     * @memberof module:core.ModuleManager
     */

  }, {
    key: 'require',
    value: function require(name, moduleExecutor) {
      if (this.use(name) === undefined) this.handler.applyModule(moduleExecutor());
    }
  }]);
  return ModuleManager;
}();

var _class;
var _temp;

/**
 * @class Component
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends ModuleSystem
 * @memberof module:core
 */
var Component = (_temp = _class = function (_ModuleSystem) {
  inherits(Component, _ModuleSystem);

  // For keeping children components;

  // Collection of promises;

  /**
   * Collection of `modules`.
   * @member {Array} module:core.Component#modules
   * @public
   */


  /**
   * Static instructions
   * @member {Object} module:core.Component#instructions
   * @static
   * @default {}
   */
  function Component() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Component.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Component.instructions;
    classCallCheck(this, Component);

    // Apply polyfilled parameters to .params;
    var _this = possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));

    _this._wait = [];
    _this.modules = [];
    _this.children = [];
    _this.params = extend(transformData(params, instructions), defaults$$1);
    if (_this.params.manager) _this.manager = new ModuleManager(_this);

    _this.modules = _this.params.modules;

    _this.integrateModules();
    return _this;
  }

  /**
   * @method wait
   * @instance
   * @description Wait for a promise.
   * @param {Promise} [promise] - The promise that should be added to a queue.
   * @return {Promise} Promise that is resolved when all promises completed.
   * @memberof module:core.Component
   */
  // Collection of modules;

  /**
   * Collection of `child` Components.
   * @member {Array} module:core.Component#children
   * @public
   */


  /**
   * Array of promises that should be resolved before Component is ready.
   * @member {Array} module:core.Component#_wait
   * @private
   */

  /**
   * Default values for parameters
   * @member {Object} module:core.Component#defaults
   * @static
   * @default {
   *   modules: [],
   *   manager: true
   * }
   */


  createClass(Component, [{
    key: 'wait',
    value: function wait(promise) {
      if (promise) this._wait.push(promise);
      return Promise.all(this._wait);
    }

    /**
     * @method defer
     * @instance
     * @description Execute `func` (Callback) when Component is ready.
     * @param {Function} func - Callback.
     * @memberof module:core.Component
     */

  }, {
    key: 'defer',
    value: function defer(func) {
      var _this2 = this;

      if (this.isDeffered) this.wait().then(function () {
        return func(_this2);
      });else func(this);
    }

    // PARAMETERS

    /**
     * @method updateParams
     * @instance
     * @description Updates parameters of the Component.
     * @return {Object} Params of this Component
     * @memberof module:core.Component
     */

  }, {
    key: 'updateParams',
    value: function updateParams() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.params = extend(params, this.params);
      return this.params;
    }

    // COPYING & CLONING

    /**
     * @method clone
     * @instance
     * @description Clone this component
     * @return {object} a cloned component with all its source component' params copied.
     * @memberof module:core.Component
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor(this.params).copy(this);
    }

    /**
     * @method copy
     * @instance
     * @description Copy source native and integrate `modules` to it.
     * @param {Component} source - Source component that is used for `copy()` action.
     * @param {Function} [customize] - Callback executed before modules integration process.
     * @return {this} Component
     * @memberof module:core.Component
     */

  }, {
    key: 'copy',
    value: function copy(source, customize) {
      this.params = _extends({}, source.params);

      if (source.native) this.native = source.native.clone(source.params);
      if (customize) customize();
      this.integrateModules(source);

      return this;
    }

    /**
     * @method add
     * @instance
     * @description Add a child `Component`.
     * @param {Component} object - Component that should be added as a `child`.
     * @return {Promise} Resolved when action is done.
     * @memberof module:core.Component
     */

  }, {
    key: 'add',
    value: function add(object) {
      var _this3 = this;

      object.parent = this;

      return new Promise(function (resolve, reject) {
        object.defer(function () {
          var native = object.native;

          if (!native) reject();

          var addPromise = _this3.applyBridge({ onAdd: object }).onAdd;

          var resolver = function resolver() {
            _this3.native.add(native);
            _this3.children.push(object);

            resolve(object);
          };

          if (addPromise instanceof Promise) addPromise.then(resolver);else resolver();
        });
      });
    }

    /**
     * @method remove
     * @instance
     * @description Remove a child `Component`.
     * @param {Component} object - Component that should be a **child** of this Component.
     * @memberof module:core.Component
     */

  }, {
    key: 'remove',
    value: function remove(object) {
      object.parent = null;
      this.native.remove(object.native);
    }

    /**
     * @method addTo
     * @instance
     * @description Adds `this` Component to specified `App`/`Component`.
     * @param {Component} object - Component that will be a parent of `this`.
     * @memberof module:core.Component
     */

  }, {
    key: 'addTo',
    value: function addTo(object) {
      return object.add(this);
    }
  }, {
    key: 'get',
    value: function get$$1(key) {
      return this.manager.get(key);
    }
  }, {
    key: 'use',
    value: function use(key) {
      return this.manager.use(key);
    }

    /**
     * Returns whether the object is `async` (`wait` promises are more than `0`).
     * @member {Boolean} module:core.Component#isDeffered
     */

  }, {
    key: 'isDeffered',
    get: function get$$1() {
      return this._wait.length > 0;
    }

    /**
     * Returns the `ModuleManager` used for this component.
     * @member {ModuleManager} module:core.Component#manager
     * @throws {ManagerError}
     */

  }, {
    key: 'manager',
    get: function get$$1() {
      if (this._manager) return this._manager;

      throw new ManagerError('Component', 'ModuleManager is not used in this component. \'manager\' parameter should be set as \'true\'', this);
    },
    set: function set$$1(manager) {
      this._manager = manager;
    }

    /**
     * Returns the `native` object used for this component.
     * @member {Object} module:core.Component#native
     */

  }, {
    key: 'native',
    get: function get$$1() {
      return this._native;
    },
    set: function set$$1(mesh) {
      this._native = mesh;
      this._native.component = this;
      return this._native;
    }
  }]);
  return Component;
}(ModuleSystem), _class.defaults = {
  modules: null,
  manager: true
}, _class.instructions = {}, _temp);

function attributes() {
  for (var _len = arguments.length, mappers = Array(_len), _key = 0; _key < _len; _key++) {
    mappers[_key] = arguments[_key];
  }

  return function (target) {
    for (var i = 0; i < mappers.length; i++) {
      var mapper = mappers[i];

      for (var k = 0; k < mapper.map.length; k++) {
        var attribute = mapper.map[k];

        Object.defineProperty(target.prototype, attribute, {
          get: mapper.getter(attribute),
          set: mapper.setter(attribute),
          configurable: mapper.configurable,
          enumerable: mapper.enumerable
        });
      }
    }
  };
}

function copy() {
  for (var _len2 = arguments.length, map = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    map[_key2] = arguments[_key2];
  }

  return {
    map: map,
    getter: function getter(name) {
      return function () {
        return this.native[name];
      };
    },
    setter: function setter(name) {
      return function (value) {
        this.native[name].copy(value);
      };
    },

    configurable: true,
    enumerable: true
  };
}

function mirror() {
  for (var _len3 = arguments.length, map = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    map[_key3] = arguments[_key3];
  }

  return {
    map: map,
    getter: function getter(name) {
      return function () {
        return this.native[name];
      };
    },
    setter: function setter(name) {
      return function (value) {
        this.native[name] = value;
      };
    },

    configurable: true,
    enumerable: true
  };
}

var _dec;
var _class$1;
var _class2;
var _temp$1;

/**
 * @class MeshComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var MeshComponent = (_dec = attributes(copy('position', 'rotation', 'quaternion', 'scale'), mirror('material', 'geometry')), _dec(_class$1 = (_temp$1 = _class2 = function (_Component) {
  inherits(MeshComponent, _Component);
  createClass(MeshComponent, null, [{
    key: 'custom',


    // CUSTOM GEOMETRY HANDLING

    /**
     * Default values for parameters
     * @member {Object} module:core.MeshComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *   geometry: {},
     *   material: false,
     *
     *   shadow: {
     *     cast: true,
     *     receive: true
     *   },
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0},
     *   scale: {x: 1, y: 1, z: 1}
     * }
     */
    value: function custom(geom) {
      var constructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mesh;

      return function (_MeshComponent) {
        inherits(_class3, _MeshComponent);

        function _class3() {
          classCallCheck(this, _class3);
          return possibleConstructorReturn(this, (_class3.__proto__ || Object.getPrototypeOf(_class3)).apply(this, arguments));
        }

        createClass(_class3, [{
          key: 'build',
          value: function build() {
            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

            var _applyBridge = this.applyBridge({
              geometry: geom,
              material: params.material
            }),
                geometry = _applyBridge.geometry,
                material = _applyBridge.material;

            return this.applyBridge({ mesh: new constructor(geometry, material) }).mesh;
          }
        }]);
        return _class3;
      }(MeshComponent);
    }

    /**
     * Static instructions
     * @member {Object} module:core.MeshComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z'],
     *   scale: ['x', 'y', 'z']
     * }
     */

  }, {
    key: 'create',
    value: function create(geom, params, constructor) {
      return new (MeshComponent.custom(geom, constructor))(params);
    }
  }, {
    key: 'from',
    value: function from(mesh) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      params.build = false;

      var component = new MeshComponent(params);

      component.native = mesh;
      component.wrap();

      return component;
    }
  }]);

  function MeshComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MeshComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MeshComponent.instructions;
    classCallCheck(this, MeshComponent);

    var _this = possibleConstructorReturn(this, (MeshComponent.__proto__ || Object.getPrototypeOf(MeshComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('MeshComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        _this.wait(build);

        _this.wait(new Promise(function (resolve) {
          build.then(function (native) {
            _this.native = native;
            _this.wrap().then(resolve);
          });
        }));
      } else {
        _this.native = build;
        _this.wait(_this.wrap());
      }
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.MeshComponent
   */


  createClass(MeshComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('MeshComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this3 = this;

      return new Promise(function (resolve) {
        // TODO: Fix defer with physics
        // this.defer(() => {
        var _params = _this3.params,
            position = _params.position,
            rotation = _params.rotation,
            scale = _params.scale,
            shadow = _params.shadow;


        _this3.position.set(position.x, position.y, position.z);
        _this3.rotation.set(rotation.x, rotation.y, rotation.z);
        _this3.scale.set(scale.x, scale.y, scale.z);

        _this3.native.castShadow = shadow.cast;
        _this3.native.receiveShadow = shadow.receive;

        _this3.applyBridge({ onWrap: 1 });

        resolve(_this3);
        // });
      });
    }

    // COPYING & CLONING

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} MeshComponent
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this4 = this;

      return get(MeshComponent.prototype.__proto__ || Object.getPrototypeOf(MeshComponent.prototype), 'copy', this).call(this, source, function () {
        _this4.position.copy(source.position);
        _this4.rotation.copy(source.rotation);
        _this4.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this MeshComponent using `.copy()`
     * @return {MeshComponent} clone of this object
     * @memberof module:core.MeshComponent
     */

  }, {
    key: 'clone',
    value: function clone(geometry, material) {
      var dest = new this.constructor({ build: false }).copy(this);

      if (geometry) dest.geometry = dest.geometry.clone();
      if (material) dest.material = dest.material.clone();

      return dest;
    }
  }]);
  return MeshComponent;
}(Component), _class2.defaults = _extends({}, Component.defaults, {

  build: true,
  geometry: {},
  material: false,

  shadow: {
    cast: true,
    receive: true
  },

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 },
  scale: { x: 1, y: 1, z: 1 }
}), _class2.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z'],
  scale: ['x', 'y', 'z']
}, _temp$1)) || _class$1);

var _dec$1;
var _class$2;
var _class2$1;
var _temp$2;

/**
 * @class LightComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var LightComponent = (_dec$1 = attributes(copy('position', 'rotation', 'quaternion', 'target')), _dec$1(_class$2 = (_temp$2 = _class2$1 = function (_Component) {
  inherits(LightComponent, _Component);
  createClass(LightComponent, null, [{
    key: 'from',

    /**
     * Default values for parameters
     * @member {Object} module:core.LightComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *
     *   shadow: {
     *     cast: true,
     *
     *     bias: 0,
     *     radius: 1,
     *
     *     mapSize: {
     *       width: 1024,
     *       height: 1024
     *     },
     *
     *     camera: {
     *       near: true,
     *       far: 400,
     *       fov: 90,
     *
     *       top: 200,
     *       bottom: -200,
     *       left: -200,
     *       right: 200
     *     }
     *   },
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0}
     * }
     */
    value: function from(light) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var wrapShadow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      params.build = false;

      var component = new LightComponent(params);

      component.native = light;
      component.wrap();
      if (wrapShadow) component.wrapShadow();

      return component;
    }

    /**
     * Static instructions
     * @member {Object} module:core.LightComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z']
     * }
     */

  }]);

  function LightComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LightComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : LightComponent.instructions;
    classCallCheck(this, LightComponent);

    var _this = possibleConstructorReturn(this, (LightComponent.__proto__ || Object.getPrototypeOf(LightComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('LightComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        build.then(function (native) {
          _this.native = native;
        });
      } else _this.native = build;

      _this.wait(_this.wrap());
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @instance
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.LightComponent
   */


  createClass(LightComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('MeshComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.defer(function () {
          var _params = _this2.params,
              position = _params.position,
              rotation = _params.rotation;


          _this2.position.set(position.x, position.y, position.z);
          _this2.rotation.set(rotation.x, rotation.y, rotation.z);

          _this2.applyBridge({ onWrap: 1 });

          resolve(_this2);
        });
      });
    }

    /**
     * @method wrapShadow
     * @instance
     * @description Wraps shadow properties
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'wrapShadow',
    value: function wrapShadow() {
      var native = this.native,
          shadow = this.params.shadow;


      native.castShadow = shadow.cast;
      native.shadow.mapSize.width = shadow.mapSize.width;
      native.shadow.mapSize.height = shadow.mapSize.height;
      native.shadow.bias = shadow.bias;
      native.shadow.radius = shadow.radius;

      var shadowCamera = native.shadow.camera;
      var camera = shadow.camera;

      shadowCamera.near = camera.near;
      shadowCamera.far = camera.far;
      shadowCamera.fov = camera.fov;

      shadowCamera.left = camera.left;
      shadowCamera.right = camera.right;
      shadowCamera.top = camera.top;
      shadowCamera.bottom = camera.bottom;
    }

    // COPYING & CLONING

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} LightComponent
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this3 = this;

      return get(LightComponent.prototype.__proto__ || Object.getPrototypeOf(LightComponent.prototype), 'copy', this).call(this, source, function () {
        if (_this3.target) _this3.target.copy(source.target());

        _this3.position.copy(source.position);
        _this3.rotation.copy(source.rotation);
        _this3.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this LightComponent using `.copy()`
     * @return {LightComponent} clone of this object
     * @memberof module:core.LightComponent
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor({ build: false }).copy(this);
    }
  }]);
  return LightComponent;
}(Component), _class2$1.defaults = _extends({}, Component.defaults, {

  build: true,

  shadow: {
    cast: true,

    bias: 0,
    radius: 1,

    mapSize: {
      width: 1024,
      height: 1024
    },

    camera: {
      near: true,
      far: 400,
      fov: 90,

      top: 200,
      bottom: -200,
      left: -200,
      right: 200
    }
  },

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 }
}), _class2$1.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z']
}, _temp$2)) || _class$2);

var _dec$2;
var _class$3;
var _class2$2;
var _temp$3;

/**
 * @class CameraComponent
 * @category core
 * @param {Object} [params] - The parameters object.
 * @param {Object} [instructions] - The instructions object.
 * @extends module:core.Component
 * @memberof module:core
 */
var CameraComponent = (_dec$2 = attributes(copy('position', 'rotation', 'quaternion', 'target')), _dec$2(_class$3 = (_temp$3 = _class2$2 = function (_Component) {
  inherits(CameraComponent, _Component);
  createClass(CameraComponent, null, [{
    key: 'from',

    /**
     * Default values for parameters
     * @member {Object} module:core.CameraComponent#defaults
     * @static
     * @default
     * {
     *   build: true,
     *
     *   position: {x: 0, y: 0, z: 0},
     *   rotation: {x: 0, y: 0, z: 0}
     * }
     */
    value: function from(camera) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      params.build = false;

      var component = new CameraComponent(params);

      component.native = camera;
      component.wrap();

      return component;
    }

    /**
     * Static instructions
     * @member {Object} module:core.CameraComponent#instructions
     * @static
     * @default
     * {
     *   position: ['x', 'y', 'z'],
     *   rotation: ['x', 'y', 'z'],
     *   scale: ['x', 'y', 'z']
     * }
     */

  }]);

  function CameraComponent(params) {
    var defaults$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CameraComponent.defaults;
    var instructions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CameraComponent.instructions;
    classCallCheck(this, CameraComponent);

    var _this = possibleConstructorReturn(this, (CameraComponent.__proto__ || Object.getPrototypeOf(CameraComponent)).call(this, params, defaults$$1, instructions));

    if (_this.params.build) {
      var build = _this.build(_this.params);

      if (!build) {
        throw new CompositionError('CameraComponent', '.build() method should return a THREE.Object3D or a Promise resolved with THREE.Object3D.', _this);
      }

      if (build instanceof Promise) {
        build.then(function (native) {
          _this.native = native;
        });
      } else _this.native = build;

      _this.wait(_this.wrap());
    }

    _this.applyCommand('postIntegrate');
    return _this;
  }

  // BUILDING & WRAPPING

  /**
   * @method build
   * @instance
   * @description Build livecycle should return a native object.
   * @throws {CompositionError}
   * @memberof module:core.CameraComponent
   */


  createClass(CameraComponent, [{
    key: 'build',
    value: function build() {
      throw new CompositionError('CameraComponent', 'Instance should have it\'s own .build().', this);
    }

    /**
     * @method wrap
     * @instance
     * @description Wraps transforms (`position` & `rotation`)
     * @return {Promise} Resolved when action is completed
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'wrap',
    value: function wrap() {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.defer(function () {
          _this2.position.set(_this2.params.position.x, _this2.params.position.y, _this2.params.position.z);
          _this2.rotation.set(_this2.params.rotation.x, _this2.params.rotation.y, _this2.params.rotation.z);

          _this2.applyBridge({ onWrap: 1 });

          resolve(_this2);
        });
      });
    }

    /**
     * @method copy
     * @instance
     * @description Copy source transforms & execute `Component.copy()`
     * @return {this} CameraComponent
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'copy',
    value: function copy$$1(source) {
      var _this3 = this;

      return get(CameraComponent.prototype.__proto__ || Object.getPrototypeOf(CameraComponent.prototype), 'copy', this).call(this, source, function () {
        if (_this3.target) _this3.target.copy(source.target());

        _this3.position.copy(source.position);
        _this3.rotation.copy(source.rotation);
        _this3.quaternion.copy(source.quaternion);
      });
    }

    /**
     * @method clone
     * @instance
     * @description Make a clone of this CameraComponent using `.copy()`
     * @return {CameraComponent} clone of this object
     * @memberof module:core.CameraComponent
     */

  }, {
    key: 'clone',
    value: function clone() {
      return new this.constructor({ build: false }).copy(this);
    }
  }]);
  return CameraComponent;
}(Component), _class2$2.defaults = _extends({}, Component.defaults, {

  build: true,

  position: { x: 0, y: 0, z: 0 },
  rotation: { x: 0, y: 0, z: 0 }
}), _class2$2.instructions = {
  position: ['x', 'y', 'z'],
  rotation: ['x', 'y', 'z'],
  scale: ['x', 'y', 'z']
}, _temp$3)) || _class$3);

const version = "2.1.8-vrfix.3";

var system = {
  window: typeof window === 'undefined' ? global : window
};

/**
 * @class App
 * @category core
 * @description This component is used to prepare a world scene, setup physics, camera, renderer and all other things that you usually do before making meshes.
 * @param {Array} [modules=[]] - Array of Modules
 * @extends ModuleSystem
 * @memberof module:core
 */

var App = function (_ModuleSystem) {
  inherits(App, _ModuleSystem);

  /**
   * @description Defines whether the scene should render or not
   * @member {Boolean} module:core.App#enabled
   * @public
   */
  function App() {
    var modules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, App);

    console.log('WHS.App ' + version);

    var _this = possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this));

    _this.enabled = true;
    _this.loops = [];

    _this.manager = new ModuleManager(_this);
    _this.modules = modules;

    _this.integrateModules();
    return _this;
  }

  // CONTROLS & UPDATING

  /**
   * @method start
   * @description Start rendering loop and physics simulation (if you use version with physics).
   * @memberof module:core.App
   */


  /**
   * Loops in this app
   * @description Array of loops that are executed by this app.
   * @member {Array} module:core.App#loops
   * @public
   */


  createClass(App, [{
    key: 'start',
    value: function start() {
      var requestAnimFrame = function () {
        return system.window.requestAnimationFrame || system.window.webkitRequestAnimationFrame || system.window.mozRequestAnimationFrame || function (callback) {
          system.window.setTimeout(callback, 1000 / 60);
        };
      }();

      var loops = this.loops,
          enabled = this.enabled;


      function process() {
        requestAnimFrame(process);
        if (!enabled) return;

        for (var i = 0, ll = loops.length; i < ll; i++) {
          var e = loops[i];
          if (e.enabled) e.execute(e.clock);
        }
      }

      this.enabled = true;
      process();
    }

    /**
     * @method stop
     * @description Stops rendering loops
     * @memberof module:core.App
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.enabled = false;
    }

    /**
     * @method addLoop
     * @description Adds loop to this app.
     * @param {Object} loop - the loop to add
     * @return {Promise} Promise that is resolved when promises completed.
     * @memberof module:core.App
     * @example <caption>Adding a loop to an app</caption>
     * const loop = new Loop(() => {
     *  // ...
     * });
     *
     * const app = new App();
     *
     * app.addLoop(loop);
     * loop.start();
     */

  }, {
    key: 'addLoop',
    value: function addLoop(loop) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.loops.push(loop);
        resolve(loop);
      });
    }

    /**
     * @method removeLoop
     * @description Removes loop from this app.
     * @param {Object} loop - the loop to remove
     * @return {Promise} Promise that is resolved when promises completed.
     * @memberof module:core.App
     */

  }, {
    key: 'removeLoop',
    value: function removeLoop(loop) {
      var _this3 = this;

      return new Promise(function (resolve) {
        var index = _this3.loops.indexOf(loop);
        if (index !== -1) _this3.loops.splice(index, 1);

        resolve(loop);
      });
    }
  }, {
    key: 'get',
    value: function get$$1(key) {
      return this.manager.get(key);
    }
  }, {
    key: 'use',
    value: function use(key) {
      return this.manager.use(key);
    }
  }]);
  return App;
}(ModuleSystem);

/**
 * @class Loop
 * @category core
 * @param {Function} func function to execute on each animation frame
 * @param {Boolean} [useClock=true] passes a Clock to the function when called, if true
 * @memberof module:core
 */

var Loop = function () {
  function Loop(func) {
    var useClock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    classCallCheck(this, Loop);

    this.func = func;
    this.clock = useClock ? new Clock() : null;
    this.enabled = false;
  }

  // CONTROLS

  /**
   * @method start
   * @instance
   * @description Starts this loop, clock if it has one. Won't do anything if loop enabled already.
   * @param {Component} [world] app to add this loop to, if provided.
   * @memberof module:core.Loop
   */


  createClass(Loop, [{
    key: 'start',
    value: function start(world) {
      if (this.enabled) return;

      if (world) world.addLoop(this);

      if (this.clock) this.clock.start();
      this.enabled = true;
    }

    /**
     * @method stop
     * @instance
     * @description Stops this loop and its clock if it has one, won't do anything if this loop is not enabled)
     * @param {Component} [world] app to remove this loop from, if provided.
     * @memberof module:core.Loop
     */

  }, {
    key: 'stop',
    value: function stop(world) {
      if (!this.enabled) return;

      if (this.clock) this.clock.stop();
      this.enabled = false;

      if (world) world.removeLoop(this);
    }

    // EXECUTION

    /**
     * @method execute
     * @instance
     * @description Executes the function of this loop
     * @memberof module:core.Loop
     * @returns {*} whatever the function of this loop returns
     */

  }, {
    key: 'execute',
    value: function execute() {
      return this.func(this.clock);
    }
  }]);
  return Loop;
}();

/** @module core */

var _class$4;
var _temp$4;

/**
 * @class AmbientLight
 * @category components/lights
 * @description AmbientLight is a simple class, it extends Light and inherits all its methods.
 * AmbientLight creates basic light around all scene, so it doesn't need properties like pos or target.
 * It supports only color and intensity as parameters, which defines the color of the surrounded light and intensity of light.
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating an AmbientLight </caption>
 * new AmbientLight({
 *   color: 0xffffff,
 *   intensity: 0.2
 * }).addTo(world);
 */
var AmbientLight$1 = (_temp$4 = _class$4 = function (_LightComponent) {
  inherits(AmbientLight$$1, _LightComponent);

  function AmbientLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AmbientLight$$1);
    return possibleConstructorReturn(this, (AmbientLight$$1.__proto__ || Object.getPrototypeOf(AmbientLight$$1)).call(this, params, AmbientLight$$1.defaults));
  }

  createClass(AmbientLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new AmbientLight(params.color, params.intensity) }).light;
    }
  }]);
  return AmbientLight$$1;
}(LightComponent), _class$4.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1
}), _temp$4);

var _class$5;
var _temp$5;

/**
 * @class DirectionalLight
 * @category components/lights
 * @description DirectinalLight creates a light that shines from a specific direction not from a specific position.<br/><br/>
 * This light will behave as though it is infinitely far away and the rays produced from it are all parallel. <br/><br/>
 * The best analogy would be a light source that acts like the sun: the sun is so far away that all sunlight hitting objects comes from the same angle.<br/><br/>
 * It has the same options as AmbientLight in light paramater, but it also supports pos and target paramaters.
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a DirectionalLight to fall down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
 * new DirectionalLight({
 *   color: 0xffffff,
 *   intensity: 0.2,
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var DirectionalLight$1 = (_temp$5 = _class$5 = function (_LightComponent) {
  inherits(DirectionalLight$$1, _LightComponent);

  function DirectionalLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DirectionalLight$$1);

    var _this = possibleConstructorReturn(this, (DirectionalLight$$1.__proto__ || Object.getPrototypeOf(DirectionalLight$$1)).call(this, params, DirectionalLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(DirectionalLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new DirectionalLight(params.color, params.intensity) }).light;
    }
  }]);
  return DirectionalLight$$1;
}(LightComponent), _class$5.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1
}), _temp$5);

var _class$6;
var _temp$6;

/**
 * @class HemisphereLight
 * @category components/lights
 * @description HemisphereLight is a light source positioned directly above the scene.<br/>
 * It also doesn't need position and target properties.
 * @classDesc
 * <iframe src="https://threejs.org/examples/webgl_lights_hemisphere.html"></iframe>
 * @param {Object} [params={light: {skyColor: 0xffffff, groundColor: 0xffffff, intensity: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a HemisphereLight</caption>
 * new HemisphereLight({
 *   skyColor: 0xff0000,
 *   groundColor: 0x0000ff,
 *   intensity: 0.2
 * }).addTo(app);
 */
var HemisphereLight$1 = (_temp$6 = _class$6 = function (_LightComponent) {
  inherits(HemisphereLight$$1, _LightComponent);

  function HemisphereLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HemisphereLight$$1);
    return possibleConstructorReturn(this, (HemisphereLight$$1.__proto__ || Object.getPrototypeOf(HemisphereLight$$1)).call(this, params, HemisphereLight$$1.defaults));
  }

  createClass(HemisphereLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new HemisphereLight(params.skyColor, params.groundColor, params.intensity) }).light;
    }
  }]);
  return HemisphereLight$$1;
}(LightComponent), _class$6.defaults = _extends({}, LightComponent.defaults, {

  skyColor: 0xffffff,
  groundColor: 0xffffff,
  intensity: 1
}), _temp$6);

var _class$7;
var _temp$7;

/**
 * @class PointLight
 * @category components/lights
 * @description PointLight creates a light at a specific position in the scene. The light shines in all directions (roughly similar to a light bulb.)<br/><br/>
 * It has the same options as AmbientLight in light paramater, but it also supports position, distance and decay.<br/>
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, decay: 1}}] - The params.
 * @extends LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a PointLight</caption>
 * new PointLight( {
 *   color: 0xff0000,
 *   intensity: 2,
 *   distance: 300
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var PointLight$1 = (_temp$7 = _class$7 = function (_LightComponent) {
  inherits(PointLight$$1, _LightComponent);

  function PointLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, PointLight$$1);

    var _this = possibleConstructorReturn(this, (PointLight$$1.__proto__ || Object.getPrototypeOf(PointLight$$1)).call(this, params, PointLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(PointLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new PointLight(params.color, params.intensity, params.distance, params.decay) }).light;
    }
  }]);
  return PointLight$$1;
}(LightComponent), _class$7.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  distance: 100,
  decay: 1
}), _temp$7);

var _class$8;
var _temp$8;

/**
 * @class SpotLight
 * @category components/lights
 * @description SpotLight creates spot light that can cast shadow in one direction. <br/><br/>
 * It has the same parameters as AmbientLight in light, but it also supports pos and target. <br/><br/>
 * SpotLight affects meshes with lambert and phong material.
 * @classDesc
 * <iframe src="https://threejs.org/examples/webgl_lights_spotlight.html"></iframe>
 * @param {Object} [params={light: {color: 0xffffff, intensity: 1, distance: 100, angle: Math.PI / 3, exponent: 0, decay: 1}}] - The params.
 * @extends module:core.LightComponent
 * @memberof module:components/lights
 * @example <caption>Creating a SpotLight that falls down from vec3(10, 20, 10) to vec3(0, 0, 0)</caption>
 * new SpotLight({
 *   color: 0x00ff00,
 *   intensity: 3,
 *   distance: 1000
 *
 *   position: [10, 20, 10]
 * }).addTo(app);
 */
var SpotLight$1 = (_temp$8 = _class$8 = function (_LightComponent) {
  inherits(SpotLight$$1, _LightComponent);

  function SpotLight$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, SpotLight$$1);

    var _this = possibleConstructorReturn(this, (SpotLight$$1.__proto__ || Object.getPrototypeOf(SpotLight$$1)).call(this, params, SpotLight$$1.defaults));

    _this.wrapShadow();
    return _this;
  }

  createClass(SpotLight$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new SpotLight(params.color, params.intensity, params.distance, params.angle, params.exponent, params.decay) }).light;
    }
  }]);
  return SpotLight$$1;
}(LightComponent), _class$8.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  distance: 100,
  angle: Math.PI / 3,
  exponent: 0,
  decay: 1
}), _temp$8);

var _class$9;
var _temp$9;

var AreaLight = (_temp$9 = _class$9 = function (_LightComponent) {
  inherits(AreaLight, _LightComponent);

  function AreaLight() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AreaLight);
    return possibleConstructorReturn(this, (AreaLight.__proto__ || Object.getPrototypeOf(AreaLight)).call(this, params, AreaLight.defaults));
  }

  createClass(AreaLight, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ light: new RectAreaLight(params.color, params.intensity, params.width, params.height) }).light;
    }
  }]);
  return AreaLight;
}(LightComponent), _class$9.defaults = _extends({}, LightComponent.defaults, {

  color: 0xffffff,
  intensity: 1,
  width: 10,
  height: 10
}), _temp$9);

/** @module components/lights */

var _class$10;
var _temp$10;

/**
 * @class CubeCamera
 * @category components/cameras
 * @description Creates 6 cameras that render to a WebGLRenderTargetCube
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Creates a CubeCamera and set it as app's camera</caption>
 * const camera = new CubeCamera({
 *   camera: {
 *     cubeResolution: 256
 *   },
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * });
 *
 * app.camera = camera;
 */
var CubeCamera$1 = (_temp$10 = _class$10 = function (_CameraComponent) {
  inherits(CubeCamera$$1, _CameraComponent);

  function CubeCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, CubeCamera$$1);
    return possibleConstructorReturn(this, (CubeCamera$$1.__proto__ || Object.getPrototypeOf(CubeCamera$$1)).call(this, params, CubeCamera$$1.defaults));
  }

  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.CubeCamera#defaults
   * @static
   * @default <pre>
   * {
   *   camera: {
   *     near: 1,
   *     far: 1000,
   *     cubeResolution: 128
   *   }
   * }</pre>
   */


  createClass(CubeCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new CubeCamera(params.near, params.far, params.cubeResolution) }).camera;
    }
  }]);
  return CubeCamera$$1;
}(CameraComponent), _class$10.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  cubeResolution: 128
}), _temp$10);

var _class$11;
var _temp$11;

/**
 * @class OrthographicCamera
 * @category components/cameras
 * @description Camera with orthographic projection.
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Create an OrthographicCamera and set it as app's camera</caption>
 * const camera = new OrthographicCamera({
 *   camera: {
 *     far: 10000
 *   },
 *
 *   position: {
 *     y: 50
 *   }
 * });
 *
 * app.camera = camera;
 */
var OrthographicCamera$1 = (_temp$11 = _class$11 = function (_CameraComponent) {
  inherits(OrthographicCamera$$1, _CameraComponent);

  function OrthographicCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, OrthographicCamera$$1);
    return possibleConstructorReturn(this, (OrthographicCamera$$1.__proto__ || Object.getPrototypeOf(OrthographicCamera$$1)).call(this, params, OrthographicCamera$$1.defaults));
  }
  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.OrthographicCamera#defaults
   * @static
   * @default <pre>
   * {
   *   near: 1,
   *   far: 1000,
   *   left: system.window.innerWidth / -2,
   *   right: system.window.innerWidth / 2,
   *   top: system.window.innerHeight / 2,
   *   bottom: system.window.innerHeight / -2
   * }</pre>
   */


  createClass(OrthographicCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new OrthographicCamera(params.left, params.right, params.top, params.bottom, params.near, params.far) }).camera;
    }
  }]);
  return OrthographicCamera$$1;
}(CameraComponent), _class$11.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  left: system.window.innerWidth / -2,
  right: system.window.innerWidth / 2,
  top: system.window.innerHeight / 2,
  bottom: system.window.innerHeight / -2
}), _temp$11);

var _class$12;
var _temp$12;

/**
 * @class PerspectiveCamera
 * @description Camera with perspective projection.
 * @category components/cameras
 * @param {Object} [params] - The parameters object.
 * @memberof module:components/cameras
 * @extends module:core.CameraComponent
 * @example <caption>Create an PerspectiveCamera and set it as app's camera</caption>
 * const camera = new PerspectiveCamera({
 *   fov: 75,
 *   aspect: window.innerWidth / window.innerHeight,
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * });
 *
 * app.camera = camera;
 */
var PerspectiveCamera$1 = (_temp$12 = _class$12 = function (_CameraComponent) {
  inherits(PerspectiveCamera$$1, _CameraComponent);

  function PerspectiveCamera$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, PerspectiveCamera$$1);
    return possibleConstructorReturn(this, (PerspectiveCamera$$1.__proto__ || Object.getPrototypeOf(PerspectiveCamera$$1)).call(this, params, PerspectiveCamera$$1.defaults));
  }
  /**
   * Default values for parameters
   * @member {Object} module:components/cameras.PerspectiveCamera#defaults
   * @static
   * @default <pre>
   * {
   *   near: 1,
   *   far: 1000,
   *   fov: 75,
   *   aspect: system.window.innerWidth / system.window.innerHeight
   * }</pre>
   */


  createClass(PerspectiveCamera$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this.applyBridge({ camera: new PerspectiveCamera(params.fov, params.aspect, params.near, params.far) }).camera;
    }
  }]);
  return PerspectiveCamera$$1;
}(CameraComponent), _class$12.defaults = _extends({}, CameraComponent.defaults, {

  near: 1,
  far: 1000,
  fov: 75,
  aspect: system.window.innerWidth / system.window.innerHeight
}), _temp$12);

/** @module components/cameras */

var _class$13;
var _temp$13;

/**
 * @class Box
 * @category components/meshes
 * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
 * pass specific parameters to build this mesh as a geometry object.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Box, and adding to app</caption>
 *  new Box({
 *    geometry: {
 *      width: 2,
 *      height: 2,
 *      depth: 2
 *    },
 *
 *    material: new THREE.MeshBasicMaterial({
 *      color: 0xffffff
 *    }),
 *
 *    position: [50, 60, 70]
 * }).addTo(app);
 */
var Box = (_temp$13 = _class$13 = function (_MeshComponent) {
  inherits(Box, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Box#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     width: 1,
   *     height: 1,
   *     depth: 1,
   *     widthSegments: 1,
   *     heightSegments: 1,
   *     depthSegments: 1
   *   }
   * }</pre>
   */
  function Box() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Box);
    return possibleConstructorReturn(this, (Box.__proto__ || Object.getPrototypeOf(Box)).call(this, params, Box.defaults, Box.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Box
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Box#instructions
   * @static
   * @default geometry: ['width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegements']
   */


  createClass(Box, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? BoxBufferGeometry : BoxGeometry)(params.geometry.width, params.geometry.height, params.geometry.depth, params.geometry.widthSegments, params.geometry.heightSegments, params.geometry.depthSegments);

      return geometry;
    }
  }]);
  return Box;
}(MeshComponent), _class$13.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    width: 1,
    height: 1,
    depth: 1,
    widthSegments: 1,
    heightSegments: 1,
    depthSegments: 1
  }
}), _class$13.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['width', 'height', 'depth', 'widthSegments', 'heightSegments', 'depthSegements']
}), _temp$13);

var _class$14;
var _temp$14;

/**
 * @class Circle
 * @category components/meshes
 * @description As told on Component definition, while you can pass any of the inherited params for this component construction, you will need to
 * pass specific parameters to build this mesh as a geometry object.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Circle, and adding to app</caption>
 *  new Circle({
 *    geometry: {
 *      radius: 4,
 *      segments: 16
 *    },
 *
 *    material: new THREE.MeshBasicMaterial({
 *      color: 0xffffff
 *    }),
 *
 *    position: [50, 60, 70]
 * }).addTo(app);
 */
var Circle = (_temp$14 = _class$14 = function (_MeshComponent) {
  inherits(Circle, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Circle#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 50,
   *     segments: 8,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Circle() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Circle);
    return possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, params, Circle.defaults, Circle.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Circle
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Circle#instructions
   * @static
   * @default geometry: ['radius', 'segments', 'thetaStart', 'thetaLength']
   */


  createClass(Circle, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? CircleBufferGeometry : CircleGeometry)(params.geometry.radius, params.geometry.segments, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Circle;
}(MeshComponent), _class$14.defaults = _extends({}, MeshComponent.defaults, {

  geometry: {
    radius: 50,
    segments: 8,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$14.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'segments', 'thetaStart', 'thetaLength']
}), _temp$14);

var _class$15;
var _temp$15;

/**
 * @class Cone
 * @category components/meshes
 * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
 * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
 * The surface area and the volume of a cylinder have been known since deep antiquity.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ConeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Cone, and adding to app</caption>
 * new Cone({
 *   geometry: {
 *     radiusTop: 2,
 *     radiusBottom: 4,
 *     height: 5
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: [0, 100, 0]
 * }).addTo(app);
 */
var Cone = (_temp$15 = _class$15 = function (_MeshComponent) {
  inherits(Cone, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Cone#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 20,
   *     height: 100,
   *     radiusSegments: 32,
   *     heightSegments: 1,
   *     openEnded: false,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Cone() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Cone);

    var _this = possibleConstructorReturn(this, (Cone.__proto__ || Object.getPrototypeOf(Cone)).call(this, params, Cone.defaults, Cone.instructions));

    if (params.build) {
      _this.build(params);
      get(Cone.prototype.__proto__ || Object.getPrototypeOf(Cone.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Cone
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Cone#instructions
   * @static
   * @default <pre>
   * geometry: [
   *   'radius',
   *   'height',
   *   'radiusSegments',
   *   'heightSegments',
   *   'openEnded',
   *   'thetaStart',
   *   'thetaLength'
   * ]
   * </pre>
   */


  createClass(Cone, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? ConeBufferGeometry : ConeGeometry)(params.geometry.radius, params.geometry.height, params.geometry.radiusSegments, params.geometry.heightSegments, params.geometry.openEnded, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Cone;
}(MeshComponent), _class$15.defaults = _extends({}, MeshComponent.defaults, {

  geometry: {
    radius: 20,
    height: 100,
    radiusSegments: 32,
    heightSegments: 1,
    openEnded: false,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$15.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'height', 'radiusSegments', 'heightSegments', 'openEnded', 'thetaStart', 'thetaLength']
}), _temp$15);

var _class$16;
var _temp$16;

/**
 * @class Cylinder
 * @category components/meshes
 * @description A cylinder is one of the most basic curvilinear geometric shapes, the surface formed by the points at a fixed distance from a given straight line, the axis of the cylinder. <br/><br/>
 * The solid enclosed by this surface and by two planes perpendicular to the axis is also called a cylinder.<br/>
 * The surface area and the volume of a cylinder have been known since deep antiquity.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#CylinderGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Cylinder, and adding to app</caption>
 * new Cylinder({
 *   geometry: {
 *     radiusTop: 2,
 *     radiusBottom: 4,
 *     height: 5
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: [0, 100, 0]
 * }).addTo(app);
 */
var Cylinder = (_temp$16 = _class$16 = function (_MeshComponent) {
  inherits(Cylinder, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Cylinder#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radiusTop: 20,
   *     radiusBottom: 20,
   *     height: 100,
   *     radiusSegments: 32,
   *     heightSegments: 1,
   *     openEnded: false,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }</pre>
   */
  function Cylinder() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Cylinder);

    var _this = possibleConstructorReturn(this, (Cylinder.__proto__ || Object.getPrototypeOf(Cylinder)).call(this, params, Cylinder.defaults, Cylinder.instructions));

    if (params.build) {
      _this.build(params);
      get(Cylinder.prototype.__proto__ || Object.getPrototypeOf(Cylinder.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Cylinder
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Cylinder#instructions
   * @static
   * @default <pre>
   * geometry: [
   *   'radiusTop',
   *   'radiusBottom',
   *   'height',
   *   'radiusSegments',
   *   'heightSegments',
   *   'openEnded',
   *   'thetaStart',
   *   'thetaLength'
   * ]
   * </pre>
   */


  createClass(Cylinder, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? CylinderBufferGeometry : CylinderGeometry)(params.geometry.radiusTop, params.geometry.radiusBottom, params.geometry.height, params.geometry.radiusSegments, params.geometry.heightSegments, params.geometry.openEnded, params.geometry.thetaStart, params.geometry.thetaLength);

      return geometry;
    }
  }]);
  return Cylinder;
}(MeshComponent), _class$16.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radiusTop: 0,
    radiusBottom: 1,
    height: 1,
    radiusSegments: 32,
    heightSegments: 1,
    openEnded: false,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$16.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radiusTop', 'radiusBottom', 'height', 'radiusSegments', 'heightSegments', 'openEnded', 'thetaStart', 'thetaLength']
}), _temp$16);

var _class$17;
var _temp$17;

/**
 * @class Dodecahedron
 * @category components/meshes
 * @description In geometry, a dodecahedron is any polyhedron with twelve flat faces. <br/><br/>
 * The most familiar dodecahedron is the regular dodecahedron, which is a Platonic solid. <br/>
 * There are also three regular star dodecahedra, which are constructed as stellations of the convex form. <br/>
 * All of these have icosahedral symmetry, order 120.
 * Dodecahedron creates Dodecahedron object by it's radius and detail.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#DodecahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Dodecahedron, and adding to app</caption>
 * new Dodecahedron({
 *   geometry: {
 *     radius: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 10
 *   }
  * }).addTo(app);
 */
var Dodecahedron = (_temp$17 = _class$17 = function (_MeshComponent) {
  inherits(Dodecahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Dodecahedron#defaults
   * @static
   * @default <pre>
   * geometry: {
   *   radius: 1,
   *   detail: 0
   * }
   * </pre>
   */
  function Dodecahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Dodecahedron);

    var _this = possibleConstructorReturn(this, (Dodecahedron.__proto__ || Object.getPrototypeOf(Dodecahedron)).call(this, params, Dodecahedron.defaults, Dodecahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Dodecahedron.prototype.__proto__ || Object.getPrototypeOf(Dodecahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Dodecahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Dodecahedron#instructions
   * @static
   * @default <pre>
   * geometry: ['radius', 'detail']
   * </pre>
   */


  createClass(Dodecahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? DodecahedronBufferGeometry : DodecahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Dodecahedron;
}(MeshComponent), _class$17.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$17.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$17);

var _class$18;
var _temp$18;

/**
 * @class Extrude
 * @category components/meshes
 * @description Extrude geometry means that you can create a 3D mesh from any 2D shape using three.js geometry based on <a href='https://threejs.org/docs/#api/math/Vector2'>THREE.Vector2.</a> <br/>
 * Such implementation will help you to make volumed shapes that have their own depth and can be seen from all angels.<br/><br/>
 * You can also find some interesting examples made using <a href='threejs.org'>three.js</a> which is a core of whs.js, such as:
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes.html'>Webgl geometry extrude</a>
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_shapes2.html'>Extrude shapes from geodata</a>
 * - <a href='http://threejs.org/examples/webgl_geometry_extrude_splines.html'>Extrude splines</a>
 *
 * Such examples can be easily implemented using whitestorm.js or it's plugins. Use `Extrude` class with <a href='https://threejs.org/docs/#api/extras/core/Shape'>THREE.Shape</a> to get extrude effect of shape defined by 2D vectors.
 * This class is similar to <a href='https://threejs.org/docs/#api/geometries/ExtrudeGeometry'>THREE.ExtrudeGeometry</a>,
 * but it also contains all properties, applied by `Shape`, such as material, mass and vectors like position (pos) and rotation (rot).
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ExtrudeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a shape, then an Extrude from it</caption>
 * const shape = new THREE.Shape([
 *   new THREE.Vector2(-4,-4),
 *   new THREE.Vector2(-2,0),
 *   new THREE.Vector2(-4,4),
 *   new THREE.Vector2(0,2),
 *   new THREE.Vector2(4,4),
 *   new THREE.Vector2(2,0),
 *   new THREE.Vector2(4,-4),
 *   new THREE.Vector2(0,-2)
 * ]);
 *
 * const extrude = new Extrude({
 *   geometry: {
 *     shapes: shape,
 *     options: {
 *       bevelEnabled: false,
 *       bevelSize: 0,
 *       amount: 2
 *     }
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * });
 *
 * extrude.addTo(app);
 */
var Extrude = (_temp$18 = _class$18 = function (_MeshComponent) {
  inherits(Extrude, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Extrude#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     shapes: [],
   *     options: {}
   *   }
   * }
   * </pre>
   */
  function Extrude() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Extrude);

    var _this = possibleConstructorReturn(this, (Extrude.__proto__ || Object.getPrototypeOf(Extrude)).call(this, params, Extrude.defaults, Extrude.instructions));

    if (params.build) {
      _this.build(params);
      get(Extrude.prototype.__proto__ || Object.getPrototypeOf(Extrude.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Extrude
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Extrude#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['shapes', 'options']
   * }
   * </pre>
   */


  createClass(Extrude, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new ExtrudeGeometry(params.geometry.shapes, params.geometry.options);

      return params.buffer ? new BufferGeometry().fromGeometry(geometry) : geometry;
    }
  }]);
  return Extrude;
}(MeshComponent), _class$18.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    shapes: [],
    options: {}
  }
}), _class$18.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['shapes', 'options']
}), _temp$18);

var _class$19;
var _temp$19;

/**
 * @class Icosahedron
 * @category components/meshes
 * @description In geometry, an icosahedron is a polyhedron with 20 faces.<br/>
 * There are many kinds of icosahedra, with some being more symmetrical than others. The most well known is the Platonic, convex regular icosahedron.<br/>
 * `Icosahedron` creates an Icosahedron object by its radius and detail.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#IcosahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Icosahedron, and adding to app</caption>
 * new Icosahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Icosahedron = (_temp$19 = _class$19 = function (_MeshComponent) {
  inherits(Icosahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Icosahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   *   }
   * }</pre>
   */
  function Icosahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Icosahedron);

    var _this = possibleConstructorReturn(this, (Icosahedron.__proto__ || Object.getPrototypeOf(Icosahedron)).call(this, params, Icosahedron.defaults, Icosahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Icosahedron.prototype.__proto__ || Object.getPrototypeOf(Icosahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Icosahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Icosahedron#instructions
   * @static
   * @default {geometry: ['radius', 'detail']}
   */


  createClass(Icosahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? IcosahedronBufferGeometry : IcosahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Icosahedron;
}(MeshComponent), _class$19.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$19.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$19);

var _class$20;
var _temp$20;

/**
 * @class Lathe
 * @category components/meshes
 * @description A `LatheGeometry` allows you to create shapes from a smooth curve.
 * This curve is defined by a number of points (also called knots) and is most often called a spline. This spline is rotated around a fixed point and results in vase- and bell-like shapes.<br/><br/>
 * In 3D computer graphics, a lathed object is a 3D model whose vertex geometry is produced by rotating the points of a spline or other point set around a fixed axis.
 * The lathing may be partial; the amount of rotation is not necessarily a full 360 degrees.
 * The point set providing the initial source data can be thought of as a cross section through the object along a plane containing its axis of radial symmetry. <br/><br/>
 * The <a href='http://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry'>following example</a> shows a geometry which can be generated using `Lathe` class.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#LatheGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Lath, and adding to app</caption>
 * const points = [];
 *
 * for (let i = 0; i < 10; i++) {
 *   points.push(
 *     new THREE.Vector2(
 *       (Math.sin(i * 0.7) * 15 + 50) / 10,
 *       (i - 5) * 0.2
 *     )
 *   );
 * }
 *
 * const lathe = new Lathe({
 *   geometry: {
 *     points: points
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 50, 10]
 * }).addTo(app);
 */
var Lathe = (_temp$20 = _class$20 = function (_MeshComponent) {
  inherits(Lathe, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Lathe#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     points: []
   *   }
   * }
   * </pre>
   */
  function Lathe() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Lathe);

    var _this = possibleConstructorReturn(this, (Lathe.__proto__ || Object.getPrototypeOf(Lathe)).call(this, params, Lathe.defaults, Lathe.instructions));

    if (params.build) {
      _this.build(params);
      get(Lathe.prototype.__proto__ || Object.getPrototypeOf(Lathe.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Lathe
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Lathe#instructions
   * @static
   * @default <pre>{
   *   geometry: ['points']
   * }
   * </pre>
   */


  createClass(Lathe, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? LatheBufferGeometry : LatheGeometry)(params.geometry.points);
    }
  }]);
  return Lathe;
}(MeshComponent), _class$20.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    points: []
  }
}), _class$20.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['points']
}), _temp$20);

var _class$21;
var _temp$21;

/**
 * @class Line
 * @category components/meshes
 * @description Line component is generated from a curve/line and amount of vectors that should be used (points).
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Line, and adding to app</caption>
 * new Line({
 *   geometry: {
 *     curve: new THREE.LineCurve3(new THREE.Vector3(10, 10, 0), new THREE.Vector3(10, 30, 0))
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Line$1 = (_temp$21 = _class$21 = function (_MeshComponent) {
  inherits(Line$$1, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Line#defaults
   * @static
   * @default <pre>
   * {
   *   curve: new LineCurve3(new Vector3(0, 0, 0), new Vector3(10, 0, 0)),
   *   points: 50
   * }
   * </pre>
   */
  function Line$$1(params) {
    classCallCheck(this, Line$$1);
    return possibleConstructorReturn(this, (Line$$1.__proto__ || Object.getPrototypeOf(Line$$1)).call(this, params, Line$$1.defaults, Line$$1.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Line
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Line#instructions
   * @static
   * @default <pre>{
   *   geometry: ['curve', 'points']
   * }
   * </pre>
   */


  createClass(Line$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Line(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = params.buffer ? new BufferGeometry() : new Geometry();

      if (params.buffer) {
        var pp = params.curve.getPoints(params.points);
        var verts = new Float32Array(pp.length * 3);

        for (var i = 0, max = pp.length; i < max; i++) {
          var i3 = i * 3;

          verts[i3] = pp[i].x;
          verts[i3 + 1] = pp[i].y;
          verts[i3 + 2] = pp[i].z;
        }

        geometry.addAttribute('position', new BufferAttribute(verts, 3));
      } else geometry.vertices = params.curve.getPoints(params.points);

      return geometry;
    }
  }]);
  return Line$$1;
}(MeshComponent), _class$21.defaults = _extends({}, MeshComponent.defaults, {

  curve: null,
  points: 50
}), _class$21.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['curve', 'points']
}), _temp$21);

var _class$22;
var _temp$22;

/**
 * @class Importer
 * @category components/meshes
 * @description Importer is a loader for meshes and any other data to your scene
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Importer, and adding to app</caption>
 * new Importer({
 *   loader: new THREE.OBJLoader(),
 *
 *   parser(geometry, material) { // data from loader
 *     return new THREE.Mesh(geometry, material); // should return your .native (mesh in this case)
 *   },
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Importer = (_temp$22 = _class$22 = function (_MeshComponent) {
  inherits(Importer, _MeshComponent);
  createClass(Importer, null, [{
    key: 'filter',


    /**
     * @method filter
     * @description Default values for filter
     * @static
     * @param {THREE.Mesh} object Instance for iterating through it's children.
     * @param {Function} filter Function with child as argument, should return a boolean whether include the child or not.
     * @return {THREE.Mesh} object with children
     * @memberof module:components/meshes.Importer
     * @example <caption>Removing unnecessary lights from children</caption>
     * new Importer({
     *   loader: new THREE.OBJLoader(),
     *
     *   parse(group) { // data from loader
     *     return Importer.filter(group, child => !child.isLight); // remove lights
     *   },
     *
     *   position: [0, 100, 0]
     * }).addTo(app);
     */


    /**
     * Default values for parameters
     * @member {Object} module:components/meshes.Importer#defaults
     * @static
     * @default <pre>
     * {
     *   url: '',
     *   loader: new JSONLoader(),
     *
     *   onLoad() {},
     *   onProgress() {},
     *   onError() {},
     *
     *   texturePath: null,
     *   useCustomMaterial: false,
     *
     *   parser(geometry, materials) {
     *     return new Mesh(geometry, materials);
     *   }
     * }</pre>
     */
    value: function filter(object, _filter) {
      var processFilter = function processFilter(object) {
        object.children.forEach(function (el, index) {
          if (el.children) processFilter(el);
          if (!_filter(el)) object.children.splice(index, 1);
        });

        return object;
      };

      return processFilter(object);
    }
  }]);

  function Importer() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Importer);
    return possibleConstructorReturn(this, (Importer.__proto__ || Object.getPrototypeOf(Importer)).call(this, params, Importer.defaults, Importer.instructions, false));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Importer
   */


  createClass(Importer, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new Promise(function (resolve) {
        if (params.texturePath) params.loader.setTexturePath(params.texturePath);

        params.loader.load(params.url, function () {
          for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
            data[_key] = arguments[_key];
          }

          // geometry, materials
          params.onLoad.apply(params, data);

          var object = params.parser.apply(_this2, data);
          if (params.material) object.material = _this2.applyBridge({ material: params.material }).material;

          resolve(object);
        }, params.onProgress, params.onError);
      });
    }
  }]);
  return Importer;
}(MeshComponent), _class$22.defaults = _extends({}, MeshComponent.defaults, {

  url: '',
  loader: new JSONLoader(),

  onLoad: function onLoad() {},
  onProgress: function onProgress() {},

  // TODO add onComplete?
  onError: function onError() {},


  texturePath: null,
  useCustomMaterial: false,

  parser: function parser(geometry, material) {
    var _applyBridge = this.applyBridge({ geometry: geometry, material: material }),
        geom = _applyBridge.geometry,
        mat = _applyBridge.material;

    return this.applyBridge({
      mesh: geom.bones ? new SkinnedMesh(geom, mat) : new Mesh(geom, mat)
    }).mesh;
  }
}), _class$22.instructions = _extends({}, MeshComponent.instructions), _temp$22);

var _class$23;
var _temp$23;

/**
 * @class Octahedron
 * @category components/meshes
 * @description In geometry, an octahedron is a polyhedron with eight faces.
 * A regular octahedron is a Platonic solid composed of eight equilateral triangles, four of which meet at each vertex.
 * <br/><br/>
 * `Octahedron` creates an Octahedron object by its `radius` and `detail`.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#OctahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating an Octahedron, and adding to app</caption>
 * new Octahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */
var Octahedron = (_temp$23 = _class$23 = function (_MeshComponent) {
  inherits(Octahedron, _MeshComponent);

  function Octahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Octahedron);

    var _this = possibleConstructorReturn(this, (Octahedron.__proto__ || Object.getPrototypeOf(Octahedron)).call(this, params, Octahedron.defaults, Octahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Octahedron.prototype.__proto__ || Object.getPrototypeOf(Octahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Octahedron
   */

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Octahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   *   }
   * }
   * </pre>
   */


  createClass(Octahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? OctahedronBufferGeometry : OctahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Octahedron;
}(MeshComponent), _class$23.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _temp$23);

var _class$24;
var _temp$24;

/**
 * @class Parametric
 * @category components/meshes
 * @description `Parametric` generates a geometry representing a <a href='https://en.wikipedia.org/wiki/Parametric_surface'>Parametric surface</a>
 * <br/><br/>
 * It is usually used to develop different kinds of highfields or visualize a <a href='https://stemkoski.github.io/Three.js/Graphulus-Function.html'>math function</a>.
 * <br/>
 * - <a href='http://math.hws.edu/graphicsbook/source/threejs/curves-and-surfaces.html'>Parametric surface</a>
 * - <a href='https://stemkoski.github.io/Three.js/Graphulus-Surface.html'>"Graphulus"</a>
 * <br/><br/>
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ParametricGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Example creating an heightfield-like geometry. `u` and `v` are like `x` and `y` in shape, but their values are always from `0` to `1`.
 * We use them in `THREE.Vector3` like `x` and `z` and `Math.random() * 5` for `y`.</caption>
 * const createParametric = (u, v) => {
 *   return new THREE.Vector3(u * 30, Math.random() * 5, v * 30);
 * }
 *
 * new Parametric({
 *   geometry: {
 *     func: createParametric
 *   },
 *
 *   material: new THREE.MeshLambertMaterial({
 *     color: 0xffffff,
 *     side: THREE.DoubleSide
 *   }),
 *
 *   position: [0, 100, -100]
 * }).addTo(app);
 */
var Parametric = (_temp$24 = _class$24 = function (_MeshComponent) {
  inherits(Parametric, _MeshComponent);

  function Parametric() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Parametric);
    return possibleConstructorReturn(this, (Parametric.__proto__ || Object.getPrototypeOf(Parametric)).call(this, params, Parametric.defaults, Parametric.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Parametric
   */

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Parametric#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     func: (u, v) => new Vector3(u, v, 0),
   *     slices: 10,
   *     tacks: 10
   *   }
   * }
   * </pre>
   */


  createClass(Parametric, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? ParametricBufferGeometry : ParametricGeometry)(params.geometry.func, params.geometry.slices, params.geometry.stacks);
    }
  }]);
  return Parametric;
}(MeshComponent), _class$24.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    func: function func(u, v) {
      return new Vector3(u, v, 0);
    },
    slices: 10,
    stacks: 10
  }
}), _temp$24);

var _class$25;
var _temp$25;

/**
 * @class Plane
 * @category components/meshes
 * @description `Plane` is used for creating planes given some `width` and `height`.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Plane, and adding to app</caption>
 * new Plane({
 *   geometry: {
 *     width: 20,
 *     height: 30
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Plane$1 = (_temp$25 = _class$25 = function (_MeshComponent) {
  inherits(Plane$$1, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Plane#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     width: 10,
   *     height: 10,
   *     wSegments: 1,
   *     hSegments: 1
   *   }
   * }
   * </pre>
   */
  function Plane$$1() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Plane$$1);

    var _this = possibleConstructorReturn(this, (Plane$$1.__proto__ || Object.getPrototypeOf(Plane$$1)).call(this, params, Plane$$1.defaults, Plane$$1.instructions));

    if (params.build) {
      _this.build(params);
      get(Plane$$1.prototype.__proto__ || Object.getPrototypeOf(Plane$$1.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Plane
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Plane#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['width', 'height', 'wSegments', 'hSegments']
   * }
   * </pre>
   */


  createClass(Plane$$1, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? PlaneBufferGeometry : PlaneGeometry)(params.geometry.width, params.geometry.height, params.geometry.wSegments, params.geometry.hSegments);

      return geometry;
    }
  }]);
  return Plane$$1;
}(MeshComponent), _class$25.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    width: 10,
    height: 10,
    wSegments: 1,
    hSegments: 1
  }
}), _class$25.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['width', 'height', 'wSegments', 'hSegments']
}), _temp$25);

var _class$26;
var _temp$26;

var verticesOfCube = [-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1];
var indicesOfFaces = [2, 1, 0, 0, 3, 2, 0, 4, 7, 7, 3, 0, 0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 6, 6, 7, 4];

/**
 * @class Polyhedron
 * @category components/meshes
 * @description In elementary geometry, a polyhedron is a solid in three dimensions with flat polygonal faces, straight edges and sharp corners or vertices.
 * <br/><br/>
 * `Polyhedron` creates a Polyhedron by its `radius` and `detail`.
 * <br/><br/>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating an Polyhedron, and adding to app</caption>
 * new Polyhedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: [0, 100, 0]
 * }).addTo(app);
 */

var Polyhedron = (_temp$26 = _class$26 = function (_MeshComponent) {
  inherits(Polyhedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Polyhedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     verticesOfCube: [
   *       -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,
   *       -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1
   *     ],
   *
   *     indicesOfFaces: [
   *       2, 1, 0, 0, 3, 2,
   *       0, 4, 7, 7, 3, 0,
   *       0, 1, 5, 5, 4, 0,
   *       1, 2, 6, 6, 5, 1,
   *       2, 3, 7, 7, 6, 2,
   *       4, 5, 6, 6, 7, 4
   *     ],
   *
   *     radius: 6,
   *     detail: 2
   *   }
   * }
   * </pre>
   */
  function Polyhedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Polyhedron);

    var _this = possibleConstructorReturn(this, (Polyhedron.__proto__ || Object.getPrototypeOf(Polyhedron)).call(this, params, Polyhedron.defaults, Polyhedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Polyhedron.prototype.__proto__ || Object.getPrototypeOf(Polyhedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Polyhedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Polyhedron#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['verticesOfCube', 'indicesOfFaces', 'radius', 'detail']
   * }
   * </pre>
   */


  createClass(Polyhedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? PolyhedronBufferGeometry : PolyhedronGeometry)(params.geometry.verticesOfCube, params.geometry.indicesOfFaces, params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Polyhedron;
}(MeshComponent), _class$26.verticesOfCube = verticesOfCube, _class$26.indicesOfFaces = indicesOfFaces, _class$26.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    verticesOfCube: verticesOfCube,
    indicesOfFaces: indicesOfFaces,
    radius: 6,
    detail: 2
  }
}), _class$26.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['verticesOfCube', 'indicesOfFaces', 'radius', 'detail']
}), _temp$26);

var _class$27;
var _temp$27;

/**
 * @class Ring
 * @category components/meshes
 * @description Ring class creates a circle or just 2D Torus. Does not support physics.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#RingGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Ring, and adding to app</caption>
 * new Ring({
 *   geometry: {
 *     innerRadius: 5,
 *     outerRadius: 2
 *   },
 *
 *   material: new THREE.MeshLambertMaterial({
 *     color: 0xffffff,
 *     side THREE.DoubleSide
 *   }),
 *
 *   position: [0, 8, 0],
 *
 *   rotation: {
 *     x: Math.PI/4
 *   }
 * }).addTo(app);
 */
var Ring = (_temp$27 = _class$27 = function (_MeshComponent) {
  inherits(Ring, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Ring#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     innerRadius: 0,
   *     outerRadius: 50,
   *     thetaSegments: 8,
   *     phiSegments: 8,
   *     thetaStart: 0,
   *     thetaLength: Math.PI * 2
   *   }
   * }
   * </pre>
   */
  function Ring() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Ring);

    var _this = possibleConstructorReturn(this, (Ring.__proto__ || Object.getPrototypeOf(Ring)).call(this, params, Ring.defaults, Ring.instructions));

    if (params.build) {
      _this.build(params);
      get(Ring.prototype.__proto__ || Object.getPrototypeOf(Ring.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Ring
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Ring#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'innerRadius',
   *     'outerRadius',
   *     'thetaSegments',
   *     'phiSegments',
   *     'thetaStart',
   *     'thetaLength'
   *   ]
   * }
   * </pre>
   */


  createClass(Ring, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? RingBufferGeometry : RingGeometry)(params.geometry.innerRadius, params.geometry.outerRadius, params.geometry.thetaSegments, params.geometry.phiSegments, params.geometry.thetaStart, params.geometry.thetaLength);
    }
  }]);
  return Ring;
}(MeshComponent), _class$27.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    innerRadius: 0,
    outerRadius: 50,
    thetaSegments: 8,
    phiSegments: 8,
    thetaStart: 0,
    thetaLength: Math.PI * 2
  }
}), _class$27.instructions = _extends({}, MeshComponent.defaults, {
  geometry: ['innerRadius', 'outerRadius', 'thetaSegments', 'phiSegments', 'thetaStart', 'thetaLength']
}), _temp$27);

var _class$28;
var _temp$28;

/**
 * @class Shape
 * @category components/meshes
 * @description Shape is a universal class. It allows you to create different 2D shapes in 3D scene.<br/>
 * Unfortunately, not all of them support physics, an alternative is to make a similar 3D object and scale its width down to near zero.
 * <br/><br/>
 * `Shape` consists of shapes that are in its shapes parameter.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#ShapeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a plane looking Shape from a THREE.Shape, and adding it to app</caption>
 * const rectWidth = 10,
 * rectLength = 5;
 *
 * const rectShape = new THREE.Shape();
 * rectShape.moveTo(0,0);
 * rectShape.lineTo(0, rectWidth);
 * rectShape.lineTo(rectLength, rectWidth);
 * rectShape.lineTo(rectLength, 0);
 * rectShape.lineTo(0, 0);
 *
 * const plane = new Shape({
 *   geometry: {
 *     shape: rectShape
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Shape = (_temp$28 = _class$28 = function (_MeshComponent) {
  inherits(Shape, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Shape#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     shapes: []
   * }
   * </pre>
   */
  function Shape() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Shape);

    var _this = possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, params, Shape.defaults, Shape.instructions));

    if (params.build) {
      _this.build(params);
      get(Shape.prototype.__proto__ || Object.getPrototypeOf(Shape.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Shape
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Shape#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['shapes']
   * }
   * </pre>
   */


  createClass(Shape, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? ShapeBufferGeometry : ShapeGeometry)(params.geometry.shapes);
    }
  }]);
  return Shape;
}(MeshComponent), _class$28.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    shapes: []
  }
}), _class$28.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['shapes']
}), _temp$28);

var _class$29;
var _temp$29;

/**
 * @class Sphere
 * @category components/meshes
 * @description Sphere class is used to create sphere objects by its radius property and other values that determines its detality.
 * <br/><br/>
 * It is similar to THREE.SphereGeometry, but it also contains all `Shape` properties, such as material, mass and vectors like position (pos) and rotation (rot).
 * <br/><br/>
 * Then it creates an `Three.js mesh` or a `Physijs mesh`, that is similar to `Three.js mesh`, but it also take into consideration collision calculations.
 * This mesh is a combination of `Three.js geometry` and `Physijs material` (The same as in three.js, but with friction and restitution).
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#SphereGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Sphere, and adding it to app</caption>
 * new Sphere({
 *   geometry: {
 *     radius: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 100
 *   }
 * }).addTo(app);
 */
var Sphere = (_temp$29 = _class$29 = function (_MeshComponent) {
  inherits(Sphere, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Sphere#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     widthSegments: 8,
   *     heightSegments: 6
   * }
   * </pre>
   */
  function Sphere() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Sphere);
    return possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, params, Sphere.defaults, Sphere.instructions));
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Sphere
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Sphere#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['radius', 'widthSegments', 'heightSegments']
   * }
   * </pre>
   */


  createClass(Sphere, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? SphereBufferGeometry : SphereGeometry)(params.geometry.radius, params.geometry.widthSegments, params.geometry.heightSegments);

      return geometry;
    }
  }]);
  return Sphere;
}(MeshComponent), _class$29.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    widthSegments: 8,
    heightSegments: 6
  }
}), _class$29.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'widthSegments', 'heightSegments']
}), _temp$29);

var _class$30;
var _temp$30;

/**
 * @class Tetrahedron
 * @category components/meshes
 * @description In geometry, a tetrahedron is a polyhedron composed of four triangular faces, six straight edges, and four vertex corners.
 * The tetrahedron is the simplest of all the ordinary convex polyhedra and the only one that has fewer than 5 faces.
 * <br/><br/>
 * `Tetrahedron` creates a Tetrahedron object by its `radius` and `detail`
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TetrahedronGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Tetrahedron, and adding it to app</caption>
 * new Tetrahedron({
 *   geometry: {
 *     radius: 2,
 *     detail: 1
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     x: 0,
 *     y: 100,
 *     z: 0
 *   }
 * }).addTo(app);
 */
var Tetrahedron = (_temp$30 = _class$30 = function (_MeshComponent) {
  inherits(Tetrahedron, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Tetrahedron#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 1,
   *     detail: 0
   * }
   * </pre>
   */
  function Tetrahedron() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Tetrahedron);

    var _this = possibleConstructorReturn(this, (Tetrahedron.__proto__ || Object.getPrototypeOf(Tetrahedron)).call(this, params, Tetrahedron.defaults, Tetrahedron.instructions));

    if (params.build) {
      _this.build(params);
      get(Tetrahedron.prototype.__proto__ || Object.getPrototypeOf(Tetrahedron.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Tetrahedron
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Tetrahedron#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: ['radius', 'detail']
   * }
   * </pre>
   */


  createClass(Tetrahedron, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new (params.buffer ? TetrahedronBufferGeometry : TetrahedronGeometry)(params.geometry.radius, params.geometry.detail);
    }
  }]);
  return Tetrahedron;
}(MeshComponent), _class$30.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 1,
    detail: 0
  }
}), _class$30.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'detail']
}), _temp$30);

var _class$31;
var _temp$31;

/**
 * @class Text
 * @category components/meshes
 * @description Text class is made for creating 3D text objects.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TextGeometry"></iframe>
 * <br/><br/>
 * Physics text object can be convex or concave. By default it's convex but you can also switch to concave.
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Text, and adding it to app</caption>
 * new Text({
 *     text: 'Some text',
 *     parameters: {
 *       font: 'path/to/font.typeface.js',
 *       size: 20,
 *       height: 5,
 *       curveSegments: 6
 *     }
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     x: -40,
 *     y: 20,
 *     z: 0
 *   }
 * }).addTo(app);
 */
var Text = (_temp$31 = _class$31 = function (_MeshComponent) {
  inherits(Text, _MeshComponent);
  createClass(Text, null, [{
    key: 'load',


    /**
     * @method load
     * @static
     * @description load() preloads a Font object and returns a Promise with it.
     * @param {String} path Path to the font
     * @return {Promise} A promise resolved with a font
     * @memberof module:components/meshes.Text
     */
    value: function load(path) {
      var loader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Text.loader;

      return new Promise(function (resolve) {
        loader.load(path, resolve);
      });
    }

    /**
     * Default FontLoader
     * @member {Object} module:components/meshes.Text#loader
     * @static
     * @default new FontLoader()
     */

    /**
     * Default values for parameters
     * @member {Object} module:components/meshes.Text#defaults
     * @static
     * @default <pre>
     * {
     *   text: 'Hello World!',
     *   font: null,
     *
     *   geometry: {
     *     size: 12,
     *     height: 50,
     *     curveSegments: 12,
     *     font: new Font(),
     *     bevelEnabled: false,
     *     bevelThickness: 10,
     *     bevelSize: 8
     *   }
     * }
     * </pre>
     */

  }]);

  function Text() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Text);
    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, params, Text.defaults, Text.instructions));
  }

  /**
   * @method build
   * @description Build is called as part of the lifecycle to create a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Text
   */


  createClass(Text, [{
    key: 'build',
    value: function build() {
      var _this2 = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var promise = new Promise(function (resolve) {
        (params.font instanceof Promise ? params.font : Promise.resolve(params.font)).then(function (font) {
          var _applyBridge = _this2.applyBridge({
            geometry: new TextGeometry(params.text, Object.assign(params.geometry, { font: font })),

            material: params.material
          }),
              geometry = _applyBridge.geometry,
              material = _applyBridge.material;

          resolve(_this2.applyBridge({
            mesh: new Mesh(geometry, material)
          }).mesh);
        });
      });

      get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), 'wait', this).call(this, promise);

      return promise;
    }
  }]);
  return Text;
}(MeshComponent), _class$31.defaults = _extends({}, MeshComponent.defaults, {
  text: 'Hello World!',
  font: null,

  geometry: {
    size: 12,
    height: 50,
    curveSegments: 12,
    font: new Font(),
    bevelEnabled: false,
    bevelThickness: 10,
    bevelSize: 8
  }
}), _class$31.instructions = _extends({}, MeshComponent.instructions), _class$31.loader = new FontLoader(), _temp$31);

var _class$32;
var _temp$32;

/**
 * @class Torus
 * @category components/meshes
 * @description Torus class makes a torus figure. A donut is a torus.
 * @classDesc
 * <iframe src="https://threejs.org/docs/index.html#api/geometries/TorusGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Torus, and adding it to app</caption>
 * new Torus({
 *   geometry: {
 *     radius: 5,
 *     tube: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   position: {
 *     y: 35
 *   }
 * }).addTo(app);
 */
var Torus = (_temp$32 = _class$32 = function (_MeshComponent) {
  inherits(Torus, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Torus#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 100,
   *     tube: 40,
   *     radialSegments: 8,
   *     tubularSegments: 6,
   *     arc: Math.PI * 2
   *   }
   * }
   * </pre>
   */
  function Torus() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Torus);

    var _this = possibleConstructorReturn(this, (Torus.__proto__ || Object.getPrototypeOf(Torus)).call(this, params, Torus.defaults, Torus.instructions));

    if (params.build) {
      _this.build(params);
      get(Torus.prototype.__proto__ || Object.getPrototypeOf(Torus.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Torus
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Torus#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'radius',
   *     'tube',
   *     'radialSegments',
   *     'tubularSegments',
   *     'arc'
   *   ]
   * }
   * </pre>
   */


  createClass(Torus, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return new TorusGeometry(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.arc);
    }
  }]);
  return Torus;
}(MeshComponent), _class$32.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 100,
    tube: 40,
    radialSegments: 8,
    tubularSegments: 6,
    arc: Math.PI * 2
  }
}), _class$32.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'tube', 'radialSegments', 'tubularSegments', 'arc']
}), _temp$32);

var _class$33;
var _temp$33;

/**
 * @class Torusknot
 * @category components/meshes
 * @description Torusknot class makes a torusknot figure. It's like a crooked donut, very crooked.
 * @classDesc
 * <iframe src="https://threejs.org/docs/scenes/geometry-browser.html#TorusKnotGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Torusknot, and adding it to app</caption>
 * new Torusknot({
 *   geometry: {
 *     radius:5,
 *     tube: 2
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *
 *   pos: {
 *     y: 100
 *   }
 * }).addTo(app);
 */
var Torusknot = (_temp$33 = _class$33 = function (_MeshComponent) {
  inherits(Torusknot, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Torusknot#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     radius: 100,
   *     tube: 40,
   *     radialSegments: 64,
   *     tubularSegments: 8,
   *     p: 2,
   *     q: 3
   *   }
   * }
   * </pre>
   */
  function Torusknot() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Torusknot);

    var _this = possibleConstructorReturn(this, (Torusknot.__proto__ || Object.getPrototypeOf(Torusknot)).call(this, params, Torusknot.defaults, Torusknot.instructions));

    if (params.build) {
      _this.build(params);
      get(Torusknot.prototype.__proto__ || Object.getPrototypeOf(Torusknot.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Torusknot
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Torusknot#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'radius',
   *     'tube',
   *     'radialSegments',
   *     'tubularSegments',
   *     'p',
   *     'q'
   *   ]
   * }
   * </pre>
   */


  createClass(Torusknot, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var GConstruct = params.buffer ? TorusKnotBufferGeometry : TorusKnotGeometry;

      return new GConstruct(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.p, params.geometry.q);
    }
  }]);
  return Torusknot;
}(MeshComponent), _class$33.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    radius: 100,
    tube: 40,
    radialSegments: 64,
    tubularSegments: 8,
    p: 2,
    q: 3
  }
}), _class$33.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['radius', 'tube', 'radialSegments', 'tubularSegments', 'p', 'q']
}), _temp$33);

var _class$34;
var _temp$34;

/**
 * @class Tube
 * @category components/meshes
 * @description Tube class makes a tube that extrudes along a 3d curve.
 * @classDesc
 * <iframe src="https://threejs.org/docs/index.html#api/geometries/TubeGeometry"></iframe>
 * @param {Object} [params] - The params.
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Creating a Tube from a three.js Curve, and adding it to app</caption>
 * const CustomSinCurve = THREE.Curve.create(
 *   function (scale) { // custom curve constructor
 *     this.scale = (scale === undefined) ? 1 : scale;
 *   },
 *
 *   function (t) { // getPoint: t is between 0-1
 *     const tx = t * 3 - 1.5,
 *     ty = Math.sin( 2 * Math.PI * t ),
 *     tz = 0;
 *
 *     return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);
 *   }
 * );
 *
 * const path = new CustomSinCurve(10);
 *
 * new Tube({
 *   geometry: {
 *     path: path
 *   },
 *
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   })
 * }).addTo(app);
 */
var Tube = (_temp$34 = _class$34 = function (_MeshComponent) {
  inherits(Tube, _MeshComponent);

  /**
   * Default values for parameters
   * @member {Object} module:components/meshes.Tube#defaults
   * @static
   * @default <pre>
   * {
   *   geometry: {
   *     path: new THREE.LineCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, 1)),
   *     segments: 20,
   *     radius: 2,
   *     radiusSegments: 8,
   *     closed: false
   *   }
   * }
   * </pre>
   */
  function Tube() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Tube);

    var _this = possibleConstructorReturn(this, (Tube.__proto__ || Object.getPrototypeOf(Tube)).call(this, params, Tube.defaults, Tube.instructions));

    if (params.build) {
      _this.build(params);
      get(Tube.prototype.__proto__ || Object.getPrototypeOf(Tube.prototype), 'wrap', _this).call(_this);
    }
    return _this;
  }

  /**
   * @method build
   * @description Build lifecycle creates a mesh using input params.
   * @param {Object} params Component parameters.
   * @return {THREE.Mesh} Built mesh
   * @memberof module:components/meshes.Tube
   */


  /**
   * Instructions
   * @member {Object} module:components/meshes.Tube#instructions
   * @static
   * @default <pre>
   * {
   *   geometry: [
   *     'path',
   *     'segments',
   *     'radius',
   *     'radiusSegments',
   *     'closed'
   *   ]
   * }
   * </pre>
   */


  createClass(Tube, [{
    key: 'build',
    value: function build() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

      var _applyBridge = this.applyBridge({
        geometry: this.buildGeometry(params),
        material: params.material
      }),
          geometry = _applyBridge.geometry,
          material = _applyBridge.material;

      return this.applyBridge({ mesh: new Mesh(geometry, material) }).mesh;
    }
  }, {
    key: 'buildGeometry',
    value: function buildGeometry() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var geometry = new (params.buffer ? TubeBufferGeometry : TubeGeometry)(params.geometry.path, params.geometry.segments, params.geometry.radius, params.geometry.radiusSegments, params.geometry.closed);

      return geometry;
    }
  }]);
  return Tube;
}(MeshComponent), _class$34.defaults = _extends({}, MeshComponent.defaults, {
  geometry: {
    path: new LineCurve3(new Vector3(0, 0, 0), new Vector3(0, 0, 1)),
    segments: 20,
    radius: 2,
    radiusSegments: 8,
    closed: false
  }
}), _class$34.instructions = _extends({}, MeshComponent.instructions, {
  geometry: ['path', 'segments', 'radius', 'radiusSegments', 'closed']
}), _temp$34);

/**
 * @class Group
 * @category components/meshes
 * @description Sometimes you need to make groups of objects (it's not conveniently to apply transforms to each object when can make just one to a group).<br/>
 * In Three.js you make it using `THREE.Object3D` and it's children. <br/><br/>
 * In whs.js we have `Group`
 * @extends module:core.MeshComponent
 * @memberof module:components/meshes
 * @example <caption>Approach 2 - Adding objects to an empty group</caption>
 * const sphere = new Sphere();
 * const box = new Box();
 * const group = new Group();
 *
 * sphere.addTo(group);
 * box.addTo(group);
* @example <caption>Approach 2 - Making a group from objects</caption>
 * const sphere = new Sphere();
 * const box = new Box();
 * const group = new Group(box, sphere);
 * // OR: const group = new Group([box, sphere]);
 */

var Group = function (_MeshComponent) {
  inherits(Group, _MeshComponent);

  function Group() {
    classCallCheck(this, Group);

    var _this = possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, {}));

    for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {
      objects[_key] = arguments[_key];
    }

    for (var i = 0; i < objects.length; i++) {
      var obj = objects[i];

      if (obj instanceof Component) obj.addTo(_this);else if (obj instanceof Object3D) _this.native.add(obj);
    }
    return _this;
  }

  createClass(Group, [{
    key: 'build',
    value: function build() {
      return new Object3D();
    }
  }]);
  return Group;
}(MeshComponent);

/** @module components/meshes */

/**
 * @class ElementModule
 * @category modules/app
 * @param {Object} [container=document.body] container is the DOM object to which application's canvas will be added to.
 * @memberof module:modules/app
 * @example <caption>Creating an element module, passing it to the App</caption>
 * new App([
 *   new ElementModule(document.getElementById('app'))
 * ]);
 */
var ElementModule = function () {
  function ElementModule() {
    var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
    classCallCheck(this, ElementModule);

    if (container.container) {
      console.warn('ElementModule now accepts only argument which is a DOM object, not a params object.');
      this.container = container.container;
    } else this.container = container;

    this.createElement();
  }

  /**
   * @method createElement
   * @instance
   * @description Creates a canvas element.
   * @memberof module:modules/app.ResizeModule
   */


  createClass(ElementModule, [{
    key: 'createElement',
    value: function createElement() {
      this.element = window.document.createElement('div');

      this.element.className = 'whs-app';
      this.element.style.width = 'inherit';
      this.element.style.height = 'inherit';
      this.element.style.position = 'relative';
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('element', this.element);
      _manager.set('container', this.container);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.container.appendChild(self.element);
    }
  }]);
  return ElementModule;
}();

var _class$35;
var _temp$35;
var _initialiseProps;

/**
 * @class RenderingModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule({
 *     bgColor: 0x162129,
 *
 *     renderer: {
 *       antialias: true
 *     }
 *   }, {shadow: true})
 * ]);
 */
var RenderingModule = (_temp$35 = _class$35 = function () {
  /**
   * additional
   * @description collection of additional scripts
   * @static
   * @member {Object} module:core.App#additional
   * @public
   */
  function RenderingModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var additional = arguments[1];
    classCallCheck(this, RenderingModule);

    _initialiseProps.call(this);

    this.params = Object.assign({
      width: window.innerWidth,
      height: window.innerHeight,

      resolution: new Vector2(1, 1),
      pixelRatio: window.devicePixelRatio,

      bgColor: 0x000000,
      bgOpacity: 1,

      renderer: {},
      fix: function fix() {}
    }, params);

    var _params = this.params,
        bgColor = _params.bgColor,
        bgOpacity = _params.bgOpacity,
        renderer = _params.renderer,
        pixelRatio = _params.pixelRatio,
        width = _params.width,
        height = _params.height,
        resolution = _params.resolution,
        fix = _params.fix;


    this.renderer = new WebGLRenderer(renderer);
    this.effects = [];

    this.renderer.setClearColor(bgColor, bgOpacity);

    if (pixelRatio) this.renderer.setPixelRatio(pixelRatio);

    this.setSize(Number(width * resolution.x).toFixed(), Number(height * resolution.y).toFixed());

    for (var key in additional) {
      if (additional[key]) this.applyAdditional(key);
    }fix(this.renderer);
  }

  /**
   * @method applyAdditional
   * @description Apply additional script from RenderingModule.additional
   * @param {Stirng} name Script name
   * @return {this}
   * @memberof module:modules/app.RenderingModule
   */


  /**
   * enabled
   * @static
   * @member {Boolean} module:core.App#enabled
   * @public
   */


  createClass(RenderingModule, [{
    key: 'applyAdditional',
    value: function applyAdditional(name) {
      RenderingModule.additional[name].apply(this, [this.renderer]);
    }

    /**
     * @method integrateRenderer
     * @description Integrate renderer
     * @param {NodeElement} element DOM object
     * @param {THREE.Scene} scene used scene
     * @param {THREE.Camera} camera used camera
     * @return {Loop} renderLoop
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'integrateRenderer',
    value: function integrateRenderer(element, scene, camera) {
      var _this = this;

      this.scene = scene;
      this.camera = camera;
      this.attachToCanvas(element);

      return new Loop(function () {
        return _this.renderer.render(_this.scene, _this.camera);
      });
    }

    /**
     * @method effect
     * @description Add three.js effect
     * @param {Object} effect three.js effect
     * @param {function} effectLoop update function for effect
     * @return {this}
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'effect',
    value: function effect(_effect) {
      var _this2 = this;

      var effectLoop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        _effect.render(_this2.scene, _this2.camera);
      };

      this.renderLoop.stop();

      var size = this.renderer.getSize();
      _effect.setSize(size.width, size.height);

      var loop = new Loop(effectLoop);

      this.effects.push(loop);
      if (this.enabled) loop.start(this.app);

      return this;
    }

    /**
     * @method setSize
     * @description Update render target width and height.
     * @param {Number} width
     * @param {Number} height
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'setSize',
    value: function setSize(width, height) {
      if (this.renderer) this.renderer.setSize(width, height);
    }

    /**
     * @method attachToCanvas
     * @description Attach renderer.domElement to element
     * @param {NodeElement} element DOM object
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'attachToCanvas',
    value: function attachToCanvas(element) {
      var canvas = this.renderer.domElement;

      // attach to new parent world dom
      element.appendChild(canvas);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
    }

    /**
     * @method stop
     * @description Stops renderLoop and effect loops
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'stop',
    value: function stop() {
      this.enabled = false;
      this.renderLoop.stop();
      this.effects.forEach(function (loop) {
        return loop.stop();
      });
    }

    /**
     * @method play
     * @description Resumes renderLoop and effect loops
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'play',
    value: function play() {
      this.enabled = true;
      this.renderLoop.start();
      this.effects.forEach(function (loop) {
        return loop.start();
      });
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      var _this3 = this;

      _manager.define('rendering');
      _manager.set('renderer', this.renderer);

      this.app = _manager.handler;

      this.renderLoop = this.integrateRenderer(_manager.get('element'), _manager.get('scene'), _manager.get('camera').native);

      _manager.update({
        element: function element(_element) {
          _this3.attachToCanvas(_element);
        },
        scene: function scene(_scene) {
          _this3.scene = _scene;
        },
        camera: function camera(_camera) {
          _this3.camera = _camera.native;
        }
      });
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var _this4 = this;

      self.renderLoop.start(this);
      self.effects.forEach(function (loop) {
        return loop.start(_this4);
      });
    }

    /**
     * @method dispose
     * @description Dispose rendering context
     * @memberof module:modules/app.RenderingModule
     */

  }, {
    key: 'dispose',
    value: function dispose() {
      this.stop();
      this.renderer.forceContextLoss();
    }
  }]);
  return RenderingModule;
}(), _class$35.additional = {
  shadow: function shadow(renderer) {
    renderer.shadowMap.enabled = true;
  }
}, _initialiseProps = function _initialiseProps() {
  this.enabled = true;
}, _temp$35);

/**
 * @class SceneModule
 * @category modules/app
 * @param {Boolean} [willSceneBeReplaced=false] willSceneBeReplaced should be true only if you are going to overwrite scene dependency even without the use of default one.
 * @memberof module:modules/app
 */

var SceneModule = function () {
  function SceneModule() {
    var willSceneBeReplaced = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    classCallCheck(this, SceneModule);

    this.scene = willSceneBeReplaced ? null : new Scene();
  }

  createClass(SceneModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('scene', this.scene);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      this.children = [];

      this.add = function (object) {
        var _this = this;

        object.parent = this;

        return new Promise(function (resolve, reject) {
          object.defer(function () {
            var native = object.native;

            if (!native) reject();

            var addPromise = _this.applyBridge({ onAdd: object }).onAdd;

            var resolver = function resolver() {
              self.scene.add(native);
              _this.children.push(object);

              resolve(object);
            };

            if (addPromise instanceof Promise) addPromise.then(resolver);else resolver();
          });
        });
      };

      this.remove = function (object) {
        object.parent = null;
        self.scene.remove(object.native);
      };

      this.setScene = function (scene) {
        self.scene = scene;
        this.manager.set('scene', scene);
      };
    }
  }]);
  return SceneModule;
}();

// import {addResizeListener} from 'detect-element-resize';

/**
 * @class ResizeModule
 * @category modules/app
 * @param {Object} [params={auto: true}] - If auto is set to true - resize will be triggered when container resizes
 * @memberof module:modules/app
 */
var ResizeModule = function () {
  function ResizeModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, ResizeModule);

    this.params = Object.assign({
      auto: true
    }, params);

    this.callbacks = [this.setSize.bind(this)];
  }

  /**
   * @function setSize
   * @instance
   * @description This function sets the provided width & height to the renderer object.
   * @param {Number} [width=1] - The promise that should be added to a queue.
   * @param {Number} [height=1] - that is resolved when all promises completed.
   * @memberof module:modules/app.ResizeModule
   */


  createClass(ResizeModule, [{
    key: 'setSize',
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this.camera.native.aspect = width / height;
      this.camera.native.updateProjectionMatrix();

      if (this.rendering) this.rendering.setSize(width, height);
    }

    /**
     * @method trigger
     * @instance
     * @description Triggers resize when called. width & height are determined automatically
     * This invokes each callbacks with the new width and height as params
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'trigger',
    value: function trigger() {
      var _container = this.container,
          offsetWidth = _container.offsetWidth,
          offsetHeight = _container.offsetHeight,
          resolution = this.resolution;


      var width = Number(offsetWidth * resolution.x).toFixed();
      var height = Number(offsetHeight * resolution.y).toFixed();

      this.callbacks.forEach(function (cb) {
        cb(width, height);
      });
    }

    /**
     * @method addAutoresize
     * @instance
     * @description Sets module to autoresize, this adds an event listene on window resize to trigger the resize
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'addAutoresize',
    value: function addAutoresize() {
      this.container = this.getContainer();
      this.resolution = this.getResolution();

      if (this.params.auto) window.addEventListener('resize', this.trigger.bind(this));
    }

    /**
     * @method addCallback
     * @instance
     * @description Adds a call back function to the existing callbacks list.
     * @param {Function} func - The callback function to add
     * @memberof module:modules/app.ResizeModule
     */

  }, {
    key: 'addCallback',
    value: function addCallback(func) {
      this.callbacks.push(func);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      var _this = this;

      _manager.define('resize');

      this.rendering = _manager.get('renderer');
      this.camera = _manager.get('camera');

      this.getResolution = function () {
        return _manager.use('rendering').params.resolution;
      };
      this.getContainer = function () {
        return _manager.get('container');
      };

      _manager.update({
        container: function container(_container2) {
          _this.container = _container2;
        }
      });

      this.addAutoresize();
    }
  }]);
  return ResizeModule;
}();

var fragment = "uniform sampler2D tPreviousLum;\r\nuniform sampler2D tCurrentLum;\r\nuniform float minLuminance;\r\nuniform float delta;\r\nuniform float tau;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tfloat previousLum = texture2D(tPreviousLum, vUv, MIP_LEVEL_1X1).r;\r\n\tfloat currentLum = texture2D(tCurrentLum, vUv, MIP_LEVEL_1X1).r;\r\n\r\n\tpreviousLum = max(minLuminance, previousLum);\r\n\tcurrentLum = max(minLuminance, currentLum);\r\n\r\n\t// Adapt the luminance using Pattanaik's technique.\r\n\tfloat adaptedLum = previousLum + (currentLum - previousLum) * (1.0 - exp(-delta * tau));\r\n\r\n\tgl_FragColor.r = adaptedLum;\r\n\r\n}\r\n";
var vertex = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * An adaptive luminosity shader material.
 */

var AdaptiveLuminosityMaterial = function (_ShaderMaterial) {
			inherits(AdaptiveLuminosityMaterial, _ShaderMaterial);

			/**
    * Constructs a new adaptive luminosity material.
    */

			function AdaptiveLuminosityMaterial() {
						classCallCheck(this, AdaptiveLuminosityMaterial);
						return possibleConstructorReturn(this, (AdaptiveLuminosityMaterial.__proto__ || Object.getPrototypeOf(AdaptiveLuminosityMaterial)).call(this, {

									type: "AdaptiveLuminosityMaterial",

									defines: {

												MIP_LEVEL_1X1: "0.0"

									},

									uniforms: {

												tPreviousLum: new Uniform(null),
												tCurrentLum: new Uniform(null),
												minLuminance: new Uniform(0.01),
												delta: new Uniform(0.0),
												tau: new Uniform(1.0)

									},

									fragmentShader: fragment,
									vertexShader: vertex,

									depthWrite: false,
									depthTest: false

						}));
			}

			return AdaptiveLuminosityMaterial;
}(ShaderMaterial);

var fragment$1 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform float focus;\r\nuniform float aspect;\r\nuniform float aperture;\r\nuniform float maxBlur;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tuniform float cameraNear;\r\n\tuniform float cameraFar;\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(1.0, aspect);\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = texture2D(tDepth, vUv).x;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = readDepth(tDepth, vUv);\r\n\r\n\t#endif\r\n\r\n\tfloat factor = depth - focus;\r\n\r\n\tvec2 dofBlur = vec2(clamp(factor * aperture, -maxBlur, maxBlur));\r\n\r\n\tvec2 dofblur9 = dofBlur * 0.9;\r\n\tvec2 dofblur7 = dofBlur * 0.7;\r\n\tvec2 dofblur4 = dofBlur * 0.4;\r\n\r\n\tvec4 color = vec4(0.0);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofBlur);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofBlur);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.15,  0.37) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.37,  0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.37, -0.15) * aspectCorrection) * dofblur9);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.15, -0.37) * aspectCorrection) * dofblur9);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.40,  0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur7);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur7);\r\n\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,  -0.4 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29,  0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.4,   0.0 ) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2(-0.29, -0.29) * aspectCorrection) * dofblur4);\r\n\tcolor += texture2D(tDiffuse, vUv + (vec2( 0.0,   0.4 ) * aspectCorrection) * dofblur4);\r\n\r\n\tgl_FragColor = color / 41.0;\r\n\r\n}\r\n";
var vertex$1 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Depth of Field shader (Bokeh).
 *
 * Original shader code by Martins Upitis:
 *  http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

var BokehMaterial = function (_ShaderMaterial) {
	inherits(BokehMaterial, _ShaderMaterial);

	/**
  * Constructs a new bokeh material.
  *
  * @param {PerspectiveCamera} [camera] - A camera.
  * @param {Object} [options] - The options.
  * @param {Number} [options.focus=1.0] - Focus distance.
  * @param {Number} [options.aperture=0.025] - Camera aperture scale. Bigger values for shallower depth of field.
  * @param {Number} [options.maxBlur=1.0] - Maximum blur strength.
  */

	function BokehMaterial() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		classCallCheck(this, BokehMaterial);


		if (options.focus === undefined) {
			options.focus = 1.0;
		}
		if (options.aperture === undefined) {
			options.aperture = 0.025;
		}
		if (options.maxBlur === undefined) {
			options.maxBlur = 1.0;
		}

		var _this = possibleConstructorReturn(this, (BokehMaterial.__proto__ || Object.getPrototypeOf(BokehMaterial)).call(this, {

			type: "BokehMaterial",

			uniforms: {

				cameraNear: new Uniform(0.1),
				cameraFar: new Uniform(2000),
				aspect: new Uniform(1.0),

				tDiffuse: new Uniform(null),
				tDepth: new Uniform(null),

				focus: new Uniform(options.focus),
				aperture: new Uniform(options.aperture),
				maxBlur: new Uniform(options.maxBlur)

			},

			fragmentShader: fragment$1,
			vertexShader: vertex$1,

			depthWrite: false,
			depthTest: false

		}));

		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Adopts the settings of the given camera.
  *
  * @param {PerspectiveCamera} camera - A camera.
  */

	createClass(BokehMaterial, [{
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
			this.uniforms.aspect.value = camera.aspect;
		}
	}]);
	return BokehMaterial;
}(ShaderMaterial);

var fragment$2 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tDepth;\r\n\r\nuniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\n\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n\r\nuniform float focalLength;\r\nuniform float focalStop;\r\n\r\nuniform float maxBlur;\r\nuniform vec3 luminanceCoefficients;\r\nuniform float luminanceThreshold;\r\nuniform float luminanceGain;\r\nuniform float bias;\r\nuniform float fringe;\r\nuniform float ditherStrength;\r\n\r\n#ifdef SHADER_FOCUS\r\n\r\n\tuniform vec2 focusCoords;\r\n\r\n#else\r\n\r\n\tuniform float focalDepth;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef PENTAGON\r\n\r\n\tfloat penta(vec2 coords) {\r\n\r\n\t\tconst vec4 HS0 = vec4( 1.0,          0.0,         0.0, 1.0);\r\n\t\tconst vec4 HS1 = vec4( 0.309016994,  0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS2 = vec4(-0.809016994,  0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS3 = vec4(-0.809016994, -0.587785252, 0.0, 1.0);\r\n\t\tconst vec4 HS4 = vec4( 0.309016994, -0.951056516, 0.0, 1.0);\r\n\t\tconst vec4 HS5 = vec4( 0.0,          0.0,         1.0, 1.0);\r\n\r\n\t\tconst vec4 ONE = vec4(1.0);\r\n\r\n\t\tconst float P_FEATHER = 0.4;\r\n\t\tconst float N_FEATHER = -P_FEATHER;\r\n\r\n\t\tfloat inOrOut = -4.0;\r\n\r\n\t\tvec4 P = vec4(coords, vec2(RINGS_FLOAT - 1.3));\r\n\r\n\t\tvec4 dist = vec4(\r\n\t\t\tdot(P, HS0),\r\n\t\t\tdot(P, HS1),\r\n\t\t\tdot(P, HS2),\r\n\t\t\tdot(P, HS3)\r\n\t\t);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\r\n\t\tinOrOut += dot(dist, ONE);\r\n\r\n\t\tdist.x = dot(P, HS4);\r\n\t\tdist.y = HS5.w - abs(P.z);\r\n\r\n\t\tdist = smoothstep(N_FEATHER, P_FEATHER, dist);\r\n\t\tinOrOut += dist.x;\r\n\r\n\t\treturn clamp(inOrOut, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef SHOW_FOCUS\r\n\r\n\tvec3 debugFocus(vec3 c, float blur, float depth) {\r\n\r\n\t\tfloat edge = 0.002 * depth;\r\n\t\tfloat m = clamp(smoothstep(0.0, edge, blur), 0.0, 1.0);\r\n\t\tfloat e = clamp(smoothstep(1.0 - edge, 1.0, blur), 0.0, 1.0);\r\n\r\n\t\tc = mix(c, vec3(1.0, 0.5, 0.0), (1.0 - m) * 0.6);\r\n\t\tc = mix(c, vec3(0.0, 0.5, 1.0), ((1.0 - e) - (1.0 - m)) * 0.2);\r\n\r\n\t\treturn c;\r\n\r\n\t}\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tfloat vignette() {\r\n\r\n\t\tconst vec2 CENTER = vec2(0.5);\r\n\r\n\t\tconst float VIGNETTE_OUT = 1.3;\r\n\t\tconst float VIGNETTE_IN = 0.0;\r\n\t\tconst float VIGNETTE_FADE = 22.0; \r\n\r\n\t\tfloat d = distance(vUv, CENTER);\r\n\t\td = smoothstep(VIGNETTE_OUT + (focalStop / VIGNETTE_FADE), VIGNETTE_IN + (focalStop / VIGNETTE_FADE), d);\r\n\r\n\t\treturn clamp(d, 0.0, 1.0);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvec2 rand(vec2 coord) {\r\n\r\n\tvec2 noise;\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tconst float a = 12.9898;\r\n\t\tconst float b = 78.233;\r\n\t\tconst float c = 43758.5453;\r\n\r\n\t\tnoise.x = clamp(fract(sin(mod(dot(coord, vec2(a, b)), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\t\tnoise.y = clamp(fract(sin(mod(dot(coord, vec2(a, b) * 2.0), 3.14)) * c), 0.0, 1.0) * 2.0 - 1.0;\r\n\r\n\t#else\r\n\r\n\t\tnoise.x = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.25) + (fract(coord.t * halfTexelSize.y) * 0.75)) * 2.0 - 1.0;\r\n\t\tnoise.y = ((fract(1.0 - coord.s * halfTexelSize.x) * 0.75) + (fract(coord.t * halfTexelSize.y) * 0.25)) * 2.0 - 1.0;\r\n\r\n\t#endif\r\n\r\n\treturn noise;\r\n\r\n}\r\n\r\nvec3 processTexel(vec2 coords, float blur) {\r\n\r\n\tvec3 c;\r\n\tc.r = texture2D(tDiffuse, coords + vec2(0.0, 1.0) * texelSize * fringe * blur).r;\r\n\tc.g = texture2D(tDiffuse, coords + vec2(-0.866, -0.5) * texelSize * fringe * blur).g;\r\n\tc.b = texture2D(tDiffuse, coords + vec2(0.866, -0.5) * texelSize * fringe * blur).b;\r\n\r\n\t// Calculate the luminance of the constructed colour.\r\n\tfloat luminance = dot(c, luminanceCoefficients);\r\n\tfloat threshold = max((luminance - luminanceThreshold) * luminanceGain, 0.0);\r\n\r\n\treturn c + mix(vec3(0.0), c, threshold * blur);\r\n\r\n}\r\n\r\nfloat linearize(float depth) {\r\n\r\n\treturn -cameraFar * cameraNear / (depth * (cameraFar - cameraNear) - cameraFar);\r\n\r\n}\r\n\r\nfloat gather(float i, float j, float ringSamples, inout vec3 color, float w, float h, float blur) {\r\n\r\n\tconst float TWO_PI = 6.28318531;\r\n\r\n\tfloat step = TWO_PI / ringSamples;\r\n\tfloat pw = cos(j * step) * i;\r\n\tfloat ph = sin(j * step) * i;\r\n\r\n\t#ifdef PENTAGON\r\n\r\n\t\tfloat p = penta(vec2(pw, ph));\r\n\r\n\t#else\r\n\r\n\t\tfloat p = 1.0;\r\n\r\n\t#endif\r\n\r\n\tcolor += processTexel(vUv + vec2(pw * w, ph * h), blur) * mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n\treturn mix(1.0, i / RINGS_FLOAT, bias) * p;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = linearize(texture2D(tDepth, vUv).x);\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = linearize(readDepth(tDepth, vUv));\r\n\r\n\t#endif\r\n\r\n\t#ifdef SHADER_FOCUS\r\n\r\n\t\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\t\tfloat fDepth = linearize(texture2D(tDepth, focusCoords).x);\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat fDepth = linearize(readDepth(tDepth, focusCoords));\r\n\r\n\t\t#endif\r\n\r\n\t#else\r\n\r\n\t\tfloat fDepth = focalDepth;\r\n\r\n\t#endif\r\n\r\n\t#ifdef MANUAL_DOF\r\n\r\n\t\tconst float nDoFStart = 1.0; \r\n\t\tconst float nDoFDist = 2.0;\r\n\t\tconst float fDoFStart = 1.0;\r\n\t\tconst float fDoFDist = 3.0;\r\n\r\n\t\tfloat focalPlane = depth - fDepth;\r\n\t\tfloat farDoF = (focalPlane - fDoFStart) / fDoFDist;\r\n\t\tfloat nearDoF = (-focalPlane - nDoFStart) / nDoFDist;\r\n\r\n\t\tfloat blur = (focalPlane > 0.0) ? farDoF : nearDoF;\r\n\r\n\t#else\r\n\r\n\t\tconst float CIRCLE_OF_CONFUSION = 0.03; // 35mm film = 0.03mm CoC.\r\n\r\n\t\tfloat focalPlaneMM = fDepth * 1000.0;\r\n\t\tfloat depthMM = depth * 1000.0;\r\n\r\n\t\tfloat focalPlane = (depthMM * focalLength) / (depthMM - focalLength);\r\n\t\tfloat farDoF = (focalPlaneMM * focalLength) / (focalPlaneMM - focalLength);\r\n\t\tfloat nearDoF = (focalPlaneMM - focalLength) / (focalPlaneMM * focalStop * CIRCLE_OF_CONFUSION);\r\n\r\n\t\tfloat blur = abs(focalPlane - farDoF) * nearDoF;\r\n\r\n\t#endif\r\n\r\n\tblur = clamp(blur, 0.0, 1.0);\r\n\r\n\t// Dithering.\r\n\tvec2 noise = rand(vUv) * ditherStrength * blur;\r\n\r\n\tfloat blurFactorX = texelSize.x * blur * maxBlur + noise.x;\r\n\tfloat blurFactorY = texelSize.y * blur * maxBlur + noise.y;\r\n\r\n\tconst int MAX_RING_SAMPLES = RINGS_INT * SAMPLES_INT;\r\n\r\n\t// Calculation of final color.\r\n\tvec4 color;\r\n\r\n\tif(blur < 0.05) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t\tfloat s = 1.0;\r\n\t\tint ringSamples;\r\n\r\n\t\tfor(int i = 1; i <= RINGS_INT; ++i) {\r\n\r\n\t\t\tringSamples = i * SAMPLES_INT;\r\n\r\n\t\t\t// Constant loop.\r\n\t\t\tfor(int j = 0; j < MAX_RING_SAMPLES; ++j) {\r\n\r\n\t\t\t\t// Break earlier.\r\n\t\t\t\tif(j >= ringSamples) { break; }\r\n\r\n\t\t\t\ts += gather(float(i), float(j), float(ringSamples), color.rgb, blurFactorX, blurFactorY, blur);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcolor.rgb /= s; // Divide by sample count.\r\n\r\n\t}\r\n\r\n\t#ifdef SHOW_FOCUS\r\n\r\n\t\tcolor.rgb = debugFocus(color.rgb, blur, depth);\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tcolor.rgb *= vignette();\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$2 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Depth of Field shader version 2.4.
 *
 * Original shader code by Martins Upitis:
 *  http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 */

var Bokeh2Material = function (_ShaderMaterial) {
	inherits(Bokeh2Material, _ShaderMaterial);

	/**
  * Constructs a new bokeh2 material.
  *
  * @param {PerspectiveCamera} [camera] - The main camera.
  * @param {Object} [options] - Additional options.
  * @param {Vector2} [options.texelSize] - The absolute screen texel size.
  * @param {Boolean} [options.showFocus=false] - Whether the focus point should be highlighted.
  * @param {Boolean} [options.manualDoF=false] - Enables manual depth of field blur.
  * @param {Boolean} [options.vignette=false] - Enables a vignette effect.
  * @param {Boolean} [options.pentagon=false] - Enable to use a pentagonal shape to scale gathered texels.
  * @param {Boolean} [options.shaderFocus=true] - Disable if you compute your own focalDepth (in metres!).
  * @param {Boolean} [options.noise=true] - Disable if you don't want noise patterns for dithering.
  */

	function Bokeh2Material() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		classCallCheck(this, Bokeh2Material);


		if (options.rings === undefined) {
			options.rings = 3;
		}
		if (options.samples === undefined) {
			options.samples = 2;
		}
		if (options.showFocus === undefined) {
			options.showFocus = false;
		}
		if (options.showFocus === undefined) {
			options.showFocus = false;
		}
		if (options.manualDoF === undefined) {
			options.manualDoF = false;
		}
		if (options.vignette === undefined) {
			options.vignette = false;
		}
		if (options.pentagon === undefined) {
			options.pentagon = false;
		}
		if (options.shaderFocus === undefined) {
			options.shaderFocus = true;
		}
		if (options.noise === undefined) {
			options.noise = true;
		}

		var _this = possibleConstructorReturn(this, (Bokeh2Material.__proto__ || Object.getPrototypeOf(Bokeh2Material)).call(this, {

			type: "Bokeh2Material",

			defines: {

				RINGS_INT: options.rings.toFixed(0),
				RINGS_FLOAT: options.rings.toFixed(1),
				SAMPLES_INT: options.samples.toFixed(0),
				SAMPLES_FLOAT: options.samples.toFixed(1)

			},

			uniforms: {

				tDiffuse: new Uniform(null),
				tDepth: new Uniform(null),

				texelSize: new Uniform(new Vector2()),
				halfTexelSize: new Uniform(new Vector2()),

				cameraNear: new Uniform(0.1),
				cameraFar: new Uniform(2000),

				focalLength: new Uniform(24.0),
				focalStop: new Uniform(0.9),

				maxBlur: new Uniform(1.0),
				luminanceThreshold: new Uniform(0.5),
				luminanceGain: new Uniform(2.0),
				luminanceCoefficients: new Uniform(new Vector3(0.2126, 0.7152, 0.0722)),
				bias: new Uniform(0.5),
				fringe: new Uniform(0.7),
				ditherStrength: new Uniform(0.0001),

				focusCoords: new Uniform(new Vector2(0.5, 0.5)),
				focalDepth: new Uniform(1.0)

			},

			fragmentShader: fragment$2,
			vertexShader: vertex$2,

			depthWrite: false,
			depthTest: false

		}));

		if (options.showFocus) {
			_this.defines.SHOW_FOCUS = "1";
		}
		if (options.manualDoF) {
			_this.defines.MANUAL_DOF = "1";
		}
		if (options.vignette) {
			_this.defines.VIGNETTE = "1";
		}
		if (options.pentagon) {
			_this.defines.PENTAGON = "1";
		}
		if (options.shaderFocus) {
			_this.defines.SHADER_FOCUS = "1";
		}
		if (options.noise) {
			_this.defines.NOISE = "1";
		}

		if (options.texelSize !== undefined) {
			_this.setTexelSize(options.texelSize.x, options.texelSize.y);
		}
		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Sets the texel size.
  *
  * @param {Number} x - The texel width.
  * @param {Number} y - The texel height.
  */

	createClass(Bokeh2Material, [{
		key: "setTexelSize",
		value: function setTexelSize(x, y) {

			this.uniforms.texelSize.value.set(x, y);
			this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
		}

		/**
   * Adopts the near and far plane and the focal length of the given camera.
   *
   * @param {PerspectiveCamera} camera - The main camera.
   */

	}, {
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
			this.uniforms.focalLength.value = camera.getFocalLength(); // unit: mm.
		}
	}]);
	return Bokeh2Material;
}(ShaderMaterial);

var fragment$3 = "uniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\n\r\nuniform float opacity1;\r\nuniform float opacity2;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel1 = opacity1 * texture2D(texture1, vUv);\r\n\tvec4 texel2 = opacity2 * texture2D(texture2, vUv);\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invTexel1 = vec3(1.0) - texel1.rgb;\r\n\t\tvec3 invTexel2 = vec3(1.0) - texel2.rgb;\r\n\r\n\t\tvec4 color = vec4(\r\n\t\t\tvec3(1.0) - invTexel1 * invTexel2,\r\n\t\t\ttexel1.a + texel2.a\r\n\t\t);\r\n\r\n\t#else\r\n\r\n\t\tvec4 color = texel1 + texel2;\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$3 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A material for combining two textures.
 *
 * This material supports the two blend modes Add and Screen.
 *
 * In Screen mode, the two textures are effectively projected on a white screen
 * simultaneously. In Add mode, the textures are simply added together which
 * often produces undesired, washed out results.
 */

var CombineMaterial = function (_ShaderMaterial) {
			inherits(CombineMaterial, _ShaderMaterial);

			/**
    * Constructs a new combine material.
    *
    * @param {Boolean} [screenMode=false] - Whether the screen blend mode should be used.
    */

			function CombineMaterial() {
						var screenMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
						classCallCheck(this, CombineMaterial);

						var _this = possibleConstructorReturn(this, (CombineMaterial.__proto__ || Object.getPrototypeOf(CombineMaterial)).call(this, {

									type: "CombineMaterial",

									uniforms: {

												texture1: new Uniform(null),
												texture2: new Uniform(null),

												opacity1: new Uniform(1.0),
												opacity2: new Uniform(1.0)

									},

									fragmentShader: fragment$3,
									vertexShader: vertex$3,

									depthWrite: false,
									depthTest: false

						}));

						if (screenMode) {
									_this.defines.SCREEN_MODE = "1";
						}

						return _this;
			}

			return CombineMaterial;
}(ShaderMaterial);

var fragment$4 = "uniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\t// Sample top left texel.\r\n\tvec4 sum = texture2D(tDiffuse, vUv0);\r\n\r\n\t// Sample top right texel.\r\n\tsum += texture2D(tDiffuse, vUv1);\r\n\r\n\t// Sample bottom right texel.\r\n\tsum += texture2D(tDiffuse, vUv2);\r\n\r\n\t// Sample bottom left texel.\r\n\tsum += texture2D(tDiffuse, vUv3);\r\n\r\n\t// Compute the average.\r\n\tgl_FragColor = sum * 0.25;\r\n\r\n}\r\n";
var vertex$4 = "uniform vec2 texelSize;\r\nuniform vec2 halfTexelSize;\r\nuniform float kernel;\r\n\r\nvarying vec2 vUv0;\r\nvarying vec2 vUv1;\r\nvarying vec2 vUv2;\r\nvarying vec2 vUv3;\r\n\r\nvoid main() {\r\n\r\n\tvec2 dUv = (texelSize * vec2(kernel)) + halfTexelSize;\r\n\r\n\tvUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\r\n\tvUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\r\n\tvUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\r\n\tvUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * An optimised convolution shader material.
 *
 * Based on the GDC2003 Presentation by Masaki Kawase, Bunkasha Games:
 *  Frame Buffer Postprocessing Effects in DOUBLE-S.T.E.A.L (Wreckless)
 * and an article by Filip Strugar, Intel:
 *  An investigation of fast real-time GPU-based image blur algorithms
 *
 * Further modified according to Apple's
 * [Best Practices for Shaders](https://goo.gl/lmRoM5).
 */

var ConvolutionMaterial = function (_ShaderMaterial) {
	inherits(ConvolutionMaterial, _ShaderMaterial);

	/**
  * Constructs a new convolution material.
  *
  * @param {Vector2} [texelSize] - The absolute screen texel size.
  */

	function ConvolutionMaterial() {
		var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
		classCallCheck(this, ConvolutionMaterial);

		var _this = possibleConstructorReturn(this, (ConvolutionMaterial.__proto__ || Object.getPrototypeOf(ConvolutionMaterial)).call(this, {

			type: "ConvolutionMaterial",

			uniforms: {

				tDiffuse: new Uniform(null),
				texelSize: new Uniform(new Vector2()),
				halfTexelSize: new Uniform(new Vector2()),
				kernel: new Uniform(0.0)

			},

			fragmentShader: fragment$4,
			vertexShader: vertex$4,

			depthWrite: false,
			depthTest: false

		}));

		_this.setTexelSize(texelSize.x, texelSize.y);

		/**
   * The current kernel size.
   *
   * @type {KernelSize}
   * @default KernelSize.LARGE
   */

		_this.kernelSize = KernelSize.LARGE;

		return _this;
	}

	/**
  * Returns the kernel.
  *
  * @return {Float32Array} The kernel.
  */

	createClass(ConvolutionMaterial, [{
		key: "getKernel",
		value: function getKernel() {
			return kernelPresets[this.kernelSize];
		}

		/**
   * Sets the texel size.
   *
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */

	}, {
		key: "setTexelSize",
		value: function setTexelSize(x, y) {

			this.uniforms.texelSize.value.set(x, y);
			this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);
		}
	}]);
	return ConvolutionMaterial;
}(ShaderMaterial);

/**
 * The Kawase blur kernel presets.
 *
 * @type {Float32Array[]}
 * @private
 */

var kernelPresets = [new Float32Array([0.0, 0.0]), new Float32Array([0.0, 1.0, 1.0]), new Float32Array([0.0, 1.0, 1.0, 2.0]), new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 4.0, 5.0]), new Float32Array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 7.0, 8.0, 9.0, 10.0])];

/**
 * A kernel size enumeration.
 *
 * @type {Object}
 * @property {Number} VERY_SMALL - A very small kernel that matches a 7x7 Gauss blur kernel.
 * @property {Number} SMALL - A small kernel that matches a 15x15 Gauss blur kernel.
 * @property {Number} MEDIUM - A medium sized kernel that matches a 23x23 Gauss blur kernel.
 * @property {Number} LARGE - A large kernel that matches a 35x35 Gauss blur kernel.
 * @property {Number} VERY_LARGE - A very large kernel that matches a 63x63 Gauss blur kernel.
 * @property {Number} HUGE - A huge kernel that matches a 127x127 Gauss blur kernel.
 */

var KernelSize = {

	VERY_SMALL: 0,
	SMALL: 1,
	MEDIUM: 2,
	LARGE: 3,
	VERY_LARGE: 4,
	HUGE: 5

};

var fragment$5 = "uniform sampler2D tDiffuse;\r\nuniform float opacity;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = opacity * texel;\r\n\r\n}\r\n";
var vertex$5 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A simple copy shader material.
 */

var CopyMaterial = function (_ShaderMaterial) {
			inherits(CopyMaterial, _ShaderMaterial);

			/**
    * Constructs a new copy material.
    */

			function CopyMaterial() {
						classCallCheck(this, CopyMaterial);
						return possibleConstructorReturn(this, (CopyMaterial.__proto__ || Object.getPrototypeOf(CopyMaterial)).call(this, {

									type: "CopyMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),
												opacity: new Uniform(1.0)

									},

									fragmentShader: fragment$5,
									vertexShader: vertex$5,

									depthWrite: false,
									depthTest: false

						}));
			}

			return CopyMaterial;
}(ShaderMaterial);

var fragment$6 = "uniform sampler2D tDepth;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifndef USE_LOGDEPTHBUF\r\n\r\n\t#include <packing>\r\n\r\n\tuniform float cameraNear;\r\n\tuniform float cameraFar;\r\n\r\n\tfloat readDepth(sampler2D depthSampler, vec2 coord) {\r\n\r\n\t\tfloat fragCoordZ = texture2D(depthSampler, coord).x;\r\n\t\tfloat viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n\r\n\t\treturn viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);\r\n\r\n\t}\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\t#ifdef USE_LOGDEPTHBUF\r\n\r\n\t\tfloat depth = texture2D(tDepth, vUv).x;\r\n\r\n\t#else\r\n\r\n\t\tfloat depth = readDepth(tDepth, vUv);\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = vec4(depth, depth, depth, 1.0);\r\n\r\n}\r\n";
var vertex$6 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A depth shader material.
 */

var DepthMaterial = function (_ShaderMaterial) {
	inherits(DepthMaterial, _ShaderMaterial);

	/**
  * Constructs a new depth material.
  *
  * @param {PerspectiveCamera} [camera] - A camera.
  */

	function DepthMaterial() {
		var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		classCallCheck(this, DepthMaterial);

		var _this = possibleConstructorReturn(this, (DepthMaterial.__proto__ || Object.getPrototypeOf(DepthMaterial)).call(this, {

			type: "DepthMaterial",

			uniforms: {

				cameraNear: new Uniform(0.1),
				cameraFar: new Uniform(2000),

				tDepth: new Uniform(null)

			},

			fragmentShader: fragment$6,
			vertexShader: vertex$6,

			depthWrite: false,
			depthTest: false

		}));

		if (camera !== null) {
			_this.adoptCameraSettings(camera);
		}

		return _this;
	}

	/**
  * Adopts the settings of the given camera.
  *
  * @param {PerspectiveCamera} camera - A camera.
  */

	createClass(DepthMaterial, [{
		key: "adoptCameraSettings",
		value: function adoptCameraSettings(camera) {

			this.uniforms.cameraNear.value = camera.near;
			this.uniforms.cameraFar.value = camera.far;
		}
	}]);
	return DepthMaterial;
}(ShaderMaterial);

var fragment$7 = "uniform sampler2D tDiffuse;\r\n\r\nuniform float angle;\r\nuniform float scale;\r\nuniform float intensity;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nfloat pattern() {\r\n\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\r\n\tvec2 point = vec2(c * vUvPattern.x - s * vUvPattern.y, s * vUvPattern.x + c * vUvPattern.y) * scale;\r\n\r\n\treturn (sin(point.x) * sin(point.y)) * 4.0;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef AVERAGE\r\n\r\n\t\tcolor = vec3((color.r + color.g + color.b) / 3.0);\r\n\r\n\t#endif\r\n\r\n\tcolor = vec3(color * 10.0 - 5.0 + pattern());\r\n\tcolor = texel.rgb + (color - texel.rgb) * intensity;\r\n\r\n\tgl_FragColor = vec4(color, texel.a);\r\n\r\n}\r\n";
var vertex$7 = "uniform vec4 offsetRepeat;\r\n\r\nvarying vec2 vUv;\r\nvarying vec2 vUvPattern;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvUvPattern = uv * offsetRepeat.zw + offsetRepeat.xy;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A dot screen shader material.
 */

var DotScreenMaterial = function (_ShaderMaterial) {
			inherits(DotScreenMaterial, _ShaderMaterial);

			/**
    * Constructs a new dot screen material.
    *
    * @param {Boolean} [average=false] - Whether the shader should output the colour average (black and white).
    */

			function DotScreenMaterial() {
						var average = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
						classCallCheck(this, DotScreenMaterial);

						var _this = possibleConstructorReturn(this, (DotScreenMaterial.__proto__ || Object.getPrototypeOf(DotScreenMaterial)).call(this, {

									type: "DotScreenMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),

												angle: new Uniform(1.57),
												scale: new Uniform(1.0),
												intensity: new Uniform(1.0),

												offsetRepeat: new Uniform(new Vector4(0.5, 0.5, 1.0, 1.0))

									},

									fragmentShader: fragment$7,
									vertexShader: vertex$7,

									depthWrite: false,
									depthTest: false

						}));

						if (average) {
									_this.defines.AVERAGE = "1";
						}

						return _this;
			}

			return DotScreenMaterial;
}(ShaderMaterial);

var fragment$8 = "uniform sampler2D tDiffuse;\r\nuniform float time;\r\n\r\nvarying vec2 vUv;\r\n\r\n#ifdef NOISE\r\n\r\n\tuniform float noiseIntensity;\r\n\r\n#endif\r\n\r\n#ifdef SCANLINES\r\n\r\n\tuniform float scanlineIntensity;\r\n\tuniform float scanlineCount;\r\n\r\n#endif\r\n\r\n#ifdef GREYSCALE\r\n\r\n\tuniform vec3 luminanceCoefficients;\r\n\tuniform float greyscaleIntensity;\r\n\r\n#elif defined(SEPIA)\r\n\r\n\tuniform float sepiaIntensity;\r\n\r\n#endif\r\n\r\n#ifdef VIGNETTE\r\n\r\n\tuniform float vignetteOffset;\r\n\tuniform float vignetteDarkness;\r\n\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tvec3 color = texel.rgb;\r\n\r\n\t#ifdef SCREEN_MODE\r\n\r\n\t\tvec3 invColor;\r\n\r\n\t#endif\r\n\r\n\t#ifdef NOISE\r\n\r\n\t\tfloat x = vUv.x * vUv.y * time * 1000.0;\r\n\t\tx = mod(x, 13.0) * mod(x, 123.0);\r\n\t\tx = mod(x, 0.01);\r\n\r\n\t\tvec3 noise = texel.rgb * clamp(0.1 + x * 100.0, 0.0, 1.0) * noiseIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invNoise = vec3(1.0) - noise;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invNoise;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += noise;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef SCANLINES\r\n\r\n\t\tvec2 sl = vec2(sin(vUv.y * scanlineCount), cos(vUv.y * scanlineCount));\r\n\t\tvec3 scanlines = texel.rgb * vec3(sl.x, sl.y, sl.x) * scanlineIntensity;\r\n\r\n\t\t#ifdef SCREEN_MODE\r\n\r\n\t\t\tinvColor = vec3(1.0) - color;\r\n\t\t\tvec3 invScanlines = vec3(1.0) - scanlines;\r\n\r\n\t\t\tcolor = vec3(1.0) - invColor * invScanlines;\r\n\r\n\t\t#else\r\n\r\n\t\t\tcolor += scanlines;\r\n\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#ifdef GREYSCALE\r\n\r\n\t\tcolor = mix(color, vec3(dot(color, luminanceCoefficients)), greyscaleIntensity);\r\n\r\n\t#elif defined(SEPIA)\r\n\r\n\t\tvec3 c = color.rgb;\r\n\r\n\t\tcolor.r = dot(c, vec3(1.0 - 0.607 * sepiaIntensity, 0.769 * sepiaIntensity, 0.189 * sepiaIntensity));\r\n\t\tcolor.g = dot(c, vec3(0.349 * sepiaIntensity, 1.0 - 0.314 * sepiaIntensity, 0.168 * sepiaIntensity));\r\n\t\tcolor.b = dot(c, vec3(0.272 * sepiaIntensity, 0.534 * sepiaIntensity, 1.0 - 0.869 * sepiaIntensity));\r\n\r\n\t#endif\r\n\r\n\t#ifdef VIGNETTE\r\n\r\n\t\tconst vec2 center = vec2(0.5);\r\n\r\n\t\t#ifdef ESKIL\r\n\r\n\t\t\tvec2 uv = (vUv - center) * vec2(vignetteOffset);\r\n\t\t\tcolor = mix(color.rgb, vec3(1.0 - vignetteDarkness), dot(uv, uv));\r\n\r\n\t\t#else\r\n\r\n\t\t\tfloat dist = distance(vUv, center);\r\n\t\t\tcolor *= smoothstep(0.8, vignetteOffset * 0.799, dist * (vignetteDarkness + vignetteOffset));\r\n\r\n\t\t#endif\t\t\r\n\r\n\t#endif\r\n\r\n\tgl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);\r\n\r\n}\r\n";
var vertex$8 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A cinematic shader that provides the following effects:
 *  - Film Grain
 *  - Scanlines
 *  - Vignette
 *  - Greyscale
 *  - Sepia
 *
 * Original scanlines algorithm by Pat "Hawthorne" Shearon.
 *  http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Optimised scanlines and noise with intensity scaling by Georg "Leviathan"
 * Steinrohder. This version was provided under a Creative Commons Attribution
 * 3.0 License: http://creativecommons.org/licenses/by/3.0.
 *
 * The sepia effect is based on:
 *  https://github.com/evanw/glfx.js
 *
 * The vignette code is based on PaintEffect postprocess from ro.me:
 *  http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

var FilmMaterial = function (_ShaderMaterial) {
		inherits(FilmMaterial, _ShaderMaterial);

		/**
   * Constructs a new film material.
   *
   * @param {Object} [options] - The options. Disabled effects will not be included in the final shader and have no negative impact on performance.
   * @param {Boolean} [options.greyscale=false] - Enable greyscale effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.sepia=false] - Enable sepia effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.vignette=false] - Apply vignette effect.
   * @param {Boolean} [options.eskil=false] - Use Eskil's vignette approach. The default looks dusty while Eskil looks burned out.
   * @param {Boolean} [options.screenMode=true] - Whether the screen blend mode should be used for noise and scanlines. Both of these effects are computed independently.
   * @param {Boolean} [options.noise=true] - Show noise-based film grain.
   * @param {Boolean} [options.scanlines=true] - Show scanlines.
   * @param {Number} [options.noiseIntensity=0.5] - The noise intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineIntensity=0.05] - The scanline intensity. 0.0 to 1.0.
   * @param {Number} [options.greyscaleIntensity=1.0] - The intensity of the greyscale effect. 0.0 to 1.0.
   * @param {Number} [options.sepiaIntensity=1.0] - The intensity of the sepia effect. 0.0 to 1.0.
   * @param {Number} [options.vignetteOffset=1.0] - The offset of the vignette effect. 0.0 to 1.0.
   * @param {Number} [options.vignetteDarkness=1.0] - The darkness of the vignette effect. 0.0 to 1.0.
   */

		function FilmMaterial() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, FilmMaterial);


				if (options.screenMode === undefined) {
						options.screenMode = true;
				}
				if (options.noise === undefined) {
						options.noise = true;
				}
				if (options.scanlines === undefined) {
						options.scanlines = true;
				}

				if (options.greyscale === undefined) {
						options.greyscale = false;
				}
				if (options.sepia === undefined) {
						options.sepia = false;
				}
				if (options.vignette === undefined) {
						options.vignette = false;
				}
				if (options.eskil === undefined) {
						options.eskil = false;
				}

				if (options.noiseIntensity === undefined) {
						options.noiseIntensity = 0.5;
				}
				if (options.scanlineIntensity === undefined) {
						options.scanlineIntensity = 0.05;
				}
				if (options.greyscaleIntensity === undefined) {
						options.greyscaleIntensity = 1.0;
				}
				if (options.sepiaIntensity === undefined) {
						options.sepiaIntensity = 1.0;
				}

				if (options.vignetteOffset === undefined) {
						options.vignetteOffset = 1.0;
				}
				if (options.vignetteDarkness === undefined) {
						options.vignetteDarkness = 1.0;
				}

				var _this = possibleConstructorReturn(this, (FilmMaterial.__proto__ || Object.getPrototypeOf(FilmMaterial)).call(this, {

						type: "FilmMaterial",

						uniforms: {

								tDiffuse: new Uniform(null),
								time: new Uniform(0.0),

								noiseIntensity: new Uniform(options.noiseIntensity),
								scanlineIntensity: new Uniform(options.scanlineIntensity),
								scanlineCount: new Uniform(0.0),

								luminanceCoefficients: new Uniform(new Vector3(0.2126, 0.7152, 0.0722)),
								greyscaleIntensity: new Uniform(options.greyscaleIntensity),
								sepiaIntensity: new Uniform(options.sepiaIntensity),

								vignetteOffset: new Uniform(options.vignetteOffset),
								vignetteDarkness: new Uniform(options.vignetteDarkness)

						},

						fragmentShader: fragment$8,
						vertexShader: vertex$8,

						depthWrite: false,
						depthTest: false

				}));

				if (options.greyscale) {
						_this.defines.GREYSCALE = "1";
				}
				if (options.sepia) {
						_this.defines.SEPIA = "1";
				}
				if (options.vignette) {
						_this.defines.VIGNETTE = "1";
				}
				if (options.eskil) {
						_this.defines.ESKIL = "1";
				}

				if (options.screenMode) {
						_this.defines.SCREEN_MODE = "1";
				}
				if (options.noise) {
						_this.defines.NOISE = "1";
				}
				if (options.scanlines) {
						_this.defines.SCANLINES = "1";
				}

				return _this;
		}

		return FilmMaterial;
}(ShaderMaterial);

var fragment$9 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tPerturb;\r\n\r\nuniform bool active;\r\n\r\nuniform float amount;\r\nuniform float angle;\r\nuniform float seed;\r\nuniform float seedX;\r\nuniform float seedY;\r\nuniform float distortionX;\r\nuniform float distortionY;\r\nuniform float colS;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat rand(vec2 tc) {\r\n\r\n\tconst float a = 12.9898;\r\n\tconst float b = 78.233;\r\n\tconst float c = 43758.5453;\r\n\r\n\tfloat dt = dot(tc, vec2(a, b));\r\n\tfloat sn = mod(dt, 3.14);\r\n\r\n\treturn fract(sin(sn) * c);\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec2 coord = vUv;\r\n\r\n\tfloat xs, ys;\r\n\tvec4 normal;\r\n\r\n\tvec2 offset;\r\n\tvec4 cr, cga, cb;\r\n\tvec4 snow, color;\r\n\r\n\tfloat sx, sy;\r\n\r\n\tif(active) {\r\n\r\n\t\txs = floor(gl_FragCoord.x / 0.5);\r\n\t\tys = floor(gl_FragCoord.y / 0.5);\r\n\r\n\t\tnormal = texture2D(tPerturb, coord * seed * seed);\r\n\r\n\t\tif(coord.y < distortionX + colS && coord.y > distortionX - colS * seed) {\r\n\r\n\t\t\tsx = clamp(ceil(seedX), 0.0, 1.0);\r\n\t\t\tcoord.y = sx * (1.0 - (coord.y + distortionY)) + (1.0 - sx) * distortionY;\r\n\r\n\t\t}\r\n\r\n\t\tif(coord.x < distortionY + colS && coord.x > distortionY - colS * seed) {\r\n\r\n\t\t\tsy = clamp(ceil(seedY), 0.0, 1.0);\r\n\t\t\tcoord.x = sy * distortionX + (1.0 - sy) * (1.0 - (coord.x + distortionX));\r\n\r\n\t\t}\r\n\r\n\t\tcoord.x += normal.x * seedX * (seed / 5.0);\r\n\t\tcoord.y += normal.y * seedY * (seed / 5.0);\r\n\r\n\t\toffset = amount * vec2(cos(angle), sin(angle));\r\n\r\n\t\tcr = texture2D(tDiffuse, coord + offset);\r\n\t\tcga = texture2D(tDiffuse, coord);\r\n\t\tcb = texture2D(tDiffuse, coord - offset);\r\n\r\n\t\tcolor = vec4(cr.r, cga.g, cb.b, cga.a);\r\n\t\tsnow = 200.0 * amount * vec4(rand(vec2(xs * seed, ys * seed * 50.0)) * 0.2);\r\n\t\tcolor += snow;\r\n\r\n\t} else {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$9 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A glitch shader material.
 *
 * Reference:
 *  https://github.com/staffantan/unityglitch
 */

var GlitchMaterial = function (_ShaderMaterial) {
			inherits(GlitchMaterial, _ShaderMaterial);

			/**
    * Constructs a new glitch material.
    */

			function GlitchMaterial() {
						classCallCheck(this, GlitchMaterial);
						return possibleConstructorReturn(this, (GlitchMaterial.__proto__ || Object.getPrototypeOf(GlitchMaterial)).call(this, {

									type: "GlitchMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),
												tPerturb: new Uniform(null),

												active: new Uniform(1),

												amount: new Uniform(0.8),
												angle: new Uniform(0.02),
												seed: new Uniform(0.02),
												seedX: new Uniform(0.02),
												seedY: new Uniform(0.02),
												distortionX: new Uniform(0.5),
												distortionY: new Uniform(0.6),
												colS: new Uniform(0.05)

									},

									fragmentShader: fragment$9,
									vertexShader: vertex$9,

									depthWrite: false,
									depthTest: false

						}));
			}

			return GlitchMaterial;
}(ShaderMaterial);

var fragment$10 = "uniform sampler2D tDiffuse;\r\nuniform vec3 lightPosition;\r\n\r\nuniform float exposure;\r\nuniform float decay;\r\nuniform float density;\r\nuniform float weight;\r\nuniform float clampMax;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec2 texCoord = vUv;\r\n\r\n\t// Calculate vector from pixel to light source in screen space.\r\n\tvec2 deltaTexCoord = texCoord - lightPosition.st;\r\n\tdeltaTexCoord *= 1.0 / NUM_SAMPLES_FLOAT * density;\r\n\r\n\t// A decreasing illumination factor.\r\n\tfloat illuminationDecay = 1.0;\r\n\r\n\tvec4 sample;\r\n\tvec4 color = vec4(0.0);\r\n\r\n\t// Estimate the probability of occlusion at each pixel by summing samples along a ray to the light source.\r\n\tfor(int i = 0; i < NUM_SAMPLES_INT; ++i) {\r\n\r\n\t\ttexCoord -= deltaTexCoord;\r\n\t\tsample = texture2D(tDiffuse, texCoord);\r\n\r\n\t\t// Apply sample attenuation scale/decay factors.\r\n\t\tsample *= illuminationDecay * weight;\r\n\r\n\t\tcolor += sample;\r\n\r\n\t\t// Update exponential decay factor.\r\n\t\tilluminationDecay *= decay;\r\n\r\n\t}\r\n\r\n\tgl_FragColor = clamp(color * exposure, 0.0, clampMax);\r\n\r\n}\r\n";
var vertex$10 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A crepuscular rays shader material.
 *
 * References:
 *
 * Thibaut Despoulain, 2012:
 *  [(WebGL) Volumetric Light Approximation in Three.js](
 *  http://bkcore.com/blog/3d/webgl-three-js-volumetric-light-godrays.html)
 *
 * Nvidia, GPU Gems 3, 2008:
 *  [Chapter 13. Volumetric Light Scattering as a Post-Process](
 *  https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch13.html)
 */

var GodRaysMaterial = function (_ShaderMaterial) {
			inherits(GodRaysMaterial, _ShaderMaterial);

			/**
    * Constructs a new god rays material.
    */

			function GodRaysMaterial() {
						classCallCheck(this, GodRaysMaterial);
						return possibleConstructorReturn(this, (GodRaysMaterial.__proto__ || Object.getPrototypeOf(GodRaysMaterial)).call(this, {

									type: "GodRaysMaterial",

									defines: {

												NUM_SAMPLES_FLOAT: "60.0",
												NUM_SAMPLES_INT: "60"

									},

									uniforms: {

												tDiffuse: new Uniform(null),
												lightPosition: new Uniform(null),

												exposure: new Uniform(0.6),
												decay: new Uniform(0.93),
												density: new Uniform(0.96),
												weight: new Uniform(0.4),
												clampMax: new Uniform(1.0)

									},

									fragmentShader: fragment$10,
									vertexShader: vertex$10,

									depthWrite: false,
									depthTest: false

						}));
			}

			return GodRaysMaterial;
}(ShaderMaterial);

var fragment$11 = "uniform sampler2D tDiffuse;\r\nuniform float distinction;\r\nuniform vec2 range;\r\nuniform vec3 luminanceCoefficients;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tfloat v = dot(texel.rgb, luminanceCoefficients);\r\n\r\n\t#ifdef RANGE\r\n\r\n\t\tfloat low = step(range.x, v);\r\n\t\tfloat high = step(v, range.y);\r\n\r\n\t\t// Apply the mask.\r\n\t\tv *= low * high;\r\n\r\n\t#endif\r\n\r\n\tv = pow(abs(v), distinction);\r\n\r\n\t#ifdef COLOR\r\n\r\n\t\tgl_FragColor = vec4(texel.rgb * v, texel.a);\r\n\r\n\t#else\r\n\r\n\t\tgl_FragColor = vec4(v, v, v, texel.a);\r\n\r\n\t#endif\r\n\r\n}\r\n";
var vertex$11 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A luminosity shader material.
 *
 * This shader produces a greyscale luminance map that describes the absolute
 * amount of light emitted by a scene. It can also be configured to output
 * colours that are scaled with their respective luminance value. Additionally,
 * a range may be provided to mask out undesired texels.
 *
 * The alpha channel will remain unaffected in all cases.
 *
 * On luminance coefficients:
 *  http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9
 *
 * Coefficients for different colour spaces:
 *  https://hsto.org/getpro/habr/post_images/2ab/69d/084/2ab69d084f9a597e032624bcd74d57a7.png
 *
 * Luminance range reference:
 *  https://cycling74.com/2007/05/23/your-first-shader/#.Vty9FfkrL4Z
 */

var LuminosityMaterial = function (_ShaderMaterial) {
	inherits(LuminosityMaterial, _ShaderMaterial);

	/**
  * Constructs a new luminosity material.
  *
  * @param {Boolean} [color=false] - Defines whether the shader should output colours scaled with their luminance value.
  * @param {Vector2} [range] - If provided, the shader will mask out texels that aren't in the specified luminance range.
  */

	function LuminosityMaterial() {
		var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
		var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
		classCallCheck(this, LuminosityMaterial);

		var _this = possibleConstructorReturn(this, (LuminosityMaterial.__proto__ || Object.getPrototypeOf(LuminosityMaterial)).call(this, {

			type: "LuminosityMaterial",

			uniforms: {

				tDiffuse: new Uniform(null),
				distinction: new Uniform(1.0),
				range: new Uniform(range !== null ? range : new Vector2()),
				luminanceCoefficients: new Uniform(new Vector3(0.2126, 0.7152, 0.0722))

			},

			fragmentShader: fragment$11,
			vertexShader: vertex$11

		}));

		if (color) {
			_this.defines.COLOR = "1";
		}
		if (range !== null) {
			_this.defines.RANGE = "1";
		}

		return _this;
	}

	return LuminosityMaterial;
}(ShaderMaterial);

var fragment$12 = "uniform sampler2D tDiffuse;\r\nuniform float granularity;\r\nuniform float dx;\r\nuniform float dy;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel;\r\n\r\n\tif(granularity > 0.0) {\r\n\r\n\t\tvec2 coord = vec2(\r\n\t\t\tdx * (floor(vUv.x / dx) + 0.5),\r\n\t\t\tdy * (floor(vUv.y / dy) + 0.5)\r\n\t\t);\r\n\r\n\t\ttexel = texture2D(tDiffuse, coord);\r\n\r\n\t} else {\r\n\r\n\t\ttexel = texture2D(tDiffuse, vUv);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texel;\r\n\r\n}\r\n";
var vertex$12 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A pixelation shader material.
 *
 * Original shader code by Robert Casanova:
 *  https://github.com/robertcasanova/pixelate-shader
 */

var PixelationMaterial = function (_ShaderMaterial) {
	inherits(PixelationMaterial, _ShaderMaterial);

	/**
  * Constructs a new pixelation material.
  */

	function PixelationMaterial() {
		classCallCheck(this, PixelationMaterial);
		return possibleConstructorReturn(this, (PixelationMaterial.__proto__ || Object.getPrototypeOf(PixelationMaterial)).call(this, {

			type: "PixelationMaterial",

			uniforms: {

				tDiffuse: new Uniform(null),
				granularity: new Uniform(1.0),
				resolution: new Uniform(new Vector2(1.0, 1.0)),
				dx: new Uniform(1.0),
				dy: new Uniform(1.0)

			},

			fragmentShader: fragment$12,
			vertexShader: vertex$12,

			depthWrite: false,
			depthTest: false

		}));
	}

	/**
  * The pixel granularity.
  *
  * @type {Number}
  */

	createClass(PixelationMaterial, [{
		key: "setResolution",


		/**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */

		value: function setResolution(width, height) {

			this.uniforms.resolution.value.set(width, height);
			this.granularity = this.granularity;
		}
	}, {
		key: "granularity",
		get: function get$$1() {
			return this.uniforms.granularity.value;
		}

		/**
   * A higher value yields coarser visuals.
   *
   * @type {Number}
   */

		,
		set: function set$$1(x) {

			var uniforms = this.uniforms;
			var resolution = uniforms.resolution.value;

			uniforms.granularity.value = x;
			uniforms.dx.value = x / resolution.x;
			uniforms.dy.value = x / resolution.y;
		}
	}]);
	return PixelationMaterial;
}(ShaderMaterial);

var fragment$13 = "#include <common>\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform vec2 center;\r\nuniform float aspect;\r\nuniform float waveSize;\r\nuniform float radius;\r\nuniform float maxRadius;\r\nuniform float amplitude;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvec2 aspectCorrection = vec2(aspect, 1.0);\r\n\r\n\tvec2 difference = vUv * aspectCorrection - center * aspectCorrection;\r\n\tfloat distance = sqrt(dot(difference, difference)) * vSize;\r\n\r\n\tvec2 displacement = vec2(0.0);\r\n\r\n\tif(distance > radius) {\r\n\r\n\t\tif(distance < radius + waveSize) {\r\n\r\n\t\t\tfloat angle = (distance - radius) * PI2 / waveSize;\r\n\t\t\tfloat cosSin = (1.0 - cos(angle)) * 0.5;\r\n\r\n\t\t\tfloat extent = maxRadius + waveSize;\r\n\t\t\tfloat decay = max(extent - distance * distance, 0.0) / extent;\r\n\r\n\t\t\tdisplacement = ((cosSin * amplitude * difference) / distance) * decay;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgl_FragColor = texture2D(tDiffuse, vUv - displacement);\r\n\r\n}\r\n";
var vertex$13 = "uniform float size;\r\nuniform float scale;\r\nuniform float cameraDistance;\r\n\r\nvarying vec2 vUv;\r\nvarying float vSize;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tvSize = (0.1 * cameraDistance) / size;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * A shock wave shader material.
 *
 * Based on a Gist by Jean-Philippe Sarda:
 *  https://gist.github.com/jpsarda/33cea67a9f2ecb0a0eda
 */

var ShockWaveMaterial = function (_ShaderMaterial) {
			inherits(ShockWaveMaterial, _ShaderMaterial);

			/**
    * Constructs a new shock wave material.
    *
    * @param {Object} [options] - The options.
    * @param {Number} [options.waveSize=0.2] - The wave size.
    * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
    */

			function ShockWaveMaterial() {
						var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
						classCallCheck(this, ShockWaveMaterial);


						if (options.maxRadius === undefined) {
									options.maxRadius = 1.0;
						}
						if (options.waveSize === undefined) {
									options.waveSize = 0.2;
						}
						if (options.amplitude === undefined) {
									options.amplitude = 0.05;
						}

						return possibleConstructorReturn(this, (ShockWaveMaterial.__proto__ || Object.getPrototypeOf(ShockWaveMaterial)).call(this, {

									type: "ShockWaveMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),

												center: new Uniform(new Vector2(0.5, 0.5)),
												aspect: new Uniform(1.0),
												cameraDistance: new Uniform(1.0),

												size: new Uniform(1.0),
												radius: new Uniform(-options.waveSize),
												maxRadius: new Uniform(options.maxRadius),
												waveSize: new Uniform(options.waveSize),
												amplitude: new Uniform(options.amplitude)

									},

									fragmentShader: fragment$13,
									vertexShader: vertex$13,

									depthWrite: false,
									depthTest: false

						}));
			}

			return ShockWaveMaterial;
}(ShaderMaterial);

var fragment$14 = "uniform sampler2D tDiffuse;\r\nuniform sampler2D tWeights;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\t// Fetch the blending weights for current pixel.\r\n\tvec4 a;\r\n\ta.xz = texture2D(tWeights, vUv).xz;\r\n\ta.y = texture2D(tWeights, vOffset.zw).g;\r\n\ta.w = texture2D(tWeights, vOffset.xy).a;\r\n\r\n\tvec4 color;\r\n\r\n\t// Check if there is any blending weight with a value greater than 0.0.\r\n\tif(dot(a, vec4(1.0)) < 1e-5) {\r\n\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\r\n\t} else {\r\n\r\n\t\t/* Up to four lines can be crossing a pixel (one through each edge). We favor\r\n\t\t * blending by choosing the line with the maximum weight for each direction.\r\n\t\t */\r\n\r\n\t\tvec2 offset;\r\n\t\toffset.x = a.a > a.b ? a.a : -a.b; // Left vs. right.\r\n\t\toffset.y = a.g > a.r ? -a.g : a.r; // Top vs. bottom (changed signs).\r\n\r\n\t\t// Then we go in the direction that has the maximum weight (horizontal vs. vertical).\r\n\t\tif(abs(offset.x) > abs(offset.y)) {\r\n\r\n\t\t\toffset.y = 0.0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\toffset.x = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\t// Fetch the opposite color and lerp by hand.\r\n\t\tcolor = texture2D(tDiffuse, vUv, 0.0);\r\n\t\tvec2 coord = vUv + sign(offset) * texelSize;\r\n\t\tvec4 oppositeColor = texture2D(tDiffuse, coord, 0.0);\r\n\t\tfloat s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);\r\n\r\n\t\t// Gamma correction.\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(2.2));\r\n\t\toppositeColor.rgb = pow(abs(oppositeColor.rgb), vec3(2.2));\r\n\t\tcolor = mix(color, oppositeColor, s);\r\n\t\tcolor.rgb = pow(abs(color.rgb), vec3(1.0 / 2.2));\r\n\r\n\t}\r\n\r\n\tgl_FragColor = color;\r\n\r\n}\r\n";
var vertex$14 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material is used to render the final antialiasing.
 */

var SMAABlendMaterial = function (_ShaderMaterial) {
			inherits(SMAABlendMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA blend material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAABlendMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
						classCallCheck(this, SMAABlendMaterial);
						return possibleConstructorReturn(this, (SMAABlendMaterial.__proto__ || Object.getPrototypeOf(SMAABlendMaterial)).call(this, {

									type: "SMAABlendMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),
												tWeights: new Uniform(null),
												texelSize: new Uniform(texelSize)

									},

									fragmentShader: fragment$14,
									vertexShader: vertex$14,

									depthWrite: false,
									depthTest: false

						}));
			}

			return SMAABlendMaterial;
}(ShaderMaterial);

var fragment$15 = "uniform sampler2D tDiffuse;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tconst vec2 THRESHOLD = vec2(EDGE_THRESHOLD);\r\n\r\n\t// Calculate color deltas.\r\n\tvec4 delta;\r\n\tvec3 c = texture2D(tDiffuse, vUv).rgb;\r\n\r\n\tvec3 cLeft = texture2D(tDiffuse, vOffset[0].xy).rgb;\r\n\tvec3 t = abs(c - cLeft);\r\n\tdelta.x = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTop = texture2D(tDiffuse, vOffset[0].zw).rgb;\r\n\tt = abs(c - cTop);\r\n\tdelta.y = max(max(t.r, t.g), t.b);\r\n\r\n\t// We do the usual threshold.\r\n\tvec2 edges = step(THRESHOLD, delta.xy);\r\n\r\n\t// Then discard if there is no edge.\r\n\tif(dot(edges, vec2(1.0)) == 0.0) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\t// Calculate right and bottom deltas.\r\n\tvec3 cRight = texture2D(tDiffuse, vOffset[1].xy).rgb;\r\n\tt = abs(c - cRight);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cBottom  = texture2D(tDiffuse, vOffset[1].zw).rgb;\r\n\tt = abs(c - cBottom);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the maximum delta in the direct neighborhood.\r\n\tfloat maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w);\r\n\r\n\t// Calculate left-left and top-top deltas.\r\n\tvec3 cLeftLeft  = texture2D(tDiffuse, vOffset[2].xy).rgb;\r\n\tt = abs(c - cLeftLeft);\r\n\tdelta.z = max(max(t.r, t.g), t.b);\r\n\r\n\tvec3 cTopTop = texture2D(tDiffuse, vOffset[2].zw).rgb;\r\n\tt = abs(c - cTopTop);\r\n\tdelta.w = max(max(t.r, t.g), t.b);\r\n\r\n\t// Calculate the final maximum delta.\r\n\tmaxDelta = max(max(maxDelta, delta.z), delta.w);\r\n\r\n\t// Local contrast adaptation in action.\r\n\tedges.xy *= step(0.5 * maxDelta, delta.xy);\r\n\r\n\tgl_FragColor = vec4(edges, 0.0, 0.0);\r\n\r\n}\r\n";
var vertex$15 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-1.0, 0.0, 0.0, 1.0); // Changed sign in W component.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // Changed sign in W component.\r\n\tvOffset[2] = uv.xyxy + texelSize.xyxy * vec4(-2.0, 0.0, 0.0, 2.0); // Changed sign in W component.\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material detects edges in a color texture.
 */

var SMAAColorEdgesMaterial = function (_ShaderMaterial) {
			inherits(SMAAColorEdgesMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA color edges material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAAColorEdgesMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
						classCallCheck(this, SMAAColorEdgesMaterial);
						return possibleConstructorReturn(this, (SMAAColorEdgesMaterial.__proto__ || Object.getPrototypeOf(SMAAColorEdgesMaterial)).call(this, {

									type: "SMAAColorEdgesMaterial",

									defines: {

												EDGE_THRESHOLD: "0.1"

									},

									uniforms: {

												tDiffuse: new Uniform(null),
												texelSize: new Uniform(texelSize)

									},

									fragmentShader: fragment$15,
									vertexShader: vertex$15,

									depthWrite: false,
									depthTest: false

						}));
			}

			return SMAAColorEdgesMaterial;
}(ShaderMaterial);

var areaImage = "data:image/png;base64,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";

var searchImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";

var fragment$16 = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + float(offset) * texelSize, 0.0)\r\n\r\nuniform sampler2D tDiffuse;\r\nuniform sampler2D tArea;\r\nuniform sampler2D tSearch;\r\n\r\nuniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvec2 round(vec2 x) {\r\n\r\n\treturn sign(x) * floor(abs(x) + 0.5);\r\n\r\n}\r\n\r\nfloat searchLength(vec2 e, float bias, float scale) {\r\n\r\n\t// Not required if tSearch accesses are set to point.\r\n\t// const vec2 SEARCH_TEX_PIXEL_SIZE = 1.0 / vec2(66.0, 33.0);\r\n\t// e = vec2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE + e * vec2(scale, 1.0) * vec2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\r\n\r\n\te.r = bias + e.r * scale;\r\n\r\n\treturn 255.0 * texture2D(tSearch, e, 0.0).r;\r\n\r\n}\r\n\r\nfloat searchXLeft(vec2 texCoord, float end) {\r\n\r\n\t/* @PSEUDO_GATHER4\r\n\t * This texCoord has been offset by (-0.25, -0.125) in the vertex shader to\r\n\t * sample between edge, thus fetching four edges in a row.\r\n\t * Sampling with different offsets in each direction allows to disambiguate\r\n\t * which edges are active from the four fetched ones.\r\n\t */\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\t// Correct the previously applied offset (-0.25, -0.125).\r\n\ttexCoord.x += 0.25 * texelSize.x;\r\n\r\n\t// The searches are biased by 1, so adjust the coords accordingly.\r\n\ttexCoord.x += texelSize.x;\r\n\r\n\t// Disambiguate the length added by the last step.\r\n\ttexCoord.x += 2.0 * texelSize.x; // Undo last step.\r\n\ttexCoord.x -= texelSize.x * searchLength(e, 0.0, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchXRight(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(0.0, 1.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(2.0, 0.0) * texelSize;\r\n\r\n\t\tif(!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.x -= 0.25 * texelSize.x;\r\n\ttexCoord.x -= texelSize.x;\r\n\ttexCoord.x -= 2.0 * texelSize.x;\r\n\ttexCoord.x += texelSize.x * searchLength(e, 0.5, 0.5);\r\n\r\n\treturn texCoord.x;\r\n\r\n}\r\n\r\nfloat searchYUp(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord += vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y -= 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y; // Changed sign.\r\n\ttexCoord.y -= 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y * searchLength(e.gr, 0.0, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nfloat searchYDown(vec2 texCoord, float end) {\r\n\r\n\tvec2 e = vec2(1.0, 0.0);\r\n\r\n\tfor(int i = 0; i < SMAA_MAX_SEARCH_STEPS_INT; ++i ) {\r\n\r\n\t\te = texture2D(tDiffuse, texCoord, 0.0).rg;\r\n\t\ttexCoord -= vec2(0.0, 2.0) * texelSize; // Changed sign.\r\n\r\n\t\tif(!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) { break; }\r\n\r\n\t}\r\n\r\n\ttexCoord.y += 0.25 * texelSize.y; // Changed sign.\r\n\ttexCoord.y += texelSize.y; // Changed sign.\r\n\ttexCoord.y += 2.0 * texelSize.y; // Changed sign.\r\n\ttexCoord.y -= texelSize.y * searchLength(e.gr, 0.5, 0.5); // Changed sign.\r\n\r\n\treturn texCoord.y;\r\n\r\n}\r\n\r\nvec2 area(vec2 dist, float e1, float e2, float offset) {\r\n\r\n\t// Rounding prevents precision errors of bilinear filtering.\r\n\tvec2 texCoord = SMAA_AREATEX_MAX_DISTANCE * round(4.0 * vec2(e1, e2)) + dist;\r\n\r\n\t// Scale and bias for texel space translation.\r\n\ttexCoord = SMAA_AREATEX_PIXEL_SIZE * texCoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);\r\n\r\n\t// Move to proper place, according to the subpixel offset.\r\n\ttexCoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\r\n\r\n\treturn texture2D(tArea, texCoord, 0.0).rg;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 weights = vec4(0.0);\r\n\tvec4 subsampleIndices = vec4(0.0);\r\n\tvec2 e = texture2D(tDiffuse, vUv).rg;\r\n\r\n\tif(e.g > 0.0) {\r\n\r\n\t\t// Edge at north.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the left.\r\n\t\tvec2 coords;\r\n\t\tcoords.x = searchXLeft(vOffset[0].xy, vOffset[2].x);\r\n\t\tcoords.y = vOffset[1].y; // vOffset[1].y = vUv.y - 0.25 * texelSize.y (@CROSSING_OFFSET)\r\n\t\td.x = coords.x;\r\n\r\n\t\t/* Now fetch the left crossing edges, two at a time using bilinear filtering.\r\n\t\tSampling at -0.25 (see @CROSSING_OFFSET) enables to discern what value each edge has. */\r\n\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).r;\r\n\r\n\t\t// Find the distance to the right.\r\n\t\tcoords.x = searchXRight(vOffset[0].zw, vOffset[2].y);\r\n\t\td.y = coords.x;\r\n\r\n\t\t// Translate distances to pixel units for better interleave arithmetic and memory accesses.\r\n\t\td = d / texelSize.x - vPixCoord.x;\r\n\r\n\t\t// The area below needs a sqrt, as the areas texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the right crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(1, 0)).r;\r\n\r\n\t\t// Pattern recognised, now get the actual area.\r\n\t\tweights.rg = area(sqrtD, e1, e2, subsampleIndices.y);\r\n\r\n\t}\r\n\r\n\tif(e.r > 0.0) {\r\n\r\n\t\t// Edge at west.\r\n\t\tvec2 d;\r\n\r\n\t\t// Find the distance to the top.\r\n\t\tvec2 coords;\r\n\r\n\t\tcoords.y = searchYUp(vOffset[1].xy, vOffset[2].z);\r\n\t\tcoords.x = vOffset[0].x; // vOffset[1].x = vUv.x - 0.25 * texelSize.x;\r\n\t\td.x = coords.y;\r\n\r\n\t\t// Fetch the top crossing edges.\r\n\t\tfloat e1 = texture2D(tDiffuse, coords, 0.0).g;\r\n\r\n\t\t// Find the distance to the bottom.\r\n\t\tcoords.y = searchYDown(vOffset[1].zw, vOffset[2].w);\r\n\t\td.y = coords.y;\r\n\r\n\t\t// Distances in pixel units.\r\n\t\td = d / texelSize.y - vPixCoord.y;\r\n\r\n\t\t// The area below needs a sqrt, as the areas texture is compressed quadratically.\r\n\t\tvec2 sqrtD = sqrt(abs(d));\r\n\r\n\t\t// Fetch the bottom crossing edges.\r\n\t\tcoords.y -= texelSize.y; // WebGL port note: Added.\r\n\t\tfloat e2 = sampleLevelZeroOffset(tDiffuse, coords, ivec2(0, 1)).g;\r\n\r\n\t\t// Get the area for this direction.\r\n\t\tweights.ba = area(sqrtD, e1, e2, subsampleIndices.x);\r\n\r\n\t}\r\n\r\n\tgl_FragColor = weights;\r\n\r\n}\r\n";
var vertex$16 = "uniform vec2 texelSize;\r\n\r\nvarying vec2 vUv;\r\nvarying vec4 vOffset[3];\r\nvarying vec2 vPixCoord;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\r\n\tvPixCoord = uv / texelSize;\r\n\r\n\t// Offsets for the searches (see @PSEUDO_GATHER4).\r\n\tvOffset[0] = uv.xyxy + texelSize.xyxy * vec4(-0.25, 0.125, 1.25, 0.125); // Changed sign in Y and W components.\r\n\tvOffset[1] = uv.xyxy + texelSize.xyxy * vec4(-0.125, 0.25, -0.125, -1.25); //Changed sign in Y and W components.\r\n\r\n\t// This indicates the ends of the loops.\r\n\tvOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * texelSize.xxyy * SMAA_MAX_SEARCH_STEPS_FLOAT;\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Subpixel Morphological Antialiasing.
 *
 * This material computes weights for detected edges.
 */

var SMAAWeightsMaterial = function (_ShaderMaterial) {
			inherits(SMAAWeightsMaterial, _ShaderMaterial);

			/**
    * Constructs a new SMAA weights material.
    *
    * @param {Vector2} [texelSize] - The absolute screen texel size.
    */

			function SMAAWeightsMaterial() {
						var texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
						classCallCheck(this, SMAAWeightsMaterial);

						/**
       * The area pattern recognition image. Encoded as base64.
       *
       * @type {String}
       */

						var _this = possibleConstructorReturn(this, (SMAAWeightsMaterial.__proto__ || Object.getPrototypeOf(SMAAWeightsMaterial)).call(this, {

									type: "SMAAWeightsMaterial",

									defines: {

												SMAA_MAX_SEARCH_STEPS_INT: "8",
												SMAA_MAX_SEARCH_STEPS_FLOAT: "8.0",

												SMAA_AREATEX_MAX_DISTANCE: "16.0",

												SMAA_AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
												SMAA_AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)"

									},

									uniforms: {

												tDiffuse: new Uniform(null),
												tArea: new Uniform(null),
												tSearch: new Uniform(null),
												texelSize: new Uniform(texelSize)

									},

									fragmentShader: fragment$16,
									vertexShader: vertex$16,

									depthWrite: false,
									depthTest: false

						}));

						_this.areaImage = areaImage;

						/**
       * The search image. Encoded as base64.
       *
       * @type {String}
       */

						_this.searchImage = searchImage;

						return _this;
			}

			return SMAAWeightsMaterial;
}(ShaderMaterial);

var fragment$17 = "uniform sampler2D tDiffuse;\r\nuniform float middleGrey;\r\nuniform float maxLuminance;\r\nuniform vec3 luminanceCoefficients;\r\n\r\n#ifdef ADAPTED_LUMINANCE\r\n\r\n\tuniform sampler2D luminanceMap;\r\n\r\n#else\r\n\r\n\tuniform float averageLuminance;\r\n\r\n#endif\r\n\r\nvarying vec2 vUv;\r\n\r\nvec3 toneMap(vec3 c) {\r\n\r\n\t#ifdef ADAPTED_LUMINANCE\r\n\r\n\t\t// Get the calculated average luminance by sampling the center.\r\n\t\tfloat lumAvg = texture2D(luminanceMap, vec2(0.5)).r;\r\n\r\n\t#else\r\n\r\n\t\tfloat lumAvg = averageLuminance;\r\n\r\n\t#endif\r\n\r\n\t// Calculate the luminance of the current pixel.\r\n\tfloat lumPixel = dot(c, luminanceCoefficients);\r\n\r\n\t// Apply the modified operator (Reinhard Eq. 4).\r\n\tfloat lumScaled = (lumPixel * middleGrey) / lumAvg;\r\n\r\n\tfloat lumCompressed = (lumScaled * (1.0 + (lumScaled / (maxLuminance * maxLuminance)))) / (1.0 + lumScaled);\r\n\r\n\treturn lumCompressed * c;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n\tvec4 texel = texture2D(tDiffuse, vUv);\r\n\tgl_FragColor = vec4(toneMap(texel.rgb), texel.a);\r\n\r\n}\r\n";
var vertex$17 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n\r\n\tvUv = uv;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n}\r\n";

/**
 * Full-screen tone-mapping shader material.
 *
 * Reference:
 *  http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf
 */

var ToneMappingMaterial = function (_ShaderMaterial) {
			inherits(ToneMappingMaterial, _ShaderMaterial);

			/**
    * Constructs a new tone mapping material.
    */

			function ToneMappingMaterial() {
						classCallCheck(this, ToneMappingMaterial);
						return possibleConstructorReturn(this, (ToneMappingMaterial.__proto__ || Object.getPrototypeOf(ToneMappingMaterial)).call(this, {

									type: "ToneMappingMaterial",

									uniforms: {

												tDiffuse: new Uniform(null),
												luminanceMap: new Uniform(null),
												averageLuminance: new Uniform(1.0),
												luminanceCoefficients: new Uniform(new Vector3(0.2126, 0.7152, 0.0722)),
												maxLuminance: new Uniform(16.0),
												middleGrey: new Uniform(0.6)

									},

									fragmentShader: fragment$17,
									vertexShader: vertex$17,

									depthWrite: false,
									depthTest: false

						}));
			}

			return ToneMappingMaterial;
}(ShaderMaterial);

/**
 * A collection of shader materials that are used in the post processing passes.
 *
 * @module postprocessing/materials
 */

/**
 * An abstract pass.
 *
 * Passes that do not rely on the depth buffer should explicitly disable the
 * depth test and depth write in their respective shader materials.
 *
 * This class implements a {@link Pass#dispose} method that frees memory on
 * demand.
 */

var Pass = function () {

		/**
   * Constructs a new pass.
   *
   * @param {Scene} [scene] - The scene to render.
   * @param {Camera} [camera] - The camera.
   * @param {Mesh} [quad] - A quad that fills the screen to render 2D filter effects. Set this to null, if you don't need it (see {@link RenderPass}).
   */

		function Pass() {
				var scene = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Scene();
				var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrthographicCamera(-1, 1, 1, -1, 0, 1);
				var quad = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Mesh(new PlaneBufferGeometry(2, 2), null);
				classCallCheck(this, Pass);


				/**
     * The name of this pass.
     *
     * @type {String}
     */

				this.name = "Pass";

				/**
     * The scene to render.
     *
     * @type {Scene}
     * @protected
     * @default new Scene()
     */

				this.scene = scene;

				/**
     * The camera.
     *
     * @type {Camera}
     * @protected
     * @default new OrthographicCamera(-1, 1, 1, -1, 0, 1)
     */

				this.camera = camera;

				/**
     * A quad mesh that fills the screen.
     *
     * Assign your shader material to this mesh!
     *
     * @type {Mesh}
     * @protected
     * @default new Mesh(new PlaneBufferGeometry(2, 2), null)
     * @example this.quad.material = this.myMaterial;
     */

				this.quad = quad;

				if (this.quad !== null) {

						this.quad.frustumCulled = false;

						if (this.scene !== null) {

								this.scene.add(this.quad);
						}
				}

				/**
     * Indicates whether the read and write buffers should be swapped after this
     * pass has finished rendering.
     *
     * Set this to true if this pass renders to the write buffer so that a
     * following pass can find the result in the read buffer.
     *
     * @type {Boolean}
     * @default false
     */

				this.needsSwap = false;

				/**
     * Enabled flag.
     *
     * @type {Boolean}
     * @default true
     */

				this.enabled = true;

				/**
     * Render to screen flag.
     *
     * @type {Boolean}
     * @default false
     */

				this.renderToScreen = false;
		}

		/**
   * Renders the effect.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - A read buffer. Contains the result of the previous pass.
   * @param {WebGLRenderTarget} writeBuffer - A write buffer. Normally used as the render target when the read buffer is used as input.
   * @param {Number} [delta] - The delta time.
   * @param {Boolean} [maskActive] - Indicates whether a stencil test mask is active or not.
   */

		createClass(Pass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta, maskActive) {

						throw new Error("Render method not implemented!");
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * You may override this method in case you want to be informed about the main
     * render size.
     *
     * The {@link EffectComposer} calls this method before this pass is
     * initialised and every time its own size is updated.
     *
     * @param {Number} width - The renderer's width.
     * @param {Number} height - The renderer's height.
     * @example this.myRenderTarget.setSize(width, height);
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {}

				/**
     * Performs initialisation tasks.
     *
     * By overriding this method you gain access to the renderer. You'll also be
     * able to configure your custom render targets to use the appropriate format
     * (RGB or RGBA).
     *
     * The provided renderer can be used to warm up special off-screen render
     * targets by performing a preliminary render operation.
     *
     * The {@link EffectComposer} calls this method when this pass is added to its
     * queue.
     *
     * @method initialise
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     * @example if(!alpha) { this.myRenderTarget.texture.format = RGBFormat; }
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {}

				/**
     * Performs a shallow search for properties that define a dispose method and
     * deletes them. The pass will be inoperative after this method was called!
     *
     * Disposable objects:
     *  - render targets
     *  - materials
     *  - textures
     *
     * The {@link EffectComposer} calls this method when it is being destroyed.
     * You may, however, use it independently to free memory when you are certain
     * that you don't need this pass anymore.
     */

		}, {
				key: "dispose",
				value: function dispose() {

						var keys = Object.keys(this);

						var key = void 0;

						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
								for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
										key = _step.value;


										if (this[key] !== null && typeof this[key].dispose === "function") {

												this[key].dispose();
												this[key] = null;
										}
								}
						} catch (err) {
								_didIteratorError = true;
								_iteratorError = err;
						} finally {
								try {
										if (!_iteratorNormalCompletion && _iterator.return) {
												_iterator.return();
										}
								} finally {
										if (_didIteratorError) {
												throw _iteratorError;
										}
								}
						}
				}
		}]);
		return Pass;
}();

/**
 * A blur pass.
 */

var BlurPass = function (_Pass) {
		inherits(BlurPass, _Pass);

		/**
   * Constructs a new blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
   * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
   */

		function BlurPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, BlurPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (BlurPass.__proto__ || Object.getPrototypeOf(BlurPass)).call(this));

				_this.name = "BlurPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetX = new WebGLRenderTarget(1, 1, {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetX.texture.name = "Blur.TargetX";
				_this.renderTargetX.texture.generateMipmaps = false;

				/**
     * A second render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetY = _this.renderTargetX.clone();

				_this.renderTargetY.texture.name = "Blur.TargetY";

				/**
     * The resolution scale.
     *
     * You need to call {@link EffectComposer#setSize} after changing this
     * value.
     *
     * @type {Number}
     * @default 0.5
     */

				_this.resolutionScale = options.resolutionScale !== undefined ? options.resolutionScale : 0.5;

				/**
     * A convolution shader material.
     *
     * @type {ConvolutionMaterial}
     * @private
     */

				_this.convolutionMaterial = new ConvolutionMaterial();

				_this.kernelSize = options.kernelSize;

				_this.quad.material = _this.convolutionMaterial;

				return _this;
		}

		/**
   * The absolute width of the internal render targets.
   *
   * @type {Number}
   */

		createClass(BlurPass, [{
				key: "render",


				/**
     * Blurs the read buffer.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						var scene = this.scene;
						var camera = this.camera;

						var renderTargetX = this.renderTargetX;
						var renderTargetY = this.renderTargetY;

						var material = this.convolutionMaterial;
						var uniforms = material.uniforms;
						var kernel = material.getKernel();

						var lastRT = readBuffer;
						var destRT = void 0;
						var i = void 0,
						    l = void 0;

						// Apply the multi-pass blur.
						for (i = 0, l = kernel.length - 1; i < l; ++i) {

								// Alternate between targets.
								destRT = i % 2 === 0 ? renderTargetX : renderTargetY;

								uniforms.kernel.value = kernel[i];
								uniforms.tDiffuse.value = lastRT.texture;
								renderer.render(scene, camera, destRT);

								lastRT = destRT;
						}

						uniforms.kernel.value = kernel[i];
						uniforms.tDiffuse.value = lastRT.texture;
						renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the format of the render targets.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						if (!alpha) {

								this.renderTargetX.texture.format = RGBFormat;
								this.renderTargetY.texture.format = RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						width = Math.max(1, Math.floor(width * this.resolutionScale));
						height = Math.max(1, Math.floor(height * this.resolutionScale));

						this.renderTargetX.setSize(width, height);
						this.renderTargetY.setSize(width, height);

						this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);
				}
		}, {
				key: "width",
				get: function get$$1() {
						return this.renderTargetX.width;
				}

				/**
     * The absolute height of the internal render targets.
     *
     * @type {Number}
     */

		}, {
				key: "height",
				get: function get$$1() {
						return this.renderTargetX.height;
				}

				/**
     * The kernel size.
     *
     * @type {KernelSize}
     * @default KernelSize.LARGE
     */

		}, {
				key: "kernelSize",
				get: function get$$1() {
						return this.convolutionMaterial.kernelSize;
				}

				/**
     * @type {KernelSize}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
						this.convolutionMaterial.kernelSize = x;
				}
		}]);
		return BlurPass;
}(Pass);

/**
 * A bloom pass.
 *
 * This pass renders a scene with superimposed blur by utilising the fast Kawase
 * convolution approach.
 */

var BloomPass = function (_Pass) {
	inherits(BloomPass, _Pass);

	/**
  * Constructs a new bloom pass.
  *
  * @param {Object} [options] - The options.
  * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
  * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
  * @param {Number} [options.intensity=1.0] - The strength of the bloom effect.
  * @param {Number} [options.distinction=1.0] - The luminance distinction factor. Raise this value to bring out the brighter elements in the scene.
  * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the bloom texture with the scene colors.
  */

	function BloomPass() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		classCallCheck(this, BloomPass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (BloomPass.__proto__ || Object.getPrototypeOf(BloomPass)).call(this));

		_this.name = "BloomPass";

		/**
   * This pass renders to the write buffer.
   */

		_this.needsSwap = true;

		/**
   * A blur pass.
   *
   * @type {BlurPass}
   * @private
   */

		_this.blurPass = new BlurPass(options);

		/**
   * A render target.
   *
   * @type {WebGLRenderTarget}
   * @private
   */

		_this.renderTarget = new WebGLRenderTarget(1, 1, {
			minFilter: LinearFilter,
			magFilter: LinearFilter,
			stencilBuffer: false,
			depthBuffer: false
		});

		_this.renderTarget.texture.name = "Bloom.Target";
		_this.renderTarget.texture.generateMipmaps = false;

		/**
   * A combine shader material.
   *
   * @type {CombineMaterial}
   * @private
   */

		_this.combineMaterial = new CombineMaterial(options.screenMode !== undefined ? options.screenMode : true);

		_this.intensity = options.intensity;

		/**
   * A luminosity shader material.
   *
   * @type {LuminosityMaterial}
   * @private
   */

		_this.luminosityMaterial = new LuminosityMaterial(true);

		_this.distinction = options.distinction;

		return _this;
	}

	/**
  * The resolution scale.
  *
  * @type {Number}
  * @default 0.5
  */

	createClass(BloomPass, [{
		key: "render",


		/**
   * Renders the effect.
   *
   * Extracts a luminance map from the read buffer, blurs it and combines it
   * with the read buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		value: function render(renderer, readBuffer, writeBuffer) {

			var quad = this.quad;
			var scene = this.scene;
			var camera = this.camera;
			var blurPass = this.blurPass;

			var luminosityMaterial = this.luminosityMaterial;
			var combineMaterial = this.combineMaterial;
			var renderTarget = this.renderTarget;

			// Luminance filter.
			quad.material = luminosityMaterial;
			luminosityMaterial.uniforms.tDiffuse.value = readBuffer.texture;
			renderer.render(scene, camera, renderTarget);

			// Convolution phase.
			blurPass.render(renderer, renderTarget, renderTarget);

			// Render the original scene with superimposed blur.
			quad.material = combineMaterial;
			combineMaterial.uniforms.texture1.value = readBuffer.texture;
			combineMaterial.uniforms.texture2.value = renderTarget.texture;

			renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
		}

		/**
   * Adjusts the format of the render targets.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   */

	}, {
		key: "initialise",
		value: function initialise(renderer, alpha) {

			this.blurPass.initialise(renderer, alpha);

			if (!alpha) {
				this.renderTarget.texture.format = RGBFormat;
			}
		}

		/**
   * Updates this pass with the renderer's size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */

	}, {
		key: "setSize",
		value: function setSize(width, height) {

			this.blurPass.setSize(width, height);

			width = this.blurPass.width;
			height = this.blurPass.height;

			this.renderTarget.setSize(width, height);
		}
	}, {
		key: "resolutionScale",
		get: function get$$1() {
			return this.blurPass.resolutionScale;
		}

		/**
   * You need to call {@link EffectComposer#setSize} after changing this value.
   *
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
			this.blurPass.resolutionScale = x;
		}

		/**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @default KernelSize.LARGE
   */

	}, {
		key: "kernelSize",
		get: function get$$1() {
			return this.blurPass.kernelSize;
		}

		/**
   * @type {KernelSize}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
			this.blurPass.kernelSize = x;
		}

		/**
   * The overall intensity of the effect.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "intensity",
		get: function get$$1() {
			return this.combineMaterial.uniforms.opacity2.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.combineMaterial.uniforms.opacity2.value = x;
		}

		/**
   * The luminance distinction factor.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "distinction",
		get: function get$$1() {
			return this.luminosityMaterial.uniforms.distinction.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.luminosityMaterial.uniforms.distinction.value = x;
		}
	}]);
	return BloomPass;
}(Pass);

/**
 * A Depth of Field (DoF) pass using a bokeh shader.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var BokehPass = function (_Pass) {
		inherits(BokehPass, _Pass);

		/**
   * Constructs a new bokeh pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the aspect ratio and the near and far plane settings.
   * @param {Object} [options] - Additional parameters.
   * @param {Number} [options.focus=1.0] - Focus distance.
   * @param {Number} [options.aperture=0.025] - Camera aperture scale. Bigger values for shallower depth of field.
   * @param {Number} [options.maxBlur=1.0] - Maximum blur strength.
   */

		function BokehPass(camera) {
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, BokehPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (BokehPass.__proto__ || Object.getPrototypeOf(BokehPass)).call(this));

				_this.name = "BokehPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A bokeh shader material.
     *
     * @type {BokehMaterial}
     * @private
     */

				_this.bokehMaterial = new BokehMaterial(camera, options);

				_this.quad.material = _this.bokehMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(BokehPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.bokehMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.bokehMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.bokehMaterial.uniforms.aspect.value = width / height;
				}
		}]);
		return BokehPass;
}(Pass);

/**
 * An advanced Depth of Field (DoF) pass.
 *
 * Yields more realistic results but is also more demanding.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var Bokeh2Pass = function (_Pass) {
		inherits(Bokeh2Pass, _Pass);

		/**
   * Constructs a new bokeh2 pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the focal length and the near and far plane settings.
   * @param {Object} [options] - Additional parameters.
   * @param {Number} [options.rings=3] - The amount of blur rings.
   * @param {Number} [options.samples=4] - The amount of samples per ring.
   * @param {Boolean} [options.showFocus=false] - Whether the focus point should be highlighted.
   * @param {Boolean} [options.manualDoF=false] - Enables manual depth of field blur.
   * @param {Boolean} [options.vignette=false] - Enables a vignette effect.
   * @param {Boolean} [options.pentagon=false] - Enable to use a pentagonal shape to scale gathered texels.
   * @param {Boolean} [options.shaderFocus=true] - Disable if you compute your own focalDepth (in metres!).
   * @param {Boolean} [options.noise=true] - Disable if you don't want noise patterns for dithering.
   */

		function Bokeh2Pass(camera) {
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, Bokeh2Pass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (Bokeh2Pass.__proto__ || Object.getPrototypeOf(Bokeh2Pass)).call(this));

				_this.name = "Bokeh2Pass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A bokeh shader material.
     *
     * @type {BokehMaterial}
     * @private
     */

				_this.bokehMaterial = new Bokeh2Material(camera, options);

				_this.quad.material = _this.bokehMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(Bokeh2Pass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.bokehMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.bokehMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.bokehMaterial.setTexelSize(1.0 / width, 1.0 / height);
				}
		}]);
		return Bokeh2Pass;
}(Pass);

/**
 * A pass that disables the stencil mask.
 */

var ClearMaskPass = function (_Pass) {
	inherits(ClearMaskPass, _Pass);

	/**
  * Constructs a new clear mask pass.
  */

	function ClearMaskPass() {
		classCallCheck(this, ClearMaskPass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (ClearMaskPass.__proto__ || Object.getPrototypeOf(ClearMaskPass)).call(this, null, null, null));

		_this.name = "ClearMaskPass";

		return _this;
	}

	/**
  * Disables the stencil test.
  *
  * @param {WebGLRenderer} renderer - The renderer.
  */

	createClass(ClearMaskPass, [{
		key: "render",
		value: function render(renderer) {

			renderer.state.buffers.stencil.setTest(false);
		}
	}]);
	return ClearMaskPass;
}(Pass);

/**
 * Used for saving the original clear color of the renderer.
 *
 * @type Color
 * @private
 * @static
 */

var color = new Color();

/**
 * A clear pass.
 *
 * You can prevent specific buffers from being cleared by setting either the
 * autoClearColor, autoClearStencil or autoClearDepth properties of the renderer
 * to false.
 */

var ClearPass = function (_Pass) {
		inherits(ClearPass, _Pass);

		/**
   * Constructs a new clear pass.
   *
   * @param {Object} [options] - Additional options.
   * @param {Color} [options.clearColor=null] - An override clear color.
   * @param {Number} [options.clearAlpha=0.0] - An override clear alpha.
   */

		function ClearPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, ClearPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ClearPass.__proto__ || Object.getPrototypeOf(ClearPass)).call(this, null, null, null));

				_this.name = "ClearPass";

				/**
     * Clear color.
     *
     * @type {Color}
     * @default null
     */

				_this.clearColor = options.clearColor !== undefined ? options.clearColor : null;

				/**
     * Clear alpha.
     *
     * @type {Number}
     * @default 0.0
     */

				_this.clearAlpha = options.clearAlpha !== undefined ? options.clearAlpha : 0.0;

				return _this;
		}

		/**
   * Clears the read buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(ClearPass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						var clearColor = this.clearColor;

						var clearAlpha = void 0;

						if (clearColor !== null) {

								color.copy(renderer.getClearColor());
								clearAlpha = renderer.getClearAlpha();
								renderer.setClearColor(clearColor, this.clearAlpha);
						}

						renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
						renderer.clear();

						if (clearColor !== null) {

								renderer.setClearColor(color, clearAlpha);
						}
				}
		}]);
		return ClearPass;
}(Pass);

/**
 * A dot screen pass.
 */

var DotScreenPass = function (_Pass) {
		inherits(DotScreenPass, _Pass);

		/**
   * Constructs a new dot screen pass.
   *
   * @param {Object} [options] - The options.
   * @param {Number} [options.angle=1.57] - The angle of the pattern.
   * @param {Number} [options.scale=1.0] - The scale of the overall effect.
   * @param {Number} [options.intensity=1.0] - The intensity of the effect.
   * @param {Boolean} [options.average=false] - Whether the shader should output a colour average (black and white).
   */

		function DotScreenPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, DotScreenPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (DotScreenPass.__proto__ || Object.getPrototypeOf(DotScreenPass)).call(this));

				_this.name = "DotScreenPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A dot screen shader material.
     *
     * @type {DotScreenMaterial}
     * @private
     */

				_this.material = new DotScreenMaterial(options.average);

				if (options.angle !== undefined) {
						_this.material.uniforms.angle.value = options.angle;
				}
				if (options.scale !== undefined) {
						_this.material.uniforms.scale.value = options.scale;
				}
				if (options.intensity !== undefined) {
						_this.material.uniforms.intensity.value = options.intensity;
				}

				_this.quad.material = _this.material;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(DotScreenPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} heght - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						width = Math.max(1, width);
						height = Math.max(1, height);

						this.material.uniforms.offsetRepeat.value.z = width;
						this.material.uniforms.offsetRepeat.value.w = height;
				}
		}]);
		return DotScreenPass;
}(Pass);

/**
 * A depth pass.
 *
 * Reads the depth from a depth texture and renders it.
 *
 * This pass requires a {@link EffectComposer#depthTexture}.
 */

var DepthPass = function (_Pass) {
		inherits(DepthPass, _Pass);

		/**
   * Constructs a new depth pass.
   *
   * @param {PerspectiveCamera} camera - The main camera. Used to obtain the near and far plane settings.
   */

		function DepthPass(camera) {
				classCallCheck(this, DepthPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (DepthPass.__proto__ || Object.getPrototypeOf(DepthPass)).call(this));

				_this.name = "DepthPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A depth shader material.
     *
     * @type {DepthMaterial}
     * @private
     */

				_this.depthMaterial = new DepthMaterial(camera);

				_this.quad.material = _this.depthMaterial;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(DepthPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						this.depthMaterial.uniforms.tDepth.value = readBuffer.depthTexture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}]);
		return DepthPass;
}(Pass);

/**
 * A film pass.
 *
 * Provides various cinematic effects.
 */

var FilmPass = function (_Pass) {
		inherits(FilmPass, _Pass);

		/**
   * Constructs a new film pass.
   *
   * @param {Object} [options] - The options. Disabled effects have no negative impact on performance.
   * @param {Boolean} [options.greyscale=false] - Enable greyscale effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.sepia=false] - Enable sepia effect. Greyscale and sepia are mutually exclusive.
   * @param {Boolean} [options.vignette=false] - Apply vignette effect.
   * @param {Boolean} [options.eskil=false] - Use Eskil's vignette approach. The default looks dusty while Eskil looks more burned out.
   * @param {Boolean} [options.screenMode=true] - Whether the screen blend mode should be used for noise and scanlines.
   * @param {Boolean} [options.scanlines=true] - Show scanlines.
   * @param {Boolean} [options.noise=true] - Show noise-based film grain.
   * @param {Number} [options.noiseIntensity=0.5] - The noise intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineIntensity=0.05] - The scanline intensity. 0.0 to 1.0.
   * @param {Number} [options.scanlineDensity=1.0] - The number of scanlines in percent, relative to the screen height.
   * @param {Number} [options.greyscaleIntensity=1.0] - The intensity of the greyscale effect.
   * @param {Number} [options.sepiaIntensity=1.0] - The intensity of the sepia effect.
   * @param {Number} [options.vignetteOffset=1.0] - The offset of the vignette effect.
   * @param {Number} [options.vignetteDarkness=1.0] - The darkness of the vignette effect.
   */

		function FilmPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, FilmPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (FilmPass.__proto__ || Object.getPrototypeOf(FilmPass)).call(this));

				_this.name = "FilmPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * Film shader material.
     *
     * @type {FilmMaterial}
     * @private
     */

				_this.material = new FilmMaterial(options);

				_this.quad.material = _this.material;

				/**
     * The amount of scanlines in percent, relative to the screen height.
     *
     * You need to call {@link EffectComposer#setSize} after changing this
     * value.
     *
     * @type {Number}
     * @default 1.25
     */

				_this.scanlineDensity = options.scanlineDensity === undefined ? 1.25 : options.scanlineDensity;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   * @param {Number} delta - The render delta time.
   */

		createClass(FilmPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;
						this.material.uniforms.time.value += delta;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the scanline count using the renderer's height.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.material.uniforms.scanlineCount.value = Math.round(height * this.scanlineDensity);
				}
		}]);
		return FilmPass;
}(Pass);

/**
 * Returns a random integer in the specified range.
 *
 * @private
 * @static
 * @param {Number} low - The lowest possible value.
 * @param {Number} high - The highest possible value.
 * @return {Number} The random value.
 */

function randomInt(low, high) {

		return low + Math.floor(Math.random() * (high - low + 1));
}

/**
 * Returns a random float in the specified range.
 *
 * @private
 * @static
 * @param {Number} low - The lowest possible value.
 * @param {Number} high - The highest possible value.
 * @return {Number} The random value.
 */

function randomFloat(low, high) {

		return low + Math.random() * (high - low);
}

/**
 * A glitch pass.
 */

var GlitchPass = function (_Pass) {
		inherits(GlitchPass, _Pass);

		/**
   * Constructs a new glitch pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.perturbMap] - A perturbation map. If none is provided, a noise texture will be created.
   * @param {Number} [options.dtSize=64] - The size of the generated noise map. Will be ignored if a perturbation map is provided.
   */

		function GlitchPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, GlitchPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (GlitchPass.__proto__ || Object.getPrototypeOf(GlitchPass)).call(this));

				_this.name = "GlitchPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * Glitch shader material.
     *
     * @type {GlitchMaterial}
     * @private
     */

				_this.material = new GlitchMaterial();

				_this.quad.material = _this.material;

				/**
     * A perturbation map.
     *
     * @type {Texture}
     * @private
     */

				_this.texture = null;

				_this.perturbMap = options.perturbMap !== undefined ? options.perturbMap : _this.generatePerturbMap(options.dtSize);
				_this.perturbMap.name = "Glitch.Perturbation";
				_this.perturbMap.generateMipmaps = false;

				/**
     * The effect mode.
     *
     * @type {GlitchMode}
     * @default GlitchMode.SPORADIC
     */

				_this.mode = GlitchMode.SPORADIC;

				/**
     * Counter for glitch activation and deactivation.
     *
     * @type {Number}
     * @private
     */

				_this.counter = 0;

				/**
     * A random break point for the sporadic glitch activation.
     *
     * @type {Number}
     * @private
     */

				_this.breakPoint = randomInt(120, 240);

				return _this;
		}

		/**
   * The current perturbation map.
   *
   * @type {Texture}
   */

		createClass(GlitchPass, [{
				key: "generatePerturbMap",


				/**
     * Destroys the current perturbation map and replaces it with a new one.
     *
     * @param {Number} [size=64] - The texture size.
     * @return {DataTexture} The perturbation texture.
     */

				value: function generatePerturbMap() {
						var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;


						var pixels = size * size;
						var data = new Float32Array(pixels * 3);

						var dt = this.perturbMap;
						var i = void 0,
						    x = void 0;

						for (i = 0; i < pixels; ++i) {

								x = Math.random();

								data[i * 3] = x;
								data[i * 3 + 1] = x;
								data[i * 3 + 2] = x;
						}

						if (dt !== null) {

								dt.dispose();
						}

						dt = new DataTexture(data, size, size, RGBFormat, FloatType);
						dt.needsUpdate = true;

						this.perturbMap = dt;

						return dt;
				}

				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

		}, {
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						var mode = this.mode;
						var counter = this.counter;
						var breakPoint = this.breakPoint;
						var uniforms = this.material.uniforms;

						uniforms.tDiffuse.value = readBuffer.texture;
						uniforms.seed.value = Math.random();
						uniforms.active.value = true;

						if (counter % breakPoint === 0 || mode === GlitchMode.CONSTANT_WILD) {

								uniforms.amount.value = Math.random() / 30.0;
								uniforms.angle.value = randomFloat(-Math.PI, Math.PI);
								uniforms.seedX.value = randomFloat(-1.0, 1.0);
								uniforms.seedY.value = randomFloat(-1.0, 1.0);
								uniforms.distortionX.value = randomFloat(0.0, 1.0);
								uniforms.distortionY.value = randomFloat(0.0, 1.0);

								this.breakPoint = randomInt(120, 240);
								this.counter = 0;
						} else {

								if (counter % breakPoint < breakPoint / 5 || mode === GlitchMode.CONSTANT_MILD) {

										uniforms.amount.value = Math.random() / 90.0;
										uniforms.angle.value = randomFloat(-Math.PI, Math.PI);
										uniforms.distortionX.value = randomFloat(0.0, 1.0);
										uniforms.distortionY.value = randomFloat(0.0, 1.0);
										uniforms.seedX.value = randomFloat(-0.3, 0.3);
										uniforms.seedY.value = randomFloat(-0.3, 0.3);
								} else {

										// Sporadic.
										uniforms.active.value = false;
								}
						}

						++this.counter;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}, {
				key: "perturbMap",
				get: function get$$1() {
						return this.texture;
				}

				/**
     * Assigning a new perturbation map does not destroy the current one!
     *
     * @type {Texture}
     */

				,
				set: function set$$1(x) {

						this.texture = x;
						this.material.uniforms.tPerturb.value = x;
				}
		}]);
		return GlitchPass;
}(Pass);

/**
 * A glitch mode enumeration.
 *
 * @type {Object}
 * @property {Number} SPORADIC - Sporadic glitches.
 * @property {Number} CONSTANT_MILD - Constant mild glitches.
 * @property {Number} CONSTANT_WILD - Constant wild glitches.
 */

var GlitchMode = {

		SPORADIC: 0,
		CONSTANT_MILD: 1,
		CONSTANT_WILD: 2

};

/**
 * A pass that renders a given scene directly on screen or into the read buffer
 * for further processing.
 */

var RenderPass = function (_Pass) {
		inherits(RenderPass, _Pass);

		/**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - Additional options.
   * @param {Material} [options.overrideMaterial=null] - An override material for the scene.
   * @param {Color} [options.clearColor=null] - An override clear color.
   * @param {Number} [options.clearAlpha=1.0] - An override clear alpha.
   * @param {Boolean} [options.clearDepth=false] - Whether depth should be cleared explicitly.
   * @param {Boolean} [options.clear=true] - Whether all buffers should be cleared.
   */

		function RenderPass(scene, camera) {
				var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
				classCallCheck(this, RenderPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (RenderPass.__proto__ || Object.getPrototypeOf(RenderPass)).call(this, scene, camera, null));

				_this.name = "RenderPass";

				/**
     * A clear pass.
     *
     * @type {ClearPass}
     */

				_this.clearPass = new ClearPass(options);

				/**
     * An override material.
     *
     * @type {Material}
     * @default null
     */

				_this.overrideMaterial = options.overrideMaterial !== undefined ? options.overrideMaterial : null;

				/**
     * Indicates whether the depth buffer should be cleared explicitly.
     *
     * @type {Boolean}
     * @default false
     */

				_this.clearDepth = options.clearDepth !== undefined ? options.clearDepth : false;

				/**
     * Indicates whether the color, depth and stencil buffers should be cleared.
     *
     * Even with clear set to true you can prevent specific buffers from being
     * cleared by setting either the autoClearColor, autoClearStencil or
     * autoClearDepth properties of the renderer to false.
     *
     * @type {Boolean}
     * @default true
     */

				_this.clear = options.clear !== undefined ? options.clear : true;

				return _this;
		}

		/**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(RenderPass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						var scene = this.scene;
						var target = this.renderToScreen ? null : readBuffer;

						if (this.clear) {

								this.clearPass.render(renderer, target);
						} else if (this.clearDepth) {

								renderer.setRenderTarget(target);
								renderer.clearDepth();
						}

						scene.overrideMaterial = this.overrideMaterial;
						renderer.render(scene, this.camera, target);
						scene.overrideMaterial = null;
				}
		}]);
		return RenderPass;
}(Pass);

/**
 * Clamps a given value.
 *
 * @private
 * @static
 * @param {Number} value - The value to clamp.
 * @param {Number} min - The lowest possible value.
 * @param {Number} max - The highest possible value.
 * @return {Number} The clamped value.
 */

function clamp(value, min, max) {

		return Math.max(min, Math.min(max, value));
}

/**
 * A crepuscular rays pass.
 */

var GodRaysPass = function (_Pass) {
		inherits(GodRaysPass, _Pass);

		/**
   * Constructs a new god rays pass.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object3D} lightSource - The main light source.
   * @param {Object} [options] - The options.
   * @param {Number} [options.density=0.96] - The density of the light rays.
   * @param {Number} [options.decay=0.93] - An illumination decay factor.
   * @param {Number} [options.weight=0.4] - A light ray weight factor.
   * @param {Number} [options.exposure=0.6] - A constant attenuation coefficient.
   * @param {Number} [options.clampMax=1.0] - An upper bound for the saturation of the overall effect.
   * @param {Number} [options.intensity=1.0] - A constant factor for additive blending.
   * @param {Number} [options.resolutionScale=0.5] - The render texture resolution scale, relative to the screen render size.
   * @param {Number} [options.kernelSize=KernelSize.LARGE] - The blur kernel size.
   * @param {Number} [options.samples=60] - The number of samples per pixel.
   * @param {Number} [options.screenMode=true] - Whether the screen blend mode should be used for combining the god rays texture with the scene colors.
   */

		function GodRaysPass(scene, camera, lightSource) {
				var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
				classCallCheck(this, GodRaysPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (GodRaysPass.__proto__ || Object.getPrototypeOf(GodRaysPass)).call(this));

				_this.name = "GodRaysPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A scene that only contains the light source.
     *
     * @type {Scene}
     * @private
     */

				_this.lightScene = new Scene();

				/**
     * The main scene.
     *
     * @type {Scene}
     * @private
     */

				_this.mainScene = scene;

				/**
     * The main camera.
     *
     * @type {Camera}
     * @private
     */

				_this.mainCamera = camera;

				/**
     * A pass that only renders the light source.
     *
     * @type {RenderPass}
     * @private
     */

				_this.renderPassLight = new RenderPass(_this.lightScene, _this.mainCamera);

				/**
     * A pass that renders the masked scene over the light.
     *
     * @type {RenderPass}
     * @private
     */

				_this.renderPassMask = new RenderPass(_this.mainScene, _this.mainCamera, {
						overrideMaterial: new MeshBasicMaterial({ color: 0x000000 }),
						clearColor: new Color(0x000000)
				});

				_this.renderPassMask.clear = false;

				/**
     * A blur pass.
     *
     * @type {BlurPass}
     * @private
     */

				_this.blurPass = new BlurPass(options);

				/**
     * A render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetX = new WebGLRenderTarget(1, 1, {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetX.texture.name = "GodRays.TargetX";
				_this.renderTargetX.texture.generateMipmaps = false;

				/**
     * A second render target.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetY = _this.renderTargetX.clone();

				_this.renderTargetY.texture.name = "GodRays.TargetY";

				/**
     * A render target for the masked light scene.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetMask = new WebGLRenderTarget(1, 1, {
						minFilter: LinearFilter,
						magFilter: LinearFilter
				});

				_this.renderTargetMask.texture.name = "GodRays.Mask";
				_this.renderTargetMask.texture.generateMipmaps = false;

				/**
     * The light source.
     *
     * @type {Object3D}
     */

				_this.lightSource = lightSource;

				/**
     * The light position in screen space.
     *
     * @type {Vector3}
     * @private
     */

				_this.screenPosition = new Vector3();

				/**
     * A god rays shader material.
     *
     * @type {GodRaysMaterial}
     * @private
     */

				_this.godRaysMaterial = new GodRaysMaterial();
				_this.godRaysMaterial.uniforms.lightPosition.value = _this.screenPosition;

				if (options.exposure !== undefined) {
						_this.godRaysMaterial.uniforms.exposure.value = options.exposure;
				}
				if (options.density !== undefined) {
						_this.godRaysMaterial.uniforms.density.value = options.density;
				}
				if (options.decay !== undefined) {
						_this.godRaysMaterial.uniforms.decay.value = options.decay;
				}
				if (options.weight !== undefined) {
						_this.godRaysMaterial.uniforms.weight.value = options.weight;
				}
				if (options.clampMax !== undefined) {
						_this.godRaysMaterial.uniforms.clampMax.value = options.clampMax;
				}

				_this.samples = options.samples;

				/**
     * A combine shader material.
     *
     * @type {CombineMaterial}
     * @private
     */

				_this.combineMaterial = new CombineMaterial(options.screenMode !== undefined ? options.screenMode : true);

				_this.intensity = options.intensity;

				return _this;
		}

		/**
   * The resolution scale.
   *
   * @type {Number}
   * @default 0.5
   */

		createClass(GodRaysPass, [{
				key: "render",


				/**
     * Renders the scene.
     *
     * The god rays pass has four phases:
     *
     * Mask Phase:
     *  First, the light source is rendered. Then the scene is rendered into the
     *  same buffer using a mask override material with depth test enabled.
     *
     * Preliminary Blur Phase:
     *  The masked scene is blurred.
     *
     * God Rays Phase:
     *  The blurred scene is blurred again, but this time along radial lines
     *  towards the light source.
     *
     * Composite Phase:
     *  The final result is combined with the read buffer.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						var quad = this.quad;
						var scene = this.scene;
						var camera = this.camera;
						var mainScene = this.mainScene;

						var lightSource = this.lightSource;
						var screenPosition = this.screenPosition;

						var godRaysMaterial = this.godRaysMaterial;
						var combineMaterial = this.combineMaterial;

						var renderTargetMask = this.renderTargetMask;
						var renderTargetX = this.renderTargetX;
						var renderTargetY = this.renderTargetY;

						var background = void 0,
						    parent = void 0;

						// Compute the screen light position and translate it to [0, 1].
						screenPosition.copy(lightSource.position).project(this.mainCamera);
						screenPosition.x = clamp((screenPosition.x + 1.0) * 0.5, 0.0, 1.0);
						screenPosition.y = clamp((screenPosition.y + 1.0) * 0.5, 0.0, 1.0);

						// Render the masked scene.
						parent = lightSource.parent;
						background = mainScene.background;
						mainScene.background = null;
						this.lightScene.add(lightSource);

						this.renderPassLight.render(renderer, renderTargetMask);
						this.renderPassMask.render(renderer, renderTargetMask);

						if (parent !== null) {

								parent.add(lightSource);
						}

						mainScene.background = background;

						// Convolution phase.
						this.blurPass.render(renderer, renderTargetMask, renderTargetX);

						// God rays pass.
						quad.material = godRaysMaterial;
						godRaysMaterial.uniforms.tDiffuse.value = renderTargetX.texture;
						renderer.render(scene, camera, renderTargetY);

						// Final pass - composite god rays onto colours.
						quad.material = combineMaterial;
						combineMaterial.uniforms.texture1.value = readBuffer.texture;
						combineMaterial.uniforms.texture2.value = renderTargetY.texture;

						renderer.render(scene, camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Adjusts the format of the render targets.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						this.renderPassLight.initialise(renderer, alpha);
						this.renderPassMask.initialise(renderer, alpha);
						this.blurPass.initialise(renderer, alpha);

						if (!alpha) {

								this.renderTargetMask.texture.format = RGBFormat;
								this.renderTargetX.texture.format = RGBFormat;
								this.renderTargetY.texture.format = RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.renderPassLight.setSize(width, height);
						this.renderPassMask.setSize(width, height);
						this.blurPass.setSize(width, height);

						width = this.blurPass.width;
						height = this.blurPass.height;

						this.renderTargetMask.setSize(width, height);
						this.renderTargetX.setSize(width, height);
						this.renderTargetY.setSize(width, height);
				}
		}, {
				key: "resolutionScale",
				get: function get$$1() {
						return this.blurPass.resolutionScale;
				}

				/**
     * You need to call {@link EffectComposer#setSize} after changing this value.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
						this.blurPass.resolutionScale = x;
				}

				/**
     * The blur kernel size.
     *
     * @type {KernelSize}
     * @default KernelSize.LARGE
     */

		}, {
				key: "kernelSize",
				get: function get$$1() {
						return this.blurPass.kernelSize;
				}

				/**
     * @type {KernelSize}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : KernelSize.LARGE;
						this.blurPass.kernelSize = x;
				}

				/**
     * The overall intensity of the effect.
     *
     * @type {Number}
     * @default 1.0
     */

		}, {
				key: "intensity",
				get: function get$$1() {
						return this.combineMaterial.uniforms.opacity2.value;
				}

				/**
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
						this.combineMaterial.uniforms.opacity2.value = x;
				}

				/**
     * The number of samples per pixel.
     *
     * @type {Number}
     * @default 60
     */

		}, {
				key: "samples",
				get: function get$$1() {
						return Number.parseInt(this.godRaysMaterial.defines.NUM_SAMPLES_INT);
				}

				/**
     * This value must be carefully chosen. A higher value directly increases the
     * GPU load.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 60;


						x = Math.floor(x);

						this.godRaysMaterial.defines.NUM_SAMPLES_FLOAT = x.toFixed(1);
						this.godRaysMaterial.defines.NUM_SAMPLES_INT = x.toFixed(0);
						this.godRaysMaterial.needsUpdate = true;
				}
		}]);
		return GodRaysPass;
}(Pass);

/**
 * A mask pass.
 */

var MaskPass = function (_Pass) {
		inherits(MaskPass, _Pass);

		/**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */

		function MaskPass(scene, camera) {
				classCallCheck(this, MaskPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (MaskPass.__proto__ || Object.getPrototypeOf(MaskPass)).call(this, scene, camera, null));

				_this.name = "MaskPass";

				/**
     * Inverse flag.
     *
     * @type {Boolean}
     * @default false
     */

				_this.inverse = false;

				/**
     * Stencil buffer clear flag.
     *
     * @type {Boolean}
     * @default true
     */

				_this.clearStencil = true;

				return _this;
		}

		/**
   * Creates a stencil bit mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(MaskPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						var context = renderer.context;
						var state = renderer.state;

						var scene = this.scene;
						var camera = this.camera;

						var writeValue = this.inverse ? 0 : 1;
						var clearValue = 1 - writeValue;

						// Don't update color or depth.
						state.buffers.color.setMask(false);
						state.buffers.depth.setMask(false);

						// Lock the buffers.
						state.buffers.color.setLocked(true);
						state.buffers.depth.setLocked(true);

						// Configure the stencil.
						state.buffers.stencil.setTest(true);
						state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
						state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
						state.buffers.stencil.setClear(clearValue);

						// Clear the stencil.
						if (this.clearStencil) {

								renderer.setRenderTarget(readBuffer);
								renderer.clearStencil();

								renderer.setRenderTarget(writeBuffer);
								renderer.clearStencil();
						}

						// Draw the mask into both buffers.
						renderer.render(scene, camera, readBuffer);
						renderer.render(scene, camera, writeBuffer);

						// Unlock the buffers.
						state.buffers.color.setLocked(false);
						state.buffers.depth.setLocked(false);

						// Only render where the stencil is set to 1.
						state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff);
						state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
				}
		}]);
		return MaskPass;
}(Pass);

/**
 * A pixelation pass.
 */

var PixelationPass = function (_Pass) {
		inherits(PixelationPass, _Pass);

		/**
   * Constructs a new pixelation pass.
   *
   * @param {Number} [granularity=30.0] - The intensity of the effect.
   */

		function PixelationPass() {
				var granularity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30.0;
				classCallCheck(this, PixelationPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (PixelationPass.__proto__ || Object.getPrototypeOf(PixelationPass)).call(this));

				_this.name = "PixelationPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A pixelation shader material.
     *
     * @type {PixelationMaterial}
     * @private
     */

				_this.pixelationMaterial = new PixelationMaterial();

				_this.granularity = granularity;

				_this.quad.material = _this.pixelationMaterial;

				return _this;
		}

		/**
   * The pixel granularity.
   *
   * @type {Number}
   * @default 30.0
   */

		createClass(PixelationPass, [{
				key: "render",


				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     */

				value: function render(renderer, readBuffer, writeBuffer) {

						this.pixelationMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.pixelationMaterial.setResolution(width, height);
				}
		}, {
				key: "granularity",
				get: function get$$1() {
						return this.pixelationMaterial.granularity;
				}

				/**
     * A higher value yields coarser visuals.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30;


						x = Math.floor(x);

						if (x % 2 > 0) {

								x += 1;
						}

						this.pixelationMaterial.granularity = x;
				}
		}]);
		return PixelationPass;
}(Pass);

/**
 * A pass that renders the result from a previous pass to another render target.
 */

var SavePass = function (_Pass) {
		inherits(SavePass, _Pass);

		/**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - The render target to use for saving the read buffer.
   * @param {Boolean} [resize=true] - Whether the render target should adjust to the size of the read/write buffer.
   */

		function SavePass(renderTarget) {
				var resize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
				classCallCheck(this, SavePass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (SavePass.__proto__ || Object.getPrototypeOf(SavePass)).call(this));

				_this.name = "SavePass";

				/**
     * Copy shader material.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.material = new CopyMaterial();

				_this.quad.material = _this.material;

				/**
     * The render target.
     *
     * @type {WebGLRenderTarget}
     */

				_this.renderTarget = renderTarget !== undefined ? renderTarget : new WebGLRenderTarget(1, 1, {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTarget.texture.name = "Save.Target";
				_this.renderTarget.texture.generateMipmaps = false;

				/**
     * Indicates whether the render target should be resized when the size of
     * the composer's read/write buffer changes.
     *
     * @type {Boolean}
     * @default true
     */

				_this.resize = resize;

				return _this;
		}

		/**
   * Saves the read buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		createClass(SavePass, [{
				key: "render",
				value: function render(renderer, readBuffer) {

						this.material.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderTarget);
				}

				/**
     * Adjusts the format of the render target.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer, alpha) {

						if (!alpha) {

								this.renderTarget.texture.format = RGBFormat;
						}
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						if (this.resize) {

								width = Math.max(1, width);
								height = Math.max(1, height);

								this.renderTarget.setSize(width, height);
						}
				}
		}]);
		return SavePass;
}(Pass);

/**
 * A shader pass.
 *
 * Used to render any shader material as a 2D filter.
 */

var ShaderPass = function (_Pass) {
		inherits(ShaderPass, _Pass);

		/**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - The shader material to use.
   * @param {String} [textureID="tDiffuse"] - The texture uniform identifier.
   */

		function ShaderPass(material) {
				var textureID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "tDiffuse";
				classCallCheck(this, ShaderPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ShaderPass.__proto__ || Object.getPrototypeOf(ShaderPass)).call(this));

				_this.name = "ShaderPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The shader material to use for rendering.
     *
     * @type {ShaderMaterial}
     */

				_this.material = material;

				_this.quad.material = _this.material;

				/**
     * The name of the color sampler uniform of the given material.
     *
     * @type {String}
     * @default "tDiffuse"
     */

				_this.textureID = textureID;

				return _this;
		}

		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(ShaderPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						if (this.material.uniforms[this.textureID] !== undefined) {

								this.material.uniforms[this.textureID].value = readBuffer.texture;
						}

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}
		}]);
		return ShaderPass;
}(Pass);

/**
 * Half PI.
 *
 * @type {Number}
 * @private
 * @static
 * @final
 */

var HALF_PI = Math.PI * 0.5;

/**
 * A vector.
 *
 * @type {Vector3}
 * @private
 * @static
 * @final
 */

var v = new Vector3();

/**
 * A vector.
 *
 * @type {Vector3}
 * @private
 * @static
 * @final
 */

var ab = new Vector3();

/**
 * A shock wave pass.
 */

var ShockWavePass = function (_Pass) {
		inherits(ShockWavePass, _Pass);

		/**
   * Constructs a new shock wave pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {Vector3} [epicenter] - The world position of the shock wave epicenter.
   * @param {Object} [options] - The options.
   * @param {Number} [options.speed=1.0] - The animation speed.
   * @param {Number} [options.maxRadius=1.0] - The extent of the shock wave.
   * @param {Number} [options.waveSize=0.2] - The wave size.
   * @param {Number} [options.amplitude=0.05] - The distortion amplitude.
   */

		function ShockWavePass(camera) {
				var epicenter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
				var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
				classCallCheck(this, ShockWavePass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ShockWavePass.__proto__ || Object.getPrototypeOf(ShockWavePass)).call(this));

				_this.name = "ShockWavePass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The main camera.
     *
     * @type {Object3D}
     */

				_this.mainCamera = camera;

				/**
     * The epicenter.
     *
     * @type {Vector3}
     * @example shockWavePass.epicenter = myMesh.position;
     */

				_this.epicenter = epicenter;

				/**
     * The object position in screen space.
     *
     * @type {Vector3}
     * @private
     */

				_this.screenPosition = new Vector3();

				/**
     * The speed of the shock wave animation.
     *
     * @type {Number}
     * @default 2.0
     */

				_this.speed = options.speed !== undefined ? options.speed : 2.0;

				/**
     * A time accumulator.
     *
     * @type {Number}
     * @private
     */

				_this.time = 0.0;

				/**
     * Indicates whether the shock wave animation is active.
     *
     * @type {Boolean}
     * @private
     */

				_this.active = false;

				/**
     * A shock wave shader material.
     *
     * @type {ShockWaveMaterial}
     * @private
     */

				_this.shockWaveMaterial = new ShockWaveMaterial(options);

				_this.shockWaveMaterial.uniforms.center.value = _this.screenPosition;

				/**
     * A copy shader material.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.copyMaterial = new CopyMaterial();

				return _this;
		}

		/**
   * Emits the shock wave.
   */

		createClass(ShockWavePass, [{
				key: "explode",
				value: function explode() {

						this.time = 0.0;
						this.active = true;
				}

				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     * @param {Number} delta - The render delta time.
     */

		}, {
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer, delta) {

						var epicenter = this.epicenter;
						var mainCamera = this.mainCamera;
						var screenPosition = this.screenPosition;

						var shockWaveMaterial = this.shockWaveMaterial;
						var uniforms = shockWaveMaterial.uniforms;
						var center = uniforms.center;
						var radius = uniforms.radius;
						var maxRadius = uniforms.maxRadius;
						var waveSize = uniforms.waveSize;

						this.copyMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						this.quad.material = this.copyMaterial;

						if (this.active) {

								// Calculate direction vectors.
								mainCamera.getWorldDirection(v);
								ab.copy(mainCamera.position).sub(epicenter);

								// Don't render the effect if the object is behind the camera.
								if (v.angleTo(ab) > HALF_PI) {

										// Scale the effect based on distance to the object.
										uniforms.cameraDistance.value = mainCamera.position.distanceTo(epicenter);

										// Calculate the screen position of the epicenter.
										screenPosition.copy(epicenter).project(mainCamera);
										center.value.x = (screenPosition.x + 1.0) * 0.5;
										center.value.y = (screenPosition.y + 1.0) * 0.5;

										uniforms.tDiffuse.value = readBuffer.texture;
										this.quad.material = shockWaveMaterial;
								}

								// Update the shock wave radius based on time.
								this.time += delta * this.speed;
								radius.value = this.time - waveSize.value;

								if (radius.value >= (maxRadius.value + waveSize.value) * 2) {

										this.active = false;
								}
						}

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.shockWaveMaterial.uniforms.aspect.value = width / height;
				}
		}]);
		return ShockWavePass;
}(Pass);

/**
 * Subpixel Morphological Antialiasing (SMAA) v2.8.
 *
 * Preset: SMAA 1x Medium (with color edge detection).
 *  https://github.com/iryoku/smaa/releases/tag/v2.8
 */

var SMAAPass = function (_Pass) {
		inherits(SMAAPass, _Pass);

		/**
   * Constructs a new SMAA pass.
   *
   * @param {Image} Image - This pass requires an Image class to create internal textures. Provide window.Image in a browser environment.
   */

		function SMAAPass(Image) {
				classCallCheck(this, SMAAPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (SMAAPass.__proto__ || Object.getPrototypeOf(SMAAPass)).call(this));

				_this.name = "SMAAPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * A render target for the color edge detection.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetColorEdges = new WebGLRenderTarget(1, 1, {
						minFilter: LinearFilter,
						format: RGBFormat,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetColorEdges.texture.name = "SMAA.ColorEdges";
				_this.renderTargetColorEdges.texture.generateMipmaps = false;

				/**
     * A render target for the SMAA weights.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetWeights = _this.renderTargetColorEdges.clone();

				_this.renderTargetWeights.texture.name = "SMAA.Weights";
				_this.renderTargetWeights.texture.format = RGBAFormat;

				/**
     * SMAA color edge detection shader material.
     *
     * @type {SMAAColorEdgesMaterial}
     * @private
     */

				_this.colorEdgesMaterial = new SMAAColorEdgesMaterial();

				/**
     * SMAA weights shader material.
     *
     * @type {SMAAWeightsMaterial}
     * @private
     */

				_this.weightsMaterial = new SMAAWeightsMaterial();

				var areaImage = new Image();
				areaImage.src = _this.weightsMaterial.areaImage;

				var areaTexture = new Texture();
				areaTexture.image = areaImage;
				areaTexture.name = "SMAA.Area";
				areaTexture.minFilter = LinearFilter;
				areaTexture.format = RGBFormat;
				areaTexture.generateMipmaps = false;
				areaTexture.needsUpdate = true;
				areaTexture.flipY = false;

				var searchImage = new Image();
				searchImage.src = _this.weightsMaterial.searchImage;

				var searchTexture = new Texture();
				searchTexture.image = searchImage;
				searchTexture.name = "SMAA.Search";
				searchTexture.magFilter = NearestFilter;
				searchTexture.minFilter = NearestFilter;
				searchTexture.generateMipmaps = false;
				searchTexture.needsUpdate = true;
				searchTexture.flipY = false;

				_this.weightsMaterial.uniforms.tDiffuse.value = _this.renderTargetColorEdges.texture;
				_this.weightsMaterial.uniforms.tArea.value = areaTexture;
				_this.weightsMaterial.uniforms.tSearch.value = searchTexture;

				/**
     * SMAA blend shader material.
     *
     * @type {SMAABlendMaterial}
     * @private
     */

				_this.blendMaterial = new SMAABlendMaterial();

				_this.blendMaterial.uniforms.tWeights.value = _this.renderTargetWeights.texture;

				_this.quad.material = _this.blendMaterial;

				return _this;
		}

		/**
   * Antialiases the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer.
   */

		createClass(SMAAPass, [{
				key: "render",
				value: function render(renderer, readBuffer, writeBuffer) {

						// Detect color edges.
						this.quad.material = this.colorEdgesMaterial;
						this.colorEdgesMaterial.uniforms.tDiffuse.value = readBuffer.texture;
						renderer.render(this.scene, this.camera, this.renderTargetColorEdges, true);

						// Compute edge weights.
						this.quad.material = this.weightsMaterial;
						renderer.render(this.scene, this.camera, this.renderTargetWeights, false);

						// Apply the antialiasing filter to the colors.
						this.quad.material = this.blendMaterial;
						this.blendMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Updates this pass with the renderer's size.
     *
     * @param {Number} width - The width.
     * @param {Number} height - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						this.renderTargetColorEdges.setSize(width, height);
						this.renderTargetWeights.setSize(width, height);

						this.colorEdgesMaterial.uniforms.texelSize.value.copy(this.weightsMaterial.uniforms.texelSize.value.copy(this.blendMaterial.uniforms.texelSize.value.set(1.0 / width, 1.0 / height)));
				}
		}]);
		return SMAAPass;
}(Pass);

/**
 * A pass that renders a given texture.
 */

var TexturePass = function (_Pass) {
	inherits(TexturePass, _Pass);

	/**
  * Constructs a new texture pass.
  *
  * @param {Texture} texture - The texture.
  * @param {Number} [opacity=1.0] - The texture opacity.
  */

	function TexturePass(texture) {
		var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
		classCallCheck(this, TexturePass);

		/**
   * The name of this pass.
   */

		var _this = possibleConstructorReturn(this, (TexturePass.__proto__ || Object.getPrototypeOf(TexturePass)).call(this));

		_this.name = "TexturePass";

		/**
   * A copy shader material used for rendering to texture.
   *
   * @type {CopyMaterial}
   * @private
   */

		_this.copyMaterial = new CopyMaterial();
		_this.copyMaterial.blending = AdditiveBlending;
		_this.copyMaterial.transparent = true;

		_this.texture = texture;
		_this.opacity = opacity;

		_this.quad.material = _this.copyMaterial;

		return _this;
	}

	/**
  * The texture.
  *
  * @type {Texture}
  */

	createClass(TexturePass, [{
		key: "render",


		/**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} readBuffer - The read buffer.
   */

		value: function render(renderer, readBuffer) {

			renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer);
		}
	}, {
		key: "texture",
		get: function get$$1() {
			return this.copyMaterial.uniforms.tDiffuse.value;
		}

		/**
   * @type {Texture}
   */

		,
		set: function set$$1(x) {
			this.copyMaterial.uniforms.tDiffuse.value = x;
		}

		/**
   * The opacity.
   *
   * @type {Number}
   * @default 1.0
   */

	}, {
		key: "opacity",
		get: function get$$1() {
			return this.copyMaterial.uniforms.opacity.value;
		}

		/**
   * @type {Number}
   */

		,
		set: function set$$1() {
			var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
			this.copyMaterial.uniforms.opacity.value = x;
		}
	}]);
	return TexturePass;
}(Pass);

/**
 * Rounds the given number up to the next power of two.
 *
 * @private
 * @static
 * @param {Number} n - A number.
 * @return {Number} The next power of two.
 */

function ceil2(n) {
		return Math.pow(2, Math.max(0, Math.ceil(Math.log2(n))));
}

/**
 * A tone mapping pass that supports adaptive luminosity.
 *
 * If adaptivity is enabled, this pass generates a texture that represents the
 * luminosity of the current scene and adjusts it over time to simulate the
 * optic nerve responding to the amount of light it is receiving.
 *
 * Reference:
 *  GDC2007 - Wolfgang Engel, Post-Processing Pipeline
 *  http://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/GAMA/2007/gdc07/Post-Processing_Pipeline.pdf
 */

var ToneMappingPass = function (_Pass) {
		inherits(ToneMappingPass, _Pass);

		/**
   * Constructs a new tone mapping pass.
   *
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.adaptive=true] - Whether the tone mapping should use an adaptive luminance map.
   * @param {Number} [options.resolution=256] - The render texture resolution.
   * @param {Number} [options.distinction=1.0] - A luminance distinction factor.
   */

		function ToneMappingPass() {
				var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				classCallCheck(this, ToneMappingPass);

				/**
     * The name of this pass.
     */

				var _this = possibleConstructorReturn(this, (ToneMappingPass.__proto__ || Object.getPrototypeOf(ToneMappingPass)).call(this));

				_this.name = "ToneMappingPass";

				/**
     * This pass renders to the write buffer.
     */

				_this.needsSwap = true;

				/**
     * The render target for the current luminosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     * @todo Use RED format in WebGL 2.0.
     */

				_this.renderTargetLuminosity = new WebGLRenderTarget(1, 1, {
						minFilter: LinearMipMapLinearFilter,
						magFilter: LinearFilter,
						format: RGBFormat,
						stencilBuffer: false,
						depthBuffer: false
				});

				_this.renderTargetLuminosity.texture.name = "ToneMapping.Luminosity";

				/**
     * The render target for adapted luminosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetAdapted = _this.renderTargetLuminosity.clone();

				_this.renderTargetAdapted.texture.name = "ToneMapping.AdaptedLuminosity";
				_this.renderTargetAdapted.texture.generateMipmaps = false;
				_this.renderTargetAdapted.texture.minFilter = LinearFilter;

				/**
     * A render target that holds a copy of the adapted limonosity.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				_this.renderTargetPrevious = _this.renderTargetAdapted.clone();

				_this.renderTargetPrevious.texture.name = "ToneMapping.PreviousLuminosity";

				/**
     * Copy shader material used for saving the luminance map.
     *
     * @type {CopyMaterial}
     * @private
     */

				_this.copyMaterial = new CopyMaterial();

				/**
     * A luminosity shader material.
     *
     * @type {LuminosityMaterial}
     * @private
     */

				_this.luminosityMaterial = new LuminosityMaterial();

				_this.luminosityMaterial.uniforms.distinction.value = options.distinction !== undefined ? options.distinction : 1.0;

				/**
     * An adaptive luminance shader material.
     *
     * @type {AdaptiveLuminosityMaterial}
     * @private
     */

				_this.adaptiveLuminosityMaterial = new AdaptiveLuminosityMaterial();

				_this.resolution = options.resolution;

				/**
     * A tone mapping shader material.
     *
     * @type {ToneMappingMaterial}
     * @private
     */

				_this.toneMappingMaterial = new ToneMappingMaterial();

				_this.adaptive = options.adaptive;

				return _this;
		}

		/**
   * The resolution of the render targets.
   *
   * @type {Number}
   * @default 256
   */

		createClass(ToneMappingPass, [{
				key: "render",


				/**
     * Renders the effect.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     * @param {WebGLRenderTarget} readBuffer - The read buffer.
     * @param {WebGLRenderTarget} writeBuffer - The write buffer.
     * @param {Number} delta - The render delta time.
     */

				value: function render(renderer, readBuffer, writeBuffer, delta) {

						var quad = this.quad;
						var scene = this.scene;
						var camera = this.camera;

						var adaptiveLuminosityMaterial = this.adaptiveLuminosityMaterial;
						var luminosityMaterial = this.luminosityMaterial;
						var toneMappingMaterial = this.toneMappingMaterial;
						var copyMaterial = this.copyMaterial;

						var renderTargetPrevious = this.renderTargetPrevious;
						var renderTargetLuminosity = this.renderTargetLuminosity;
						var renderTargetAdapted = this.renderTargetAdapted;

						if (this.adaptive) {

								// Render the luminance of the current scene into a render target with mipmapping enabled.
								quad.material = luminosityMaterial;
								luminosityMaterial.uniforms.tDiffuse.value = readBuffer.texture;
								renderer.render(scene, camera, renderTargetLuminosity);

								// Use the new luminance values, the previous luminance and the frame delta to adapt the luminance over time.
								quad.material = adaptiveLuminosityMaterial;
								adaptiveLuminosityMaterial.uniforms.delta.value = delta;
								adaptiveLuminosityMaterial.uniforms.tPreviousLum.value = renderTargetPrevious.texture;
								adaptiveLuminosityMaterial.uniforms.tCurrentLum.value = renderTargetLuminosity.texture;
								renderer.render(scene, camera, renderTargetAdapted);

								// Copy the new adapted luminance value so that it can be used by the next frame.
								quad.material = copyMaterial;
								copyMaterial.uniforms.tDiffuse.value = renderTargetAdapted.texture;
								renderer.render(scene, camera, renderTargetPrevious);
						}

						// Apply the tone mapping to the colours.
						quad.material = toneMappingMaterial;
						toneMappingMaterial.uniforms.tDiffuse.value = readBuffer.texture;

						renderer.render(this.scene, this.camera, this.renderToScreen ? null : writeBuffer);
				}

				/**
     * Renders something into the previous luminosity texture.
     *
     * @param {WebGLRenderer} renderer - The renderer.
     */

		}, {
				key: "initialise",
				value: function initialise(renderer) {

						this.quad.material = new MeshBasicMaterial({ color: 0x7fffff });
						renderer.render(this.scene, this.camera, this.renderTargetPrevious);
						this.quad.material.dispose();
				}
		}, {
				key: "resolution",
				get: function get$$1() {
						return this.renderTargetLuminosity.width;
				}

				/**
     * The resolution of the render targets. Must be a power of two for mipmaps.
     *
     * @type {Number}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 256;


						x = ceil2(x);

						this.renderTargetLuminosity.setSize(x, x);
						this.renderTargetPrevious.setSize(x, x);
						this.renderTargetAdapted.setSize(x, x);

						this.adaptiveLuminosityMaterial.defines.MIP_LEVEL_1X1 = (Math.round(Math.log(x)) / Math.log(2)).toFixed(1);
						this.adaptiveLuminosityMaterial.needsUpdate = true;
				}

				/**
     * Whether this pass uses adaptive luminosity.
     *
     * @type {Boolean}
     * @default true
     */

		}, {
				key: "adaptive",
				get: function get$$1() {
						return this.toneMappingMaterial.defines.ADAPTED_LUMINANCE !== undefined;
				}

				/**
     * Whether this pass should use adaptive luminosity.
     *
     * @type {Boolean}
     */

				,
				set: function set$$1() {
						var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


						if (x) {

								this.toneMappingMaterial.defines.ADAPTED_LUMINANCE = "1";
								this.toneMappingMaterial.uniforms.luminanceMap.value = this.renderTargetAdapted.texture;
						} else {

								delete this.toneMappingMaterial.defines.ADAPTED_LUMINANCE;
								this.toneMappingMaterial.uniforms.luminanceMap.value = null;
						}

						this.toneMappingMaterial.needsUpdate = true;
				}
		}]);
		return ToneMappingPass;
}(Pass);

/**
 * A compilation of the post processing passes.
 *
 * @module postprocessing/passes
 */

/**
 * The EffectComposer may be used in place of a normal WebGLRenderer.
 *
 * The auto clear behaviour of the provided renderer will be disabled to prevent
 * unnecessary clear operations.
 *
 * It is common practice to use a {@link RenderPass} as the first pass to
 * automatically clear the screen and render the scene to a texture for further
 * processing.
 */

var EffectComposer = function () {

		/**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} [renderer] - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.depthTexture=false] - Set to true if one of your passes relies on a depth texture.
   */

		function EffectComposer() {
				var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				classCallCheck(this, EffectComposer);


				/**
     * The renderer.
     *
     * You may replace the renderer at any time by using
     * {@link EffectComposer#replaceRenderer}.
     *
     * @type {WebGLRenderer}
     */

				this.renderer = renderer;

				/**
     * The read buffer.
     *
     * Reading from and writing to the same render target should be avoided.
     * Therefore, two seperate yet identical buffers are used.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				this.readBuffer = null;

				/**
     * The write buffer.
     *
     * @type {WebGLRenderTarget}
     * @private
     */

				this.writeBuffer = null;

				if (this.renderer !== null) {

						this.renderer.autoClear = false;

						this.readBuffer = this.createBuffer(options.depthBuffer !== undefined ? options.depthBuffer : true, options.stencilBuffer !== undefined ? options.stencilBuffer : false, options.depthTexture !== undefined ? options.depthTexture : false);

						this.writeBuffer = this.readBuffer.clone();
				}

				/**
     * A copy pass used for copying masked scenes.
     *
     * @type {ShaderPass}
     * @private
     */

				this.copyPass = new ShaderPass(new CopyMaterial());

				/**
     * The passes.
     *
     * @type {Pass[]}
     * @private
     */

				this.passes = [];
		}

		/**
   * The depth texture of the read and write buffers.
   *
   * @type {DepthTexture}
   * @default null
   */

		createClass(EffectComposer, [{
				key: "replaceRenderer",


				/**
     * Replaces the current renderer with the given one. The DOM element of the
     * current renderer will automatically be removed from its parent node and the
     * DOM element of the new renderer will take its place.
     *
     * The auto clear mechanism of the provided renderer will be disabled.
     *
     * Switching between renderers allows you to dynamically enable or disable
     * antialiasing.
     *
     * @param {WebGLRenderer} renderer - The new renderer.
     * @return {WebGLRenderer} The old renderer.
     */

				value: function replaceRenderer(renderer) {

						var oldRenderer = this.renderer;

						var parent = void 0,
						    oldSize = void 0,
						    newSize = void 0;

						if (oldRenderer !== null && oldRenderer !== renderer) {

								this.renderer = renderer;
								this.renderer.autoClear = false;

								parent = oldRenderer.domElement.parentNode;
								oldSize = oldRenderer.getSize();
								newSize = renderer.getSize();

								if (parent !== null) {

										parent.removeChild(oldRenderer.domElement);
										parent.appendChild(renderer.domElement);
								}

								if (oldSize.width !== newSize.width || oldSize.height !== newSize.height) {

										this.setSize();
								}
						}

						return oldRenderer;
				}

				/**
     * Creates a new render target by replicating the renderer's canvas.
     *
     * The created render target uses a linear filter for texel minification and
     * magnification. Its render texture format depends on whether the renderer
     * uses the alpha channel. Mipmaps are disabled.
     *
     * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
     * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
     * @param {Boolean} depthTexture - Whether the render target should have a depth texture.
     * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
     */

		}, {
				key: "createBuffer",
				value: function createBuffer(depthBuffer, stencilBuffer, depthTexture) {

						var size = this.renderer.getSize();
						var pixelRatio = this.renderer.getPixelRatio();
						var alpha = this.renderer.context.getContextAttributes().alpha;

						var renderTarget = new WebGLRenderTarget(size.width * pixelRatio, size.height * pixelRatio, {
								minFilter: LinearFilter,
								magFilter: LinearFilter,
								format: alpha ? RGBAFormat : RGBFormat,
								depthBuffer: depthBuffer,
								stencilBuffer: stencilBuffer,
								depthTexture: depthTexture ? new DepthTexture() : null
						});

						if (depthTexture && stencilBuffer) {

								renderTarget.depthTexture.format = DepthStencilFormat;
								renderTarget.depthTexture.type = UnsignedInt248Type;
						}

						renderTarget.texture.name = "EffectComposer.Buffer";
						renderTarget.texture.generateMipmaps = false;

						return renderTarget;
				}

				/**
     * Adds a pass, optionally at a specific index.
     *
     * @param {Pass} pass - A new pass.
     * @param {Number} [index] - An index at which the pass should be inserted.
     */

		}, {
				key: "addPass",
				value: function addPass(pass, index) {

						var renderer = this.renderer;
						var size = renderer.getSize();
						var pixelRatio = renderer.getPixelRatio();

						pass.setSize(size.width * pixelRatio, size.height * pixelRatio);
						pass.initialise(renderer, renderer.context.getContextAttributes().alpha);

						if (index !== undefined) {

								this.passes.splice(index, 0, pass);
						} else {

								this.passes.push(pass);
						}
				}

				/**
     * Removes a pass.
     *
     * @param {Pass} pass - The pass.
     */

		}, {
				key: "removePass",
				value: function removePass(pass) {

						this.passes.splice(this.passes.indexOf(pass), 1);
				}

				/**
     * Renders all enabled passes in the order in which they were added.
     *
     * @param {Number} delta - The time between the last frame and the current one in seconds.
     */

		}, {
				key: "render",
				value: function render(delta) {

						var passes = this.passes;
						var renderer = this.renderer;
						var copyPass = this.copyPass;

						var readBuffer = this.readBuffer;
						var writeBuffer = this.writeBuffer;

						var maskActive = false;
						var pass = void 0,
						    context = void 0,
						    buffer = void 0;
						var i = void 0,
						    l = void 0;

						for (i = 0, l = passes.length; i < l; ++i) {

								pass = passes[i];

								if (pass.enabled) {

										pass.render(renderer, readBuffer, writeBuffer, delta, maskActive);

										if (pass.needsSwap) {

												if (maskActive) {

														context = renderer.context;
														context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
														copyPass.render(renderer, readBuffer, writeBuffer);
														context.stencilFunc(context.EQUAL, 1, 0xffffffff);
												}

												buffer = readBuffer;
												readBuffer = writeBuffer;
												writeBuffer = buffer;
										}

										if (pass instanceof MaskPass) {

												maskActive = true;
										} else if (pass instanceof ClearMaskPass) {

												maskActive = false;
										}
								}
						}
				}

				/**
     * Sets the size of the buffers and the renderer's output canvas.
     *
     * Every pass will be informed of the new size. It's up to each pass how that
     * information is used.
     *
     * If no width or height is specified, the render targets and passes will be
     * updated with the current size of the renderer.
     *
     * @param {Number} [width] - The width.
     * @param {Number} [height] - The height.
     */

		}, {
				key: "setSize",
				value: function setSize(width, height) {

						var passes = this.passes;
						var size = this.renderer.getSize();
						var pixelRatio = this.renderer.getPixelRatio();

						var i = void 0,
						    l = void 0;

						if (width === undefined || height === undefined) {

								width = size.width;
								height = size.height;
						}

						this.renderer.setSize(width, height);

						width *= pixelRatio;
						height *= pixelRatio;

						this.readBuffer.setSize(width, height);
						this.writeBuffer.setSize(width, height);

						for (i = 0, l = passes.length; i < l; ++i) {

								passes[i].setSize(width, height);
						}
				}

				/**
     * Resets this composer by deleting all passes and creating new buffers.
     *
     * @param {WebGLRenderTarget} [renderTarget] - A new render target. If none is provided, the settings of the renderer will be used.
     */

		}, {
				key: "reset",
				value: function reset(renderTarget) {

						var depthBuffer = this.readBuffer.depthBuffer;
						var stencilBuffer = this.readBuffer.stencilBuffer;
						var depthTexture = this.readBuffer.depthTexture !== null;

						this.dispose(renderTarget === undefined ? this.createBuffer(depthBuffer, stencilBuffer, depthTexture) : renderTarget);
				}

				/**
     * Destroys all passes and render targets.
     *
     * This method deallocates all render targets, textures and materials created
     * by the passes. It also deletes this composer's frame buffers.
     *
     * @param {WebGLRenderTarget} [renderTarget] - A new render target. If none is provided, the composer will become inoperative.
     */

		}, {
				key: "dispose",
				value: function dispose(renderTarget) {

						var passes = this.passes;

						if (this.readBuffer !== null && this.writeBuffer !== null) {

								this.readBuffer.dispose();
								this.writeBuffer.dispose();

								this.readBuffer = null;
								this.writeBuffer = null;
						}

						while (passes.length > 0) {

								passes.pop().dispose();
						}

						if (renderTarget !== undefined) {

								// Reanimate.
								this.readBuffer = renderTarget;
								this.writeBuffer = this.readBuffer.clone();
						} else {

								this.copyPass.dispose();
						}
				}
		}, {
				key: "depthTexture",
				get: function get$$1() {
						return this.readBuffer.depthTexture;
				}

				/**
     * The read and write buffers share a single depth texture. Depth will be
     * written to this texture when something is rendered into one of the buffers
     * and the involved materials have depth write enabled.
     *
     * You may enable this mechanism during the instantiation of the composer or
     * by assigning a DepthTexture instance later on. You may also disable it by
     * assigning null.
     *
     * @type {DepthTexture}
     */

				,
				set: function set$$1(x) {

						this.readBuffer.depthTexture = x;
						this.writeBuffer.depthTexture = x;
				}
		}]);
		return EffectComposer;
}();

var _class$36;
var _temp$36;

var polyfill = function polyfill(object, method) {
  var showWarn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (object[method]) return;
  if (showWarn) console.warn('@PostProcessorModule: pass.' + method + '() was not found.', object);
  object[method] = function () {};
};

/**
 * @class PostProcessorModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new PostProcessorModule()
 * ]);
 *
 * const processor = app.use('postprocessor');
 *
 * processor
 *   .render()
 *   .pass(new GlitchPass())
 *   .renderToScreen()
 */
var PostProcessorModule = (_temp$36 = _class$36 = function () {
  function PostProcessorModule() {
    var _this = this;

    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PostProcessorModule.defaults;
    classCallCheck(this, PostProcessorModule);
    this.currentPass = null;
    this.defer = new Promise(function (resolve) {
      _this.resolve = resolve;
    });

    this.debug = params.debug;
    this.params = params;
  }

  createClass(PostProcessorModule, [{
    key: 'manager',
    value: function manager(_manager) {
      var _this2 = this;

      _manager.define('postprocessor');

      this.effects = _manager.use('rendering').effects;
      this.renderer = _manager.get('renderer');
      this.scene = _manager.get('scene');
      this.camera = _manager.get('camera');

      this.composer = new EffectComposer(this.renderer, this.params);

      _manager.use('rendering').stop();

      var composer = this.composer;
      this.renderLoop = new Loop(function (clock) {
        return composer.render(clock.getDelta());
      }).start(_manager.handler);

      _manager.update({
        renderer: function renderer(_renderer) {
          _this2.composer.replaceRenderer(_renderer);
        },

        scene: function scene(_scene) {
          _this2.scene = _scene;
        },

        camera: function camera(_camera) {
          _this2.camera = _camera;
        }
      });

      this.resolve();
    }

    /**
     * @method render
     * @description Adds RenderPass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      this.defer.then(function () {
        var pass = new RenderPass(_this3.scene, _this3.camera.native);

        // TODO: Support for effects.

        _this3.composer.addPass(pass);
        _this3.currentPass = pass;
      });

      return this;
    }

    /**
     * @method pass
     * @description Adds your custom pass
     * @param {Pass} pass A custom pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'pass',
    value: function pass(_pass) {
      var _this4 = this;

      this.defer.then(function () {
        polyfill(_pass, 'setSize', _this4.debug);
        polyfill(_pass, 'initialise', _this4.debug);

        _this4.composer.addPass(_pass);
        _this4.currentPass = _pass;
      });

      return this;
    }

    /**
     * @method shader
     * @description Adds a pass made from shader material
     * @param {Material} material A ShaderMaterial
     * @param {String} textureID Name of the readBuffer uniform
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'shader',
    value: function shader(material) {
      var _this5 = this;

      var textureID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'readBuffer';

      this.defer.then(function () {
        if (!material.uniforms[textureID]) material.uniforms[textureID] = { value: null };

        var pass = new ShaderPass(material, textureID);

        _this5.composer.addPass(pass);
        _this5.currentPass = pass;
      });

      return this;
    }

    /**
     * @method get
     * @description Returns a pass by the given name
     * @param {String} name The name of the pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'get',
    value: function get$$1(name) {
      return name ? this.composer.passes.filter(function (pass) {
        return pass.name === name;
      })[0] : this.currentPass;
    }

    /**
     * @method renderToScreen
     * @description Sets the renderToScreen property of currentPass
     * @param {String} [name=true] The name of the pass
     * @return {this}
     * @memberof module:modules/app.PostProcessorModule
     */

  }, {
    key: 'renderToScreen',
    value: function renderToScreen() {
      var _this6 = this;

      var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.defer.then(function () {
        _this6.currentPass.renderToScreen = bool;
      });

      return this;
    }
  }]);
  return PostProcessorModule;
}(), _class$36.defaults = {
  debug: true
}, _temp$36);

/**
 * @class EventsPatchModule
 * @description This one is used in the core to handle events used by modules. If you want to make custom events - please make a similar one.
 * @category modules/app
 * @memberof module:modules/app
 */
var EventsPatchModule = function () {
  function EventsPatchModule() {
    classCallCheck(this, EventsPatchModule);
  }

  createClass(EventsPatchModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('events');
      this.element = _manager.get('renderer').domElement;
    }

    /**
     * @function patchEvents
     * @description This methods patches the list of events on specific object.
     * @param {Number} originObject - The object that gives events.
     * @param {Number} [destObject=this] - The object that takes events.
     * @param {Array[Strings]} [events=[]] - The list of events by names.
     * @memberof module:modules/app.EventsPatchModule
     */

  }, {
    key: 'patchEvents',
    value: function patchEvents(originObject) {
      var destObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
      var events = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      events.forEach(function (event) {
        return originObject.addEventListener(event, function (e) {
          return destObject.emit(event, e);
        });
      });
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var element = self.element,
          patchEvents = self.patchEvents;


      patchEvents(element, this, ['mousemove', 'mouseup', 'contextmenu', 'mousedown', 'click', 'wheel', 'touchstart', 'touchend', 'touchmove', 'keydown', 'keyup', 'keypress']);
    }
  }]);
  return EventsPatchModule;
}();

/**
 * @class VirtualMouseModule
 * @category modules/app
 * @param {Boolean} [globalMovement=false]
 * @memberof module:modules/app
 * @extends Events
 */

var VirtualMouseModule = function (_Events) {
  inherits(VirtualMouseModule, _Events);

  function VirtualMouseModule() {
    var globalMovement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    classCallCheck(this, VirtualMouseModule);

    var _this = possibleConstructorReturn(this, (VirtualMouseModule.__proto__ || Object.getPrototypeOf(VirtualMouseModule)).call(this));

    _this.mouse = new Vector2();
    _this.raycaster = new Raycaster();
    _this.world = null;
    _this.canvas = null;
    _this.projectionPlane = new Plane(new Vector3(0, 0, 1), 0);

    _this.globalMovement = globalMovement;
    return _this;
  }

  createClass(VirtualMouseModule, [{
    key: 'update',
    value: function update(e, customX, customY) {
      var rect = this.canvas.getBoundingClientRect();

      var x = customX || e.clientX;
      var y = customY || e.clientY;

      this.mouse.x = (x - rect.left) / (rect.right - rect.left) * 2 - 1;
      this.mouse.y = -((y - rect.top) / (rect.bottom - rect.top)) * 2 + 1;

      this.projectionPlane.normal.copy(this.camera.getWorldDirection());

      this.raycaster.setFromCamera(this.mouse, this.camera);
      this.emit('move');
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('mouse');
      _manager.require('events', function () {
        return new EventsPatchModule();
      });

      this.canvas = _manager.get('renderer').domElement;
      this.camera = _manager.get('camera').native;
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      var _this2 = this;

      ['click', 'mousedown', 'mouseup', 'mousemove'].forEach(function (ev) {
        return _this2.on(ev, function (e) {
          return self.emit(ev, e);
        });
      });

      self.globalX = 0;
      self.globalY = 0;

      this.on('mousemove', function (e) {
        if (document.pointerLockElement !== null) {
          self.globalX += e.movementX;
          self.globalY += e.movementY;

          self.update(e, self.globalX, self.globalY);
        } else self.update(e);
      });
    }

    /**
     * @method track
     * @description Starts tracking events on a component
     * @param {Component} component A component, that should be tracked by the mouse
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'track',
    value: function track(component) {
      var _this3 = this;

      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      var isHovered = false;

      this.on('move', function () {
        if (_this3.hovers(component, nested)) {
          if (isHovered) component.emit('mousemove');else {
            component.emit('mouseover');
            isHovered = true;
          }
        } else if (isHovered) {
          component.emit('mouseout');
          isHovered = false;
        }
      });

      this.on('click', function () {
        if (isHovered) component.emit('click');else component.emit('offClick');
      });

      this.on('mousedown', function () {
        if (isHovered) component.emit('mousedown');
      });

      this.on('mouseup', function () {
        if (isHovered) component.emit('mouseup');
      });
    }

    /**
     * @method intersection
     * @description Returns an intersection data
     * @param {Component} component A component that intersects with mouse ray (or doesn't)
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @return {Array} intersection data.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'intersection',
    value: function intersection(_ref) {
      var native = _ref.native;
      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (native.children.length > 0 && nested) {
        var objects = [];
        native.traverse(function (child) {
          return objects.push(child);
        });

        return this.raycaster.intersectObjects(objects);
      }

      return this.raycaster.intersectObject(native);
    }

    /**
     * @method project
     * @description Returns a vector based on mouse ray intersection with plane
     * @param {THREE.Plane} [plane=this.projectionPlane] Math plane that is used
     * @param {Vector3} [target] Optional target
     * @return {Vector3} An intersection point.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'project',
    value: function project() {
      var plane = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.projectionPlane;
      var target = arguments[1];

      return this.raycaster.ray.intersectPlane(plane, target);
    }

    /**
     * @method hovers
     * @description Returns a boolean based on intersection data (Whether mouse hovers the component)
     * @param {Component} component A component that intersects with mouse ray (or doesn't)
     * @param {Boolean} nested Whether component's children should be tracked or not
     * @return {Boolean} Whether the component is hovered.
     * @memberof module:modules/app.VirtualMouseModule
     */

  }, {
    key: 'hovers',
    value: function hovers(component) {
      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      return this.intersection(component, nested).length > 0;
    }

    /**
     * Mouse ray
     * @member {THREE.Ray} module:modules/app.VirtualMouseModule#ray
     * @public
     */

  }, {
    key: 'ray',
    get: function get$$1() {
      return this.raycaster.ray;
    }

    /**
     * Mouse x [-1; 1]
     * @member {Number} module:modules/app.VirtualMouseModule#x
     * @public
     */

  }, {
    key: 'x',
    get: function get$$1() {
      return this.mouse.x;
    }

    /**
     * Mouse y [-1; 1]
     * @member {Number} module:modules/app.VirtualMouseModule#y
     * @public
     */

  }, {
    key: 'y',
    get: function get$$1() {
      return this.mouse.y;
    }
  }]);
  return VirtualMouseModule;
}(minivents_commonjs);

/**
 * @class ControlsModule
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new ControlsModule.from(new THREE.TrackballControls())
 * ]);
 */

var ControlsModule = function () {
  createClass(ControlsModule, null, [{
    key: 'from',
    value: function from(controls) {
      return new ControlsModule({ controls: controls });
    }
  }]);

  function ControlsModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, ControlsModule);

    this.params = Object.assign({
      controls: false,
      fix: function fix(controls) {
        return controls;
      },

      update: function update(c) {
        this.controls.update(c.getDelta());
      }
    }, params);

    this.controls = this.params.controls;
    this.update = this.params.update;
  }

  createClass(ControlsModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('controls');
      _manager.require('events', function () {
        return new EventsPatchModule();
      });
    }

    /**
     * @method setControls
     * @description Set working controls
     * @param {Object} controls Working three.js controls object.
     * @return {this}
     * @memberof module:modules/app.ControlsModule
     */

  }, {
    key: 'setControls',
    value: function setControls(controls) {
      this.controls = controls;
      return this;
    }

    /**
     * @method setUpdate
     * @description Set controls update function
     * @param {Function} update Update function
     * @return {this}
     * @memberof module:modules/app.ControlsModule
     */

  }, {
    key: 'setUpdate',
    value: function setUpdate(update) {
      this.update = update;
      return this;
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.updateLoop = new Loop(self.update.bind(self));
      self.updateLoop.start(this);
    }
  }]);
  return ControlsModule;
}();

/**
 * @class FogModule
 * @category modules/app
 * @param {Object} [params={color: 0xefd1b5, density: 0.020, near: 10, far: 1000}] - The parameters object.
 * @param {String} [type=exp2] - The type of fog - exp2 or linear
 * @memberof module:modules/app
 * @example <caption>How to create and apply a FogModule</caption>
 * const fogModule = new FogModule({
 *    color: 0xffffff,
 *    density: 0.03,
 *    near: 20,
 *    far: 200
 *  }, 'exp2');
 *
 * new App([
 *  ...,
 *  fogModule
 * ]);
 */

var FogModule = function () {
  function FogModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var type = arguments[1];
    classCallCheck(this, FogModule);

    this.params = Object.assign({
      color: 0xefd1b5,
      density: 0.020,
      near: 10,
      far: 1000
    }, params);
    if (!type || type === 'exp2') this.fog = new FogExp2(this.params.color, this.params.density);else if (type === 'linear') this.fog = new Fog(this.params.color, this.params.near, this.params.far);
  }

  createClass(FogModule, [{
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('fog', this.fog);
      _manager.get('scene').fog = this.fog;
    }
  }]);
  return FogModule;
}();

var isEqualDefault = function isEqualDefault(a, b) {
  if (a === b) return true;else if (a && a.equals && a.equals(b)) return true;

  return false;
};

/**
 * @class StateModule
 * @description `StateModule` is useful for apps, where you need state manipulation.
 * This can be: _transitions between screens, games, development moments_.
 * You can check [basic/state](https://whs-dev.surge.sh/examples/?basic/state) example.
 * @category modules/app
 * @param {Object} [params]
 * @memberof module:modules/app
 * @example <caption> Creating a state module</caption>
 * new App([
 *   // ...
 *   new StateModule().default({
 *     sphereColor: 0xff0000
 *   })
 * ]);
 */

var StateModule = function () {
  createClass(StateModule, null, [{
    key: 'actionGenerate',
    value: function actionGenerate(isEqual) {
      return function () {
        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [{}, ''];
        var _ref = arguments[1];
        var key = _ref.key,
            data = _ref.data;

        if (isEqual(state[0][key], data)) return state;

        state[0][key] = data;
        state[1] = key;

        return state;
      };
    }
  }]);

  function StateModule() {
    var equalCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isEqualDefault;
    classCallCheck(this, StateModule);

    this.store = createStore(StateModule.actionGenerate(equalCheck));

    this.configuration = {};
    this.currentConfig = 'default';
    this.prevConfig = 'default';
  }

  /**
   * @method default
   * @description Add default configuration.
   * @param {Object} data Configuration setup
   * @memberof module:modules/app.StateModule
   * @example
   * new WHS.StateModule().default({
   *   sphereColor: UTILS.$colors.mesh,
   *   planeColor: 0x447F8B
   * })
   */


  createClass(StateModule, [{
    key: 'default',
    value: function _default(data) {
      this.config({ default: data });
      return this;
    }

    /**
     * @method setEqualCheck
     * @description Sets an equalCheck function
     * @param {Function} func function to generate equal check
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'setEqualCheck',
    value: function setEqualCheck(func) {
      this.store.replaceReducer(StateModule.actionGenerate(func));
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('state');
    }

    /**
     * @method config
     * @description Load configurations from object.
     * @param {Object} configs Configuration data
     * @memberof module:modules/app.StateModule
     * @example <caption> Adding `green` configuration</caption>
     * state.config({
     *   green: {
     *     sphereColor: 0x00ff00,
     *     planeColor: 0x00ff00
     *   }
     * });
     */

  }, {
    key: 'config',
    value: function config(configs) {
      for (var key in configs) {
        if (key) {
          this.configuration[key] = key === 'default' ? configs[key] : Object.assign({}, this.configuration.default, configs[key]);
        }
      }
    }

    /**
     * @method update
     * @description Load updates from object.
     * @param {Object} updates Updates data
     * @memberof module:modules/app.StateModule
     * @example <caption> Update callback for `sphereColor`</caption>
     * state.update({
     *   sphereColor: color => sphere.material.color.setHex(color)
     * });
     */

  }, {
    key: 'update',
    value: function update() {
      var _this = this;

      var updates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.store.subscribe(function () {
        var _store$getState = _this.store.getState(),
            _store$getState2 = slicedToArray(_store$getState, 2),
            data = _store$getState2[0],
            changedKey = _store$getState2[1];

        var callback = updates[changedKey];

        if (callback) callback(data[changedKey]);
      });
    }

    /**
     * @method to
     * @description Switch to configuration.
     * @param {String} configName Configuration name.
     * @memberof module:modules/app.StateModule
     * @example <caption> Changes configuration to `green`</caption>
     * state.to('green');
     */

  }, {
    key: 'to',
    value: function to(configName) {
      this.prevConfig = this.currentConfig;
      this.currentConfig = configName;

      var config = this.configuration[configName] ? this.configuration[configName] : this.configuration.default;

      this.set(config);
    }

    /**
     * @method set
     * @description Set current parameters.
     * @param {Object} data Configuration parameters.
     * @memberof module:modules/app.StateModule
     * @example
     * state.set({
     *   sphereColor: 0x00ff00
     * });
     */

  }, {
    key: 'set',
    value: function set$$1(data) {
      for (var key in data) {
        if (key) this.store.dispatch({ type: 'ADD', key: key, data: data[key] });
      }
    }

    /**
     * @method get
     * @description Return data of parameter.
     * @param {String} key Parameter name.
     * @memberof module:modules/app.StateModule
     * @example
     * state.get('sphereColor'); // 0x00ff00
     */

  }, {
    key: 'get',
    value: function get$$1(key) {
      return this.store.getState()[0][key];
    }

    /**
     * @method prev
     * @description Return `trueVal` if `config` match previous configuration, in other case - return `falseVal`.
     * @param {String} config Configuration name.
     * @param {Any} trueVal Value returned if condition is truthy.
     * @param {Any} falseVal Value returned if condition is falsy.
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'prev',
    value: function prev(config, trueVal, falseVal) {
      return this.prevConfig === config ? trueVal : falseVal;
    }

    /**
     * @method current
     * @description Return `trueVal` if `config` match current configuration, in other case - return `falseVal`.
     * @param {String} config Configuration name.
     * @param {Any} trueVal Value returned if condition is truthy.
     * @param {Any} falseVal Value returned if condition is falsy.
     * @memberof module:modules/app.StateModule
     */

  }, {
    key: 'current',
    value: function current(config, trueVal, falseVal) {
      return this.currentConfig === config ? trueVal : falseVal;
    }
  }]);
  return StateModule;
}();

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe

var ThreeOrbitControls = function (_EventDispatcher) {
  inherits(ThreeOrbitControls, _EventDispatcher);

  function ThreeOrbitControls(object, domElement, eventHandler) {
    classCallCheck(this, ThreeOrbitControls);

    var _this = possibleConstructorReturn(this, (ThreeOrbitControls.__proto__ || Object.getPrototypeOf(ThreeOrbitControls)).call(this));

    _this.object = object;

    _this.domElement = domElement === undefined ? document : domElement;
    _this.eventHandler = eventHandler;

    // Set to false to disable this control
    _this.enabled = true;

    // "target" sets the location of focus, where the object orbits around
    _this.target = new Vector3();

    // How far you can dolly in and out ( PerspectiveCamera only )
    _this.minDistance = 0;
    _this.maxDistance = Infinity;

    // How far you can zoom in and out ( OrthographicCamera only )
    _this.minZoom = 0;
    _this.maxZoom = Infinity;

    // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.
    _this.minPolarAngle = 0; // radians
    _this.maxPolarAngle = Math.PI; // radians

    // How far you can orbit horizontally, upper and lower limits.
    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
    _this.minAzimuthAngle = -Infinity; // radians
    _this.maxAzimuthAngle = Infinity; // radians

    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop
    _this.enableDamping = false;
    _this.dampingFactor = 0.25;

    // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming
    _this.enableZoom = true;
    _this.zoomSpeed = 1.0;

    // Set to false to disable rotating
    _this.enableRotate = true;
    _this.rotateSpeed = 1.0;

    // Set to false to disable panning
    _this.enablePan = true;
    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push

    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop
    _this.autoRotate = false;
    _this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

    // Set to false to disable use of the keys
    _this.enableKeys = true;

    // The four arrow keys
    _this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

    // Mouse buttons
    _this.mouseButtons = { ORBIT: MOUSE.LEFT, ZOOM: MOUSE.MIDDLE, PAN: MOUSE.RIGHT };

    // for reset
    _this.target0 = _this.target.clone();
    _this.position0 = _this.object.position.clone();
    _this.zoom0 = _this.object.zoom;

    //
    // public methods
    //

    _this.getPolarAngle = function () {
      return spherical.phi;
    };

    _this.getAzimuthalAngle = function () {
      return spherical.theta;
    };

    _this.reset = function () {
      _this.target.copy(_this.target0);
      _this.object.position.copy(_this.position0);
      _this.object.zoom = _this.zoom0;

      _this.object.updateProjectionMatrix();
      _this.dispatchEvent(changeEvent);

      _this.update();

      state = STATE.NONE;
    };

    // this method is exposed, but perhaps it would be better if we can make it private...
    _this.update = function () {
      var offset = new Vector3();

      // so camera.up is the orbit axis
      var quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
      var quatInverse = quat.clone().inverse();

      var lastPosition = new Vector3();
      var lastQuaternion = new Quaternion();

      return function () {
        var position = _this.object.position;

        offset.copy(position).sub(_this.target);

        // rotate offset to "y-axis-is-up" space
        offset.applyQuaternion(quat);

        // angle from z-axis around y-axis
        spherical.setFromVector3(offset);

        if (_this.autoRotate && state === STATE.NONE) rotateLeft(getAutoRotationAngle());

        spherical.theta += sphericalDelta.theta;
        spherical.phi += sphericalDelta.phi;

        // restrict theta to be between desired limits
        spherical.theta = Math.max(_this.minAzimuthAngle, Math.min(_this.maxAzimuthAngle, spherical.theta));

        // restrict phi to be between desired limits
        spherical.phi = Math.max(_this.minPolarAngle, Math.min(_this.maxPolarAngle, spherical.phi));

        spherical.makeSafe();

        spherical.radius *= scale;

        // restrict radius to be between desired limits
        spherical.radius = Math.max(_this.minDistance, Math.min(_this.maxDistance, spherical.radius));

        // move target to panned location
        _this.target.add(panOffset);

        offset.setFromSpherical(spherical);

        // rotate offset back to "camera-up-vector-is-up" space
        offset.applyQuaternion(quatInverse);

        position.copy(_this.target).add(offset);

        _this.object.lookAt(_this.target);

        if (_this.enableDamping === true) {
          sphericalDelta.theta *= 1 - _this.dampingFactor;
          sphericalDelta.phi *= 1 - _this.dampingFactor;
        } else sphericalDelta.set(0, 0, 0);

        scale = 1;
        panOffset.set(0, 0, 0);

        // update condition is:
        // min(camera displacement, camera rotation in radians)^2 > EPS
        // using small-angle approximation cos(x/2) = 1 - x^2 / 8

        if (zoomChanged || lastPosition.distanceToSquared(_this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(_this.object.quaternion)) > EPS) {
          _this.dispatchEvent(changeEvent);

          lastPosition.copy(_this.object.position);
          lastQuaternion.copy(_this.object.quaternion);
          zoomChanged = false;

          return true;
        }

        return false;
      }();
    };

    _this.dispose = function () {
      _this.domElement.removeEventListener('contextmenu', onContextMenu, false);
      _this.domElement.removeEventListener('mousedown', onMouseDown, false);
      _this.domElement.removeEventListener('wheel', onMouseWheel, false);

      _this.domElement.removeEventListener('touchstart', onTouchStart, false);
      _this.domElement.removeEventListener('touchend', onTouchEnd, false);
      _this.domElement.removeEventListener('touchmove', onTouchMove, false);

      document.removeEventListener('mousemove', onMouseMove, false);
      document.removeEventListener('mouseup', onMouseUp, false);

      window.removeEventListener('keydown', onKeyDown, false);

      // this.dispatchEvent( { type: 'dispose' } ); // should this be added here?
    };

    //
    // internals
    //

    var changeEvent = { type: 'change' };
    var startEvent = { type: 'start' };
    var endEvent = { type: 'end' };

    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };

    var state = STATE.NONE;

    var EPS = 0.000001;

    // current position in spherical coordinates
    var spherical = new Spherical();
    var sphericalDelta = new Spherical();

    var scale = 1;
    var panOffset = new Vector3();
    var zoomChanged = false;

    var rotateStart = new Vector2();
    var rotateEnd = new Vector2();
    var rotateDelta = new Vector2();

    var panStart = new Vector2();
    var panEnd = new Vector2();
    var panDelta = new Vector2();

    var dollyStart = new Vector2();
    var dollyEnd = new Vector2();
    var dollyDelta = new Vector2();

    var getAutoRotationAngle = function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * _this.autoRotateSpeed;
    };

    var getZoomScale = function getZoomScale() {
      return Math.pow(0.95, _this.zoomSpeed);
    };

    var rotateLeft = function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    };

    var rotateUp = function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    };

    var panLeft = function () {
      var v = new Vector3();

      return function (distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    }();

    var panUp = function () {
      var v = new Vector3();

      return function (distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    }();

    // deltaX and deltaY are in pixels; right and down are positive
    var pan = function () {
      var offset = new Vector3();

      return function (deltaX, deltaY) {
        var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

        if (_this.object instanceof PerspectiveCamera) {
          // perspective
          var position = _this.object.position;
          offset.copy(position).sub(_this.target);
          var targetDistance = offset.length();

          // half of the fov is center to top of screen
          targetDistance *= Math.tan(_this.object.fov / 2 * Math.PI / 180.0);

          // we actually don't use screenWidth, since perspective camera is fixed to screen height
          panLeft(2 * deltaX * targetDistance / element.clientHeight, _this.object.matrix);
          panUp(2 * deltaY * targetDistance / element.clientHeight, _this.object.matrix);
        } else if (_this.object instanceof OrthographicCamera) {
          // orthographic
          panLeft(deltaX * (_this.object.right - _this.object.left) / _this.object.zoom / element.clientWidth, _this.object.matrix);
          panUp(deltaY * (_this.object.top - _this.object.bottom) / _this.object.zoom / element.clientHeight, _this.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - pan disabled.');
          _this.enablePan = false;
        }
      };
    }();

    var dollyIn = function dollyIn(dollyScale) {
      if (_this.object instanceof PerspectiveCamera) scale /= dollyScale;else if (_this.object instanceof OrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom * dollyScale));
        _this.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    };

    var dollyOut = function dollyOut(dollyScale) {
      if (_this.object instanceof PerspectiveCamera) scale *= dollyScale;else if (_this.object instanceof OrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom / dollyScale));
        _this.object.updateProjectionMatrix();
        zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControlsModule.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    };

    //
    // event callbacks - update the object state
    //

    var handleMouseDownRotate = function handleMouseDownRotate(event) {
      // console.log( 'handleMouseDownRotate' );

      rotateStart.set(event.clientX, event.clientY);
    };

    var handleMouseDownDolly = function handleMouseDownDolly(event) {
      // console.log( 'handleMouseDownDolly' );

      dollyStart.set(event.clientX, event.clientY);
    };

    var handleMouseDownPan = function handleMouseDownPan(event) {
      // console.log( 'handleMouseDownPan' );

      panStart.set(event.clientX, event.clientY);
    };

    var handleMouseMoveRotate = function handleMouseMoveRotate(event) {
      // console.log( 'handleMouseMoveRotate' );

      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart);

      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      // rotating across whole screen goes 360 degrees around
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * _this.rotateSpeed);

      // rotating up and down along whole screen attempts to go 360, but limited to 180
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * _this.rotateSpeed);

      rotateStart.copy(rotateEnd);

      _this.update();
    };

    var handleMouseMoveDolly = function handleMouseMoveDolly(event) {
      // console.log( 'handleMouseMoveDolly' );

      dollyEnd.set(event.clientX, event.clientY);

      dollyDelta.subVectors(dollyEnd, dollyStart);

      if (dollyDelta.y > 0) dollyIn(getZoomScale());else if (dollyDelta.y < 0) dollyOut(getZoomScale());

      dollyStart.copy(dollyEnd);

      _this.update();
    };

    var handleMouseMovePan = function handleMouseMovePan(event) {
      // console.log( 'handleMouseMovePan' );

      panEnd.set(event.clientX, event.clientY);

      panDelta.subVectors(panEnd, panStart);

      pan(panDelta.x, panDelta.y);

      panStart.copy(panEnd);

      _this.update();
    };

    var handleMouseUp = function handleMouseUp(event) {
      // console.log( 'handleMouseUp' );
    };

    var handleMouseWheel = function handleMouseWheel(event) {
      // console.log( 'handleMouseWheel' );

      if (event.deltaY < 0) dollyOut(getZoomScale());else if (event.deltaY > 0) dollyIn(getZoomScale());

      _this.update();
    };

    var handleKeyDown = function handleKeyDown(event) {
      // console.log( 'handleKeyDown' );

      switch (event.keyCode) {
        case _this.keys.UP:
          pan(0, _this.keyPanSpeed);
          _this.update();
          break;

        case _this.keys.BOTTOM:
          pan(0, -_this.keyPanSpeed);
          _this.update();
          break;

        case _this.keys.LEFT:
          pan(_this.keyPanSpeed, 0);
          _this.update();
          break;

        case _this.keys.RIGHT:
          pan(-_this.keyPanSpeed, 0);
          _this.update();
          break;

      }
    };

    var handleTouchStartRotate = function handleTouchStartRotate(event) {
      // console.log( 'handleTouchStartRotate' );

      rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    };

    var handleTouchStartDolly = function handleTouchStartDolly(event) {
      // console.log( 'handleTouchStartDolly' );

      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;

      var distance = Math.sqrt(dx * dx + dy * dy);

      dollyStart.set(0, distance);
    };

    var handleTouchStartPan = function handleTouchStartPan(event) {
      // console.log( 'handleTouchStartPan' );

      panStart.set(event.touches[0].pageX, event.touches[0].pageY);
    };

    var handleTouchMoveRotate = function handleTouchMoveRotate(event) {
      // console.log( 'handleTouchMoveRotate' );

      rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      rotateDelta.subVectors(rotateEnd, rotateStart);

      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      // rotating across whole screen goes 360 degrees around
      rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * _this.rotateSpeed);

      // rotating up and down along whole screen attempts to go 360, but limited to 180
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * _this.rotateSpeed);

      rotateStart.copy(rotateEnd);

      _this.update();
    };

    var handleTouchMoveDolly = function handleTouchMoveDolly(event) {
      // console.log( 'handleTouchMoveDolly' );

      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;

      var distance = Math.sqrt(dx * dx + dy * dy);

      dollyEnd.set(0, distance);

      dollyDelta.subVectors(dollyEnd, dollyStart);

      if (dollyDelta.y > 0) dollyOut(getZoomScale());else if (dollyDelta.y < 0) dollyIn(getZoomScale());

      dollyStart.copy(dollyEnd);

      _this.update();
    };

    var handleTouchMovePan = function handleTouchMovePan(event) {
      // console.log( 'handleTouchMovePan' );

      panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

      panDelta.subVectors(panEnd, panStart);

      pan(panDelta.x, panDelta.y);

      panStart.copy(panEnd);

      _this.update();
    };

    var handleTouchEnd = function handleTouchEnd() {
      // console.log( 'handleTouchEnd' );
    };

    //
    // event handlers - FSM: listen for events and reset state
    //

    var onMouseDown = function onMouseDown(event) {
      if (_this.enabled === false) return;

      event.preventDefault();

      if (event.button === _this.mouseButtons.ORBIT) {
        if (_this.enableRotate === false) return;

        handleMouseDownRotate(event);

        state = STATE.ROTATE;
      } else if (event.button === _this.mouseButtons.ZOOM) {
        if (_this.enableZoom === false) return;

        handleMouseDownDolly(event);

        state = STATE.DOLLY;
      } else if (event.button === _this.mouseButtons.PAN) {
        if (_this.enablePan === false) return;

        handleMouseDownPan(event);

        state = STATE.PAN;
      }

      if (state !== STATE.NONE) {
        _this.eventHandler.on('mousemove', onMouseMove, false);
        _this.eventHandler.on('mouseup', onMouseUp, false);

        _this.dispatchEvent(startEvent);
      }
    };

    var onMouseMove = function onMouseMove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();

      if (state === STATE.ROTATE) {
        if (_this.enableRotate === false) return;

        handleMouseMoveRotate(event);
      } else if (state === STATE.DOLLY) {
        if (_this.enableZoom === false) return;

        handleMouseMoveDolly(event);
      } else if (state === STATE.PAN) {
        if (_this.enablePan === false) return;

        handleMouseMovePan(event);
      }
    };

    var onMouseUp = function onMouseUp(event) {
      if (_this.enabled === false) return;

      handleMouseUp(event);

      document.removeEventListener('mousemove', onMouseMove, false);
      document.removeEventListener('mouseup', onMouseUp, false);

      _this.dispatchEvent(endEvent);

      state = STATE.NONE;
    };

    var onMouseWheel = function onMouseWheel(event) {
      if (_this.enabled === false || _this.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;

      event.preventDefault();
      event.stopPropagation();

      handleMouseWheel(event);

      _this.dispatchEvent(startEvent); // not sure why these are here...
      _this.dispatchEvent(endEvent);
    };

    var onKeyDown = function onKeyDown(event) {
      if (_this.enabled === false || _this.enableKeys === false || _this.enablePan === false) return;

      handleKeyDown(event);
    };

    var onTouchStart = function onTouchStart(event) {
      if (_this.enabled === false) return;

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate

          if (_this.enableRotate === false) return;

          handleTouchStartRotate(event);

          state = STATE.TOUCH_ROTATE;

          break;

        case 2:
          // two-fingered touch: dolly

          if (_this.enableZoom === false) return;

          handleTouchStartDolly(event);

          state = STATE.TOUCH_DOLLY;

          break;

        case 3:
          // three-fingered touch: pan

          if (_this.enablePan === false) return;

          handleTouchStartPan(event);

          state = STATE.TOUCH_PAN;

          break;

        default:

          state = STATE.NONE;

      }

      if (state !== STATE.NONE) _this.dispatchEvent(startEvent);
    };

    var onTouchMove = function onTouchMove(event) {
      if (_this.enabled === false) return;

      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate

          if (_this.enableRotate === false) return;
          if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

          handleTouchMoveRotate(event);

          break;

        case 2:
          // two-fingered touch: dolly

          if (_this.enableZoom === false) return;
          if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

          handleTouchMoveDolly(event);

          break;

        case 3:
          // three-fingered touch: pan

          if (_this.enablePan === false) return;
          if (state !== STATE.TOUCH_PAN) return; // is this needed?...

          handleTouchMovePan(event);

          break;

        default:

          state = STATE.NONE;

      }
    };

    var onTouchEnd = function onTouchEnd(event) {
      if (_this.enabled === false) return;

      handleTouchEnd(event);

      _this.dispatchEvent(endEvent);

      state = STATE.NONE;
    };

    var onContextMenu = function onContextMenu(event) {
      event.preventDefault();
    };

    //

    _this.eventHandler.on('contextmenu', onContextMenu, false);

    _this.eventHandler.on('mousedown', onMouseDown, false);
    _this.eventHandler.on('wheel', onMouseWheel, false);

    _this.eventHandler.on('touchstart', onTouchStart, false);
    _this.eventHandler.on('touchend', onTouchEnd, false);
    _this.eventHandler.on('touchmove', onTouchMove, false);

    _this.eventHandler.on('keydown', onKeyDown, false);

    // force an update at start

    _this.update();
    return _this;
  }

  createClass(ThreeOrbitControls, [{
    key: 'center',
    get: function get$$1() {
      console.warn('OrbitControls: .center has been renamed to .target');
      return this.target;
    }
  }, {
    key: 'noZoom',
    get: function get$$1() {
      console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;
    }
  }, {
    key: 'noRotate',
    get: function get$$1() {
      console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;
    }
  }, {
    key: 'noPan',
    get: function get$$1() {
      console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;
    }
  }, {
    key: 'noKeys',
    get: function get$$1() {
      console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;
    }
  }, {
    key: 'staticMoving',
    get: function get$$1() {
      console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;
    }
  }, {
    key: 'dynamicDampingFactor',
    get: function get$$1() {
      console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;
    },
    set: function set$$1(value) {
      console.warn('OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;
    }
  }]);
  return ThreeOrbitControls;
}(EventDispatcher);

/**
 * @class OrbitControlsModule
 * @category modules/app
 * @param {Object} [params]
 * @param {Object} [params.object=camera] Object to which controls are applied.
 * @param {THREE.Vector3} [params.target=new Vector3()] Controls center vector.
 * @param {Boolean} [params.follow=false] Follow the target
 * @memberof module:modules/app
 * @example <caption> Creating a rendering module and passing it to App's modules</caption>
 * new App([
 *   new ElementModule(),
 *   new SceneModule(),
 *   new DefineModule('camera', new WHS.PerspectiveCamera({
 *     position: new THREE.Vector3(0, 6, 18),
 *     far: 10000
 *   })),
 *   new RenderingModule(),
 *   new OrbitControlsModule()
 * ]);
 */

var OrbitControlsModule = function (_ControlsModule) {
  inherits(OrbitControlsModule, _ControlsModule);

  function OrbitControlsModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, OrbitControlsModule);

    var _this = possibleConstructorReturn(this, (OrbitControlsModule.__proto__ || Object.getPrototypeOf(OrbitControlsModule)).call(this, params));

    _this.params = Object.assign({
      follow: false,
      object: null,
      target: new Vector3()
    }, params);
    return _this;
  }

  createClass(OrbitControlsModule, [{
    key: 'manager',
    value: function manager(_manager) {
      get(OrbitControlsModule.prototype.__proto__ || Object.getPrototypeOf(OrbitControlsModule.prototype), 'manager', this).call(this, _manager);

      var _params = this.params,
          obj = _params.object,
          follow = _params.follow,
          target = _params.target;

      var object = obj ? obj.native : _manager.get('camera').native;

      var controls = new ThreeOrbitControls(object, _manager.get('element'), _manager.handler);

      var updateProcessor = follow ? function (c) {
        controls.update(c.getDelta());
        controls.target.copy(target);
      } : function (c) {
        controls.update(c.getDelta());
      };

      this.setControls(controls);
      this.setUpdate(updateProcessor);

      _manager.update({
        camera: function camera(_camera) {
          if (obj) return;
          controls.object = _camera.native;
        },
        element: function element(_element) {
          controls.domElement = _element;
        }
      });

      controls.target.copy(target);
    }
  }]);
  return OrbitControlsModule;
}(ControlsModule);

/** @module modules/app/controls */

/** @module modules/app */

/**
 * @class DynamicGeometryModule
 * @category modules/mesh
 * @param {Object} [params={attributes: false}] - params
 * @param {Boolean} [patchEvents=true]
 * @memberof module:modules/mesh
 */
var DynamicGeometryModule = function () {
  function DynamicGeometryModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DynamicGeometryModule);

    this.params = Object.assign({
      attributes: false
    }, params);
  }

  createClass(DynamicGeometryModule, [{
    key: "integrate",
    value: function integrate(self) {
      var _this = this;

      var params = self.params;

      this.g_ = function () {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.buildGeometry) {
          this.native.geometry = this.buildGeometry(this.updateParams({ geometry: params }));
        }
      };

      if (params.attributes) {
        var _loop = function _loop(key) {
          if (key) {
            Object.defineProperty(_this, "g_" + key, {
              get: function get$$1() {
                return this.native.geometry.parameters[key];
              },
              set: function set$$1(value) {
                this.native.geometry = this.buildGeometry(this.updateParams({ geometry: defineProperty({}, key, value) }));
              },

              configurable: true,
              enumerable: true
            });
          }
        };

        for (var key in this.params.geometry) {
          _loop(key);
        }
      }
    }
  }]);
  return DynamicGeometryModule;
}();

var loader = new TextureLoader();

/**
 * @class TextureModule
 * @category modules/mesh
 * @description A TextureModule can be applied to any Mesh or Model.
 * @param {Array} [textures] - array of texture objects
 * @memberof module:modules/mesh
 * @example <caption>Creating an instance. url takes a path, or a data object.</caption>
 * var woodTexture = new TextureModule({
 *   url: `${process.assetsPath}/textures/wood.jpg`
 * });
 * @example <caption>More comprehensive example, wood texture applied to a Box.</caption>
 * new Box({
 *   geometry: {
 *     width: 2,
 *     height: 2,
 *     depth: 2
 *   },
 *   modules: [
 *     new TextureModule({
 *       url: `path/to/texture.jpg`,
 *       repeat: new THREE.Vector2(1, 1) // optional
 *     })
 *   ],
 *   material: new THREE.MeshBasicMaterial({
 *     color: 0xffffff
 *   }),
 *   position: [50, 60, 70]
 * }).addTo(app);
 */
var TextureModule = function () {
  createClass(TextureModule, null, [{
    key: 'load',
    value: function load(url) {
      return new TextureModule({ url: url }).textures[0][1];
    }
  }]);

  function TextureModule() {
    var _this = this;

    classCallCheck(this, TextureModule);
    this.textures = [];
    this.bridge = {
      material: function material(_material, self) {
        self.textures.forEach(function (texture) {
          _material[texture[0]] = texture[1];
        });

        _material.needsUpdate = true;
        return _material;
      }
    };

    for (var _len = arguments.length, textures = Array(_len), _key = 0; _key < _len; _key++) {
      textures[_key] = arguments[_key];
    }

    textures.forEach(function (_ref) {
      var url = _ref.url,
          _ref$type = _ref.type,
          type = _ref$type === undefined ? 'map' : _ref$type,
          _ref$offset = _ref.offset,
          offset = _ref$offset === undefined ? new Vector2(0, 0) : _ref$offset,
          _ref$repeat = _ref.repeat,
          repeat = _ref$repeat === undefined ? new Vector2(1, 1) : _ref$repeat,
          _ref$wrap = _ref.wrap,
          wrap = _ref$wrap === undefined ? RepeatWrapping : _ref$wrap,
          _ref$mapping = _ref.mapping,
          mapping = _ref$mapping === undefined ? UVMapping : _ref$mapping,
          _ref$fix = _ref.fix,
          fix = _ref$fix === undefined ? function (tex) {
        return tex;
      } : _ref$fix;

      var texture = loader.load(url);

      if (wrap.length > 0) {
        texture.wrapS = wrap[0];
        texture.wrapT = wrap[1];
      } else texture.wrapS = texture.wrapT = wrap;

      texture.mapping = mapping;

      texture.offset.copy(offset);
      texture.repeat.copy(repeat);

      texture.magFilter = NearestFilter;
      texture.minFilter = LinearMipMapLinearFilter;

      _this.textures.push([type, fix(texture)]);
    });
  }

  return TextureModule;
}();

/**
 * @class AnimationModule
 * @category modules/mesh
 * @description Convenience module that wraps the <a href='https://threejs.org/docs/#manual/introduction/Animation-system'>three.js animation system</a>
 * @param {App} app - the app
 * @param {Boolean} [isDeferred=false] - set to true if animation should not start automatically
 * @param {Object} [params={speed: 1}] - the params
 * @memberof module:modules/mesh
 * @example <caption>Create animation module and play a given clip of an imported model</caption>
 * const animationModule = new AnimationModule(app, false, {
 *   speed: 1.2 // speed up animation by 20%
 * });
 *
 * new Importer({
 *   parser(geometry, materials) {
 *     // Override parse to generate a skinnedMesh, needed for skinned models
 *     return new THREE.SkinnedMesh(geometry, materials);
 *   },
 *
 *   url: `path/to/model.json`,
 *   useCustomMaterial: true,
 *
 *   material: new THREE.MeshStandardMaterial({
 *     skinning: true
 *   }),
 *
 *   modules: [animationModule]
 * }).addTo(app).then(() => {
 *   // adding model to app returns a promise, so pipe the function to kick off the animation clip
 *   animationModule.play('clipName');
 * });
 */

var AnimationModule = function () {
  function AnimationModule(app, isDeferred) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, AnimationModule);
    this.bridge = {
      mesh: function mesh(_mesh, self) {
        _mesh.geometry.skeleton = _mesh.skeleton;

        self.mixer = new AnimationMixer(_mesh.geometry);
        self.clips = _mesh.geometry.animations;

        return _mesh;
      }
    };

    this.params = Object.assign({
      speed: 1
    }, params);
    this.clock = new Clock();

    this.app = app;
    this.isDeferred = isDeferred;
  }

  /**
   * @method play
   * @instance
   * @description Plays the given clip name
   * @param {String} clipName - the clip to play
   * @memberof module:modules/mesh.AnimationModule
   */


  createClass(AnimationModule, [{
    key: 'play',
    value: function play(clipName) {
      var clip = AnimationClip.findByName(this.clips, clipName);
      var action = this.mixer.clipAction(clip);

      action.play();
    }

    /**
     * @method update
     * @instance
     * @description Update the mixer (being called on frame animation loop)
     * @memberof module:modules/mesh.AnimationModule
     */

  }, {
    key: 'update',
    value: function update() {
      if (this.mixer) this.mixer.update(this.clock.getDelta() * this.params.speed);
    }
  }, {
    key: 'integrate',
    value: function integrate(self) {
      self.loop = new Loop(function () {
        self.update();
      });

      if (!self.isDeferred) self.loop.start(self.app);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.define('animation');
    }
  }]);
  return AnimationModule;
}();

/** @module modules/mesh */

/**
 * @class DefineModule
 * @category modules
 * @param {String} name
 * @param {Object} data
 * @memberof module:modules
 * @example <caption> Creating a DefineModule with PerspectiveCamera as camera module and passing it to App's modules</caption>
 * new App([
 *   // ...
 *   new DefineModule('camera', new PerspectiveCamera())
 * ]);
 */
var DefineModule = function () {
  function DefineModule(name, data) {
    classCallCheck(this, DefineModule);

    this.name = name;
    this.data = data;
  }

  createClass(DefineModule, [{
    key: "manager",
    value: function manager(_manager) {
      _manager.set(this.name, this.data);
    }
  }]);
  return DefineModule;
}();

/** @module modules */

var Model = function (_Importer) {
  inherits(Model, _Importer);

  function Model(params) {
    var _ref;

    classCallCheck(this, Model);

    console.warn('Model is deprecated. Use Importer instead.');

    if (params.geometry) {
      params.url = params.geometry.path;
      params.loader = params.geometry.loader;
    }

    for (var _len = arguments.length, additional = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      additional[_key - 1] = arguments[_key];
    }

    return possibleConstructorReturn(this, (_ref = Model.__proto__ || Object.getPrototypeOf(Model)).call.apply(_ref, [this, params].concat(additional)));
  }

  return Model;
}(Importer);

var CameraModule = function () {
  function CameraModule() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, CameraModule);

    console.warn('CameraModule is deprecated. Use DefineModule instead.');
    this.camera = new PerspectiveCamera$1(params);
  }

  createClass(CameraModule, [{
    key: 'integrate',
    value: function integrate(self) {
      this.add(self.camera);
    }
  }, {
    key: 'manager',
    value: function manager(_manager) {
      _manager.set('camera', this.camera);
    }
  }]);
  return CameraModule;
}();

/**
 * Namespace containing all classes from all modules. Used as global in UMD pattern.
 * @namespace WHS
 * @example <caption>The use of WHS namespace.</caption>
 * new WHS.App() // core
 * new WHS.PerspectiveCamera() // components
 * new WHS.ResizeModule() // modules
 * WHS.extend() // utils
 */

export { Component, MeshComponent, LightComponent, CameraComponent, App, Loop, ModuleManager, AmbientLight$1 as AmbientLight, DirectionalLight$1 as DirectionalLight, HemisphereLight$1 as HemisphereLight, PointLight$1 as PointLight, SpotLight$1 as SpotLight, AreaLight, CubeCamera$1 as CubeCamera, OrthographicCamera$1 as OrthographicCamera, PerspectiveCamera$1 as PerspectiveCamera, Box, Circle, Cone, Cylinder, Dodecahedron, Extrude, Icosahedron, Lathe, Line$1 as Line, Importer, Octahedron, Parametric, Plane$1 as Plane, Polyhedron, Ring, Shape, Sphere, Tetrahedron, Text, Torus, Torusknot, Tube, Group, extend, instruct, transformData, toArray, ElementModule, RenderingModule, SceneModule, ResizeModule, PostProcessorModule, VirtualMouseModule, EventsPatchModule, ControlsModule, FogModule, StateModule, OrbitControlsModule, DynamicGeometryModule, TextureModule, AnimationModule, DefineModule, Model, CameraModule };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2hzLm1vZHVsZS5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3V0aWxzL2V4dGVuZC5qcyIsIi4uL3NyYy91dGlscy90cmFuc2Zvcm1EYXRhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL21pbml2ZW50cy9kaXN0L21pbml2ZW50cy5jb21tb25qcy5qcyIsIi4uL3NyYy9jb3JlL2Vycm9ycy5qcyIsIi4uL3NyYy9jb3JlL01vZHVsZVN5c3RlbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL3BvbnlmaWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NyZWF0ZVN0b3JlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY29tcG9zZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9pbmRleC5qcyIsIi4uL3NyYy9jb3JlL01vZHVsZU1hbmFnZXIuanMiLCIuLi9zcmMvY29yZS9Db21wb25lbnQuanMiLCIuLi9zcmMvY29yZS9wcm90b3R5cGUvYXR0cmlidXRlcy5qcyIsIi4uL3NyYy9jb3JlL01lc2hDb21wb25lbnQuanMiLCIuLi9zcmMvY29yZS9MaWdodENvbXBvbmVudC5qcyIsIi4uL3NyYy9jb3JlL0NhbWVyYUNvbXBvbmVudC5qcyIsIi4uL3NyYy9wb2x5ZmlsbC5qcyIsIi4uL3NyYy9jb3JlL0FwcC5qcyIsIi4uL3NyYy9jb3JlL0xvb3AuanMiLCIuLi9zcmMvY29yZS9pbmRleC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9BbWJpZW50TGlnaHQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9saWdodHMvUG9pbnRMaWdodC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL2xpZ2h0cy9TcG90TGlnaHQuanMiLCIuLi9zcmMvY29tcG9uZW50cy9saWdodHMvQXJlYUxpZ2h0LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbGlnaHRzL2luZGV4LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvY2FtZXJhcy9DdWJlQ2FtZXJhLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvY2FtZXJhcy9PcnRob2dyYXBoaWNDYW1lcmEuanMiLCIuLi9zcmMvY29tcG9uZW50cy9jYW1lcmFzL1BlcnNwZWN0aXZlQ2FtZXJhLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvY2FtZXJhcy9pbmRleC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9Cb3guanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvQ2lyY2xlLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL0NvbmUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvQ3lsaW5kZXIuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvRG9kZWNhaGVkcm9uLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL0V4dHJ1ZGUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvSWNvc2FoZWRyb24uanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvTGF0aGUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvTGluZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9JbXBvcnRlci5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9PY3RhaGVkcm9uLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1BhcmFtZXRyaWMuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvUGxhbmUuanMiLCIuLi9zcmMvY29tcG9uZW50cy9tZXNoZXMvUG9seWhlZHJvbi5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9SaW5nLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1NoYXBlLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1NwaGVyZS5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9UZXRyYWhlZHJvbi5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9UZXh0LmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1RvcnVzLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL1RvcnVza25vdC5qcyIsIi4uL3NyYy9jb21wb25lbnRzL21lc2hlcy9UdWJlLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL0dyb3VwLmpzIiwiLi4vc3JjL2NvbXBvbmVudHMvbWVzaGVzL2luZGV4LmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL0VsZW1lbnRNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvUmVuZGVyaW5nTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL1NjZW5lTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL1Jlc2l6ZU1vZHVsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0FkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQm9rZWhNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0Jva2VoMk1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQ29tYmluZU1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvQ29udm9sdXRpb25NYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0NvcHlNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0RlcHRoTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Eb3RTY3JlZW5NYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0ZpbG1NYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL0dsaXRjaE1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvR29kUmF5c01hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvTHVtaW5vc2l0eU1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvUGl4ZWxhdGlvbk1hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvU2hvY2tXYXZlTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9TTUFBQmxlbmRNYXRlcmlhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL1NNQUFDb2xvckVkZ2VzTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9pbWFnZXMvc21hYS9hcmVhSW1hZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9pbWFnZXMvc21hYS9zZWFyY2hJbWFnZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvbWF0ZXJpYWxzL1NNQUFXZWlnaHRzTWF0ZXJpYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL21hdGVyaWFscy9Ub25lTWFwcGluZ01hdGVyaWFsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9tYXRlcmlhbHMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9QYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvQmx1clBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9CbG9vbVBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9Cb2tlaFBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9Cb2tlaDJQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvQ2xlYXJNYXNrUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0NsZWFyUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0RvdFNjcmVlblBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9EZXB0aFBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9GaWxtUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL0dsaXRjaFBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9SZW5kZXJQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvR29kUmF5c1Bhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9NYXNrUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1BpeGVsYXRpb25QYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvU2F2ZVBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9TaGFkZXJQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvU2hvY2tXYXZlUGFzcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvcGFzc2VzL1NNQUFQYXNzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3Bvc3Rwcm9jZXNzaW5nL3NyYy9wYXNzZXMvVGV4dHVyZVBhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9Ub25lTWFwcGluZ1Bhc3MuanMiLCIuLi9ub2RlX21vZHVsZXMvcG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wb3N0cHJvY2Vzc2luZy9zcmMvY29yZS9FZmZlY3RDb21wb3Nlci5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9Qb3N0UHJvY2Vzc29yTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL0V2ZW50c1BhdGNoTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL1ZpcnR1YWxNb3VzZU1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9Db250cm9sc01vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9Gb2dNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvU3RhdGVNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9hcHAvY29udHJvbHMvbGliL1RocmVlT3JiaXRDb250cm9scy5qcyIsIi4uL3NyYy9tb2R1bGVzL2FwcC9jb250cm9scy9PcmJpdENvbnRyb2xzTW9kdWxlLmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL2NvbnRyb2xzL2luZGV4LmpzIiwiLi4vc3JjL21vZHVsZXMvYXBwL2luZGV4LmpzIiwiLi4vc3JjL21vZHVsZXMvbWVzaC9EeW5hbWljR2VvbWV0cnlNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9tZXNoL1RleHR1cmVNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9tZXNoL0FuaW1hdGlvbk1vZHVsZS5qcyIsIi4uL3NyYy9tb2R1bGVzL21lc2gvaW5kZXguanMiLCIuLi9zcmMvbW9kdWxlcy9EZWZpbmVNb2R1bGUuanMiLCIuLi9zcmMvbW9kdWxlcy9pbmRleC5qcyIsIi4uL3NyYy9kZXByZWNhdGlvbi5qcyIsIi4uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZXh0ZW5kID0gKG9iamVjdCwgLi4uZXh0ZW5zaW9ucykgPT4geyAvLyAkLmV4dGVuZCBhbHRlcm5hdGl2ZSwgLi4uIGlzIHRoZSBzcHJlYWQgb3BlcmF0b3IuXG4gIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhleHRlbnNpb24pO1xuICAgIC8vIGNvbnNvbGUubG9nKHR5cGVvZiBleHRlbnNpb24pO1xuXG4gICAgaWYgKCFleHRlbnNpb24pXG4gICAgICBjb250aW51ZTsgLy8gSWdub3JlIG51bGwgYW5kIHVuZGVmaW5lZCBvYmplY3RzIGFuZCBwYXJhbWV0ZXJzLlxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGV4dGVuc2lvbikpIHsgLy8gRG8gbm90IHRyYXZlcnNlIHRoZSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICBpZiAob2JqZWN0W3Byb3BdICE9PSB1bmRlZmluZWQgJiYgZXh0ZW5zaW9uW3Byb3BdXG4gICAgICAgICYmIG9iamVjdFtwcm9wXS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICAmJiBleHRlbnNpb25bcHJvcF0udG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgLy8gR29lcyBkZWVwIG9ubHkgaWYgb2JqZWN0W3Byb3BdIGFuZCBleHRlbnNpb25bcHJvcF0gYXJlIGJvdGggb2JqZWN0cyAhXG4gICAgICAgIGlmIChvYmplY3RbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkgZXh0ZW5kKG9iamVjdFtwcm9wXSwgZXh0ZW5zaW9uW3Byb3BdKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBvYmplY3RbcHJvcF0gPSB0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAndW5kZWZpbmVkJyA/IGV4dGVuc2lvbltwcm9wXSA6IG9iamVjdFtwcm9wXTtcblxuICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uW3Byb3BdKSkgb2JqZWN0W3Byb3BdID0gZXh0ZW5zaW9uW3Byb3BdLnNsaWNlKCk7IC8vIEFkZCB2YWx1ZXMgdGhhdCBkbyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uW3Byb3BdKSkgb2JqZWN0W3Byb3BdID0gZXh0ZW5zaW9uW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiZXhwb3J0IGNvbnN0IGluc3RydWN0ID0gKGFycmF5LCBpbnN0QXJyYXkpID0+IHtcbiAgY29uc3QgdGVtcE9iamVjdCA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbnN0QXJyYXkubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICBjb25zdCBndWlkZSA9IGluc3RBcnJheVtpXTtcblxuICAgIHRlbXBPYmplY3RbZ3VpZGVdID0gYXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gdGVtcE9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1EYXRhID0gKG9iamVjdCwgaW5zdHJ1Y3Rpb25zKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIGluc3RydWN0aW9ucykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFtrZXldKSlcbiAgICAgIG9iamVjdFtrZXldID0gaW5zdHJ1Y3Qob2JqZWN0W2tleV0sIGluc3RydWN0aW9uc1trZXldKTtcbiAgICBlbHNlIGlmIChvYmplY3Rba2V5XSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKEFycmF5LmlzQXJyYXkoaW5zdHJ1Y3Rpb25zW2tleV0pKSlcbiAgICAgIG9iamVjdFtrZXldID0gdHJhbnNmb3JtRGF0YShvYmplY3Rba2V5XSwgaW5zdHJ1Y3Rpb25zW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKG9iamVjdCwgaW5zdHJ1Y3Rpb24pID0+IHtcbiAgY29uc3QgdGVtcEFycmF5ID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGluc3RydWN0aW9uLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgY29uc3QgZ3VpZGUgPSBpbnN0cnVjdGlvbltpXTtcblxuICAgIHRlbXBBcnJheVtpXSA9IG9iamVjdFtndWlkZV07XG4gIH1cblxuICByZXR1cm4gdGVtcEFycmF5O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRXZlbnRzKHRhcmdldCl7XG4gIHZhciBldmVudHMgPSB7fSwgZW1wdHkgPSBbXTtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXNcbiAgLyoqXG4gICAqICBPbjogbGlzdGVuIHRvIGV2ZW50c1xuICAgKi9cbiAgdGFyZ2V0Lm9uID0gZnVuY3Rpb24odHlwZSwgZnVuYywgY3R4KXtcbiAgICAoZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdKS5wdXNoKFtmdW5jLCBjdHhdKVxuICB9XG4gIC8qKlxuICAgKiAgT2ZmOiBzdG9wIGxpc3RlbmluZyB0byBldmVudCAvIHNwZWNpZmljIGNhbGxiYWNrXG4gICAqL1xuICB0YXJnZXQub2ZmID0gZnVuY3Rpb24odHlwZSwgZnVuYyl7XG4gICAgdHlwZSB8fCAoZXZlbnRzID0ge30pXG4gICAgdmFyIGxpc3QgPSBldmVudHNbdHlwZV0gfHwgZW1wdHksXG4gICAgICAgIGkgPSBsaXN0Lmxlbmd0aCA9IGZ1bmMgPyBsaXN0Lmxlbmd0aCA6IDA7XG4gICAgd2hpbGUoaS0tKSBmdW5jID09IGxpc3RbaV1bMF0gJiYgbGlzdC5zcGxpY2UoaSwxKVxuICB9XG4gIC8qKiBcbiAgICogRW1pdDogc2VuZCBldmVudCwgY2FsbGJhY2tzIHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAqL1xuICB0YXJnZXQuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICAgIHZhciBlID0gZXZlbnRzW3R5cGVdIHx8IGVtcHR5LCBsaXN0ID0gZS5sZW5ndGggPiAwID8gZS5zbGljZSgwLCBlLmxlbmd0aCkgOiBlLCBpPTAsIGo7XG4gICAgd2hpbGUoaj1saXN0W2krK10pIGpbMF0uYXBwbHkoalsxXSwgZW1wdHkuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICB9O1xufTsiLCJleHBvcnQgY2xhc3MgQ29tcG9zaXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY2xhc3NJbnN0YW5jZSwgbWVzc2FnZSwgY29tcG9uZW50KSB7XG4gICAgc3VwZXIoYEAke2NsYXNzSW5zdGFuY2V9OiAke21lc3NhZ2V9YCk7XG5cbiAgICBjb25zdCBzdGFja0FycmF5ID0gdGhpcy5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3RhY2tBcnJheS5zcGxpY2UoMSwgMik7XG5cbiAgICB0aGlzLnN0YWNrID0gc3RhY2tBcnJheS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChjb25zb2xlKSBjb25zb2xlLmVycm9yKCdDb21wb25lbnQ6JywgY29tcG9uZW50KTtcblxuICAgIHRoaXMubmFtZSA9ICdDb21wb3NpdGlvbkVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjbGFzc0luc3RhbmNlLCBtZXNzYWdlLCBhY3RpdmVNb2R1bGUsIGRlcGVuZGVuY3lNb2R1bGUgPSBmYWxzZSkge1xuICAgIHN1cGVyKGBAJHtjbGFzc0luc3RhbmNlfTogJHttZXNzYWdlfWApO1xuXG4gICAgY29uc3Qgc3RhY2tBcnJheSA9IHRoaXMuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIHN0YWNrQXJyYXkuc3BsaWNlKDEsIDIpO1xuXG4gICAgdGhpcy5zdGFjayA9IHN0YWNrQXJyYXkuam9pbignXFxuJyk7XG5cbiAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcignQWN0aXZlIG1vZHVsZTonLCBhY3RpdmVNb2R1bGUpO1xuICAgIGlmIChjb25zb2xlICYmIGRlcGVuZGVuY3lNb2R1bGUpIGNvbnNvbGUuZXJyb3IoJ0RlcGVuZGVuY3kgcHVibGlzaGVkIGJ5IG1vZHVsZTonLCBkZXBlbmRlbmN5TW9kdWxlKTtcblxuICAgIHRoaXMubmFtZSA9ICdEZXBlbmRlbmN5RXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYW5hZ2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzSW5zdGFuY2UsIG1lc3NhZ2UsIGNvbXBvbmVudCwgYWN0aXZlTW9kdWxlID0gZmFsc2UpIHtcbiAgICBzdXBlcihgQCR7Y2xhc3NJbnN0YW5jZX06ICR7bWVzc2FnZX1gKTtcblxuICAgIGNvbnN0IHN0YWNrQXJyYXkgPSB0aGlzLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICBzdGFja0FycmF5LnNwbGljZSgxLCAyKTtcblxuICAgIHRoaXMuc3RhY2sgPSBzdGFja0FycmF5LmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ0NvbXBvbmVudDonLCBjb21wb25lbnQpO1xuICAgIGlmIChjb25zb2xlICYmIGFjdGl2ZU1vZHVsZSkgY29uc29sZS5lcnJvcignQWN0aXZlIG1vZHVsZTonLCBhY3RpdmVNb2R1bGUpO1xuXG4gICAgdGhpcy5uYW1lID0gJ01hbmFnZXJFcnJvcic7XG4gIH1cbn1cbiIsImltcG9ydCB7UkVWSVNJT059IGZyb20gJ3RocmVlJztcbmltcG9ydCBFdmVudHMgZnJvbSAnbWluaXZlbnRzJztcbmltcG9ydCB7TWFuYWdlckVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8vIENoZWNrIGZvciBUaHJlZS5qc1xuY29uc3Qgd2FybkRlcHMgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignV2hpdGVzdG9ybUpTIEZyYW1ld29yayByZXF1aXJlcyBUaHJlZS5qcyByODQuIGh0dHBzOi8vdGhyZWVqcy5vcmcvJyk7XG59O1xuXG50cnkge1xuICBpZiAoIVJFVklTSU9OKSB3YXJuRGVwcygpO1xufSBjYXRjaCAoZXJyKSB7XG4gIHdhcm5EZXBzKCk7XG59XG5cbi8qKlxuICogQGNsYXNzIE1vZHVsZVN5c3RlbVxuICogQGNhdGVnb3J5IGNvcmVcbiAqIEBkZXNjcmlwdGlvbiAgUHJvdmlkZXMgQVBJIGZvciBjbGFzc2VzIHRoYXQgd2lsbCB1c2UgTW9kdWxlcy48YnIvPlxuICogVGhpcyBjbGFzcyBpbmNsdWRlcyBiYXNpYyBldmVudCBzeXN0ZW0gd2l0aCB0aG9zZSBzdXBwb3J0ZWQgbWV0aG9kczpcbiAqIDxwcmU+Lm9uKCk8L3ByZT48cHJlPi5vZmYoKTwvcHJlPjxwcmU+LmVtaXQoKTwvcHJlPlxuICogQGV4dGVuZHMgRXZlbnRzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuZXhwb3J0IGNsYXNzIE1vZHVsZVN5c3RlbSBleHRlbmRzIEV2ZW50cyB7XG4gIC8vIElOVEVHUkFUSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW50ZWdyYXRlTW9kdWxlc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgbWV0aG9kIGFwcGxpZXMgYWxsIG1vZHVsZXMgZnJvbSAubW9kdWxlcyBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3NvdXJjZV0gSWYgc291cmNlIChzaG91bGQgYmUgYSBjb21wb25lbnQpIGlzIHByb3ZpZGVkLCB3aWxsIHJlcGxhY2UgLm1vZHVsZXMgd2l0aCBzb3VyY2UncyBvbmUgYmVmb3JlIGV4ZWN1dGluZyBtb2R1bGVzLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBpbnRlZ3JhdGVNb2R1bGVzKHNvdXJjZSkge1xuICAgIGlmICghdGhpcy5tb2R1bGVzICYmICFzb3VyY2UpIHJldHVybjtcbiAgICBpZiAoc291cmNlICYmIHNvdXJjZS5tb2R1bGVzKSB0aGlzLm1vZHVsZXMgPSBzb3VyY2UubW9kdWxlcy5zbGljZSgwKTtcblxuICAgIGlmICh0aGlzLm1vZHVsZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBtYXggPSB0aGlzLm1vZHVsZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspXG4gICAgICAgIHRoaXMuYXBwbHlNb2R1bGUodGhpcy5tb2R1bGVzW2ldLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSkgdGhpcy5hcHBseUJyaWRnZSh7b25Db3B5OiBzb3VyY2V9KTtcbiAgfVxuXG4gIC8vIEFQUExZSU5HIE1PRFVMRSAoLi4uYW5kIGEgXCJicmlkZ2VcIiBmb3IgbW9kdWxlKVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFwcGx5QnJpZGdlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gTWFrZXMgY29tcG9uZW50LXNwZWNpZmljIEFQSSB0byB3b3JrIHdpdGggbW9kdWxlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGJyaWRnZU1hcFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggbW9kaWZpZWQgdmFsdWVzLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBhcHBseUJyaWRnZShicmlkZ2VNYXAgPSB7fSkge1xuICAgIGNvbnN0IG1vZHVsZXMgPSB0aGlzLm1vZHVsZXM7XG4gICAgaWYgKCFtb2R1bGVzKSByZXR1cm4gYnJpZGdlTWFwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGJyaWRnZU1hcCkge1xuICAgICAgICBpZiAoYnJpZGdlTWFwW2tleV0pIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAgICAgaWYgKG1vZHVsZSAmJiBtb2R1bGUuYnJpZGdlICYmIG1vZHVsZS5icmlkZ2Vba2V5XSlcbiAgICAgICAgICAgIGJyaWRnZU1hcFtrZXldID0gbW9kdWxlLmJyaWRnZVtrZXldLmFwcGx5KHRoaXMsIFticmlkZ2VNYXBba2V5XSwgbW9kdWxlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnJpZGdlTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYXBwbHlDb21tYW5kXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gLmFwcGx5Q29tbWFuZCBydW5zIGEgbWV0aG9kIGNhbGxlZCBgbmFtZWAgb24gYWxsIG1vZHVsZXMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBtZXRob2QgbmFtZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiPShmdW5jLCBtb2R1bGVTY29wZSkgPT4gZnVuYy5hcHBseSh0aGlzLCBbbW9kdWxlU2NvcGVdKV0gSG93IHRoZSBmdW5jdGlvbiBpcyB3cmFwcGVkL1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBhcHBseUNvbW1hbmQobmFtZSwgY2IgPSAoZnVuYywgbW9kdWxlU2NvcGUpID0+IGZ1bmMuYXBwbHkodGhpcywgW21vZHVsZVNjb3BlXSkpIHtcbiAgICBjb25zdCBtb2R1bGVzID0gdGhpcy5tb2R1bGVzO1xuICAgIGlmICghbW9kdWxlcykgcmV0dXJuO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IG1vZHVsZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICBpZiAobmFtZSBpbiBtb2R1bGUpIGNiKG1vZHVsZVtuYW1lXSwgbW9kdWxlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhcHBseU1vZHVsZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIC5hcHBseU1vZHVsZSBpcyBhbHNvIHVzZWQgaW4gLmludGVncmF0ZU1vZHVsZXMoKSBmdW5jdGlvbi5cbiAgICogSXQgZG9lcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgc2F5cyAoYXBwbGllcyBtb2R1bGUgdG8gY29tcG9uZW50IG9yIGFwcCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIG1vZHVsZSB0byBhcHBseVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwdXNoPXRydWVdXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBtb2R1bGUgdGhhdCB3YXMgYXBwbGllZC5cbiAgICogQHRocm93cyB7TWFuYWdlckVycm9yfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlU3lzdGVtXG4gICAqL1xuICBhcHBseU1vZHVsZShtb2R1bGUsIHB1c2ggPSB0cnVlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHJldHVybjtcbiAgICBpZiAocHVzaCAmJiB0aGlzLm1vZHVsZXMpIHRoaXMubW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgZWxzZSBpZiAocHVzaCkgdGhpcy5tb2R1bGVzID0gW21vZHVsZV07XG5cbiAgICBpZiAodGhpcy5tYW5hZ2VyKSB0aGlzLm1hbmFnZXIuYWN0aXZlKG1vZHVsZSk7XG5cbiAgICBpZiAobW9kdWxlLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyKSBtb2R1bGUubWFuYWdlcih0aGlzLm1hbmFnZXIpO1xuICAgIGVsc2UgaWYgKG1vZHVsZS5tYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgTWFuYWdlckVycm9yKFxuICAgICAgICAnQ29tcG9uZW50JyxcbiAgICAgICAgYE1vZHVsZSByZXF1aXJlcyBNb2R1bGVNYW5hZ2VyIHRoYXQgaXMgdHVybmVkIG9mZiBmb3IgdGhpcyBjb21wb25lbnRgLFxuICAgICAgICB0aGlzLCBtb2R1bGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1vZHVsZS5pbnRlZ3JhdGUpIG1vZHVsZS5pbnRlZ3JhdGUuYmluZCh0aGlzKShtb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VNb2R1bGVzXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gRGlzcG9zZXMgb2YgYWxsIG1vZHVsZXNcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZVN5c3RlbVxuICAgKi9cbiAgZGlzcG9zZU1vZHVsZXMoKSB7XG4gICAgd2hpbGUgKHRoaXMubW9kdWxlcy5sZW5ndGgpXG4gICAgICB0aGlzLmRpc3Bvc2VNb2R1bGUodGhpcy5tb2R1bGVzWzBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VNb2R1bGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBEaXNwb3NlcyBvZiB0aGUgZ2l2ZW4gbW9kdWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIG1vZHVsZSB0byBkaXNwb3NlXG4gICAqIEByZXR1cm4ge01vZHVsZX0gUmV0dXJucyBtb2R1bGUgdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZVN5c3RlbVxuICAgKi9cbiAgZGlzcG9zZU1vZHVsZShtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5tb2R1bGVzLnNwbGljZSh0aGlzLm1vZHVsZXMuaW5kZXhPZihtb2R1bGUpLCAxKTtcblxuICAgIGlmIChtb2R1bGUuZGlzcG9zZSkgbW9kdWxlLmRpc3Bvc2UuYmluZCh0aGlzKShtb2R1bGUpO1xuXG4gICAgcmV0dXJuIG1vZHVsZTtcbiAgfVxuXG4gIC8vIFBJUEVEIE1FVEhPRFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG1vZHVsZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIHBpcGVkIHZlcnNpb24gb2YgLmFwcGx5TW9kdWxlKCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgdGhlIG1vZHVsZSB0byBhcHBseVxuICAgKiBAcmV0dXJuIHt0aGlzfSByZXR1cm5zIHRoaXMgLSBhcHAvY29tcG9uZW50XG4gICAqIEB0aHJvd3Mge01hbmFnZXJFcnJvcn1cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZVN5c3RlbVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5QaXBlZCBtb2R1bGVzPC9jYXB0aW9uPlxuICAgKiBjb21wb25lbnRcbiAgICogICAubW9kdWxlKG5ldyBNb2R1bGUxKCkpXG4gICAqICAgLm1vZHVsZShuZXcgTW9kdWxlMigpKVxuICAgKiAgIC5tb2R1bGUobmV3IE1vZHVsZTMoKSlcbiAgICovXG4gIG1vZHVsZShtb2R1bGUpIHtcbiAgICB0aGlzLmFwcGx5TW9kdWxlKG1vZHVsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbCc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xuZXhwb3J0IHZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gICAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICAgKlxuICAgKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gICAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAgICogaW50byBhIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIGJ5IHVzaW5nIGBjb21iaW5lUmVkdWNlcnNgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBhY3Rpb24gdG8gaGFuZGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gaHlkcmF0ZSB0aGUgc3RhdGUgZnJvbSB0aGUgc2VydmVyIGluIHVuaXZlcnNhbCBhcHBzLCBvciB0byByZXN0b3JlIGFcbiAgICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAgICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICAgKiBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyBgY29tYmluZVJlZHVjZXJzYCBrZXlzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAgICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICAgKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gICAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gICAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAgICovXG59O2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVN0b3JlKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICB2YXIgX3JlZjI7XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBzdGF0ZSB0cmVlIG1hbmFnZWQgYnkgdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgY3VycmVudCBzdGF0ZSB0cmVlIG9mIHlvdXIgYXBwbGljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWlzU3Vic2NyaWJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtdXN0IGJlIHBsYWluIG9iamVjdHMuICcgKyAnVXNlIGN1c3RvbSBtaWRkbGV3YXJlIGZvciBhc3luYyBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYWN0aW9uLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbWF5IG5vdCBoYXZlIGFuIHVuZGVmaW5lZCBcInR5cGVcIiBwcm9wZXJ0eS4gJyArICdIYXZlIHlvdSBtaXNzcGVsbGVkIGEgY29uc3RhbnQ/Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlcnMgbWF5IG5vdCBkaXNwYXRjaCBhY3Rpb25zLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzID0gbmV4dExpc3RlbmVycztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSByZWR1Y2VyIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBzdG9yZSB0byBjYWxjdWxhdGUgdGhlIHN0YXRlLlxuICAgKlxuICAgKiBZb3UgbWlnaHQgbmVlZCB0aGlzIGlmIHlvdXIgYXBwIGltcGxlbWVudHMgY29kZSBzcGxpdHRpbmcgYW5kIHlvdSB3YW50IHRvXG4gICAqIGxvYWQgc29tZSBvZiB0aGUgcmVkdWNlcnMgZHluYW1pY2FsbHkuIFlvdSBtaWdodCBhbHNvIG5lZWQgdGhpcyBpZiB5b3VcbiAgICogaW1wbGVtZW50IGEgaG90IHJlbG9hZGluZyBtZWNoYW5pc20gZm9yIFJlZHV4LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0UmVkdWNlciBUaGUgcmVkdWNlciBmb3IgdGhlIHN0b3JlIHRvIHVzZSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyO1xuICAgIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4geyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9XG5cbiAgLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG4gIGRpc3BhdGNoKHsgdHlwZTogQWN0aW9uVHlwZXMuSU5JVCB9KTtcblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldFN0YXRlOiBnZXRTdGF0ZSxcbiAgICByZXBsYWNlUmVkdWNlcjogcmVwbGFjZVJlZHVjZXJcbiAgfSwgX3JlZjJbJCRvYnNlcnZhYmxlXSA9IG9ic2VydmFibGUsIF9yZWYyO1xufSIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59IiwiLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGEoYi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xufSIsImltcG9ydCBjcmVhdGVTdG9yZSBmcm9tICcuL2NyZWF0ZVN0b3JlJztcbmltcG9ydCBjb21iaW5lUmVkdWNlcnMgZnJvbSAnLi9jb21iaW5lUmVkdWNlcnMnO1xuaW1wb3J0IGJpbmRBY3Rpb25DcmVhdG9ycyBmcm9tICcuL2JpbmRBY3Rpb25DcmVhdG9ycyc7XG5pbXBvcnQgYXBwbHlNaWRkbGV3YXJlIGZyb20gJy4vYXBwbHlNaWRkbGV3YXJlJztcbmltcG9ydCBjb21wb3NlIGZyb20gJy4vY29tcG9zZSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICcuL3V0aWxzL3dhcm5pbmcnO1xuXG4vKlxuKiBUaGlzIGlzIGEgZHVtbXkgZnVuY3Rpb24gdG8gY2hlY2sgaWYgdGhlIGZ1bmN0aW9uIG5hbWUgaGFzIGJlZW4gYWx0ZXJlZCBieSBtaW5pZmljYXRpb24uXG4qIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiovXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICB3YXJuaW5nKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFxcJ3Byb2R1Y3Rpb25cXCcuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBEZWZpbmVQbHVnaW4gZm9yIHdlYnBhY2sgKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAwMzAwMzEpICcgKyAndG8gZW5zdXJlIHlvdSBoYXZlIHRoZSBjb3JyZWN0IGNvZGUgZm9yIHlvdXIgcHJvZHVjdGlvbiBidWlsZC4nKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RvcmUsIGNvbWJpbmVSZWR1Y2VycywgYmluZEFjdGlvbkNyZWF0b3JzLCBhcHBseU1pZGRsZXdhcmUsIGNvbXBvc2UgfTsiLCJpbXBvcnQge2NyZWF0ZVN0b3JlfSBmcm9tICdyZWR1eCc7XG5pbXBvcnQge0RlcGVuZGVuY3lFcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vKipcbiAqIEBjbGFzcyBNb2R1bGVNYW5hZ2VyXG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBoYW5kbGVyXG4gKiBAZGVzY3JpcHRpb24gIFNvbHZlcyBtb2R1bGVzIGRlcGVuZGVuY2llc1xuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2R1bGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0KSB7XG4gICAgdGhpcy5oYW5kbGVyID0gb2JqZWN0O1xuICAgIHRoaXMuY3VycmVudE1vZHVsZSA9IG51bGw7XG5cbiAgICB0aGlzLnN0b3JlID0gY3JlYXRlU3RvcmUoKHN0YXRlID0gW3t9LCAnJ10sIGFjdGlvbikgPT4ge1xuICAgICAgc3RhdGVbMF1bYWN0aW9uLmtleV0gPSBhY3Rpb24uZGF0YTtcbiAgICAgIHN0YXRlWzFdID0gYWN0aW9uLmtleTtcblxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tb2R1bGVzID0ge307XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhY3RpdmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIC5jdXJyZW50TW9kdWxlIHRvIHByb3ZpZGVkIG1vZHVsZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgbW9kdWxlIHRvIG1ha2UgY3VycmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgYWN0aXZlKG1vZHVsZSkge1xuICAgIHRoaXMuY3VycmVudE1vZHVsZSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gU2V0J3MgLmN1cnJlbnRNb2R1bGUgdG8gbnVsbC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudE1vZHVsZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkZWZpbmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBEZWZpbmUgdGhlIG1vZHVsZSBpbiBtYW5hZ2VyXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBtb2R1bGUgbmFtZVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgZGVmaW5lKG5hbWUpIHtcbiAgICB0aGlzLm1vZHVsZXNbbmFtZV0gPSB0aGlzLmN1cnJlbnRNb2R1bGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB1c2VcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRlZmluZWQgbW9kdWxlIGZyb20gbWFuYWdlclxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbW9kdWxlIG5hbWVcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICovXG4gIHVzZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlc1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEFuIGFsaWFzIGZvciAuYWRkKCkgPGJyLz48YnIvPlxuICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgeW91IGtub3cgdGhhdCB5b3Ugd2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgZGVwZW5kZW5jeS48YnIvPlxuICAgKiBVc2UgaXQgaW4geW91ciBhcHAsIGJ1dCBub3QgaW4gbW9kdWxlIHRoYXQgeW91IHByb3ZpZGUgdG8gb3RoZXIgcGVvcGxlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgb2YgdGhlIGRlcGVuZGVuY3lcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIHZhbHVlIG9mIHRoZSBkZXBlbmRlbmN5XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqL1xuICBzZXQoa2V5LCBkYXRhKSB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnQUREJyxcbiAgICAgIGtleSxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgZGVwZW5kZW5jeSBpbiBzdG9yZSBvYmplY3QsIGJ5IGtleS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSB0aGUga2V5IG9mIHRoZSBkZXBlbmRlbmN5XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqIEByZXR1cm4ge09iamVjdHxNb2R1bGV9XG4gICAqIEB0aHJvd3Mge0RlcGVuZGVuY3lFcnJvcn0gaWYgZGVwZW5kZW5jeSBpcyBub3QgaW4gdGhlIHN0b3JlXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCB0aGUgJ2hlbGxvJyBkZXBlbmRlbmN5PC9jYXB0aW9uPlxuICAgKiBtYW5hZ2VyLmdldCgnaGVsbG8nKTsgLy8gLT4ge3dvcmxkOiB0cnVlfVxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGlmICghdGhpcy5zdG9yZS5nZXRTdGF0ZSgpWzBdW2tleV0pIHtcbiAgICAgIHRocm93IG5ldyBEZXBlbmRlbmN5RXJyb3IoXG4gICAgICAgICdNb2R1bGVNYW5hZ2VyJyxcbiAgICAgICAgYE1vZHVsZSByZXF1aXJlcyAnJHtrZXl9JyBkZXBlbmRlbmN5YCxcbiAgICAgICAgdGhpcy5jdXJyZW50TW9kdWxlXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKClbMF1ba2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhhc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgd2hldGhlciBtYW5hZ2VyIGhhcyBhIGRlcGVuZGVuY3kgd2l0aCB0aGUgZ2l2ZW4ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgdGhlIGtleSBvZiB0aGUgZGVwZW5kZW5jeVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBhbGwgcHJvbWlzZXMgY29tcGxldGVkLlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5DaGVjayB3aGV0aGVyIHRoZSBzdG9yZSBoYXMgdGhlICdoZWxsbycgZGVwZW5kZW5jeTwvY2FwdGlvbj5cbiAgICogbWFuYWdlci5oYXMoJ2hlbGxvJyk7IC8vIC0+IHRydWVcbiAgICovXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnN0b3JlLmdldFN0YXRlKClbMF1ba2V5XSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIGRlcHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtkZXBzTWFwPXt9XVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlclxuICAgKi9cbiAgdXBkYXRlKGRlcHNNYXAgPSB7fSkge1xuICAgIHRoaXMuc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IFtkYXRhLCBjaGFuZ2VkS2V5XSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gZGVwc01hcFtjaGFuZ2VkS2V5XTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhkYXRhW2NoYW5nZWRLZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAYWxpYXMgbW9kdWxlOmNvcmUuTW9kdWxlTWFuYWdlciNzZXRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLk1vZHVsZU1hbmFnZXJcbiAgICovXG4gIGFkZCguLi5kYXRhKSB7XG4gICAgY29uc29sZS53YXJuKCcuYWRkKCkgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIFVzZSAuc2V0KCkgaW5zdGVhZCcpO1xuICAgIHJldHVybiB0aGlzLnNldCguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcXVpcmVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBSZXF1aXJlIG1vZHVsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBEZWZpbmVkIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbW9kdWxlRXhlY3V0b3IgRnVuY3Rpb24gdGhhdCByZXR1cm5zIGFwcGxpZWQgbW9kdWxlXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Nb2R1bGVNYW5hZ2VyXG4gICAqL1xuICByZXF1aXJlKG5hbWUsIG1vZHVsZUV4ZWN1dG9yKSB7XG4gICAgaWYgKHRoaXMudXNlKG5hbWUpID09PSB1bmRlZmluZWQpIHRoaXMuaGFuZGxlci5hcHBseU1vZHVsZShtb2R1bGVFeGVjdXRvcigpKTtcbiAgfVxufVxuIiwiaW1wb3J0IHtleHRlbmQsIHRyYW5zZm9ybURhdGF9IGZyb20gJy4uL3V0aWxzL2luZGV4JztcbmltcG9ydCB7TW9kdWxlU3lzdGVtfSBmcm9tICcuL01vZHVsZVN5c3RlbSc7XG5pbXBvcnQge01vZHVsZU1hbmFnZXJ9IGZyb20gJy4vTW9kdWxlTWFuYWdlcic7XG5pbXBvcnQge01hbmFnZXJFcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vKipcbiAqIEBjbGFzcyBDb21wb25lbnRcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1ldGVycyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW2luc3RydWN0aW9uc10gLSBUaGUgaW5zdHJ1Y3Rpb25zIG9iamVjdC5cbiAqIEBleHRlbmRzIE1vZHVsZVN5c3RlbVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIE1vZHVsZVN5c3RlbSB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IHtcbiAgICogICBtb2R1bGVzOiBbXSxcbiAgICogICBtYW5hZ2VyOiB0cnVlXG4gICAqIH1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBtb2R1bGVzOiBudWxsLFxuICAgIG1hbmFnZXI6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogU3RhdGljIGluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHt9O1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBwcm9taXNlcyB0aGF0IHNob3VsZCBiZSByZXNvbHZlZCBiZWZvcmUgQ29tcG9uZW50IGlzIHJlYWR5LlxuICAgKiBAbWVtYmVyIHtBcnJheX0gbW9kdWxlOmNvcmUuQ29tcG9uZW50I193YWl0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2FpdCA9IFtdOyAvLyBDb2xsZWN0aW9uIG9mIHByb21pc2VzO1xuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIGBtb2R1bGVzYC5cbiAgICogQG1lbWJlciB7QXJyYXl9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNtb2R1bGVzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG1vZHVsZXMgPSBbXTsgLy8gQ29sbGVjdGlvbiBvZiBtb2R1bGVzO1xuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIGBjaGlsZGAgQ29tcG9uZW50cy5cbiAgICogQG1lbWJlciB7QXJyYXl9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNjaGlsZHJlblxuICAgKiBAcHVibGljXG4gICAqL1xuICBjaGlsZHJlbiA9IFtdOyAvLyBGb3Iga2VlcGluZyBjaGlsZHJlbiBjb21wb25lbnRzO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9LCBkZWZhdWx0cyA9IENvbXBvbmVudC5kZWZhdWx0cywgaW5zdHJ1Y3Rpb25zID0gQ29tcG9uZW50Lmluc3RydWN0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBBcHBseSBwb2x5ZmlsbGVkIHBhcmFtZXRlcnMgdG8gLnBhcmFtcztcbiAgICB0aGlzLnBhcmFtcyA9IGV4dGVuZCh0cmFuc2Zvcm1EYXRhKHBhcmFtcywgaW5zdHJ1Y3Rpb25zKSwgZGVmYXVsdHMpO1xuICAgIGlmICh0aGlzLnBhcmFtcy5tYW5hZ2VyKSB0aGlzLm1hbmFnZXIgPSBuZXcgTW9kdWxlTWFuYWdlcih0aGlzKTtcblxuICAgIHRoaXMubW9kdWxlcyA9IHRoaXMucGFyYW1zLm1vZHVsZXM7XG5cbiAgICB0aGlzLmludGVncmF0ZU1vZHVsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHdhaXRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBXYWl0IGZvciBhIHByb21pc2UuXG4gICAqIEBwYXJhbSB7UHJvbWlzZX0gW3Byb21pc2VdIC0gVGhlIHByb21pc2UgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gYSBxdWV1ZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIHByb21pc2VzIGNvbXBsZXRlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICAgKi9cbiAgd2FpdChwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UpIHRoaXMuX3dhaXQucHVzaChwcm9taXNlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5fd2FpdCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkZWZlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEV4ZWN1dGUgYGZ1bmNgIChDYWxsYmFjaykgd2hlbiBDb21wb25lbnQgaXMgcmVhZHkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBDYWxsYmFjay5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNvbXBvbmVudFxuICAgKi9cbiAgZGVmZXIoZnVuYykge1xuICAgIGlmICh0aGlzLmlzRGVmZmVyZWQpIHRoaXMud2FpdCgpLnRoZW4oKCkgPT4gZnVuYyh0aGlzKSk7XG4gICAgZWxzZSBmdW5jKHRoaXMpO1xuICB9XG5cbiAgLy8gUEFSQU1FVEVSU1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVBhcmFtc1xuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgcGFyYW1ldGVycyBvZiB0aGUgQ29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFBhcmFtcyBvZiB0aGlzIENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICB1cGRhdGVQYXJhbXMocGFyYW1zID0ge30pIHtcbiAgICB0aGlzLnBhcmFtcyA9IGV4dGVuZChwYXJhbXMsIHRoaXMucGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvLyBDT1BZSU5HICYgQ0xPTklOR1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQ2xvbmUgdGhpcyBjb21wb25lbnRcbiAgICogQHJldHVybiB7b2JqZWN0fSBhIGNsb25lZCBjb21wb25lbnQgd2l0aCBhbGwgaXRzIHNvdXJjZSBjb21wb25lbnQnIHBhcmFtcyBjb3BpZWQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhcmFtcykuY29weSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDb3B5IHNvdXJjZSBuYXRpdmUgYW5kIGludGVncmF0ZSBgbW9kdWxlc2AgdG8gaXQuXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBzb3VyY2UgLSBTb3VyY2UgY29tcG9uZW50IHRoYXQgaXMgdXNlZCBmb3IgYGNvcHkoKWAgYWN0aW9uLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplXSAtIENhbGxiYWNrIGV4ZWN1dGVkIGJlZm9yZSBtb2R1bGVzIGludGVncmF0aW9uIHByb2Nlc3MuXG4gICAqIEByZXR1cm4ge3RoaXN9IENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICBjb3B5KHNvdXJjZSwgY3VzdG9taXplKSB7XG4gICAgdGhpcy5wYXJhbXMgPSB7Li4uc291cmNlLnBhcmFtc307XG5cbiAgICBpZiAoc291cmNlLm5hdGl2ZSkgdGhpcy5uYXRpdmUgPSBzb3VyY2UubmF0aXZlLmNsb25lKHNvdXJjZS5wYXJhbXMpO1xuICAgIGlmIChjdXN0b21pemUpIGN1c3RvbWl6ZSgpO1xuICAgIHRoaXMuaW50ZWdyYXRlTW9kdWxlcyhzb3VyY2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBhZGRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBBZGQgYSBjaGlsZCBgQ29tcG9uZW50YC5cbiAgICogQHBhcmFtIHtDb21wb25lbnR9IG9iamVjdCAtIENvbXBvbmVudCB0aGF0IHNob3VsZCBiZSBhZGRlZCBhcyBhIGBjaGlsZGAuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gYWN0aW9uIGlzIGRvbmUuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIGFkZChvYmplY3QpIHtcbiAgICBvYmplY3QucGFyZW50ID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBvYmplY3QuZGVmZXIoKCkgPT4ge1xuICAgICAgICBjb25zdCB7bmF0aXZlfSA9IG9iamVjdDtcbiAgICAgICAgaWYgKCFuYXRpdmUpIHJlamVjdCgpO1xuXG4gICAgICAgIGNvbnN0IGFkZFByb21pc2UgPSB0aGlzLmFwcGx5QnJpZGdlKHtvbkFkZDogb2JqZWN0fSkub25BZGQ7XG5cbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5uYXRpdmUuYWRkKG5hdGl2ZSk7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKG9iamVjdCk7XG5cbiAgICAgICAgICByZXNvbHZlKG9iamVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGFkZFByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSBhZGRQcm9taXNlLnRoZW4ocmVzb2x2ZXIpO1xuICAgICAgICBlbHNlIHJlc29sdmVyKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBhIGNoaWxkIGBDb21wb25lbnRgLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb2JqZWN0IC0gQ29tcG9uZW50IHRoYXQgc2hvdWxkIGJlIGEgKipjaGlsZCoqIG9mIHRoaXMgQ29tcG9uZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gICAqL1xuICByZW1vdmUob2JqZWN0KSB7XG4gICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmUucmVtb3ZlKG9iamVjdC5uYXRpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkVG9cbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGB0aGlzYCBDb21wb25lbnQgdG8gc3BlY2lmaWVkIGBBcHBgL2BDb21wb25lbnRgLlxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gb2JqZWN0IC0gQ29tcG9uZW50IHRoYXQgd2lsbCBiZSBhIHBhcmVudCBvZiBgdGhpc2AuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAgICovXG4gIGFkZFRvKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuYWRkKHRoaXMpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0KGtleSk7XG4gIH1cblxuICB1c2Uoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFuYWdlci51c2Uoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIG9iamVjdCBpcyBgYXN5bmNgIChgd2FpdGAgcHJvbWlzZXMgYXJlIG1vcmUgdGhhbiBgMGApLlxuICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6Y29yZS5Db21wb25lbnQjaXNEZWZmZXJlZFxuICAgKi9cbiAgZ2V0IGlzRGVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhaXQubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgTW9kdWxlTWFuYWdlcmAgdXNlZCBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqIEBtZW1iZXIge01vZHVsZU1hbmFnZXJ9IG1vZHVsZTpjb3JlLkNvbXBvbmVudCNtYW5hZ2VyXG4gICAqIEB0aHJvd3Mge01hbmFnZXJFcnJvcn1cbiAgICovXG4gIGdldCBtYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyKSByZXR1cm4gdGhpcy5fbWFuYWdlcjtcblxuICAgIHRocm93IG5ldyBNYW5hZ2VyRXJyb3IoXG4gICAgICAnQ29tcG9uZW50JyxcbiAgICAgIGBNb2R1bGVNYW5hZ2VyIGlzIG5vdCB1c2VkIGluIHRoaXMgY29tcG9uZW50LiAnbWFuYWdlcicgcGFyYW1ldGVyIHNob3VsZCBiZSBzZXQgYXMgJ3RydWUnYCxcbiAgICAgIHRoaXNcbiAgICApO1xuICB9XG5cbiAgc2V0IG1hbmFnZXIobWFuYWdlcikge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBuYXRpdmVgIG9iamVjdCB1c2VkIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5Db21wb25lbnQjbmF0aXZlXG4gICAqL1xuICBnZXQgbmF0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9uYXRpdmU7XG4gIH1cblxuICBzZXQgbmF0aXZlKG1lc2gpIHtcbiAgICB0aGlzLl9uYXRpdmUgPSBtZXNoO1xuICAgIHRoaXMuX25hdGl2ZS5jb21wb25lbnQgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9uYXRpdmU7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQ29tcG9uZW50XG59O1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoLi4ubWFwcGVycykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbWFwcGVyID0gbWFwcGVyc1tpXTtcblxuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBtYXBwZXIubWFwLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1hcHBlci5tYXBba107XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldC5wcm90b3R5cGUsIGF0dHJpYnV0ZSwge1xuICAgICAgICAgIGdldDogbWFwcGVyLmdldHRlcihhdHRyaWJ1dGUpLFxuICAgICAgICAgIHNldDogbWFwcGVyLnNldHRlcihhdHRyaWJ1dGUpLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogbWFwcGVyLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBtYXBwZXIuZW51bWVyYWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KC4uLm1hcCkge1xuICByZXR1cm4ge1xuICAgIG1hcCxcbiAgICBnZXR0ZXIobmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlW25hbWVdO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHNldHRlcihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubmF0aXZlW25hbWVdLmNvcHkodmFsdWUpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaXJyb3IoLi4ubWFwKSB7XG4gIHJldHVybiB7XG4gICAgbWFwLFxuICAgIGdldHRlcihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVbbmFtZV07XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0dGVyKG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYXRpdmVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9O1xufVxuIiwiaW1wb3J0IHtNZXNofSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnLi9Db21wb25lbnQnO1xuXG5pbXBvcnQge2F0dHJpYnV0ZXMsIGNvcHksIG1pcnJvcn0gZnJvbSAnLi9wcm90b3R5cGUvYXR0cmlidXRlcyc7XG5pbXBvcnQge0NvbXBvc2l0aW9uRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuQGF0dHJpYnV0ZXMoXG4gIGNvcHkoJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3F1YXRlcm5pb24nLCAnc2NhbGUnKSxcbiAgbWlycm9yKCdtYXRlcmlhbCcsICdnZW9tZXRyeScpXG4pXG4vKipcbiAqIEBjbGFzcyBNZXNoQ29tcG9uZW50XG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtpbnN0cnVjdGlvbnNdIC0gVGhlIGluc3RydWN0aW9ucyBvYmplY3QuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5jbGFzcyBNZXNoQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudCNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0XG4gICAqIHtcbiAgICogICBidWlsZDogdHJ1ZSxcbiAgICogICBnZW9tZXRyeToge30sXG4gICAqICAgbWF0ZXJpYWw6IGZhbHNlLFxuICAgKlxuICAgKiAgIHNoYWRvdzoge1xuICAgKiAgICAgY2FzdDogdHJ1ZSxcbiAgICogICAgIHJlY2VpdmU6IHRydWVcbiAgICogICB9LFxuICAgKlxuICAgKiAgIHBvc2l0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAqICAgcm90YXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICogICBzY2FsZToge3g6IDEsIHk6IDEsIHo6IDF9XG4gICAqIH1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5Db21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBidWlsZDogdHJ1ZSxcbiAgICBnZW9tZXRyeToge30sXG4gICAgbWF0ZXJpYWw6IGZhbHNlLFxuXG4gICAgc2hhZG93OiB7XG4gICAgICBjYXN0OiB0cnVlLFxuICAgICAgcmVjZWl2ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBwb3NpdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9LFxuICAgIHJvdGF0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAgc2NhbGU6IHt4OiAxLCB5OiAxLCB6OiAxfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgaW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdFxuICAgKiB7XG4gICAqICAgcG9zaXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICogICByb3RhdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgKiAgIHNjYWxlOiBbJ3gnLCAneScsICd6J11cbiAgICogfVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAgc2NhbGU6IFsneCcsICd5JywgJ3onXVxuICB9O1xuXG4gIC8vIENVU1RPTSBHRU9NRVRSWSBIQU5ETElOR1xuXG4gIHN0YXRpYyBjdXN0b20oZ2VvbSwgY29uc3RydWN0b3IgPSBNZXNoKSB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gICAgICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgICAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBjb25zdHJ1Y3RvcihnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShnZW9tLCBwYXJhbXMsIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoTWVzaENvbXBvbmVudC5jdXN0b20oZ2VvbSwgY29uc3RydWN0b3IpKShwYXJhbXMpO1xuICB9XG5cbiAgc3RhdGljIGZyb20obWVzaCwgcGFyYW1zID0ge30pIHtcbiAgICBwYXJhbXMuYnVpbGQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBNZXNoQ29tcG9uZW50KHBhcmFtcyk7XG5cbiAgICBjb21wb25lbnQubmF0aXZlID0gbWVzaDtcbiAgICBjb21wb25lbnQud3JhcCgpO1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgZGVmYXVsdHMgPSBNZXNoQ29tcG9uZW50LmRlZmF1bHRzLCBpbnN0cnVjdGlvbnMgPSBNZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucykge1xuICAgIHN1cGVyKHBhcmFtcywgZGVmYXVsdHMsIGluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuYnVpbGQpIHtcbiAgICAgIGNvbnN0IGJ1aWxkID0gdGhpcy5idWlsZCh0aGlzLnBhcmFtcyk7XG5cbiAgICAgIGlmICghYnVpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbXBvc2l0aW9uRXJyb3IoXG4gICAgICAgICAgJ01lc2hDb21wb25lbnQnLFxuICAgICAgICAgICcuYnVpbGQoKSBtZXRob2Qgc2hvdWxkIHJldHVybiBhIFRIUkVFLk9iamVjdDNEIG9yIGEgUHJvbWlzZSByZXNvbHZlZCB3aXRoIFRIUkVFLk9iamVjdDNELicsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVpbGQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMud2FpdChidWlsZCk7XG5cbiAgICAgICAgdGhpcy53YWl0KG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGJ1aWxkLnRoZW4obmF0aXZlID0+IHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlID0gbmF0aXZlO1xuICAgICAgICAgICAgdGhpcy53cmFwKCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5uYXRpdmUgPSBidWlsZDtcbiAgICAgICAgdGhpcy53YWl0KHRoaXMud3JhcCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFwcGx5Q29tbWFuZCgncG9zdEludGVncmF0ZScpO1xuICB9XG5cbiAgLy8gQlVJTERJTkcgJiBXUkFQUElOR1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaXZlY3ljbGUgc2hvdWxkIHJldHVybiBhIG5hdGl2ZSBvYmplY3QuXG4gICAqIEB0aHJvd3Mge0NvbXBvc2l0aW9uRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gICAqL1xuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICdNZXNoQ29tcG9uZW50JyxcbiAgICAgICdJbnN0YW5jZSBzaG91bGQgaGF2ZSBpdFxcJ3Mgb3duIC5idWlsZCgpLicsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHdyYXBcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBXcmFwcyB0cmFuc2Zvcm1zIChgcG9zaXRpb25gICYgYHJvdGF0aW9uYClcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhY3Rpb24gaXMgY29tcGxldGVkXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gICAqL1xuICB3cmFwKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIC8vIFRPRE86IEZpeCBkZWZlciB3aXRoIHBoeXNpY3NcbiAgICAgIC8vIHRoaXMuZGVmZXIoKCkgPT4ge1xuICAgICAgY29uc3Qge3Bvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIHNoYWRvd30gPSB0aGlzLnBhcmFtcztcblxuICAgICAgdGhpcy5wb3NpdGlvbi5zZXQocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueik7XG4gICAgICB0aGlzLnJvdGF0aW9uLnNldChyb3RhdGlvbi54LCByb3RhdGlvbi55LCByb3RhdGlvbi56KTtcbiAgICAgIHRoaXMuc2NhbGUuc2V0KHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnopO1xuXG4gICAgICB0aGlzLm5hdGl2ZS5jYXN0U2hhZG93ID0gc2hhZG93LmNhc3Q7XG4gICAgICB0aGlzLm5hdGl2ZS5yZWNlaXZlU2hhZG93ID0gc2hhZG93LnJlY2VpdmU7XG5cbiAgICAgIHRoaXMuYXBwbHlCcmlkZ2Uoe29uV3JhcDogMX0pO1xuXG4gICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgLy8gfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDT1BZSU5HICYgQ0xPTklOR1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDb3B5IHNvdXJjZSB0cmFuc2Zvcm1zICYgZXhlY3V0ZSBgQ29tcG9uZW50LmNvcHkoKWBcbiAgICogQHJldHVybiB7dGhpc30gTWVzaENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICAgKi9cbiAgY29weShzb3VyY2UpIHtcbiAgICByZXR1cm4gc3VwZXIuY29weShzb3VyY2UsICgpID0+IHtcbiAgICAgIHRoaXMucG9zaXRpb24uY29weShzb3VyY2UucG9zaXRpb24pO1xuICAgICAgdGhpcy5yb3RhdGlvbi5jb3B5KHNvdXJjZS5yb3RhdGlvbik7XG4gICAgICB0aGlzLnF1YXRlcm5pb24uY29weShzb3VyY2UucXVhdGVybmlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIE1ha2UgYSBjbG9uZSBvZiB0aGlzIE1lc2hDb21wb25lbnQgdXNpbmcgYC5jb3B5KClgXG4gICAqIEByZXR1cm4ge01lc2hDb21wb25lbnR9IGNsb25lIG9mIHRoaXMgb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gICAqL1xuICBjbG9uZShnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcbiAgICBjb25zdCBkZXN0ID0gbmV3IHRoaXMuY29uc3RydWN0b3Ioe2J1aWxkOiBmYWxzZX0pLmNvcHkodGhpcyk7XG5cbiAgICBpZiAoZ2VvbWV0cnkpIGRlc3QuZ2VvbWV0cnkgPSBkZXN0Lmdlb21ldHJ5LmNsb25lKCk7XG4gICAgaWYgKG1hdGVyaWFsKSBkZXN0Lm1hdGVyaWFsID0gZGVzdC5tYXRlcmlhbC5jbG9uZSgpO1xuXG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTWVzaENvbXBvbmVudFxufTtcbiIsImltcG9ydCB7Q29tcG9uZW50fSBmcm9tICcuL0NvbXBvbmVudCc7XG5cbmltcG9ydCB7YXR0cmlidXRlcywgY29weX0gZnJvbSAnLi9wcm90b3R5cGUvYXR0cmlidXRlcyc7XG5pbXBvcnQge0NvbXBvc2l0aW9uRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuQGF0dHJpYnV0ZXMoXG4gIGNvcHkoJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3F1YXRlcm5pb24nLCAndGFyZ2V0Jylcbilcbi8qKlxuICogQGNsYXNzIExpZ2h0Q29tcG9uZW50XG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtpbnN0cnVjdGlvbnNdIC0gVGhlIGluc3RydWN0aW9ucyBvYmplY3QuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5Db21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5jbGFzcyBMaWdodENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHRcbiAgICoge1xuICAgKiAgIGJ1aWxkOiB0cnVlLFxuICAgKlxuICAgKiAgIHNoYWRvdzoge1xuICAgKiAgICAgY2FzdDogdHJ1ZSxcbiAgICpcbiAgICogICAgIGJpYXM6IDAsXG4gICAqICAgICByYWRpdXM6IDEsXG4gICAqXG4gICAqICAgICBtYXBTaXplOiB7XG4gICAqICAgICAgIHdpZHRoOiAxMDI0LFxuICAgKiAgICAgICBoZWlnaHQ6IDEwMjRcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBjYW1lcmE6IHtcbiAgICogICAgICAgbmVhcjogdHJ1ZSxcbiAgICogICAgICAgZmFyOiA0MDAsXG4gICAqICAgICAgIGZvdjogOTAsXG4gICAqXG4gICAqICAgICAgIHRvcDogMjAwLFxuICAgKiAgICAgICBib3R0b206IC0yMDAsXG4gICAqICAgICAgIGxlZnQ6IC0yMDAsXG4gICAqICAgICAgIHJpZ2h0OiAyMDBcbiAgICogICAgIH1cbiAgICogICB9LFxuICAgKlxuICAgKiAgIHBvc2l0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAqICAgcm90YXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfVxuICAgKiB9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgYnVpbGQ6IHRydWUsXG5cbiAgICBzaGFkb3c6IHtcbiAgICAgIGNhc3Q6IHRydWUsXG5cbiAgICAgIGJpYXM6IDAsXG4gICAgICByYWRpdXM6IDEsXG5cbiAgICAgIG1hcFNpemU6IHtcbiAgICAgICAgd2lkdGg6IDEwMjQsXG4gICAgICAgIGhlaWdodDogMTAyNFxuICAgICAgfSxcblxuICAgICAgY2FtZXJhOiB7XG4gICAgICAgIG5lYXI6IHRydWUsXG4gICAgICAgIGZhcjogNDAwLFxuICAgICAgICBmb3Y6IDkwLFxuXG4gICAgICAgIHRvcDogMjAwLFxuICAgICAgICBib3R0b206IC0yMDAsXG4gICAgICAgIGxlZnQ6IC0yMDAsXG4gICAgICAgIHJpZ2h0OiAyMDBcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zaXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfSxcbiAgICByb3RhdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBpbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdFxuICAgKiB7XG4gICAqICAgcG9zaXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICogICByb3RhdGlvbjogWyd4JywgJ3knLCAneiddXG4gICAqIH1cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgcG9zaXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICByb3RhdGlvbjogWyd4JywgJ3knLCAneiddXG4gIH07XG5cbiAgc3RhdGljIGZyb20obGlnaHQsIHBhcmFtcyA9IHt9LCB3cmFwU2hhZG93ID0gdHJ1ZSkge1xuICAgIHBhcmFtcy5idWlsZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29tcG9uZW50ID0gbmV3IExpZ2h0Q29tcG9uZW50KHBhcmFtcyk7XG5cbiAgICBjb21wb25lbnQubmF0aXZlID0gbGlnaHQ7XG4gICAgY29tcG9uZW50LndyYXAoKTtcbiAgICBpZiAod3JhcFNoYWRvdykgY29tcG9uZW50LndyYXBTaGFkb3coKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMsIGRlZmF1bHRzID0gTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsIGluc3RydWN0aW9ucyA9IExpZ2h0Q29tcG9uZW50Lmluc3RydWN0aW9ucykge1xuICAgIHN1cGVyKHBhcmFtcywgZGVmYXVsdHMsIGluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAodGhpcy5wYXJhbXMuYnVpbGQpIHtcbiAgICAgIGNvbnN0IGJ1aWxkID0gdGhpcy5idWlsZCh0aGlzLnBhcmFtcyk7XG5cbiAgICAgIGlmICghYnVpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbXBvc2l0aW9uRXJyb3IoXG4gICAgICAgICAgJ0xpZ2h0Q29tcG9uZW50JyxcbiAgICAgICAgICAnLmJ1aWxkKCkgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBUSFJFRS5PYmplY3QzRCBvciBhIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBUSFJFRS5PYmplY3QzRC4nLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1aWxkIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBidWlsZC50aGVuKG5hdGl2ZSA9PiB7XG4gICAgICAgICAgdGhpcy5uYXRpdmUgPSBuYXRpdmU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHRoaXMubmF0aXZlID0gYnVpbGQ7XG5cbiAgICAgIHRoaXMud2FpdCh0aGlzLndyYXAoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseUNvbW1hbmQoJ3Bvc3RJbnRlZ3JhdGUnKTtcbiAgfVxuXG4gIC8vIEJVSUxESU5HICYgV1JBUFBJTkdcblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpdmVjeWNsZSBzaG91bGQgcmV0dXJuIGEgbmF0aXZlIG9iamVjdC5cbiAgICogQHRocm93cyB7Q29tcG9zaXRpb25FcnJvcn1cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gICAqL1xuICBidWlsZCgpIHtcbiAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICdNZXNoQ29tcG9uZW50JyxcbiAgICAgICdJbnN0YW5jZSBzaG91bGQgaGF2ZSBpdFxcJ3Mgb3duIC5idWlsZCgpLicsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHdyYXBcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBXcmFwcyB0cmFuc2Zvcm1zIChgcG9zaXRpb25gICYgYHJvdGF0aW9uYClcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhY3Rpb24gaXMgY29tcGxldGVkXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICAgKi9cbiAgd3JhcCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLmRlZmVyKCgpID0+IHtcbiAgICAgICAgY29uc3Qge3Bvc2l0aW9uLCByb3RhdGlvbn0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbi5zZXQocm90YXRpb24ueCwgcm90YXRpb24ueSwgcm90YXRpb24ueik7XG5cbiAgICAgICAgdGhpcy5hcHBseUJyaWRnZSh7b25XcmFwOiAxfSk7XG5cbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgd3JhcFNoYWRvd1xuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFdyYXBzIHNoYWRvdyBwcm9wZXJ0aWVzXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICAgKi9cbiAgd3JhcFNoYWRvdygpIHtcbiAgICBjb25zdCB7bmF0aXZlLCBwYXJhbXM6IHtzaGFkb3d9fSA9IHRoaXM7XG5cbiAgICBuYXRpdmUuY2FzdFNoYWRvdyA9IHNoYWRvdy5jYXN0O1xuICAgIG5hdGl2ZS5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IHNoYWRvdy5tYXBTaXplLndpZHRoO1xuICAgIG5hdGl2ZS5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSBzaGFkb3cubWFwU2l6ZS5oZWlnaHQ7XG4gICAgbmF0aXZlLnNoYWRvdy5iaWFzID0gc2hhZG93LmJpYXM7XG4gICAgbmF0aXZlLnNoYWRvdy5yYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xuXG4gICAgY29uc3Qgc2hhZG93Q2FtZXJhID0gbmF0aXZlLnNoYWRvdy5jYW1lcmE7XG4gICAgY29uc3QgY2FtZXJhID0gc2hhZG93LmNhbWVyYTtcblxuICAgIHNoYWRvd0NhbWVyYS5uZWFyID0gY2FtZXJhLm5lYXI7XG4gICAgc2hhZG93Q2FtZXJhLmZhciA9IGNhbWVyYS5mYXI7XG4gICAgc2hhZG93Q2FtZXJhLmZvdiA9IGNhbWVyYS5mb3Y7XG5cbiAgICBzaGFkb3dDYW1lcmEubGVmdCA9IGNhbWVyYS5sZWZ0O1xuICAgIHNoYWRvd0NhbWVyYS5yaWdodCA9IGNhbWVyYS5yaWdodDtcbiAgICBzaGFkb3dDYW1lcmEudG9wID0gY2FtZXJhLnRvcDtcbiAgICBzaGFkb3dDYW1lcmEuYm90dG9tID0gY2FtZXJhLmJvdHRvbTtcbiAgfVxuXG4gIC8vIENPUFlJTkcgJiBDTE9OSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENvcHkgc291cmNlIHRyYW5zZm9ybXMgJiBleGVjdXRlIGBDb21wb25lbnQuY29weSgpYFxuICAgKiBAcmV0dXJuIHt0aGlzfSBMaWdodENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAgICovXG4gIGNvcHkoc291cmNlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvcHkoc291cmNlLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50YXJnZXQpIHRoaXMudGFyZ2V0LmNvcHkoc291cmNlLnRhcmdldCgpKTtcblxuICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG4gICAgICB0aGlzLnJvdGF0aW9uLmNvcHkoc291cmNlLnJvdGF0aW9uKTtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KHNvdXJjZS5xdWF0ZXJuaW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gTWFrZSBhIGNsb25lIG9mIHRoaXMgTGlnaHRDb21wb25lbnQgdXNpbmcgYC5jb3B5KClgXG4gICAqIEByZXR1cm4ge0xpZ2h0Q29tcG9uZW50fSBjbG9uZSBvZiB0aGlzIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7YnVpbGQ6IGZhbHNlfSkuY29weSh0aGlzKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBMaWdodENvbXBvbmVudFxufTtcbiIsImltcG9ydCB7Q29tcG9uZW50fSBmcm9tICcuL0NvbXBvbmVudCc7XG5cbmltcG9ydCB7YXR0cmlidXRlcywgY29weX0gZnJvbSAnLi9wcm90b3R5cGUvYXR0cmlidXRlcyc7XG5pbXBvcnQge0NvbXBvc2l0aW9uRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuQGF0dHJpYnV0ZXMoXG4gIGNvcHkoJ3Bvc2l0aW9uJywgJ3JvdGF0aW9uJywgJ3F1YXRlcm5pb24nLCAndGFyZ2V0Jylcbilcbi8qKlxuICogQGNsYXNzIENhbWVyYUNvbXBvbmVudFxuICogQGNhdGVnb3J5IGNvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5zdHJ1Y3Rpb25zXSAtIFRoZSBpbnN0cnVjdGlvbnMgb2JqZWN0LlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmVcbiAqL1xuY2xhc3MgQ2FtZXJhQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHRcbiAgICoge1xuICAgKiAgIGJ1aWxkOiB0cnVlLFxuICAgKlxuICAgKiAgIHBvc2l0aW9uOiB7eDogMCwgeTogMCwgejogMH0sXG4gICAqICAgcm90YXRpb246IHt4OiAwLCB5OiAwLCB6OiAwfVxuICAgKiB9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgYnVpbGQ6IHRydWUsXG5cbiAgICBwb3NpdGlvbjoge3g6IDAsIHk6IDAsIHo6IDB9LFxuICAgIHJvdGF0aW9uOiB7eDogMCwgeTogMCwgejogMH1cbiAgfTtcblxuICAvKipcbiAgICogU3RhdGljIGluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkNhbWVyYUNvbXBvbmVudCNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdFxuICAgKiB7XG4gICAqICAgcG9zaXRpb246IFsneCcsICd5JywgJ3onXSxcbiAgICogICByb3RhdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgKiAgIHNjYWxlOiBbJ3gnLCAneScsICd6J11cbiAgICogfVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICBwb3NpdGlvbjogWyd4JywgJ3knLCAneiddLFxuICAgIHJvdGF0aW9uOiBbJ3gnLCAneScsICd6J10sXG4gICAgc2NhbGU6IFsneCcsICd5JywgJ3onXVxuICB9O1xuXG4gIHN0YXRpYyBmcm9tKGNhbWVyYSwgcGFyYW1zID0ge30pIHtcbiAgICBwYXJhbXMuYnVpbGQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IG5ldyBDYW1lcmFDb21wb25lbnQocGFyYW1zKTtcblxuICAgIGNvbXBvbmVudC5uYXRpdmUgPSBjYW1lcmE7XG4gICAgY29tcG9uZW50LndyYXAoKTtcblxuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMsIGRlZmF1bHRzID0gQ2FtZXJhQ29tcG9uZW50LmRlZmF1bHRzLCBpbnN0cnVjdGlvbnMgPSBDYW1lcmFDb21wb25lbnQuaW5zdHJ1Y3Rpb25zKSB7XG4gICAgc3VwZXIocGFyYW1zLCBkZWZhdWx0cywgaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5idWlsZCkge1xuICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkKHRoaXMucGFyYW1zKTtcblxuICAgICAgaWYgKCFidWlsZCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29tcG9zaXRpb25FcnJvcihcbiAgICAgICAgICAnQ2FtZXJhQ29tcG9uZW50JyxcbiAgICAgICAgICAnLmJ1aWxkKCkgbWV0aG9kIHNob3VsZCByZXR1cm4gYSBUSFJFRS5PYmplY3QzRCBvciBhIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBUSFJFRS5PYmplY3QzRC4nLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1aWxkIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBidWlsZC50aGVuKG5hdGl2ZSA9PiB7XG4gICAgICAgICAgdGhpcy5uYXRpdmUgPSBuYXRpdmU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHRoaXMubmF0aXZlID0gYnVpbGQ7XG5cbiAgICAgIHRoaXMud2FpdCh0aGlzLndyYXAoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBseUNvbW1hbmQoJ3Bvc3RJbnRlZ3JhdGUnKTtcbiAgfVxuXG4gIC8vIEJVSUxESU5HICYgV1JBUFBJTkdcblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpdmVjeWNsZSBzaG91bGQgcmV0dXJuIGEgbmF0aXZlIG9iamVjdC5cbiAgICogQHRocm93cyB7Q29tcG9zaXRpb25FcnJvcn1cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkNhbWVyYUNvbXBvbmVudFxuICAgKi9cbiAgYnVpbGQoKSB7XG4gICAgdGhyb3cgbmV3IENvbXBvc2l0aW9uRXJyb3IoXG4gICAgICAnQ2FtZXJhQ29tcG9uZW50JyxcbiAgICAgICdJbnN0YW5jZSBzaG91bGQgaGF2ZSBpdFxcJ3Mgb3duIC5idWlsZCgpLicsXG4gICAgICB0aGlzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHdyYXBcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBXcmFwcyB0cmFuc2Zvcm1zIChgcG9zaXRpb25gICYgYHJvdGF0aW9uYClcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhY3Rpb24gaXMgY29tcGxldGVkXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnRcbiAgICovXG4gIHdyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5kZWZlcigoKSA9PiB7XG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KHRoaXMucGFyYW1zLnBvc2l0aW9uLngsIHRoaXMucGFyYW1zLnBvc2l0aW9uLnksIHRoaXMucGFyYW1zLnBvc2l0aW9uLnopO1xuICAgICAgICB0aGlzLnJvdGF0aW9uLnNldCh0aGlzLnBhcmFtcy5yb3RhdGlvbi54LCB0aGlzLnBhcmFtcy5yb3RhdGlvbi55LCB0aGlzLnBhcmFtcy5yb3RhdGlvbi56KTtcblxuICAgICAgICB0aGlzLmFwcGx5QnJpZGdlKHtvbldyYXA6IDF9KTtcblxuICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQ29weSBzb3VyY2UgdHJhbnNmb3JtcyAmIGV4ZWN1dGUgYENvbXBvbmVudC5jb3B5KClgXG4gICAqIEByZXR1cm4ge3RoaXN9IENhbWVyYUNvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50XG4gICAqL1xuICBjb3B5KHNvdXJjZSkge1xuICAgIHJldHVybiBzdXBlci5jb3B5KHNvdXJjZSwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0KSB0aGlzLnRhcmdldC5jb3B5KHNvdXJjZS50YXJnZXQoKSk7XG5cbiAgICAgIHRoaXMucG9zaXRpb24uY29weShzb3VyY2UucG9zaXRpb24pO1xuICAgICAgdGhpcy5yb3RhdGlvbi5jb3B5KHNvdXJjZS5yb3RhdGlvbik7XG4gICAgICB0aGlzLnF1YXRlcm5pb24uY29weShzb3VyY2UucXVhdGVybmlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIE1ha2UgYSBjbG9uZSBvZiB0aGlzIENhbWVyYUNvbXBvbmVudCB1c2luZyBgLmNvcHkoKWBcbiAgICogQHJldHVybiB7Q2FtZXJhQ29tcG9uZW50fSBjbG9uZSBvZiB0aGlzIG9iamVjdFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3Ioe2J1aWxkOiBmYWxzZX0pLmNvcHkodGhpcyk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQ2FtZXJhQ29tcG9uZW50XG59O1xuIiwiZXhwb3J0IGNvbnN0IHN5c3RlbSA9IHtcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvd1xufTtcbiIsImltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7c3lzdGVtfSBmcm9tICcuLi9wb2x5ZmlsbCc7XG5pbXBvcnQge01vZHVsZVN5c3RlbX0gZnJvbSAnLi9Nb2R1bGVTeXN0ZW0nO1xuaW1wb3J0IHtNb2R1bGVNYW5hZ2VyfSBmcm9tICcuL01vZHVsZU1hbmFnZXInO1xuXG4vKipcbiAqIEBjbGFzcyBBcHBcbiAqIEBjYXRlZ29yeSBjb3JlXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBwcmVwYXJlIGEgd29ybGQgc2NlbmUsIHNldHVwIHBoeXNpY3MsIGNhbWVyYSwgcmVuZGVyZXIgYW5kIGFsbCBvdGhlciB0aGluZ3MgdGhhdCB5b3UgdXN1YWxseSBkbyBiZWZvcmUgbWFraW5nIG1lc2hlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFttb2R1bGVzPVtdXSAtIEFycmF5IG9mIE1vZHVsZXNcbiAqIEBleHRlbmRzIE1vZHVsZVN5c3RlbVxuICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlXG4gKi9cbmNsYXNzIEFwcCBleHRlbmRzIE1vZHVsZVN5c3RlbSB7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gRGVmaW5lcyB3aGV0aGVyIHRoZSBzY2VuZSBzaG91bGQgcmVuZGVyIG9yIG5vdFxuICAgKiBAbWVtYmVyIHtCb29sZWFufSBtb2R1bGU6Y29yZS5BcHAjZW5hYmxlZFxuICAgKiBAcHVibGljXG4gICAqL1xuICBlbmFibGVkID0gdHJ1ZTtcblxuICAvKipcbiAgICogTG9vcHMgaW4gdGhpcyBhcHBcbiAgICogQGRlc2NyaXB0aW9uIEFycmF5IG9mIGxvb3BzIHRoYXQgYXJlIGV4ZWN1dGVkIGJ5IHRoaXMgYXBwLlxuICAgKiBAbWVtYmVyIHtBcnJheX0gbW9kdWxlOmNvcmUuQXBwI2xvb3BzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGxvb3BzID0gW107XG5cbiAgY29uc3RydWN0b3IobW9kdWxlcyA9IFtdKSB7XG4gICAgY29uc29sZS5sb2coYFdIUy5BcHAgJHt2ZXJzaW9ufWApO1xuXG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTW9kdWxlTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuXG4gICAgdGhpcy5pbnRlZ3JhdGVNb2R1bGVzKCk7XG4gIH1cblxuICAvLyBDT05UUk9MUyAmIFVQREFUSU5HXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc3RhcnRcbiAgICogQGRlc2NyaXB0aW9uIFN0YXJ0IHJlbmRlcmluZyBsb29wIGFuZCBwaHlzaWNzIHNpbXVsYXRpb24gKGlmIHlvdSB1c2UgdmVyc2lvbiB3aXRoIHBoeXNpY3MpLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQXBwXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKCgpID0+IHtcbiAgICAgIHJldHVybiBzeXN0ZW0ud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICB8fCBzeXN0ZW0ud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICB8fCBzeXN0ZW0ud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICB8fCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBzeXN0ZW0ud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IHtsb29wcywgZW5hYmxlZH0gPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgIHJlcXVlc3RBbmltRnJhbWUocHJvY2Vzcyk7XG4gICAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxsID0gbG9vcHMubGVuZ3RoOyBpIDwgbGw7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbG9vcHNbaV07XG4gICAgICAgIGlmIChlLmVuYWJsZWQpIGUuZXhlY3V0ZShlLmNsb2NrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHN0b3BcbiAgICogQGRlc2NyaXB0aW9uIFN0b3BzIHJlbmRlcmluZyBsb29wc1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQXBwXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkTG9vcFxuICAgKiBAZGVzY3JpcHRpb24gQWRkcyBsb29wIHRvIHRoaXMgYXBwLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9vcCAtIHRoZSBsb29wIHRvIGFkZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiBwcm9taXNlcyBjb21wbGV0ZWQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5BcHBcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+QWRkaW5nIGEgbG9vcCB0byBhbiBhcHA8L2NhcHRpb24+XG4gICAqIGNvbnN0IGxvb3AgPSBuZXcgTG9vcCgoKSA9PiB7XG4gICAqICAvLyAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IGFwcCA9IG5ldyBBcHAoKTtcbiAgICpcbiAgICogYXBwLmFkZExvb3AobG9vcCk7XG4gICAqIGxvb3Auc3RhcnQoKTtcbiAgICovXG4gIGFkZExvb3AobG9vcCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMubG9vcHMucHVzaChsb29wKTtcbiAgICAgIHJlc29sdmUobG9vcCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVMb29wXG4gICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGxvb3AgZnJvbSB0aGlzIGFwcC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGxvb3AgLSB0aGUgbG9vcCB0byByZW1vdmVcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gcHJvbWlzZXMgY29tcGxldGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvcmUuQXBwXG4gICAqL1xuICByZW1vdmVMb29wKGxvb3ApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubG9vcHMuaW5kZXhPZihsb29wKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHRoaXMubG9vcHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgcmVzb2x2ZShsb29wKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldChrZXkpO1xuICB9XG5cbiAgdXNlKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hbmFnZXIudXNlKGtleSk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQXBwXG59O1xuIiwiaW1wb3J0IHtDbG9ja30gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIEBjbGFzcyBMb29wXG4gKiBAY2F0ZWdvcnkgY29yZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDbG9jaz10cnVlXSBwYXNzZXMgYSBDbG9jayB0byB0aGUgZnVuY3Rpb24gd2hlbiBjYWxsZWQsIGlmIHRydWVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZVxuICovXG5jbGFzcyBMb29wIHtcbiAgY29uc3RydWN0b3IoZnVuYywgdXNlQ2xvY2sgPSB0cnVlKSB7XG4gICAgdGhpcy5mdW5jID0gZnVuYztcbiAgICB0aGlzLmNsb2NrID0gdXNlQ2xvY2sgPyBuZXcgQ2xvY2soKSA6IG51bGw7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBDT05UUk9MU1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gU3RhcnRzIHRoaXMgbG9vcCwgY2xvY2sgaWYgaXQgaGFzIG9uZS4gV29uJ3QgZG8gYW55dGhpbmcgaWYgbG9vcCBlbmFibGVkIGFscmVhZHkuXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBbd29ybGRdIGFwcCB0byBhZGQgdGhpcyBsb29wIHRvLCBpZiBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb3JlLkxvb3BcbiAgICovXG4gIHN0YXJ0KHdvcmxkKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgaWYgKHdvcmxkKSB3b3JsZC5hZGRMb29wKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuY2xvY2spIHRoaXMuY2xvY2suc3RhcnQoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc3RvcFxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFN0b3BzIHRoaXMgbG9vcCBhbmQgaXRzIGNsb2NrIGlmIGl0IGhhcyBvbmUsIHdvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgbG9vcCBpcyBub3QgZW5hYmxlZClcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IFt3b3JsZF0gYXBwIHRvIHJlbW92ZSB0aGlzIGxvb3AgZnJvbSwgaWYgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Mb29wXG4gICAqL1xuICBzdG9wKHdvcmxkKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmNsb2NrKSB0aGlzLmNsb2NrLnN0b3AoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGlmICh3b3JsZCkgd29ybGQucmVtb3ZlTG9vcCh0aGlzKTtcbiAgfVxuXG4gIC8vIEVYRUNVVElPTlxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGV4ZWN1dGVcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gb2YgdGhpcyBsb29wXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29yZS5Mb29wXG4gICAqIEByZXR1cm5zIHsqfSB3aGF0ZXZlciB0aGUgZnVuY3Rpb24gb2YgdGhpcyBsb29wIHJldHVybnNcbiAgICovXG4gIGV4ZWN1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVuYyh0aGlzLmNsb2NrKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBMb29wXG59O1xuIiwiLyoqIEBtb2R1bGUgY29yZSAqL1xuZXhwb3J0ICogZnJvbSAnLi9Db21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9NZXNoQ29tcG9uZW50JztcbmV4cG9ydCAqIGZyb20gJy4vTGlnaHRDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9DYW1lcmFDb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9BcHAnO1xuZXhwb3J0ICogZnJvbSAnLi9Mb29wJztcbmV4cG9ydCAqIGZyb20gJy4vTW9kdWxlTWFuYWdlcic7XG4iLCJpbXBvcnQge0FtYmllbnRMaWdodCBhcyBBbWJpZW50TGlnaHROYXRpdmV9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBBbWJpZW50TGlnaHRcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL2xpZ2h0c1xuICogQGRlc2NyaXB0aW9uIEFtYmllbnRMaWdodCBpcyBhIHNpbXBsZSBjbGFzcywgaXQgZXh0ZW5kcyBMaWdodCBhbmQgaW5oZXJpdHMgYWxsIGl0cyBtZXRob2RzLlxuICogQW1iaWVudExpZ2h0IGNyZWF0ZXMgYmFzaWMgbGlnaHQgYXJvdW5kIGFsbCBzY2VuZSwgc28gaXQgZG9lc24ndCBuZWVkIHByb3BlcnRpZXMgbGlrZSBwb3Mgb3IgdGFyZ2V0LlxuICogSXQgc3VwcG9ydHMgb25seSBjb2xvciBhbmQgaW50ZW5zaXR5IGFzIHBhcmFtZXRlcnMsIHdoaWNoIGRlZmluZXMgdGhlIGNvbG9yIG9mIHRoZSBzdXJyb3VuZGVkIGxpZ2h0IGFuZCBpbnRlbnNpdHkgb2YgbGlnaHQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17bGlnaHQ6IHtjb2xvcjogMHhmZmZmZmYsIGludGVuc2l0eTogMX19XSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5MaWdodENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL2xpZ2h0c1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYW4gQW1iaWVudExpZ2h0IDwvY2FwdGlvbj5cbiAqIG5ldyBBbWJpZW50TGlnaHQoe1xuICogICBjb2xvcjogMHhmZmZmZmYsXG4gKiAgIGludGVuc2l0eTogMC4yXG4gKiB9KS5hZGRUbyh3b3JsZCk7XG4gKi9cbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIExpZ2h0Q29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkxpZ2h0Q29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIGludGVuc2l0eTogMVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBBbWJpZW50TGlnaHQuZGVmYXVsdHMpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bGlnaHQ6IG5ldyBBbWJpZW50TGlnaHROYXRpdmUoXG4gICAgICBwYXJhbXMuY29sb3IsXG4gICAgICBwYXJhbXMuaW50ZW5zaXR5XG4gICAgKX0pLmxpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEFtYmllbnRMaWdodFxufTtcbiIsImltcG9ydCB7RGlyZWN0aW9uYWxMaWdodCBhcyBEaXJlY3Rpb25hbExpZ2h0TmF0aXZlLCBEaXJlY3Rpb25hbExpZ2h0SGVscGVyfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0xpZ2h0Q29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0xpZ2h0Q29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgRGlyZWN0aW9uYWxMaWdodFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZGVzY3JpcHRpb24gRGlyZWN0aW5hbExpZ2h0IGNyZWF0ZXMgYSBsaWdodCB0aGF0IHNoaW5lcyBmcm9tIGEgc3BlY2lmaWMgZGlyZWN0aW9uIG5vdCBmcm9tIGEgc3BlY2lmaWMgcG9zaXRpb24uPGJyLz48YnIvPlxuICogVGhpcyBsaWdodCB3aWxsIGJlaGF2ZSBhcyB0aG91Z2ggaXQgaXMgaW5maW5pdGVseSBmYXIgYXdheSBhbmQgdGhlIHJheXMgcHJvZHVjZWQgZnJvbSBpdCBhcmUgYWxsIHBhcmFsbGVsLiA8YnIvPjxici8+XG4gKiBUaGUgYmVzdCBhbmFsb2d5IHdvdWxkIGJlIGEgbGlnaHQgc291cmNlIHRoYXQgYWN0cyBsaWtlIHRoZSBzdW46IHRoZSBzdW4gaXMgc28gZmFyIGF3YXkgdGhhdCBhbGwgc3VubGlnaHQgaGl0dGluZyBvYmplY3RzIGNvbWVzIGZyb20gdGhlIHNhbWUgYW5nbGUuPGJyLz48YnIvPlxuICogSXQgaGFzIHRoZSBzYW1lIG9wdGlvbnMgYXMgQW1iaWVudExpZ2h0IGluIGxpZ2h0IHBhcmFtYXRlciwgYnV0IGl0IGFsc28gc3VwcG9ydHMgcG9zIGFuZCB0YXJnZXQgcGFyYW1hdGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtsaWdodDoge2NvbG9yOiAweGZmZmZmZiwgaW50ZW5zaXR5OiAxfX1dIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIERpcmVjdGlvbmFsTGlnaHQgdG8gZmFsbCBkb3duIGZyb20gdmVjMygxMCwgMjAsIDEwKSB0byB2ZWMzKDAsIDAsIDApPC9jYXB0aW9uPlxuICogbmV3IERpcmVjdGlvbmFsTGlnaHQoe1xuICogICBjb2xvcjogMHhmZmZmZmYsXG4gKiAgIGludGVuc2l0eTogMC4yLFxuICpcbiAqICAgcG9zaXRpb246IFsxMCwgMjAsIDEwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgRGlyZWN0aW9uYWxMaWdodCBleHRlbmRzIExpZ2h0Q29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkxpZ2h0Q29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIGludGVuc2l0eTogMVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBEaXJlY3Rpb25hbExpZ2h0LmRlZmF1bHRzKTtcbiAgICB0aGlzLndyYXBTaGFkb3coKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2xpZ2h0OiBuZXcgRGlyZWN0aW9uYWxMaWdodE5hdGl2ZShcbiAgICAgIHBhcmFtcy5jb2xvcixcbiAgICAgIHBhcmFtcy5pbnRlbnNpdHlcbiAgICApfSkubGlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgRGlyZWN0aW9uYWxMaWdodFxufTtcbiIsImltcG9ydCB7SGVtaXNwaGVyZUxpZ2h0IGFzIEhlbWlzcGhlcmVMaWdodE5hdGl2ZSwgSGVtaXNwaGVyZUxpZ2h0SGVscGVyfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0xpZ2h0Q29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0xpZ2h0Q29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgSGVtaXNwaGVyZUxpZ2h0XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9saWdodHNcbiAqIEBkZXNjcmlwdGlvbiBIZW1pc3BoZXJlTGlnaHQgaXMgYSBsaWdodCBzb3VyY2UgcG9zaXRpb25lZCBkaXJlY3RseSBhYm92ZSB0aGUgc2NlbmUuPGJyLz5cbiAqIEl0IGFsc28gZG9lc24ndCBuZWVkIHBvc2l0aW9uIGFuZCB0YXJnZXQgcHJvcGVydGllcy5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy93ZWJnbF9saWdodHNfaGVtaXNwaGVyZS5odG1sXCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17bGlnaHQ6IHtza3lDb2xvcjogMHhmZmZmZmYsIGdyb3VuZENvbG9yOiAweGZmZmZmZiwgaW50ZW5zaXR5OiAxfX1dIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkxpZ2h0Q29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIEhlbWlzcGhlcmVMaWdodDwvY2FwdGlvbj5cbiAqIG5ldyBIZW1pc3BoZXJlTGlnaHQoe1xuICogICBza3lDb2xvcjogMHhmZjAwMDAsXG4gKiAgIGdyb3VuZENvbG9yOiAweDAwMDBmZixcbiAqICAgaW50ZW5zaXR5OiAwLjJcbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIEhlbWlzcGhlcmVMaWdodCBleHRlbmRzIExpZ2h0Q29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkxpZ2h0Q29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgc2t5Q29sb3I6IDB4ZmZmZmZmLFxuICAgIGdyb3VuZENvbG9yOiAweGZmZmZmZixcbiAgICBpbnRlbnNpdHk6IDFcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBIZW1pc3BoZXJlTGlnaHQuZGVmYXVsdHMpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bGlnaHQ6IG5ldyBIZW1pc3BoZXJlTGlnaHROYXRpdmUoXG4gICAgICBwYXJhbXMuc2t5Q29sb3IsXG4gICAgICBwYXJhbXMuZ3JvdW5kQ29sb3IsXG4gICAgICBwYXJhbXMuaW50ZW5zaXR5XG4gICAgKX0pLmxpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEhlbWlzcGhlcmVMaWdodFxufTtcbiIsImltcG9ydCB7UG9pbnRMaWdodCBhcyBQb2ludExpZ2h0TmF0aXZlLCBQb2ludExpZ2h0SGVscGVyfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0xpZ2h0Q29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0xpZ2h0Q29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgUG9pbnRMaWdodFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbGlnaHRzXG4gKiBAZGVzY3JpcHRpb24gUG9pbnRMaWdodCBjcmVhdGVzIGEgbGlnaHQgYXQgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbiB0aGUgc2NlbmUuIFRoZSBsaWdodCBzaGluZXMgaW4gYWxsIGRpcmVjdGlvbnMgKHJvdWdobHkgc2ltaWxhciB0byBhIGxpZ2h0IGJ1bGIuKTxici8+PGJyLz5cbiAqIEl0IGhhcyB0aGUgc2FtZSBvcHRpb25zIGFzIEFtYmllbnRMaWdodCBpbiBsaWdodCBwYXJhbWF0ZXIsIGJ1dCBpdCBhbHNvIHN1cHBvcnRzIHBvc2l0aW9uLCBkaXN0YW5jZSBhbmQgZGVjYXkuPGJyLz5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXtsaWdodDoge2NvbG9yOiAweGZmZmZmZiwgaW50ZW5zaXR5OiAxLCBkaXN0YW5jZTogMTAwLCBkZWNheTogMX19XSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBMaWdodENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL2xpZ2h0c1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBQb2ludExpZ2h0PC9jYXB0aW9uPlxuICogbmV3IFBvaW50TGlnaHQoIHtcbiAqICAgY29sb3I6IDB4ZmYwMDAwLFxuICogICBpbnRlbnNpdHk6IDIsXG4gKiAgIGRpc3RhbmNlOiAzMDBcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMTAsIDIwLCAxMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFBvaW50TGlnaHQgZXh0ZW5kcyBMaWdodENvbXBvbmVudCB7XG4gIHN0YXRpYyBkZWZhdWx0cz0ge1xuICAgIC4uLkxpZ2h0Q29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIGludGVuc2l0eTogMSxcbiAgICBkaXN0YW5jZTogMTAwLFxuICAgIGRlY2F5OiAxXG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgUG9pbnRMaWdodC5kZWZhdWx0cyk7XG4gICAgdGhpcy53cmFwU2hhZG93KCk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtsaWdodDogbmV3IFBvaW50TGlnaHROYXRpdmUoXG4gICAgICBwYXJhbXMuY29sb3IsXG4gICAgICBwYXJhbXMuaW50ZW5zaXR5LFxuICAgICAgcGFyYW1zLmRpc3RhbmNlLFxuICAgICAgcGFyYW1zLmRlY2F5XG4gICAgKX0pLmxpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFBvaW50TGlnaHRcbn07XG4iLCJpbXBvcnQge1Nwb3RMaWdodCBhcyBTcG90TGlnaHROYXRpdmV9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TGlnaHRDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTGlnaHRDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBTcG90TGlnaHRcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL2xpZ2h0c1xuICogQGRlc2NyaXB0aW9uIFNwb3RMaWdodCBjcmVhdGVzIHNwb3QgbGlnaHQgdGhhdCBjYW4gY2FzdCBzaGFkb3cgaW4gb25lIGRpcmVjdGlvbi4gPGJyLz48YnIvPlxuICogSXQgaGFzIHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgQW1iaWVudExpZ2h0IGluIGxpZ2h0LCBidXQgaXQgYWxzbyBzdXBwb3J0cyBwb3MgYW5kIHRhcmdldC4gPGJyLz48YnIvPlxuICogU3BvdExpZ2h0IGFmZmVjdHMgbWVzaGVzIHdpdGggbGFtYmVydCBhbmQgcGhvbmcgbWF0ZXJpYWwuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvd2ViZ2xfbGlnaHRzX3Nwb3RsaWdodC5odG1sXCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17bGlnaHQ6IHtjb2xvcjogMHhmZmZmZmYsIGludGVuc2l0eTogMSwgZGlzdGFuY2U6IDEwMCwgYW5nbGU6IE1hdGguUEkgLyAzLCBleHBvbmVudDogMCwgZGVjYXk6IDF9fV0gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTGlnaHRDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9saWdodHNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgU3BvdExpZ2h0IHRoYXQgZmFsbHMgZG93biBmcm9tIHZlYzMoMTAsIDIwLCAxMCkgdG8gdmVjMygwLCAwLCAwKTwvY2FwdGlvbj5cbiAqIG5ldyBTcG90TGlnaHQoe1xuICogICBjb2xvcjogMHgwMGZmMDAsXG4gKiAgIGludGVuc2l0eTogMyxcbiAqICAgZGlzdGFuY2U6IDEwMDBcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMTAsIDIwLCAxMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFNwb3RMaWdodCBleHRlbmRzIExpZ2h0Q29tcG9uZW50IHtcbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkxpZ2h0Q29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIGludGVuc2l0eTogMSxcbiAgICBkaXN0YW5jZTogMTAwLFxuICAgIGFuZ2xlOiBNYXRoLlBJIC8gMyxcbiAgICBleHBvbmVudDogMCxcbiAgICBkZWNheTogMVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBTcG90TGlnaHQuZGVmYXVsdHMpO1xuICAgIHRoaXMud3JhcFNoYWRvdygpO1xuICB9XG5cbiAgYnVpbGQocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bGlnaHQ6IG5ldyBTcG90TGlnaHROYXRpdmUoXG4gICAgICBwYXJhbXMuY29sb3IsXG4gICAgICBwYXJhbXMuaW50ZW5zaXR5LFxuICAgICAgcGFyYW1zLmRpc3RhbmNlLFxuICAgICAgcGFyYW1zLmFuZ2xlLFxuICAgICAgcGFyYW1zLmV4cG9uZW50LFxuICAgICAgcGFyYW1zLmRlY2F5XG4gICAgKX0pLmxpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFNwb3RMaWdodFxufTtcbiIsImltcG9ydCB7UmVjdEFyZWFMaWdodCBhcyBSZWN0QXJlYUxpZ2h0TmF0aXZlfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0xpZ2h0Q29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0xpZ2h0Q29tcG9uZW50JztcblxuY2xhc3MgQXJlYUxpZ2h0IGV4dGVuZHMgTGlnaHRDb21wb25lbnQge1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTGlnaHRDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgaW50ZW5zaXR5OiAxLFxuICAgIHdpZHRoOiAxMCxcbiAgICBoZWlnaHQ6IDEwXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEFyZWFMaWdodC5kZWZhdWx0cyk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtsaWdodDogbmV3IFJlY3RBcmVhTGlnaHROYXRpdmUoXG4gICAgICBwYXJhbXMuY29sb3IsXG4gICAgICBwYXJhbXMuaW50ZW5zaXR5LFxuICAgICAgcGFyYW1zLndpZHRoLFxuICAgICAgcGFyYW1zLmhlaWdodFxuICAgICl9KS5saWdodDtcbiAgfVxufVxuXG5leHBvcnQge1xuICBBcmVhTGlnaHRcbn07XG4iLCIvKiogQG1vZHVsZSBjb21wb25lbnRzL2xpZ2h0cyAqL1xuZXhwb3J0ICogZnJvbSAnLi9BbWJpZW50TGlnaHQnO1xuZXhwb3J0ICogZnJvbSAnLi9EaXJlY3Rpb25hbExpZ2h0JztcbmV4cG9ydCAqIGZyb20gJy4vSGVtaXNwaGVyZUxpZ2h0JztcbmV4cG9ydCAqIGZyb20gJy4vUG9pbnRMaWdodCc7XG5leHBvcnQgKiBmcm9tICcuL1Nwb3RMaWdodCc7XG5leHBvcnQgKiBmcm9tICcuL0FyZWFMaWdodCc7XG4iLCJpbXBvcnQge0N1YmVDYW1lcmEgYXMgQ3ViZUNhbWVyYU5hdGl2ZX0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHtDYW1lcmFDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvQ2FtZXJhQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgQ3ViZUNhbWVyYVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvY2FtZXJhc1xuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgNiBjYW1lcmFzIHRoYXQgcmVuZGVyIHRvIGEgV2ViR0xSZW5kZXJUYXJnZXRDdWJlXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1ldGVycyBvYmplY3QuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvY2FtZXJhc1xuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuQ2FtZXJhQ29tcG9uZW50XG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGVzIGEgQ3ViZUNhbWVyYSBhbmQgc2V0IGl0IGFzIGFwcCdzIGNhbWVyYTwvY2FwdGlvbj5cbiAqIGNvbnN0IGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKHtcbiAqICAgY2FtZXJhOiB7XG4gKiAgICAgY3ViZVJlc29sdXRpb246IDI1NlxuICogICB9LFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB4OiAwLFxuICogICAgIHk6IDEwMCxcbiAqICAgICB6OiAwXG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGFwcC5jYW1lcmEgPSBjYW1lcmE7XG4gKi9cbmNsYXNzIEN1YmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmFDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL2NhbWVyYXMuQ3ViZUNhbWVyYSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBjYW1lcmE6IHtcbiAgICogICAgIG5lYXI6IDEsXG4gICAqICAgICBmYXI6IDEwMDAsXG4gICAqICAgICBjdWJlUmVzb2x1dGlvbjogMTI4XG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uQ2FtZXJhQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgbmVhcjogMSxcbiAgICBmYXI6IDEwMDAsXG4gICAgY3ViZVJlc29sdXRpb246IDEyOFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBDdWJlQ2FtZXJhLmRlZmF1bHRzKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2NhbWVyYTogbmV3IEN1YmVDYW1lcmFOYXRpdmUoXG4gICAgICBwYXJhbXMubmVhcixcbiAgICAgIHBhcmFtcy5mYXIsXG4gICAgICBwYXJhbXMuY3ViZVJlc29sdXRpb25cbiAgICApfSkuY2FtZXJhO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEN1YmVDYW1lcmFcbn07XG4iLCJpbXBvcnQge09ydGhvZ3JhcGhpY0NhbWVyYSBhcyBPcnRob2dyYXBoaWNDYW1lcmFOYXRpdmV9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7Q2FtZXJhQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0NhbWVyYUNvbXBvbmVudCc7XG5pbXBvcnQge3N5c3RlbX0gZnJvbSAnLi4vLi4vcG9seWZpbGwnO1xuXG4vKipcbiAqIEBjbGFzcyBPcnRob2dyYXBoaWNDYW1lcmFcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL2NhbWVyYXNcbiAqIEBkZXNjcmlwdGlvbiBDYW1lcmEgd2l0aCBvcnRob2dyYXBoaWMgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIG9iamVjdC5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9jYW1lcmFzXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5DYW1lcmFDb21wb25lbnRcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0ZSBhbiBPcnRob2dyYXBoaWNDYW1lcmEgYW5kIHNldCBpdCBhcyBhcHAncyBjYW1lcmE8L2NhcHRpb24+XG4gKiBjb25zdCBjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKHtcbiAqICAgY2FtZXJhOiB7XG4gKiAgICAgZmFyOiAxMDAwMFxuICogICB9LFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB5OiA1MFxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBhcHAuY2FtZXJhID0gY2FtZXJhO1xuICovXG5jbGFzcyBPcnRob2dyYXBoaWNDYW1lcmEgZXh0ZW5kcyBDYW1lcmFDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9jYW1lcmFzLk9ydGhvZ3JhcGhpY0NhbWVyYSNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBuZWFyOiAxLFxuICAgKiAgIGZhcjogMTAwMCxcbiAgICogICBsZWZ0OiBzeXN0ZW0ud2luZG93LmlubmVyV2lkdGggLyAtMixcbiAgICogICByaWdodDogc3lzdGVtLndpbmRvdy5pbm5lcldpZHRoIC8gMixcbiAgICogICB0b3A6IHN5c3RlbS53aW5kb3cuaW5uZXJIZWlnaHQgLyAyLFxuICAgKiAgIGJvdHRvbTogc3lzdGVtLndpbmRvdy5pbm5lckhlaWdodCAvIC0yXG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5DYW1lcmFDb21wb25lbnQuZGVmYXVsdHMsXG5cbiAgICBuZWFyOiAxLFxuICAgIGZhcjogMTAwMCxcbiAgICBsZWZ0OiBzeXN0ZW0ud2luZG93LmlubmVyV2lkdGggLyAtMixcbiAgICByaWdodDogc3lzdGVtLndpbmRvdy5pbm5lcldpZHRoIC8gMixcbiAgICB0b3A6IHN5c3RlbS53aW5kb3cuaW5uZXJIZWlnaHQgLyAyLFxuICAgIGJvdHRvbTogc3lzdGVtLndpbmRvdy5pbm5lckhlaWdodCAvIC0yXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIE9ydGhvZ3JhcGhpY0NhbWVyYS5kZWZhdWx0cyk7XG4gIH1cblxuICBidWlsZChwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtjYW1lcmE6IG5ldyBPcnRob2dyYXBoaWNDYW1lcmFOYXRpdmUoXG4gICAgICBwYXJhbXMubGVmdCxcbiAgICAgIHBhcmFtcy5yaWdodCxcbiAgICAgIHBhcmFtcy50b3AsXG4gICAgICBwYXJhbXMuYm90dG9tLFxuICAgICAgcGFyYW1zLm5lYXIsXG4gICAgICBwYXJhbXMuZmFyXG4gICAgKX0pLmNhbWVyYTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBPcnRob2dyYXBoaWNDYW1lcmFcbn07XG4iLCJpbXBvcnQge1BlcnNwZWN0aXZlQ2FtZXJhIGFzIFBlcnNwZWN0aXZlQ2FtZXJhTmF0aXZlfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQge0NhbWVyYUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9DYW1lcmFDb21wb25lbnQnO1xuaW1wb3J0IHtzeXN0ZW19IGZyb20gJy4uLy4uL3BvbHlmaWxsJztcblxuLyoqXG4gKiBAY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmFcbiAqIEBkZXNjcmlwdGlvbiBDYW1lcmEgd2l0aCBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uLlxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvY2FtZXJhc1xuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL2NhbWVyYXNcbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLkNhbWVyYUNvbXBvbmVudFxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGFuIFBlcnNwZWN0aXZlQ2FtZXJhIGFuZCBzZXQgaXQgYXMgYXBwJ3MgY2FtZXJhPC9jYXB0aW9uPlxuICogY29uc3QgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKHtcbiAqICAgZm92OiA3NSxcbiAqICAgYXNwZWN0OiB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCxcbiAqXG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgeDogMCxcbiAqICAgICB5OiAxMDAsXG4gKiAgICAgejogMFxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBhcHAuY2FtZXJhID0gY2FtZXJhO1xuICovXG5jbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYSBleHRlbmRzIENhbWVyYUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL2NhbWVyYXMuUGVyc3BlY3RpdmVDYW1lcmEjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgbmVhcjogMSxcbiAgICogICBmYXI6IDEwMDAsXG4gICAqICAgZm92OiA3NSxcbiAgICogICBhc3BlY3Q6IHN5c3RlbS53aW5kb3cuaW5uZXJXaWR0aCAvIHN5c3RlbS53aW5kb3cuaW5uZXJIZWlnaHRcbiAgICogfTwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLkNhbWVyYUNvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIG5lYXI6IDEsXG4gICAgZmFyOiAxMDAwLFxuICAgIGZvdjogNzUsXG4gICAgYXNwZWN0OiBzeXN0ZW0ud2luZG93LmlubmVyV2lkdGggLyBzeXN0ZW0ud2luZG93LmlubmVySGVpZ2h0XG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFBlcnNwZWN0aXZlQ2FtZXJhLmRlZmF1bHRzKTtcbiAgfVxuXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe2NhbWVyYTogbmV3IFBlcnNwZWN0aXZlQ2FtZXJhTmF0aXZlKFxuICAgICAgcGFyYW1zLmZvdixcbiAgICAgIHBhcmFtcy5hc3BlY3QsXG4gICAgICBwYXJhbXMubmVhcixcbiAgICAgIHBhcmFtcy5mYXJcbiAgICApfSkuY2FtZXJhO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFBlcnNwZWN0aXZlQ2FtZXJhXG59O1xuIiwiLyoqIEBtb2R1bGUgY29tcG9uZW50cy9jYW1lcmFzICovXG5leHBvcnQgKiBmcm9tICcuL0N1YmVDYW1lcmEnO1xuZXhwb3J0ICogZnJvbSAnLi9PcnRob2dyYXBoaWNDYW1lcmEnO1xuZXhwb3J0ICogZnJvbSAnLi9QZXJzcGVjdGl2ZUNhbWVyYSc7XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBCb3hCdWZmZXJHZW9tZXRyeSxcbiAgQm94R2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEJveFxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gQXMgdG9sZCBvbiBDb21wb25lbnQgZGVmaW5pdGlvbiwgd2hpbGUgeW91IGNhbiBwYXNzIGFueSBvZiB0aGUgaW5oZXJpdGVkIHBhcmFtcyBmb3IgdGhpcyBjb21wb25lbnQgY29uc3RydWN0aW9uLCB5b3Ugd2lsbCBuZWVkIHRvXG4gKiBwYXNzIHNwZWNpZmljIHBhcmFtZXRlcnMgdG8gYnVpbGQgdGhpcyBtZXNoIGFzIGEgZ2VvbWV0cnkgb2JqZWN0LlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNCb3hHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgQm94LCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqICBuZXcgQm94KHtcbiAqICAgIGdlb21ldHJ5OiB7XG4gKiAgICAgIHdpZHRoOiAyLFxuICogICAgICBoZWlnaHQ6IDIsXG4gKiAgICAgIGRlcHRoOiAyXG4gKiAgICB9LFxuICpcbiAqICAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgIH0pLFxuICpcbiAqICAgIHBvc2l0aW9uOiBbNTAsIDYwLCA3MF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIEJveCBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Cb3gjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHdpZHRoOiAxLFxuICAgKiAgICAgaGVpZ2h0OiAxLFxuICAgKiAgICAgZGVwdGg6IDEsXG4gICAqICAgICB3aWR0aFNlZ21lbnRzOiAxLFxuICAgKiAgICAgaGVpZ2h0U2VnbWVudHM6IDEsXG4gICAqICAgICBkZXB0aFNlZ21lbnRzOiAxXG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICBkZXB0aDogMSxcbiAgICAgIHdpZHRoU2VnbWVudHM6IDEsXG4gICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICAgIGRlcHRoU2VnbWVudHM6IDFcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Cb3gjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgZ2VvbWV0cnk6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2RlcHRoJywgJ3dpZHRoU2VnbWVudHMnLCAnaGVpZ2h0U2VnbWVudHMnLCAnZGVwdGhTZWdlbWVudHMnXVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWyd3aWR0aCcsICdoZWlnaHQnLCAnZGVwdGgnLCAnd2lkdGhTZWdtZW50cycsICdoZWlnaHRTZWdtZW50cycsICdkZXB0aFNlZ2VtZW50cyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEJveC5kZWZhdWx0cywgQm94Lmluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkJveFxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IChwYXJhbXMuYnVmZmVyID8gQm94QnVmZmVyR2VvbWV0cnkgOiBCb3hHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkud2lkdGgsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmRlcHRoLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LndpZHRoU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0U2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuZGVwdGhTZWdtZW50c1xuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgQm94XG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgQ2lyY2xlQnVmZmVyR2VvbWV0cnksXG4gIENpcmNsZUdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBDaXJjbGVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEFzIHRvbGQgb24gQ29tcG9uZW50IGRlZmluaXRpb24sIHdoaWxlIHlvdSBjYW4gcGFzcyBhbnkgb2YgdGhlIGluaGVyaXRlZCBwYXJhbXMgZm9yIHRoaXMgY29tcG9uZW50IGNvbnN0cnVjdGlvbiwgeW91IHdpbGwgbmVlZCB0b1xuICogcGFzcyBzcGVjaWZpYyBwYXJhbWV0ZXJzIHRvIGJ1aWxkIHRoaXMgbWVzaCBhcyBhIGdlb21ldHJ5IG9iamVjdC5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjQ2lyY2xlR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIENpcmNsZSwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiAgbmV3IENpcmNsZSh7XG4gKiAgICBnZW9tZXRyeToge1xuICogICAgICByYWRpdXM6IDQsXG4gKiAgICAgIHNlZ21lbnRzOiAxNlxuICogICAgfSxcbiAqXG4gKiAgICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgICB9KSxcbiAqXG4gKiAgICBwb3NpdGlvbjogWzUwLCA2MCwgNzBdXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQ2lyY2xlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDUwLFxuICAgKiAgICAgc2VnbWVudHM6IDgsXG4gICAqICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgKiAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDUwLFxuICAgICAgc2VnbWVudHM6IDgsXG4gICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQ2lyY2xlI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IGdlb21ldHJ5OiBbJ3JhZGl1cycsICdzZWdtZW50cycsICd0aGV0YVN0YXJ0JywgJ3RoZXRhTGVuZ3RoJ11cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ3NlZ21lbnRzJywgJ3RoZXRhU3RhcnQnLCAndGhldGFMZW5ndGgnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBDaXJjbGUuZGVmYXVsdHMsIENpcmNsZS5pbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5DaXJjbGVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyAocGFyYW1zLmJ1ZmZlciA/IENpcmNsZUJ1ZmZlckdlb21ldHJ5IDogQ2lyY2xlR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5zZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50aGV0YVN0YXJ0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBDaXJjbGVcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBDb25lQnVmZmVyR2VvbWV0cnksXG4gIENvbmVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgQ29uZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gQSBjeWxpbmRlciBpcyBvbmUgb2YgdGhlIG1vc3QgYmFzaWMgY3VydmlsaW5lYXIgZ2VvbWV0cmljIHNoYXBlcywgdGhlIHN1cmZhY2UgZm9ybWVkIGJ5IHRoZSBwb2ludHMgYXQgYSBmaXhlZCBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RyYWlnaHQgbGluZSwgdGhlIGF4aXMgb2YgdGhlIGN5bGluZGVyLiA8YnIvPjxici8+XG4gKiBUaGUgc29saWQgZW5jbG9zZWQgYnkgdGhpcyBzdXJmYWNlIGFuZCBieSB0d28gcGxhbmVzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGF4aXMgaXMgYWxzbyBjYWxsZWQgYSBjeWxpbmRlci48YnIvPlxuICogVGhlIHN1cmZhY2UgYXJlYSBhbmQgdGhlIHZvbHVtZSBvZiBhIGN5bGluZGVyIGhhdmUgYmVlbiBrbm93biBzaW5jZSBkZWVwIGFudGlxdWl0eS5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjQ29uZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBDb25lLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBDb25lKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXNUb3A6IDIsXG4gKiAgICAgcmFkaXVzQm90dG9tOiA0LFxuICogICAgIGhlaWdodDogNVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zOiBbMCwgMTAwLCAwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgQ29uZSBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Db25lI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDIwLFxuICAgKiAgICAgaGVpZ2h0OiAxMDAsXG4gICAqICAgICByYWRpdXNTZWdtZW50czogMzIsXG4gICAqICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICogICAgIG9wZW5FbmRlZDogZmFsc2UsXG4gICAqICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgKiAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcblxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDIwLFxuICAgICAgaGVpZ2h0OiAxMDAsXG4gICAgICByYWRpdXNTZWdtZW50czogMzIsXG4gICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICAgIG9wZW5FbmRlZDogZmFsc2UsXG4gICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQ29uZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiBnZW9tZXRyeTogW1xuICAgKiAgICdyYWRpdXMnLFxuICAgKiAgICdoZWlnaHQnLFxuICAgKiAgICdyYWRpdXNTZWdtZW50cycsXG4gICAqICAgJ2hlaWdodFNlZ21lbnRzJyxcbiAgICogICAnb3BlbkVuZGVkJyxcbiAgICogICAndGhldGFTdGFydCcsXG4gICAqICAgJ3RoZXRhTGVuZ3RoJ1xuICAgKiBdXG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogW1xuICAgICAgJ3JhZGl1cycsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgICdyYWRpdXNTZWdtZW50cycsXG4gICAgICAnaGVpZ2h0U2VnbWVudHMnLFxuICAgICAgJ29wZW5FbmRlZCcsXG4gICAgICAndGhldGFTdGFydCcsXG4gICAgICAndGhldGFMZW5ndGgnXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBDb25lLmRlZmF1bHRzLCBDb25lLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Db25lXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgKHBhcmFtcy5idWZmZXIgPyBDb25lQnVmZmVyR2VvbWV0cnkgOiBDb25lR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0U2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkub3BlbkVuZGVkLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhU3RhcnQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFMZW5ndGhcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIENvbmVcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LFxuICBDeWxpbmRlckdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBDeWxpbmRlclxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gQSBjeWxpbmRlciBpcyBvbmUgb2YgdGhlIG1vc3QgYmFzaWMgY3VydmlsaW5lYXIgZ2VvbWV0cmljIHNoYXBlcywgdGhlIHN1cmZhY2UgZm9ybWVkIGJ5IHRoZSBwb2ludHMgYXQgYSBmaXhlZCBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RyYWlnaHQgbGluZSwgdGhlIGF4aXMgb2YgdGhlIGN5bGluZGVyLiA8YnIvPjxici8+XG4gKiBUaGUgc29saWQgZW5jbG9zZWQgYnkgdGhpcyBzdXJmYWNlIGFuZCBieSB0d28gcGxhbmVzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGF4aXMgaXMgYWxzbyBjYWxsZWQgYSBjeWxpbmRlci48YnIvPlxuICogVGhlIHN1cmZhY2UgYXJlYSBhbmQgdGhlIHZvbHVtZSBvZiBhIGN5bGluZGVyIGhhdmUgYmVlbiBrbm93biBzaW5jZSBkZWVwIGFudGlxdWl0eS5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjQ3lsaW5kZXJHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgQ3lsaW5kZXIsIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IEN5bGluZGVyKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXNUb3A6IDIsXG4gKiAgICAgcmFkaXVzQm90dG9tOiA0LFxuICogICAgIGhlaWdodDogNVxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zOiBbMCwgMTAwLCAwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgQ3lsaW5kZXIgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuQ3lsaW5kZXIjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1c1RvcDogMjAsXG4gICAqICAgICByYWRpdXNCb3R0b206IDIwLFxuICAgKiAgICAgaGVpZ2h0OiAxMDAsXG4gICAqICAgICByYWRpdXNTZWdtZW50czogMzIsXG4gICAqICAgICBoZWlnaHRTZWdtZW50czogMSxcbiAgICogICAgIG9wZW5FbmRlZDogZmFsc2UsXG4gICAqICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgKiAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAqICAgfVxuICAgKiB9PC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgcmFkaXVzVG9wOiAwLFxuICAgICAgcmFkaXVzQm90dG9tOiAxLFxuICAgICAgaGVpZ2h0OiAxLFxuICAgICAgcmFkaXVzU2VnbWVudHM6IDMyLFxuICAgICAgaGVpZ2h0U2VnbWVudHM6IDEsXG4gICAgICBvcGVuRW5kZWQ6IGZhbHNlLFxuICAgICAgdGhldGFTdGFydDogMCxcbiAgICAgIHRoZXRhTGVuZ3RoOiBNYXRoLlBJICogMlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkN5bGluZGVyI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIGdlb21ldHJ5OiBbXG4gICAqICAgJ3JhZGl1c1RvcCcsXG4gICAqICAgJ3JhZGl1c0JvdHRvbScsXG4gICAqICAgJ2hlaWdodCcsXG4gICAqICAgJ3JhZGl1c1NlZ21lbnRzJyxcbiAgICogICAnaGVpZ2h0U2VnbWVudHMnLFxuICAgKiAgICdvcGVuRW5kZWQnLFxuICAgKiAgICd0aGV0YVN0YXJ0JyxcbiAgICogICAndGhldGFMZW5ndGgnXG4gICAqIF1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbXG4gICAgICAncmFkaXVzVG9wJyxcbiAgICAgICdyYWRpdXNCb3R0b20nLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAncmFkaXVzU2VnbWVudHMnLFxuICAgICAgJ2hlaWdodFNlZ21lbnRzJyxcbiAgICAgICdvcGVuRW5kZWQnLFxuICAgICAgJ3RoZXRhU3RhcnQnLFxuICAgICAgJ3RoZXRhTGVuZ3RoJ1xuICAgIF1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgQ3lsaW5kZXIuZGVmYXVsdHMsIEN5bGluZGVyLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5DeWxpbmRlclxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IChwYXJhbXMuYnVmZmVyID8gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSA6IEN5bGluZGVyR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1c1RvcCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXNCb3R0b20sXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1c1NlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmhlaWdodFNlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5Lm9wZW5FbmRlZCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50aGV0YVN0YXJ0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhTGVuZ3RoXG4gICAgKTtcblxuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBDeWxpbmRlclxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuICBEb2RlY2FoZWRyb25HZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgRG9kZWNhaGVkcm9uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbiBnZW9tZXRyeSwgYSBkb2RlY2FoZWRyb24gaXMgYW55IHBvbHloZWRyb24gd2l0aCB0d2VsdmUgZmxhdCBmYWNlcy4gPGJyLz48YnIvPlxuICogVGhlIG1vc3QgZmFtaWxpYXIgZG9kZWNhaGVkcm9uIGlzIHRoZSByZWd1bGFyIGRvZGVjYWhlZHJvbiwgd2hpY2ggaXMgYSBQbGF0b25pYyBzb2xpZC4gPGJyLz5cbiAqIFRoZXJlIGFyZSBhbHNvIHRocmVlIHJlZ3VsYXIgc3RhciBkb2RlY2FoZWRyYSwgd2hpY2ggYXJlIGNvbnN0cnVjdGVkIGFzIHN0ZWxsYXRpb25zIG9mIHRoZSBjb252ZXggZm9ybS4gPGJyLz5cbiAqIEFsbCBvZiB0aGVzZSBoYXZlIGljb3NhaGVkcmFsIHN5bW1ldHJ5LCBvcmRlciAxMjAuXG4gKiBEb2RlY2FoZWRyb24gY3JlYXRlcyBEb2RlY2FoZWRyb24gb2JqZWN0IGJ5IGl0J3MgcmFkaXVzIGFuZCBkZXRhaWwuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI0RvZGVjYWhlZHJvbkdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBEb2RlY2FoZWRyb24sIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IERvZGVjYWhlZHJvbih7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcmFkaXVzOiAyXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHk6IDEwXG4gKiAgIH1cbiAgKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBEb2RlY2FoZWRyb24gZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkRvZGVjYWhlZHJvbiNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIGdlb21ldHJ5OiB7XG4gICAqICAgcmFkaXVzOiAxLFxuICAgKiAgIGRldGFpbDogMFxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMSxcbiAgICAgIGRldGFpbDogMFxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkRvZGVjYWhlZHJvbiNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiBnZW9tZXRyeTogWydyYWRpdXMnLCAnZGV0YWlsJ11cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3JhZGl1cycsICdkZXRhaWwnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBEb2RlY2FoZWRyb24uZGVmYXVsdHMsIERvZGVjYWhlZHJvbi5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuRG9kZWNhaGVkcm9uXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5IDogRG9kZWNhaGVkcm9uR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5kZXRhaWxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIERvZGVjYWhlZHJvblxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIEJ1ZmZlckdlb21ldHJ5LFxuICBFeHRydWRlR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEV4dHJ1ZGVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEV4dHJ1ZGUgZ2VvbWV0cnkgbWVhbnMgdGhhdCB5b3UgY2FuIGNyZWF0ZSBhIDNEIG1lc2ggZnJvbSBhbnkgMkQgc2hhcGUgdXNpbmcgdGhyZWUuanMgZ2VvbWV0cnkgYmFzZWQgb24gPGEgaHJlZj0naHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvbWF0aC9WZWN0b3IyJz5USFJFRS5WZWN0b3IyLjwvYT4gPGJyLz5cbiAqIFN1Y2ggaW1wbGVtZW50YXRpb24gd2lsbCBoZWxwIHlvdSB0byBtYWtlIHZvbHVtZWQgc2hhcGVzIHRoYXQgaGF2ZSB0aGVpciBvd24gZGVwdGggYW5kIGNhbiBiZSBzZWVuIGZyb20gYWxsIGFuZ2Vscy48YnIvPjxici8+XG4gKiBZb3UgY2FuIGFsc28gZmluZCBzb21lIGludGVyZXN0aW5nIGV4YW1wbGVzIG1hZGUgdXNpbmcgPGEgaHJlZj0ndGhyZWVqcy5vcmcnPnRocmVlLmpzPC9hPiB3aGljaCBpcyBhIGNvcmUgb2Ygd2hzLmpzLCBzdWNoIGFzOlxuICogLSA8YSBocmVmPSdodHRwOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvd2ViZ2xfZ2VvbWV0cnlfZXh0cnVkZV9zaGFwZXMuaHRtbCc+V2ViZ2wgZ2VvbWV0cnkgZXh0cnVkZTwvYT5cbiAqIC0gPGEgaHJlZj0naHR0cDovL3RocmVlanMub3JnL2V4YW1wbGVzL3dlYmdsX2dlb21ldHJ5X2V4dHJ1ZGVfc2hhcGVzMi5odG1sJz5FeHRydWRlIHNoYXBlcyBmcm9tIGdlb2RhdGE8L2E+XG4gKiAtIDxhIGhyZWY9J2h0dHA6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy93ZWJnbF9nZW9tZXRyeV9leHRydWRlX3NwbGluZXMuaHRtbCc+RXh0cnVkZSBzcGxpbmVzPC9hPlxuICpcbiAqIFN1Y2ggZXhhbXBsZXMgY2FuIGJlIGVhc2lseSBpbXBsZW1lbnRlZCB1c2luZyB3aGl0ZXN0b3JtLmpzIG9yIGl0J3MgcGx1Z2lucy4gVXNlIGBFeHRydWRlYCBjbGFzcyB3aXRoIDxhIGhyZWY9J2h0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2V4dHJhcy9jb3JlL1NoYXBlJz5USFJFRS5TaGFwZTwvYT4gdG8gZ2V0IGV4dHJ1ZGUgZWZmZWN0IG9mIHNoYXBlIGRlZmluZWQgYnkgMkQgdmVjdG9ycy5cbiAqIFRoaXMgY2xhc3MgaXMgc2ltaWxhciB0byA8YSBocmVmPSdodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeSc+VEhSRUUuRXh0cnVkZUdlb21ldHJ5PC9hPixcbiAqIGJ1dCBpdCBhbHNvIGNvbnRhaW5zIGFsbCBwcm9wZXJ0aWVzLCBhcHBsaWVkIGJ5IGBTaGFwZWAsIHN1Y2ggYXMgbWF0ZXJpYWwsIG1hc3MgYW5kIHZlY3RvcnMgbGlrZSBwb3NpdGlvbiAocG9zKSBhbmQgcm90YXRpb24gKHJvdCkuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI0V4dHJ1ZGVHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgc2hhcGUsIHRoZW4gYW4gRXh0cnVkZSBmcm9tIGl0PC9jYXB0aW9uPlxuICogY29uc3Qgc2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoW1xuICogICBuZXcgVEhSRUUuVmVjdG9yMigtNCwtNCksXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IyKC0yLDApLFxuICogICBuZXcgVEhSRUUuVmVjdG9yMigtNCw0KSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoMCwyKSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoNCw0KSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoMiwwKSxcbiAqICAgbmV3IFRIUkVFLlZlY3RvcjIoNCwtNCksXG4gKiAgIG5ldyBUSFJFRS5WZWN0b3IyKDAsLTIpXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBleHRydWRlID0gbmV3IEV4dHJ1ZGUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHNoYXBlczogc2hhcGUsXG4gKiAgICAgb3B0aW9uczoge1xuICogICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcbiAqICAgICAgIGJldmVsU2l6ZTogMCxcbiAqICAgICAgIGFtb3VudDogMlxuICogICAgIH1cbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMCwgMTAwLCAwXVxuICogfSk7XG4gKlxuICogZXh0cnVkZS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBFeHRydWRlIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5FeHRydWRlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICBzaGFwZXM6IFtdLFxuICAgKiAgICAgb3B0aW9uczoge31cbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgc2hhcGVzOiBbXSxcbiAgICAgIG9wdGlvbnM6IHt9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuRXh0cnVkZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsnc2hhcGVzJywgJ29wdGlvbnMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydzaGFwZXMnLCAnb3B0aW9ucyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEV4dHJ1ZGUuZGVmYXVsdHMsIEV4dHJ1ZGUuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkV4dHJ1ZGVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBFeHRydWRlR2VvbWV0cnkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuc2hhcGVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5Lm9wdGlvbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHBhcmFtcy5idWZmZXIgPyBuZXcgQnVmZmVyR2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoZ2VvbWV0cnkpIDogZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgRXh0cnVkZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnksXG4gIEljb3NhaGVkcm9uR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEljb3NhaGVkcm9uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbiBnZW9tZXRyeSwgYW4gaWNvc2FoZWRyb24gaXMgYSBwb2x5aGVkcm9uIHdpdGggMjAgZmFjZXMuPGJyLz5cbiAqIFRoZXJlIGFyZSBtYW55IGtpbmRzIG9mIGljb3NhaGVkcmEsIHdpdGggc29tZSBiZWluZyBtb3JlIHN5bW1ldHJpY2FsIHRoYW4gb3RoZXJzLiBUaGUgbW9zdCB3ZWxsIGtub3duIGlzIHRoZSBQbGF0b25pYywgY29udmV4IHJlZ3VsYXIgaWNvc2FoZWRyb24uPGJyLz5cbiAqIGBJY29zYWhlZHJvbmAgY3JlYXRlcyBhbiBJY29zYWhlZHJvbiBvYmplY3QgYnkgaXRzIHJhZGl1cyBhbmQgZGV0YWlsLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNJY29zYWhlZHJvbkdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBJY29zYWhlZHJvbiwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgSWNvc2FoZWRyb24oe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czogMixcbiAqICAgICBkZXRhaWw6IDFcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMCwgMTAwLCAwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgSWNvc2FoZWRyb24gZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkljb3NhaGVkcm9uI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDEsXG4gICAqICAgICBkZXRhaWw6IDBcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDEsXG4gICAgICBkZXRhaWw6IDBcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5JY29zYWhlZHJvbiNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCB7Z2VvbWV0cnk6IFsncmFkaXVzJywgJ2RldGFpbCddfVxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydyYWRpdXMnLCAnZGV0YWlsJ11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgSWNvc2FoZWRyb24uZGVmYXVsdHMsIEljb3NhaGVkcm9uLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5JY29zYWhlZHJvblxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgKHBhcmFtcy5idWZmZXIgPyBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5IDogSWNvc2FoZWRyb25HZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmRldGFpbFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgSWNvc2FoZWRyb25cbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBMYXRoZUJ1ZmZlckdlb21ldHJ5LFxuICBMYXRoZUdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBMYXRoZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gQSBgTGF0aGVHZW9tZXRyeWAgYWxsb3dzIHlvdSB0byBjcmVhdGUgc2hhcGVzIGZyb20gYSBzbW9vdGggY3VydmUuXG4gKiBUaGlzIGN1cnZlIGlzIGRlZmluZWQgYnkgYSBudW1iZXIgb2YgcG9pbnRzIChhbHNvIGNhbGxlZCBrbm90cykgYW5kIGlzIG1vc3Qgb2Z0ZW4gY2FsbGVkIGEgc3BsaW5lLiBUaGlzIHNwbGluZSBpcyByb3RhdGVkIGFyb3VuZCBhIGZpeGVkIHBvaW50IGFuZCByZXN1bHRzIGluIHZhc2UtIGFuZCBiZWxsLWxpa2Ugc2hhcGVzLjxici8+PGJyLz5cbiAqIEluIDNEIGNvbXB1dGVyIGdyYXBoaWNzLCBhIGxhdGhlZCBvYmplY3QgaXMgYSAzRCBtb2RlbCB3aG9zZSB2ZXJ0ZXggZ2VvbWV0cnkgaXMgcHJvZHVjZWQgYnkgcm90YXRpbmcgdGhlIHBvaW50cyBvZiBhIHNwbGluZSBvciBvdGhlciBwb2ludCBzZXQgYXJvdW5kIGEgZml4ZWQgYXhpcy5cbiAqIFRoZSBsYXRoaW5nIG1heSBiZSBwYXJ0aWFsOyB0aGUgYW1vdW50IG9mIHJvdGF0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBhIGZ1bGwgMzYwIGRlZ3JlZXMuXG4gKiBUaGUgcG9pbnQgc2V0IHByb3ZpZGluZyB0aGUgaW5pdGlhbCBzb3VyY2UgZGF0YSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGNyb3NzIHNlY3Rpb24gdGhyb3VnaCB0aGUgb2JqZWN0IGFsb25nIGEgcGxhbmUgY29udGFpbmluZyBpdHMgYXhpcyBvZiByYWRpYWwgc3ltbWV0cnkuIDxici8+PGJyLz5cbiAqIFRoZSA8YSBocmVmPSdodHRwOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI0xhdGhlR2VvbWV0cnknPmZvbGxvd2luZyBleGFtcGxlPC9hPiBzaG93cyBhIGdlb21ldHJ5IHdoaWNoIGNhbiBiZSBnZW5lcmF0ZWQgdXNpbmcgYExhdGhlYCBjbGFzcy5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjTGF0aGVHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgTGF0aCwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBjb25zdCBwb2ludHMgPSBbXTtcbiAqXG4gKiBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAqICAgcG9pbnRzLnB1c2goXG4gKiAgICAgbmV3IFRIUkVFLlZlY3RvcjIoXG4gKiAgICAgICAoTWF0aC5zaW4oaSAqIDAuNykgKiAxNSArIDUwKSAvIDEwLFxuICogICAgICAgKGkgLSA1KSAqIDAuMlxuICogICAgIClcbiAqICAgKTtcbiAqIH1cbiAqXG4gKiBjb25zdCBsYXRoZSA9IG5ldyBMYXRoZSh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcG9pbnRzOiBwb2ludHNcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMCwgNTAsIDEwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgTGF0aGUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkxhdGhlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICBwb2ludHM6IFtdXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHBvaW50czogW11cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5MYXRoZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPntcbiAgICogICBnZW9tZXRyeTogWydwb2ludHMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydwb2ludHMnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBMYXRoZS5kZWZhdWx0cywgTGF0aGUuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkxhdGhlXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IExhdGhlQnVmZmVyR2VvbWV0cnkgOiBMYXRoZUdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5wb2ludHNcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIExhdGhlXG59O1xuIiwiaW1wb3J0IHtcbiAgTGluZSBhcyBMaW5lTmF0aXZlLFxuICBCdWZmZXJHZW9tZXRyeSxcbiAgR2VvbWV0cnksXG4gIEJ1ZmZlckF0dHJpYnV0ZSxcbiAgTGluZUN1cnZlMyxcbiAgVmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgTGluZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gTGluZSBjb21wb25lbnQgaXMgZ2VuZXJhdGVkIGZyb20gYSBjdXJ2ZS9saW5lIGFuZCBhbW91bnQgb2YgdmVjdG9ycyB0aGF0IHNob3VsZCBiZSB1c2VkIChwb2ludHMpLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgTGluZSwgYW5kIGFkZGluZyB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgTGluZSh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgY3VydmU6IG5ldyBUSFJFRS5MaW5lQ3VydmUzKG5ldyBUSFJFRS5WZWN0b3IzKDEwLCAxMCwgMCksIG5ldyBUSFJFRS5WZWN0b3IzKDEwLCAzMCwgMCkpXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSlcbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIExpbmUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLkxpbmUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgY3VydmU6IG5ldyBMaW5lQ3VydmUzKG5ldyBWZWN0b3IzKDAsIDAsIDApLCBuZXcgVmVjdG9yMygxMCwgMCwgMCkpLFxuICAgKiAgIHBvaW50czogNTBcbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgY3VydmU6IG51bGwsXG4gICAgcG9pbnRzOiA1MFxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuTGluZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPntcbiAgICogICBnZW9tZXRyeTogWydjdXJ2ZScsICdwb2ludHMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydjdXJ2ZScsICdwb2ludHMnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcywgTGluZS5kZWZhdWx0cywgTGluZS5pbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5MaW5lXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IExpbmVOYXRpdmUoZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBwYXJhbXMuYnVmZmVyID8gbmV3IEJ1ZmZlckdlb21ldHJ5KCkgOiBuZXcgR2VvbWV0cnkoKTtcblxuICAgIGlmIChwYXJhbXMuYnVmZmVyKSB7XG4gICAgICBjb25zdCBwcCA9IHBhcmFtcy5jdXJ2ZS5nZXRQb2ludHMocGFyYW1zLnBvaW50cyk7XG4gICAgICBjb25zdCB2ZXJ0cyA9IG5ldyBGbG9hdDMyQXJyYXkocHAubGVuZ3RoICogMyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBwcC5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBjb25zdCBpMyA9IGkgKiAzO1xuXG4gICAgICAgIHZlcnRzW2kzXSA9IHBwW2ldLng7XG4gICAgICAgIHZlcnRzW2kzICsgMV0gPSBwcFtpXS55O1xuICAgICAgICB2ZXJ0c1tpMyArIDJdID0gcHBbaV0uejtcbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUodmVydHMsIDMpKTtcbiAgICB9IGVsc2UgZ2VvbWV0cnkudmVydGljZXMgPSBwYXJhbXMuY3VydmUuZ2V0UG9pbnRzKHBhcmFtcy5wb2ludHMpO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIExpbmVcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBKU09OTG9hZGVyLFxuICBTa2lubmVkTWVzaFxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgSW1wb3J0ZXJcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEltcG9ydGVyIGlzIGEgbG9hZGVyIGZvciBtZXNoZXMgYW5kIGFueSBvdGhlciBkYXRhIHRvIHlvdXIgc2NlbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIEltcG9ydGVyLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBJbXBvcnRlcih7XG4gKiAgIGxvYWRlcjogbmV3IFRIUkVFLk9CSkxvYWRlcigpLFxuICpcbiAqICAgcGFyc2VyKGdlb21ldHJ5LCBtYXRlcmlhbCkgeyAvLyBkYXRhIGZyb20gbG9hZGVyXG4gKiAgICAgcmV0dXJuIG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7IC8vIHNob3VsZCByZXR1cm4geW91ciAubmF0aXZlIChtZXNoIGluIHRoaXMgY2FzZSlcbiAqICAgfSxcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMCwgMTAwLCAwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgSW1wb3J0ZXIgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuSW1wb3J0ZXIjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgdXJsOiAnJyxcbiAgICogICBsb2FkZXI6IG5ldyBKU09OTG9hZGVyKCksXG4gICAqXG4gICAqICAgb25Mb2FkKCkge30sXG4gICAqICAgb25Qcm9ncmVzcygpIHt9LFxuICAgKiAgIG9uRXJyb3IoKSB7fSxcbiAgICpcbiAgICogICB0ZXh0dXJlUGF0aDogbnVsbCxcbiAgICogICB1c2VDdXN0b21NYXRlcmlhbDogZmFsc2UsXG4gICAqXG4gICAqICAgcGFyc2VyKGdlb21ldHJ5LCBtYXRlcmlhbHMpIHtcbiAgICogICAgIHJldHVybiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWxzKTtcbiAgICogICB9XG4gICAqIH08L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuXG4gICAgdXJsOiAnJyxcbiAgICBsb2FkZXI6IG5ldyBKU09OTG9hZGVyKCksXG5cbiAgICBvbkxvYWQoKSB7fSxcbiAgICBvblByb2dyZXNzKCkge30sXG4gICAgLy8gVE9ETyBhZGQgb25Db21wbGV0ZT9cbiAgICBvbkVycm9yKCkge30sXG5cbiAgICB0ZXh0dXJlUGF0aDogbnVsbCxcbiAgICB1c2VDdXN0b21NYXRlcmlhbDogZmFsc2UsXG5cbiAgICBwYXJzZXIoZ2VvbWV0cnksIG1hdGVyaWFsKSB7XG4gICAgICBjb25zdCB7Z2VvbWV0cnk6IGdlb20sIG1hdGVyaWFsOiBtYXR9ID0gdGhpcy5hcHBseUJyaWRnZSh7Z2VvbWV0cnksIG1hdGVyaWFsfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgICAgbWVzaDogZ2VvbS5ib25lcyA/IG5ldyBTa2lubmVkTWVzaChnZW9tLCBtYXQpIDogbmV3IE1lc2goZ2VvbSwgbWF0KVxuICAgICAgfSkubWVzaDtcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9uc1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpbHRlclxuICAgKiBAZGVzY3JpcHRpb24gRGVmYXVsdCB2YWx1ZXMgZm9yIGZpbHRlclxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7VEhSRUUuTWVzaH0gb2JqZWN0IEluc3RhbmNlIGZvciBpdGVyYXRpbmcgdGhyb3VnaCBpdCdzIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXIgRnVuY3Rpb24gd2l0aCBjaGlsZCBhcyBhcmd1bWVudCwgc2hvdWxkIHJldHVybiBhIGJvb2xlYW4gd2hldGhlciBpbmNsdWRlIHRoZSBjaGlsZCBvciBub3QuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IG9iamVjdCB3aXRoIGNoaWxkcmVuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuSW1wb3J0ZXJcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UmVtb3ZpbmcgdW5uZWNlc3NhcnkgbGlnaHRzIGZyb20gY2hpbGRyZW48L2NhcHRpb24+XG4gICAqIG5ldyBJbXBvcnRlcih7XG4gICAqICAgbG9hZGVyOiBuZXcgVEhSRUUuT0JKTG9hZGVyKCksXG4gICAqXG4gICAqICAgcGFyc2UoZ3JvdXApIHsgLy8gZGF0YSBmcm9tIGxvYWRlclxuICAgKiAgICAgcmV0dXJuIEltcG9ydGVyLmZpbHRlcihncm91cCwgY2hpbGQgPT4gIWNoaWxkLmlzTGlnaHQpOyAvLyByZW1vdmUgbGlnaHRzXG4gICAqICAgfSxcbiAgICpcbiAgICogICBwb3NpdGlvbjogWzAsIDEwMCwgMF1cbiAgICogfSkuYWRkVG8oYXBwKTtcbiAgICovXG4gIHN0YXRpYyBmaWx0ZXIob2JqZWN0LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBwcm9jZXNzRmlsdGVyID0gb2JqZWN0ID0+IHtcbiAgICAgIG9iamVjdC5jaGlsZHJlbi5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuKSBwcm9jZXNzRmlsdGVyKGVsKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIoZWwpKSBvYmplY3QuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG5cbiAgICByZXR1cm4gcHJvY2Vzc0ZpbHRlcihvYmplY3QpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIEltcG9ydGVyLmRlZmF1bHRzLCBJbXBvcnRlci5pbnN0cnVjdGlvbnMsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuSW1wb3J0ZXJcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKHBhcmFtcy50ZXh0dXJlUGF0aCkgcGFyYW1zLmxvYWRlci5zZXRUZXh0dXJlUGF0aChwYXJhbXMudGV4dHVyZVBhdGgpO1xuXG4gICAgICBwYXJhbXMubG9hZGVyLmxvYWQocGFyYW1zLnVybCwgKC4uLmRhdGEpID0+IHsgLy8gZ2VvbWV0cnksIG1hdGVyaWFsc1xuICAgICAgICBwYXJhbXMub25Mb2FkKC4uLmRhdGEpO1xuXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHBhcmFtcy5wYXJzZXIuYXBwbHkodGhpcywgZGF0YSk7XG4gICAgICAgIGlmIChwYXJhbXMubWF0ZXJpYWwpIG9iamVjdC5tYXRlcmlhbCA9IHRoaXMuYXBwbHlCcmlkZ2Uoe21hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWx9KS5tYXRlcmlhbDtcblxuICAgICAgICByZXNvbHZlKG9iamVjdCk7XG4gICAgICB9LCBwYXJhbXMub25Qcm9ncmVzcywgcGFyYW1zLm9uRXJyb3IpO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIEltcG9ydGVyXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxuICBPY3RhaGVkcm9uR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIE9jdGFoZWRyb25cbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEluIGdlb21ldHJ5LCBhbiBvY3RhaGVkcm9uIGlzIGEgcG9seWhlZHJvbiB3aXRoIGVpZ2h0IGZhY2VzLlxuICogQSByZWd1bGFyIG9jdGFoZWRyb24gaXMgYSBQbGF0b25pYyBzb2xpZCBjb21wb3NlZCBvZiBlaWdodCBlcXVpbGF0ZXJhbCB0cmlhbmdsZXMsIGZvdXIgb2Ygd2hpY2ggbWVldCBhdCBlYWNoIHZlcnRleC5cbiAqIDxici8+PGJyLz5cbiAqIGBPY3RhaGVkcm9uYCBjcmVhdGVzIGFuIE9jdGFoZWRyb24gb2JqZWN0IGJ5IGl0cyBgcmFkaXVzYCBhbmQgYGRldGFpbGAuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI09jdGFoZWRyb25HZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGFuIE9jdGFoZWRyb24sIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IE9jdGFoZWRyb24oe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czogMixcbiAqICAgICBkZXRhaWw6IDFcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiBbMCwgMTAwLCAwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgT2N0YWhlZHJvbiBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuT2N0YWhlZHJvbiNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgcmFkaXVzOiAxLFxuICAgKiAgICAgZGV0YWlsOiAwXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMSxcbiAgICAgIGRldGFpbDogMFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBPY3RhaGVkcm9uLmRlZmF1bHRzLCBPY3RhaGVkcm9uLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5PY3RhaGVkcm9uXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSA6IE9jdGFoZWRyb25HZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmRldGFpbFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgT2N0YWhlZHJvblxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSxcbiAgUGFyYW1ldHJpY0dlb21ldHJ5LFxuICBWZWN0b3IzXG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBQYXJhbWV0cmljXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBgUGFyYW1ldHJpY2AgZ2VuZXJhdGVzIGEgZ2VvbWV0cnkgcmVwcmVzZW50aW5nIGEgPGEgaHJlZj0naHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFyYW1ldHJpY19zdXJmYWNlJz5QYXJhbWV0cmljIHN1cmZhY2U8L2E+XG4gKiA8YnIvPjxici8+XG4gKiBJdCBpcyB1c3VhbGx5IHVzZWQgdG8gZGV2ZWxvcCBkaWZmZXJlbnQga2luZHMgb2YgaGlnaGZpZWxkcyBvciB2aXN1YWxpemUgYSA8YSBocmVmPSdodHRwczovL3N0ZW1rb3NraS5naXRodWIuaW8vVGhyZWUuanMvR3JhcGh1bHVzLUZ1bmN0aW9uLmh0bWwnPm1hdGggZnVuY3Rpb248L2E+LlxuICogPGJyLz5cbiAqIC0gPGEgaHJlZj0naHR0cDovL21hdGguaHdzLmVkdS9ncmFwaGljc2Jvb2svc291cmNlL3RocmVlanMvY3VydmVzLWFuZC1zdXJmYWNlcy5odG1sJz5QYXJhbWV0cmljIHN1cmZhY2U8L2E+XG4gKiAtIDxhIGhyZWY9J2h0dHBzOi8vc3RlbWtvc2tpLmdpdGh1Yi5pby9UaHJlZS5qcy9HcmFwaHVsdXMtU3VyZmFjZS5odG1sJz5cIkdyYXBodWx1c1wiPC9hPlxuICogPGJyLz48YnIvPlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNQYXJhbWV0cmljR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeGFtcGxlIGNyZWF0aW5nIGFuIGhlaWdodGZpZWxkLWxpa2UgZ2VvbWV0cnkuIGB1YCBhbmQgYHZgIGFyZSBsaWtlIGB4YCBhbmQgYHlgIGluIHNoYXBlLCBidXQgdGhlaXIgdmFsdWVzIGFyZSBhbHdheXMgZnJvbSBgMGAgdG8gYDFgLlxuICogV2UgdXNlIHRoZW0gaW4gYFRIUkVFLlZlY3RvcjNgIGxpa2UgYHhgIGFuZCBgemAgYW5kIGBNYXRoLnJhbmRvbSgpICogNWAgZm9yIGB5YC48L2NhcHRpb24+XG4gKiBjb25zdCBjcmVhdGVQYXJhbWV0cmljID0gKHUsIHYpID0+IHtcbiAqICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHUgKiAzMCwgTWF0aC5yYW5kb20oKSAqIDUsIHYgKiAzMCk7XG4gKiB9XG4gKlxuICogbmV3IFBhcmFtZXRyaWMoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIGZ1bmM6IGNyZWF0ZVBhcmFtZXRyaWNcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmLFxuICogICAgIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGVcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjogWzAsIDEwMCwgLTEwMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFBhcmFtZXRyaWMgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlBhcmFtZXRyaWMjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIGZ1bmM6ICh1LCB2KSA9PiBuZXcgVmVjdG9yMyh1LCB2LCAwKSxcbiAgICogICAgIHNsaWNlczogMTAsXG4gICAqICAgICB0YWNrczogMTBcbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgZnVuYzogKHUsIHYpID0+IG5ldyBWZWN0b3IzKHUsIHYsIDApLFxuICAgICAgc2xpY2VzOiAxMCxcbiAgICAgIHN0YWNrczogMTBcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgUGFyYW1ldHJpYy5kZWZhdWx0cywgUGFyYW1ldHJpYy5pbnN0cnVjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5QYXJhbWV0cmljXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSA6IFBhcmFtZXRyaWNHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuZnVuYyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5zbGljZXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuc3RhY2tzXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBQYXJhbWV0cmljXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgUGxhbmVCdWZmZXJHZW9tZXRyeSxcbiAgUGxhbmVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgUGxhbmVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIGBQbGFuZWAgaXMgdXNlZCBmb3IgY3JlYXRpbmcgcGxhbmVzIGdpdmVuIHNvbWUgYHdpZHRoYCBhbmQgYGhlaWdodGAuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI1BsYW5lR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFBsYW5lLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBQbGFuZSh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgd2lkdGg6IDIwLFxuICogICAgIGhlaWdodDogMzBcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgUGxhbmUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlBsYW5lI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICB3aWR0aDogMTAsXG4gICAqICAgICBoZWlnaHQ6IDEwLFxuICAgKiAgICAgd1NlZ21lbnRzOiAxLFxuICAgKiAgICAgaFNlZ21lbnRzOiAxXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHdpZHRoOiAxMCxcbiAgICAgIGhlaWdodDogMTAsXG4gICAgICB3U2VnbWVudHM6IDEsXG4gICAgICBoU2VnbWVudHM6IDFcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5QbGFuZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3dTZWdtZW50cycsICdoU2VnbWVudHMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWyd3aWR0aCcsICdoZWlnaHQnLCAnd1NlZ21lbnRzJywgJ2hTZWdtZW50cyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFBsYW5lLmRlZmF1bHRzLCBQbGFuZS5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUGxhbmVcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyAocGFyYW1zLmJ1ZmZlciA/IFBsYW5lQnVmZmVyR2VvbWV0cnkgOiBQbGFuZUdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS53aWR0aCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5oZWlnaHQsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkud1NlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmhTZWdtZW50c1xuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUGxhbmVcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnksXG4gIFBvbHloZWRyb25HZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuY29uc3QgW3ZlcnRpY2VzT2ZDdWJlLCBpbmRpY2VzT2ZGYWNlc10gPSBbXG4gIFtcbiAgICAtMSwgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsXG4gICAgLTEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgMSwgLTEsIDEsIDFcbiAgXSxcbiAgW1xuICAgIDIsIDEsIDAsIDAsIDMsIDIsXG4gICAgMCwgNCwgNywgNywgMywgMCxcbiAgICAwLCAxLCA1LCA1LCA0LCAwLFxuICAgIDEsIDIsIDYsIDYsIDUsIDEsXG4gICAgMiwgMywgNywgNywgNiwgMixcbiAgICA0LCA1LCA2LCA2LCA3LCA0XG4gIF1cbl07XG5cbi8qKlxuICogQGNsYXNzIFBvbHloZWRyb25cbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIEluIGVsZW1lbnRhcnkgZ2VvbWV0cnksIGEgcG9seWhlZHJvbiBpcyBhIHNvbGlkIGluIHRocmVlIGRpbWVuc2lvbnMgd2l0aCBmbGF0IHBvbHlnb25hbCBmYWNlcywgc3RyYWlnaHQgZWRnZXMgYW5kIHNoYXJwIGNvcm5lcnMgb3IgdmVydGljZXMuXG4gKiA8YnIvPjxici8+XG4gKiBgUG9seWhlZHJvbmAgY3JlYXRlcyBhIFBvbHloZWRyb24gYnkgaXRzIGByYWRpdXNgIGFuZCBgZGV0YWlsYC5cbiAqIDxici8+PGJyLz5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhbiBQb2x5aGVkcm9uLCBhbmQgYWRkaW5nIHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBQb2x5aGVkcm9uKHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICByYWRpdXM6IDIsXG4gKiAgICAgZGV0YWlsOiAxXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjogWzAsIDEwMCwgMF1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFBvbHloZWRyb24gZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgc3RhdGljIHZlcnRpY2VzT2ZDdWJlID0gdmVydGljZXNPZkN1YmU7XG4gIHN0YXRpYyBpbmRpY2VzT2ZGYWNlcyA9IGluZGljZXNPZkZhY2VzO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Qb2x5aGVkcm9uI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICB2ZXJ0aWNlc09mQ3ViZTogW1xuICAgKiAgICAgICAtMSwgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsXG4gICAqICAgICAgIC0xLCAtMSwgMSwgMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAxLCAxXG4gICAqICAgICBdLFxuICAgKlxuICAgKiAgICAgaW5kaWNlc09mRmFjZXM6IFtcbiAgICogICAgICAgMiwgMSwgMCwgMCwgMywgMixcbiAgICogICAgICAgMCwgNCwgNywgNywgMywgMCxcbiAgICogICAgICAgMCwgMSwgNSwgNSwgNCwgMCxcbiAgICogICAgICAgMSwgMiwgNiwgNiwgNSwgMSxcbiAgICogICAgICAgMiwgMywgNywgNywgNiwgMixcbiAgICogICAgICAgNCwgNSwgNiwgNiwgNywgNFxuICAgKiAgICAgXSxcbiAgICpcbiAgICogICAgIHJhZGl1czogNixcbiAgICogICAgIGRldGFpbDogMlxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB2ZXJ0aWNlc09mQ3ViZSxcbiAgICAgIGluZGljZXNPZkZhY2VzLFxuICAgICAgcmFkaXVzOiA2LFxuICAgICAgZGV0YWlsOiAyXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUG9seWhlZHJvbiNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsndmVydGljZXNPZkN1YmUnLCAnaW5kaWNlc09mRmFjZXMnLCAncmFkaXVzJywgJ2RldGFpbCddXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbJ3ZlcnRpY2VzT2ZDdWJlJywgJ2luZGljZXNPZkZhY2VzJywgJ3JhZGl1cycsICdkZXRhaWwnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBQb2x5aGVkcm9uLmRlZmF1bHRzLCBQb2x5aGVkcm9uLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Qb2x5aGVkcm9uXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSA6IFBvbHloZWRyb25HZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudmVydGljZXNPZkN1YmUsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaW5kaWNlc09mRmFjZXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmRldGFpbFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgUG9seWhlZHJvblxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFJpbmdHZW9tZXRyeSxcbiAgUmluZ0J1ZmZlckdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBSaW5nXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBSaW5nIGNsYXNzIGNyZWF0ZXMgYSBjaXJjbGUgb3IganVzdCAyRCBUb3J1cy4gRG9lcyBub3Qgc3VwcG9ydCBwaHlzaWNzLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNSaW5nR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFJpbmcsIGFuZCBhZGRpbmcgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IFJpbmcoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIGlubmVyUmFkaXVzOiA1LFxuICogICAgIG91dGVyUmFkaXVzOiAyXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZixcbiAqICAgICBzaWRlIFRIUkVFLkRvdWJsZVNpZGVcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjogWzAsIDgsIDBdLFxuICpcbiAqICAgcm90YXRpb246IHtcbiAqICAgICB4OiBNYXRoLlBJLzRcbiAqICAgfVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgUmluZyBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuUmluZyNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAqICAgICBvdXRlclJhZGl1czogNTAsXG4gICAqICAgICB0aGV0YVNlZ21lbnRzOiA4LFxuICAgKiAgICAgcGhpU2VnbWVudHM6IDgsXG4gICAqICAgICB0aGV0YVN0YXJ0OiAwLFxuICAgKiAgICAgdGhldGFMZW5ndGg6IE1hdGguUEkgKiAyXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgb3V0ZXJSYWRpdXM6IDUwLFxuICAgICAgdGhldGFTZWdtZW50czogOCxcbiAgICAgIHBoaVNlZ21lbnRzOiA4LFxuICAgICAgdGhldGFTdGFydDogMCxcbiAgICAgIHRoZXRhTGVuZ3RoOiBNYXRoLlBJICogMlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlJpbmcjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiBbXG4gICAqICAgICAnaW5uZXJSYWRpdXMnLFxuICAgKiAgICAgJ291dGVyUmFkaXVzJyxcbiAgICogICAgICd0aGV0YVNlZ21lbnRzJyxcbiAgICogICAgICdwaGlTZWdtZW50cycsXG4gICAqICAgICAndGhldGFTdGFydCcsXG4gICAqICAgICAndGhldGFMZW5ndGgnXG4gICAqICAgXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiBbXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICd0aGV0YVNlZ21lbnRzJyxcbiAgICAgICdwaGlTZWdtZW50cycsXG4gICAgICAndGhldGFTdGFydCcsXG4gICAgICAndGhldGFMZW5ndGgnXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBSaW5nLmRlZmF1bHRzLCBSaW5nLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5SaW5nXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IFJpbmdCdWZmZXJHZW9tZXRyeSA6IFJpbmdHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaW5uZXJSYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkub3V0ZXJSYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudGhldGFTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5waGlTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50aGV0YVN0YXJ0LFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnRoZXRhTGVuZ3RoXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBSaW5nXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgU2hhcGVCdWZmZXJHZW9tZXRyeSxcbiAgU2hhcGVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgU2hhcGVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIFNoYXBlIGlzIGEgdW5pdmVyc2FsIGNsYXNzLiBJdCBhbGxvd3MgeW91IHRvIGNyZWF0ZSBkaWZmZXJlbnQgMkQgc2hhcGVzIGluIDNEIHNjZW5lLjxici8+XG4gKiBVbmZvcnR1bmF0ZWx5LCBub3QgYWxsIG9mIHRoZW0gc3VwcG9ydCBwaHlzaWNzLCBhbiBhbHRlcm5hdGl2ZSBpcyB0byBtYWtlIGEgc2ltaWxhciAzRCBvYmplY3QgYW5kIHNjYWxlIGl0cyB3aWR0aCBkb3duIHRvIG5lYXIgemVyby5cbiAqIDxici8+PGJyLz5cbiAqIGBTaGFwZWAgY29uc2lzdHMgb2Ygc2hhcGVzIHRoYXQgYXJlIGluIGl0cyBzaGFwZXMgcGFyYW1ldGVyLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNTaGFwZUdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBwbGFuZSBsb29raW5nIFNoYXBlIGZyb20gYSBUSFJFRS5TaGFwZSwgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBjb25zdCByZWN0V2lkdGggPSAxMCxcbiAqIHJlY3RMZW5ndGggPSA1O1xuICpcbiAqIGNvbnN0IHJlY3RTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuICogcmVjdFNoYXBlLm1vdmVUbygwLDApO1xuICogcmVjdFNoYXBlLmxpbmVUbygwLCByZWN0V2lkdGgpO1xuICogcmVjdFNoYXBlLmxpbmVUbyhyZWN0TGVuZ3RoLCByZWN0V2lkdGgpO1xuICogcmVjdFNoYXBlLmxpbmVUbyhyZWN0TGVuZ3RoLCAwKTtcbiAqIHJlY3RTaGFwZS5saW5lVG8oMCwgMCk7XG4gKlxuICogY29uc3QgcGxhbmUgPSBuZXcgU2hhcGUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHNoYXBlOiByZWN0U2hhcGVcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgU2hhcGUgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlNoYXBlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICBzaGFwZXM6IFtdXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgc2hhcGVzOiBbXVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlNoYXBlI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogWydzaGFwZXMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydzaGFwZXMnXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBTaGFwZS5kZWZhdWx0cywgU2hhcGUuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlNoYXBlXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyAocGFyYW1zLmJ1ZmZlciA/IFNoYXBlQnVmZmVyR2VvbWV0cnkgOiBTaGFwZUdlb21ldHJ5KShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5zaGFwZXNcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFNoYXBlXG59O1xuIiwiaW1wb3J0IHtcbiAgTWVzaCxcbiAgU3BoZXJlQnVmZmVyR2VvbWV0cnksXG4gIFNwaGVyZUdlb21ldHJ5XG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBTcGhlcmVcbiAqIEBjYXRlZ29yeSBjb21wb25lbnRzL21lc2hlc1xuICogQGRlc2NyaXB0aW9uIFNwaGVyZSBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBzcGhlcmUgb2JqZWN0cyBieSBpdHMgcmFkaXVzIHByb3BlcnR5IGFuZCBvdGhlciB2YWx1ZXMgdGhhdCBkZXRlcm1pbmVzIGl0cyBkZXRhbGl0eS5cbiAqIDxici8+PGJyLz5cbiAqIEl0IGlzIHNpbWlsYXIgdG8gVEhSRUUuU3BoZXJlR2VvbWV0cnksIGJ1dCBpdCBhbHNvIGNvbnRhaW5zIGFsbCBgU2hhcGVgIHByb3BlcnRpZXMsIHN1Y2ggYXMgbWF0ZXJpYWwsIG1hc3MgYW5kIHZlY3RvcnMgbGlrZSBwb3NpdGlvbiAocG9zKSBhbmQgcm90YXRpb24gKHJvdCkuXG4gKiA8YnIvPjxici8+XG4gKiBUaGVuIGl0IGNyZWF0ZXMgYW4gYFRocmVlLmpzIG1lc2hgIG9yIGEgYFBoeXNpanMgbWVzaGAsIHRoYXQgaXMgc2ltaWxhciB0byBgVGhyZWUuanMgbWVzaGAsIGJ1dCBpdCBhbHNvIHRha2UgaW50byBjb25zaWRlcmF0aW9uIGNvbGxpc2lvbiBjYWxjdWxhdGlvbnMuXG4gKiBUaGlzIG1lc2ggaXMgYSBjb21iaW5hdGlvbiBvZiBgVGhyZWUuanMgZ2VvbWV0cnlgIGFuZCBgUGh5c2lqcyBtYXRlcmlhbGAgKFRoZSBzYW1lIGFzIGluIHRocmVlLmpzLCBidXQgd2l0aCBmcmljdGlvbiBhbmQgcmVzdGl0dXRpb24pLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNTcGhlcmVHZW9tZXRyeVwiPjwvaWZyYW1lPlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgU3BoZXJlLCBhbmQgYWRkaW5nIGl0IHRvIGFwcDwvY2FwdGlvbj5cbiAqIG5ldyBTcGhlcmUoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czogMlxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zaXRpb246IHtcbiAqICAgICB5OiAxMDBcbiAqICAgfVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuY2xhc3MgU3BoZXJlIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5TcGhlcmUjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMSxcbiAgICogICAgIHdpZHRoU2VnbWVudHM6IDgsXG4gICAqICAgICBoZWlnaHRTZWdtZW50czogNlxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMSxcbiAgICAgIHdpZHRoU2VnbWVudHM6IDgsXG4gICAgICBoZWlnaHRTZWdtZW50czogNlxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlNwaGVyZSNpbnN0cnVjdGlvbnNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ3dpZHRoU2VnbWVudHMnLCAnaGVpZ2h0U2VnbWVudHMnXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogWydyYWRpdXMnLCAnd2lkdGhTZWdtZW50cycsICdoZWlnaHRTZWdtZW50cyddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFNwaGVyZS5kZWZhdWx0cywgU3BoZXJlLmluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlNwaGVyZVxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IChwYXJhbXMuYnVmZmVyID8gU3BoZXJlQnVmZmVyR2VvbWV0cnkgOiBTcGhlcmVHZW9tZXRyeSkoXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LndpZHRoU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuaGVpZ2h0U2VnbWVudHNcbiAgICApO1xuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFNwaGVyZVxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnksXG4gIFRldHJhaGVkcm9uR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFRldHJhaGVkcm9uXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBJbiBnZW9tZXRyeSwgYSB0ZXRyYWhlZHJvbiBpcyBhIHBvbHloZWRyb24gY29tcG9zZWQgb2YgZm91ciB0cmlhbmd1bGFyIGZhY2VzLCBzaXggc3RyYWlnaHQgZWRnZXMsIGFuZCBmb3VyIHZlcnRleCBjb3JuZXJzLlxuICogVGhlIHRldHJhaGVkcm9uIGlzIHRoZSBzaW1wbGVzdCBvZiBhbGwgdGhlIG9yZGluYXJ5IGNvbnZleCBwb2x5aGVkcmEgYW5kIHRoZSBvbmx5IG9uZSB0aGF0IGhhcyBmZXdlciB0aGFuIDUgZmFjZXMuXG4gKiA8YnIvPjxici8+XG4gKiBgVGV0cmFoZWRyb25gIGNyZWF0ZXMgYSBUZXRyYWhlZHJvbiBvYmplY3QgYnkgaXRzIGByYWRpdXNgIGFuZCBgZGV0YWlsYFxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3Mvc2NlbmVzL2dlb21ldHJ5LWJyb3dzZXIuaHRtbCNUZXRyYWhlZHJvbkdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBUZXRyYWhlZHJvbiwgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgVGV0cmFoZWRyb24oe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czogMixcbiAqICAgICBkZXRhaWw6IDFcbiAqICAgfSxcbiAqXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqXG4gKiAgIHBvc2l0aW9uOiB7XG4gKiAgICAgeDogMCxcbiAqICAgICB5OiAxMDAsXG4gKiAgICAgejogMFxuICogICB9XG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBUZXRyYWhlZHJvbiBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVGV0cmFoZWRyb24jZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgZ2VvbWV0cnk6IHtcbiAgICogICAgIHJhZGl1czogMSxcbiAgICogICAgIGRldGFpbDogMFxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHJhZGl1czogMSxcbiAgICAgIGRldGFpbDogMFxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5zdHJ1Y3Rpb25zXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRldHJhaGVkcm9uI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogWydyYWRpdXMnLCAnZGV0YWlsJ11cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBpbnN0cnVjdGlvbnMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5pbnN0cnVjdGlvbnMsXG4gICAgZ2VvbWV0cnk6IFsncmFkaXVzJywgJ2RldGFpbCddXG4gIH07XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30pIHtcbiAgICBzdXBlcihwYXJhbXMsIFRldHJhaGVkcm9uLmRlZmF1bHRzLCBUZXRyYWhlZHJvbi5pbnN0cnVjdGlvbnMpO1xuXG4gICAgaWYgKHBhcmFtcy5idWlsZCkge1xuICAgICAgdGhpcy5idWlsZChwYXJhbXMpO1xuICAgICAgc3VwZXIud3JhcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqIEBkZXNjcmlwdGlvbiBCdWlsZCBsaWZlY3ljbGUgY3JlYXRlcyBhIG1lc2ggdXNpbmcgaW5wdXQgcGFyYW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIENvbXBvbmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtUSFJFRS5NZXNofSBCdWlsdCBtZXNoXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVGV0cmFoZWRyb25cbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3Qge2dlb21ldHJ5LCBtYXRlcmlhbH0gPSB0aGlzLmFwcGx5QnJpZGdlKHtcbiAgICAgIGdlb21ldHJ5OiB0aGlzLmJ1aWxkR2VvbWV0cnkocGFyYW1zKSxcbiAgICAgIG1hdGVyaWFsOiBwYXJhbXMubWF0ZXJpYWxcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmFwcGx5QnJpZGdlKHttZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpfSkubWVzaDtcbiAgfVxuXG4gIGJ1aWxkR2VvbWV0cnkocGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IChwYXJhbXMuYnVmZmVyID8gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSA6IFRldHJhaGVkcm9uR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5kZXRhaWxcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIFRldHJhaGVkcm9uXG59O1xuIiwiaW1wb3J0IHtcbiAgRm9udCxcbiAgTWVzaCxcbiAgVGV4dEdlb21ldHJ5LFxuICBGb250TG9hZGVyXG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtNZXNoQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL01lc2hDb21wb25lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBUZXh0XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBUZXh0IGNsYXNzIGlzIG1hZGUgZm9yIGNyZWF0aW5nIDNEIHRleHQgb2JqZWN0cy5cbiAqIEBjbGFzc0Rlc2NcbiAqIDxpZnJhbWUgc3JjPVwiaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzL3NjZW5lcy9nZW9tZXRyeS1icm93c2VyLmh0bWwjVGV4dEdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiA8YnIvPjxici8+XG4gKiBQaHlzaWNzIHRleHQgb2JqZWN0IGNhbiBiZSBjb252ZXggb3IgY29uY2F2ZS4gQnkgZGVmYXVsdCBpdCdzIGNvbnZleCBidXQgeW91IGNhbiBhbHNvIHN3aXRjaCB0byBjb25jYXZlLlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtcy5cbiAqIEBleHRlbmRzIG1vZHVsZTpjb3JlLk1lc2hDb21wb25lbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNyZWF0aW5nIGEgVGV4dCwgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgVGV4dCh7XG4gKiAgICAgdGV4dDogJ1NvbWUgdGV4dCcsXG4gKiAgICAgcGFyYW1ldGVyczoge1xuICogICAgICAgZm9udDogJ3BhdGgvdG8vZm9udC50eXBlZmFjZS5qcycsXG4gKiAgICAgICBzaXplOiAyMCxcbiAqICAgICAgIGhlaWdodDogNSxcbiAqICAgICAgIGN1cnZlU2VnbWVudHM6IDZcbiAqICAgICB9XG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHg6IC00MCxcbiAqICAgICB5OiAyMCxcbiAqICAgICB6OiAwXG4gKiAgIH1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciBwYXJhbWV0ZXJzXG4gICAqIEBtZW1iZXIge09iamVjdH0gbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRleHQjZGVmYXVsdHNcbiAgICogQHN0YXRpY1xuICAgKiBAZGVmYXVsdCA8cHJlPlxuICAgKiB7XG4gICAqICAgdGV4dDogJ0hlbGxvIFdvcmxkIScsXG4gICAqICAgZm9udDogbnVsbCxcbiAgICpcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgc2l6ZTogMTIsXG4gICAqICAgICBoZWlnaHQ6IDUwLFxuICAgKiAgICAgY3VydmVTZWdtZW50czogMTIsXG4gICAqICAgICBmb250OiBuZXcgRm9udCgpLFxuICAgKiAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcbiAgICogICAgIGJldmVsVGhpY2tuZXNzOiAxMCxcbiAgICogICAgIGJldmVsU2l6ZTogOFxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIHRleHQ6ICdIZWxsbyBXb3JsZCEnLFxuICAgIGZvbnQ6IG51bGwsXG5cbiAgICBnZW9tZXRyeToge1xuICAgICAgc2l6ZTogMTIsXG4gICAgICBoZWlnaHQ6IDUwLFxuICAgICAgY3VydmVTZWdtZW50czogMTIsXG4gICAgICBmb250OiBuZXcgRm9udCgpLFxuICAgICAgYmV2ZWxFbmFibGVkOiBmYWxzZSxcbiAgICAgIGJldmVsVGhpY2tuZXNzOiAxMCxcbiAgICAgIGJldmVsU2l6ZTogOFxuICAgIH1cbiAgfTtcblxuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zXG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgRm9udExvYWRlclxuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UZXh0I2xvYWRlclxuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IG5ldyBGb250TG9hZGVyKClcbiAgICovXG4gIHN0YXRpYyBsb2FkZXIgPSBuZXcgRm9udExvYWRlcigpO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHN0YXRpY1xuICAgKiBAZGVzY3JpcHRpb24gbG9hZCgpIHByZWxvYWRzIGEgRm9udCBvYmplY3QgYW5kIHJldHVybnMgYSBQcm9taXNlIHdpdGggaXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdG8gdGhlIGZvbnRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHJlc29sdmVkIHdpdGggYSBmb250XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVGV4dFxuICAgKi9cbiAgc3RhdGljIGxvYWQocGF0aCwgbG9hZGVyID0gVGV4dC5sb2FkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2FkZXIubG9hZChwYXRoLCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBUZXh0LmRlZmF1bHRzLCBUZXh0Lmluc3RydWN0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgaXMgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIGxpZmVjeWNsZSB0byBjcmVhdGUgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRleHRcbiAgICovXG4gIGJ1aWxkKHBhcmFtcyA9IHRoaXMucGFyYW1zKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgKHBhcmFtcy5mb250IGluc3RhbmNlb2YgUHJvbWlzZSA/IHBhcmFtcy5mb250IDogUHJvbWlzZS5yZXNvbHZlKHBhcmFtcy5mb250KSlcbiAgICAgIC50aGVuKGZvbnQgPT4ge1xuICAgICAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgICAgIGdlb21ldHJ5OiBuZXcgVGV4dEdlb21ldHJ5KFxuICAgICAgICAgICAgcGFyYW1zLnRleHQsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICBwYXJhbXMuZ2VvbWV0cnksXG4gICAgICAgICAgICAgIHtmb250fVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICAgICAgICBtZXNoOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gICAgICAgICAgfSkubWVzaFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdXBlci53YWl0KHByb21pc2UpO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgVGV4dFxufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFRvcnVzR2VvbWV0cnlcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQge01lc2hDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvTWVzaENvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIFRvcnVzXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBUb3J1cyBjbGFzcyBtYWtlcyBhIHRvcnVzIGZpZ3VyZS4gQSBkb251dCBpcyBhIHRvcnVzLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3MvaW5kZXguaHRtbCNhcGkvZ2VvbWV0cmllcy9Ub3J1c0dlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBUb3J1cywgYW5kIGFkZGluZyBpdCB0byBhcHA8L2NhcHRpb24+XG4gKiBuZXcgVG9ydXMoe1xuICogICBnZW9tZXRyeToge1xuICogICAgIHJhZGl1czogNSxcbiAqICAgICB0dWJlOiAyXG4gKiAgIH0sXG4gKlxuICogICBtYXRlcmlhbDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAqICAgICBjb2xvcjogMHhmZmZmZmZcbiAqICAgfSksXG4gKlxuICogICBwb3NpdGlvbjoge1xuICogICAgIHk6IDM1XG4gKiAgIH1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFRvcnVzIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Ub3J1cyNkZWZhdWx0c1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeToge1xuICAgKiAgICAgcmFkaXVzOiAxMDAsXG4gICAqICAgICB0dWJlOiA0MCxcbiAgICogICAgIHJhZGlhbFNlZ21lbnRzOiA4LFxuICAgKiAgICAgdHVidWxhclNlZ21lbnRzOiA2LFxuICAgKiAgICAgYXJjOiBNYXRoLlBJICogMlxuICAgKiAgIH1cbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50LmRlZmF1bHRzLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICByYWRpdXM6IDEwMCxcbiAgICAgIHR1YmU6IDQwLFxuICAgICAgcmFkaWFsU2VnbWVudHM6IDgsXG4gICAgICB0dWJ1bGFyU2VnbWVudHM6IDYsXG4gICAgICBhcmM6IE1hdGguUEkgKiAyXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVG9ydXMjaW5zdHJ1Y3Rpb25zXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiBbXG4gICAqICAgICAncmFkaXVzJyxcbiAgICogICAgICd0dWJlJyxcbiAgICogICAgICdyYWRpYWxTZWdtZW50cycsXG4gICAqICAgICAndHVidWxhclNlZ21lbnRzJyxcbiAgICogICAgICdhcmMnXG4gICAqICAgXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogW1xuICAgICAgJ3JhZGl1cycsXG4gICAgICAndHViZScsXG4gICAgICAncmFkaWFsU2VnbWVudHMnLFxuICAgICAgJ3R1YnVsYXJTZWdtZW50cycsXG4gICAgICAnYXJjJ1xuICAgIF1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgVG9ydXMuZGVmYXVsdHMsIFRvcnVzLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5Ub3J1c1xuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgVG9ydXNHZW9tZXRyeShcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudHViZSxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpYWxTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuYXJjXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBUb3J1c1xufTtcbiIsImltcG9ydCB7XG4gIE1lc2gsXG4gIFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LFxuICBUb3J1c0tub3RHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgVG9ydXNrbm90XG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBUb3J1c2tub3QgY2xhc3MgbWFrZXMgYSB0b3J1c2tub3QgZmlndXJlLiBJdCdzIGxpa2UgYSBjcm9va2VkIGRvbnV0LCB2ZXJ5IGNyb29rZWQuXG4gKiBAY2xhc3NEZXNjXG4gKiA8aWZyYW1lIHNyYz1cImh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy9zY2VuZXMvZ2VvbWV0cnktYnJvd3Nlci5odG1sI1RvcnVzS25vdEdlb21ldHJ5XCI+PC9pZnJhbWU+XG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBUaGUgcGFyYW1zLlxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYSBUb3J1c2tub3QsIGFuZCBhZGRpbmcgaXQgdG8gYXBwPC9jYXB0aW9uPlxuICogbmV3IFRvcnVza25vdCh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcmFkaXVzOjUsXG4gKiAgICAgdHViZTogMlxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pLFxuICpcbiAqICAgcG9zOiB7XG4gKiAgICAgeTogMTAwXG4gKiAgIH1cbiAqIH0pLmFkZFRvKGFwcCk7XG4gKi9cbmNsYXNzIFRvcnVza25vdCBleHRlbmRzIE1lc2hDb21wb25lbnQge1xuICAvKipcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHBhcmFtZXRlcnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVG9ydXNrbm90I2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICByYWRpdXM6IDEwMCxcbiAgICogICAgIHR1YmU6IDQwLFxuICAgKiAgICAgcmFkaWFsU2VnbWVudHM6IDY0LFxuICAgKiAgICAgdHVidWxhclNlZ21lbnRzOiA4LFxuICAgKiAgICAgcDogMixcbiAgICogICAgIHE6IDNcbiAgICogICB9XG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLi4uTWVzaENvbXBvbmVudC5kZWZhdWx0cyxcbiAgICBnZW9tZXRyeToge1xuICAgICAgcmFkaXVzOiAxMDAsXG4gICAgICB0dWJlOiA0MCxcbiAgICAgIHJhZGlhbFNlZ21lbnRzOiA2NCxcbiAgICAgIHR1YnVsYXJTZWdtZW50czogOCxcbiAgICAgIHA6IDIsXG4gICAgICBxOiAzXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnN0cnVjdGlvbnNcbiAgICogQG1lbWJlciB7T2JqZWN0fSBtb2R1bGU6Y29tcG9uZW50cy9tZXNoZXMuVG9ydXNrbm90I2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogW1xuICAgKiAgICAgJ3JhZGl1cycsXG4gICAqICAgICAndHViZScsXG4gICAqICAgICAncmFkaWFsU2VnbWVudHMnLFxuICAgKiAgICAgJ3R1YnVsYXJTZWdtZW50cycsXG4gICAqICAgICAncCcsXG4gICAqICAgICAncSdcbiAgICogICBdXG4gICAqIH1cbiAgICogPC9wcmU+XG4gICAqL1xuICBzdGF0aWMgaW5zdHJ1Y3Rpb25zID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuaW5zdHJ1Y3Rpb25zLFxuICAgIGdlb21ldHJ5OiBbXG4gICAgICAncmFkaXVzJyxcbiAgICAgICd0dWJlJyxcbiAgICAgICdyYWRpYWxTZWdtZW50cycsXG4gICAgICAndHVidWxhclNlZ21lbnRzJyxcbiAgICAgICdwJyxcbiAgICAgICdxJ1xuICAgIF1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcywgVG9ydXNrbm90LmRlZmF1bHRzLCBUb3J1c2tub3QuaW5zdHJ1Y3Rpb25zKTtcblxuICAgIGlmIChwYXJhbXMuYnVpbGQpIHtcbiAgICAgIHRoaXMuYnVpbGQocGFyYW1zKTtcbiAgICAgIHN1cGVyLndyYXAoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBidWlsZFxuICAgKiBAZGVzY3JpcHRpb24gQnVpbGQgbGlmZWN5Y2xlIGNyZWF0ZXMgYSBtZXNoIHVzaW5nIGlucHV0IHBhcmFtcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBDb21wb25lbnQgcGFyYW1ldGVycy5cbiAgICogQHJldHVybiB7VEhSRUUuTWVzaH0gQnVpbHQgbWVzaFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzLlRvcnVza25vdFxuICAgKi9cbiAgYnVpbGQocGFyYW1zID0gdGhpcy5wYXJhbXMpIHtcbiAgICBjb25zdCB7Z2VvbWV0cnksIG1hdGVyaWFsfSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe1xuICAgICAgZ2VvbWV0cnk6IHRoaXMuYnVpbGRHZW9tZXRyeShwYXJhbXMpLFxuICAgICAgbWF0ZXJpYWw6IHBhcmFtcy5tYXRlcmlhbFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlCcmlkZ2Uoe21lc2g6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCl9KS5tZXNoO1xuICB9XG5cbiAgYnVpbGRHZW9tZXRyeShwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IEdDb25zdHJ1Y3QgPSBwYXJhbXMuYnVmZmVyID8gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgOiBUb3J1c0tub3RHZW9tZXRyeTtcblxuICAgIHJldHVybiBuZXcgR0NvbnN0cnVjdChcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpdXMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkudHViZSxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5yYWRpYWxTZWdtZW50cyxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS50dWJ1bGFyU2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucCxcbiAgICAgIHBhcmFtcy5nZW9tZXRyeS5xXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBUb3J1c2tub3Rcbn07XG4iLCJpbXBvcnQge1xuICBNZXNoLFxuICBMaW5lQ3VydmUzLFxuICBWZWN0b3IzLFxuICBUdWJlQnVmZmVyR2VvbWV0cnksXG4gIFR1YmVHZW9tZXRyeVxufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcblxuLyoqXG4gKiBAY2xhc3MgVHViZVxuICogQGNhdGVnb3J5IGNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZGVzY3JpcHRpb24gVHViZSBjbGFzcyBtYWtlcyBhIHR1YmUgdGhhdCBleHRydWRlcyBhbG9uZyBhIDNkIGN1cnZlLlxuICogQGNsYXNzRGVzY1xuICogPGlmcmFtZSBzcmM9XCJodHRwczovL3RocmVlanMub3JnL2RvY3MvaW5kZXguaHRtbCNhcGkvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnlcIj48L2lmcmFtZT5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbXMuXG4gKiBAZXh0ZW5kcyBtb2R1bGU6Y29yZS5NZXNoQ29tcG9uZW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOmNvbXBvbmVudHMvbWVzaGVzXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5DcmVhdGluZyBhIFR1YmUgZnJvbSBhIHRocmVlLmpzIEN1cnZlLCBhbmQgYWRkaW5nIGl0IHRvIGFwcDwvY2FwdGlvbj5cbiAqIGNvbnN0IEN1c3RvbVNpbkN1cnZlID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuICogICBmdW5jdGlvbiAoc2NhbGUpIHsgLy8gY3VzdG9tIGN1cnZlIGNvbnN0cnVjdG9yXG4gKiAgICAgdGhpcy5zY2FsZSA9IChzY2FsZSA9PT0gdW5kZWZpbmVkKSA/IDEgOiBzY2FsZTtcbiAqICAgfSxcbiAqXG4gKiAgIGZ1bmN0aW9uICh0KSB7IC8vIGdldFBvaW50OiB0IGlzIGJldHdlZW4gMC0xXG4gKiAgICAgY29uc3QgdHggPSB0ICogMyAtIDEuNSxcbiAqICAgICB0eSA9IE1hdGguc2luKCAyICogTWF0aC5QSSAqIHQgKSxcbiAqICAgICB0eiA9IDA7XG4gKlxuICogICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh0eCwgdHksIHR6KS5tdWx0aXBseVNjYWxhcih0aGlzLnNjYWxlKTtcbiAqICAgfVxuICogKTtcbiAqXG4gKiBjb25zdCBwYXRoID0gbmV3IEN1c3RvbVNpbkN1cnZlKDEwKTtcbiAqXG4gKiBuZXcgVHViZSh7XG4gKiAgIGdlb21ldHJ5OiB7XG4gKiAgICAgcGF0aDogcGF0aFxuICogICB9LFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gKiAgICAgY29sb3I6IDB4ZmZmZmZmXG4gKiAgIH0pXG4gKiB9KS5hZGRUbyhhcHApO1xuICovXG5jbGFzcyBUdWJlIGV4dGVuZHMgTWVzaENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgcGFyYW1ldGVyc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UdWJlI2RlZmF1bHRzXG4gICAqIEBzdGF0aWNcbiAgICogQGRlZmF1bHQgPHByZT5cbiAgICoge1xuICAgKiAgIGdlb21ldHJ5OiB7XG4gICAqICAgICBwYXRoOiBuZXcgVEhSRUUuTGluZUN1cnZlMyhuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMCwgMCwgMSkpLFxuICAgKiAgICAgc2VnbWVudHM6IDIwLFxuICAgKiAgICAgcmFkaXVzOiAyLFxuICAgKiAgICAgcmFkaXVzU2VnbWVudHM6IDgsXG4gICAqICAgICBjbG9zZWQ6IGZhbHNlXG4gICAqICAgfVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIC4uLk1lc2hDb21wb25lbnQuZGVmYXVsdHMsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHBhdGg6IG5ldyBMaW5lQ3VydmUzKG5ldyBWZWN0b3IzKDAsIDAsIDApLCBuZXcgVmVjdG9yMygwLCAwLCAxKSksXG4gICAgICBzZWdtZW50czogMjAsXG4gICAgICByYWRpdXM6IDIsXG4gICAgICByYWRpdXNTZWdtZW50czogOCxcbiAgICAgIGNsb3NlZDogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0aW9uc1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UdWJlI2luc3RydWN0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEBkZWZhdWx0IDxwcmU+XG4gICAqIHtcbiAgICogICBnZW9tZXRyeTogW1xuICAgKiAgICAgJ3BhdGgnLFxuICAgKiAgICAgJ3NlZ21lbnRzJyxcbiAgICogICAgICdyYWRpdXMnLFxuICAgKiAgICAgJ3JhZGl1c1NlZ21lbnRzJyxcbiAgICogICAgICdjbG9zZWQnXG4gICAqICAgXVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKi9cbiAgc3RhdGljIGluc3RydWN0aW9ucyA9IHtcbiAgICAuLi5NZXNoQ29tcG9uZW50Lmluc3RydWN0aW9ucyxcbiAgICBnZW9tZXRyeTogW1xuICAgICAgJ3BhdGgnLFxuICAgICAgJ3NlZ21lbnRzJyxcbiAgICAgICdyYWRpdXMnLFxuICAgICAgJ3JhZGl1c1NlZ21lbnRzJyxcbiAgICAgICdjbG9zZWQnXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgc3VwZXIocGFyYW1zLCBUdWJlLmRlZmF1bHRzLCBUdWJlLmluc3RydWN0aW9ucyk7XG5cbiAgICBpZiAocGFyYW1zLmJ1aWxkKSB7XG4gICAgICB0aGlzLmJ1aWxkKHBhcmFtcyk7XG4gICAgICBzdXBlci53cmFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIGxpZmVjeWNsZSBjcmVhdGVzIGEgbWVzaCB1c2luZyBpbnB1dCBwYXJhbXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgQ29tcG9uZW50IHBhcmFtZXRlcnMuXG4gICAqIEByZXR1cm4ge1RIUkVFLk1lc2h9IEJ1aWx0IG1lc2hcbiAgICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlcy5UdWJlXG4gICAqL1xuICBidWlsZChwYXJhbXMgPSB0aGlzLnBhcmFtcykge1xuICAgIGNvbnN0IHtnZW9tZXRyeSwgbWF0ZXJpYWx9ID0gdGhpcy5hcHBseUJyaWRnZSh7XG4gICAgICBnZW9tZXRyeTogdGhpcy5idWlsZEdlb21ldHJ5KHBhcmFtcyksXG4gICAgICBtYXRlcmlhbDogcGFyYW1zLm1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUJyaWRnZSh7bWVzaDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKX0pLm1lc2g7XG4gIH1cblxuICBidWlsZEdlb21ldHJ5KHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgKHBhcmFtcy5idWZmZXIgPyBUdWJlQnVmZmVyR2VvbWV0cnkgOiBUdWJlR2VvbWV0cnkpKFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnBhdGgsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkuc2VnbWVudHMsXG4gICAgICBwYXJhbXMuZ2VvbWV0cnkucmFkaXVzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LnJhZGl1c1NlZ21lbnRzLFxuICAgICAgcGFyYW1zLmdlb21ldHJ5LmNsb3NlZFxuICAgICk7XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgVHViZVxufTtcbiIsImltcG9ydCB7T2JqZWN0M0R9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7TWVzaENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9NZXNoQ29tcG9uZW50JztcbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL0NvbXBvbmVudCc7XG5cbi8qKlxuICogQGNsYXNzIEdyb3VwXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50cy9tZXNoZXNcbiAqIEBkZXNjcmlwdGlvbiBTb21ldGltZXMgeW91IG5lZWQgdG8gbWFrZSBncm91cHMgb2Ygb2JqZWN0cyAoaXQncyBub3QgY29udmVuaWVudGx5IHRvIGFwcGx5IHRyYW5zZm9ybXMgdG8gZWFjaCBvYmplY3Qgd2hlbiBjYW4gbWFrZSBqdXN0IG9uZSB0byBhIGdyb3VwKS48YnIvPlxuICogSW4gVGhyZWUuanMgeW91IG1ha2UgaXQgdXNpbmcgYFRIUkVFLk9iamVjdDNEYCBhbmQgaXQncyBjaGlsZHJlbi4gPGJyLz48YnIvPlxuICogSW4gd2hzLmpzIHdlIGhhdmUgYEdyb3VwYFxuICogQGV4dGVuZHMgbW9kdWxlOmNvcmUuTWVzaENvbXBvbmVudFxuICogQG1lbWJlcm9mIG1vZHVsZTpjb21wb25lbnRzL21lc2hlc1xuICogQGV4YW1wbGUgPGNhcHRpb24+QXBwcm9hY2ggMiAtIEFkZGluZyBvYmplY3RzIHRvIGFuIGVtcHR5IGdyb3VwPC9jYXB0aW9uPlxuICogY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICogY29uc3QgYm94ID0gbmV3IEJveCgpO1xuICogY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAqXG4gKiBzcGhlcmUuYWRkVG8oZ3JvdXApO1xuICogYm94LmFkZFRvKGdyb3VwKTtcbiogQGV4YW1wbGUgPGNhcHRpb24+QXBwcm9hY2ggMiAtIE1ha2luZyBhIGdyb3VwIGZyb20gb2JqZWN0czwvY2FwdGlvbj5cbiAqIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAqIGNvbnN0IGJveCA9IG5ldyBCb3goKTtcbiAqIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKGJveCwgc3BoZXJlKTtcbiAqIC8vIE9SOiBjb25zdCBncm91cCA9IG5ldyBHcm91cChbYm94LCBzcGhlcmVdKTtcbiAqL1xuY2xhc3MgR3JvdXAgZXh0ZW5kcyBNZXNoQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4ub2JqZWN0cykge1xuICAgIHN1cGVyKHt9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2JqID0gb2JqZWN0c1tpXTtcblxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbXBvbmVudCkgb2JqLmFkZFRvKHRoaXMpO1xuICAgICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0M0QpIHRoaXMubmF0aXZlLmFkZChvYmopO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0M0QoKTtcbiAgfVxufVxuXG5leHBvcnQge1xuICBHcm91cFxufTtcbiIsIi8qKiBAbW9kdWxlIGNvbXBvbmVudHMvbWVzaGVzICovXG5leHBvcnQgKiBmcm9tICcuL0JveCc7XG5leHBvcnQgKiBmcm9tICcuL0NpcmNsZSc7XG5leHBvcnQgKiBmcm9tICcuL0NvbmUnO1xuZXhwb3J0ICogZnJvbSAnLi9DeWxpbmRlcic7XG5leHBvcnQgKiBmcm9tICcuL0RvZGVjYWhlZHJvbic7XG5leHBvcnQgKiBmcm9tICcuL0V4dHJ1ZGUnO1xuZXhwb3J0ICogZnJvbSAnLi9JY29zYWhlZHJvbic7XG5leHBvcnQgKiBmcm9tICcuL0xhdGhlJztcbmV4cG9ydCAqIGZyb20gJy4vTGluZSc7XG5leHBvcnQgKiBmcm9tICcuL0ltcG9ydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vT2N0YWhlZHJvbic7XG5leHBvcnQgKiBmcm9tICcuL1BhcmFtZXRyaWMnO1xuZXhwb3J0ICogZnJvbSAnLi9QbGFuZSc7XG5leHBvcnQgKiBmcm9tICcuL1BvbHloZWRyb24nO1xuZXhwb3J0ICogZnJvbSAnLi9SaW5nJztcbmV4cG9ydCAqIGZyb20gJy4vU2hhcGUnO1xuZXhwb3J0ICogZnJvbSAnLi9TcGhlcmUnO1xuZXhwb3J0ICogZnJvbSAnLi9UZXRyYWhlZHJvbic7XG5leHBvcnQgKiBmcm9tICcuL1RleHQnO1xuZXhwb3J0ICogZnJvbSAnLi9Ub3J1cyc7XG5leHBvcnQgKiBmcm9tICcuL1RvcnVza25vdCc7XG5leHBvcnQgKiBmcm9tICcuL1R1YmUnO1xuZXhwb3J0ICogZnJvbSAnLi9Hcm91cCc7XG4iLCIvKipcbiAqIEBjbGFzcyBFbGVtZW50TW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9hcHBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGFpbmVyPWRvY3VtZW50LmJvZHldIGNvbnRhaW5lciBpcyB0aGUgRE9NIG9iamVjdCB0byB3aGljaCBhcHBsaWNhdGlvbidzIGNhbnZhcyB3aWxsIGJlIGFkZGVkIHRvLlxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYW4gZWxlbWVudCBtb2R1bGUsIHBhc3NpbmcgaXQgdG8gdGhlIEFwcDwvY2FwdGlvbj5cbiAqIG5ldyBBcHAoW1xuICogICBuZXcgRWxlbWVudE1vZHVsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpXG4gKiBdKTtcbiAqL1xuZXhwb3J0IGNsYXNzIEVsZW1lbnRNb2R1bGUge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWluZXIpIHtcbiAgICAgIGNvbnNvbGUud2FybignRWxlbWVudE1vZHVsZSBub3cgYWNjZXB0cyBvbmx5IGFyZ3VtZW50IHdoaWNoIGlzIGEgRE9NIG9iamVjdCwgbm90IGEgcGFyYW1zIG9iamVjdC4nKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyLmNvbnRhaW5lcjtcbiAgICB9IGVsc2UgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNyZWF0ZUVsZW1lbnRcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVzaXplTW9kdWxlXG4gICAqL1xuICBjcmVhdGVFbGVtZW50KCkge1xuICAgIHRoaXMuZWxlbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSAnd2hzLWFwcCc7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gJ2luaGVyaXQnO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnaW5oZXJpdCc7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuc2V0KCdlbGVtZW50JywgdGhpcy5lbGVtZW50KTtcbiAgICBtYW5hZ2VyLnNldCgnY29udGFpbmVyJywgdGhpcy5jb250YWluZXIpO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBzZWxmLmNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmVsZW1lbnQpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBXZWJHTFJlbmRlcmVyLFxuICBWZWN0b3IyXG59IGZyb20gJ3RocmVlJztcblxuaW1wb3J0IHtMb29wfSBmcm9tICcuLi8uLi9jb3JlL0xvb3AnO1xuXG4vKipcbiAqIEBjbGFzcyBSZW5kZXJpbmdNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSByZW5kZXJpbmcgbW9kdWxlIGFuZCBwYXNzaW5nIGl0IHRvIEFwcCdzIG1vZHVsZXM8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgbmV3IEVsZW1lbnRNb2R1bGUoKSxcbiAqICAgbmV3IFNjZW5lTW9kdWxlKCksXG4gKiAgIG5ldyBEZWZpbmVNb2R1bGUoJ2NhbWVyYScsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSh7XG4gKiAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDYsIDE4KSxcbiAqICAgICBmYXI6IDEwMDAwXG4gKiAgIH0pKSxcbiAqICAgbmV3IFJlbmRlcmluZ01vZHVsZSh7XG4gKiAgICAgYmdDb2xvcjogMHgxNjIxMjksXG4gKlxuICogICAgIHJlbmRlcmVyOiB7XG4gKiAgICAgICBhbnRpYWxpYXM6IHRydWVcbiAqICAgICB9XG4gKiAgIH0sIHtzaGFkb3c6IHRydWV9KVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBSZW5kZXJpbmdNb2R1bGUge1xuICAvKipcbiAgICogYWRkaXRpb25hbFxuICAgKiBAZGVzY3JpcHRpb24gY29sbGVjdGlvbiBvZiBhZGRpdGlvbmFsIHNjcmlwdHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyIHtPYmplY3R9IG1vZHVsZTpjb3JlLkFwcCNhZGRpdGlvbmFsXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBhZGRpdGlvbmFsID0ge1xuICAgIHNoYWRvdyhyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBlbmFibGVkXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlciB7Qm9vbGVhbn0gbW9kdWxlOmNvcmUuQXBwI2VuYWJsZWRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZW5hYmxlZCA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zID0ge30sIGFkZGl0aW9uYWwpIHtcbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG5cbiAgICAgIHJlc29sdXRpb246IG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgcGl4ZWxSYXRpbzogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG5cbiAgICAgIGJnQ29sb3I6IDB4MDAwMDAwLFxuICAgICAgYmdPcGFjaXR5OiAxLFxuXG4gICAgICByZW5kZXJlcjoge30sXG4gICAgICBmaXgoKSB7fVxuICAgIH0sIHBhcmFtcyk7XG5cbiAgICBjb25zdCB7XG4gICAgICBiZ0NvbG9yLFxuICAgICAgYmdPcGFjaXR5LFxuICAgICAgcmVuZGVyZXIsXG4gICAgICBwaXhlbFJhdGlvLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgZml4XG4gICAgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICB0aGlzLmVmZmVjdHMgPSBbXTtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihcbiAgICAgIGJnQ29sb3IsXG4gICAgICBiZ09wYWNpdHlcbiAgICApO1xuXG4gICAgaWYgKHBpeGVsUmF0aW8pIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcblxuICAgIHRoaXMuc2V0U2l6ZShcbiAgICAgIE51bWJlcih3aWR0aCAqIHJlc29sdXRpb24ueCkudG9GaXhlZCgpLFxuICAgICAgTnVtYmVyKGhlaWdodCAqIHJlc29sdXRpb24ueSkudG9GaXhlZCgpXG4gICAgKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGFkZGl0aW9uYWwpXG4gICAgICBpZiAoYWRkaXRpb25hbFtrZXldKSB0aGlzLmFwcGx5QWRkaXRpb25hbChrZXkpO1xuXG4gICAgZml4KHRoaXMucmVuZGVyZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYXBwbHlBZGRpdGlvbmFsXG4gICAqIEBkZXNjcmlwdGlvbiBBcHBseSBhZGRpdGlvbmFsIHNjcmlwdCBmcm9tIFJlbmRlcmluZ01vZHVsZS5hZGRpdGlvbmFsXG4gICAqIEBwYXJhbSB7U3Rpcm5nfSBuYW1lIFNjcmlwdCBuYW1lXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVuZGVyaW5nTW9kdWxlXG4gICAqL1xuICBhcHBseUFkZGl0aW9uYWwobmFtZSkge1xuICAgIFJlbmRlcmluZ01vZHVsZS5hZGRpdGlvbmFsW25hbWVdLmFwcGx5KHRoaXMsIFt0aGlzLnJlbmRlcmVyXSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnRlZ3JhdGVSZW5kZXJlclxuICAgKiBAZGVzY3JpcHRpb24gSW50ZWdyYXRlIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Tm9kZUVsZW1lbnR9IGVsZW1lbnQgRE9NIG9iamVjdFxuICAgKiBAcGFyYW0ge1RIUkVFLlNjZW5lfSBzY2VuZSB1c2VkIHNjZW5lXG4gICAqIEBwYXJhbSB7VEhSRUUuQ2FtZXJhfSBjYW1lcmEgdXNlZCBjYW1lcmFcbiAgICogQHJldHVybiB7TG9vcH0gcmVuZGVyTG9vcFxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgaW50ZWdyYXRlUmVuZGVyZXIoZWxlbWVudCwgc2NlbmUsIGNhbWVyYSkge1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmF0dGFjaFRvQ2FudmFzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIG5ldyBMb29wKCgpID0+IHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBlZmZlY3RcbiAgICogQGRlc2NyaXB0aW9uIEFkZCB0aHJlZS5qcyBlZmZlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdCB0aHJlZS5qcyBlZmZlY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZWZmZWN0TG9vcCB1cGRhdGUgZnVuY3Rpb24gZm9yIGVmZmVjdFxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgZWZmZWN0KGVmZmVjdCwgZWZmZWN0TG9vcCA9ICgpID0+IHtcbiAgICBlZmZlY3QucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfSkge1xuICAgIHRoaXMucmVuZGVyTG9vcC5zdG9wKCk7XG5cbiAgICBjb25zdCBzaXplID0gdGhpcy5yZW5kZXJlci5nZXRTaXplKCk7XG4gICAgZWZmZWN0LnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgY29uc3QgbG9vcCA9IG5ldyBMb29wKGVmZmVjdExvb3ApO1xuXG4gICAgdGhpcy5lZmZlY3RzLnB1c2gobG9vcCk7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkgbG9vcC5zdGFydCh0aGlzLmFwcCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldFNpemVcbiAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZSByZW5kZXIgdGFyZ2V0IHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVuZGVyaW5nTW9kdWxlXG4gICAqL1xuICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYXR0YWNoVG9DYW52YXNcbiAgICogQGRlc2NyaXB0aW9uIEF0dGFjaCByZW5kZXJlci5kb21FbGVtZW50IHRvIGVsZW1lbnRcbiAgICogQHBhcmFtIHtOb2RlRWxlbWVudH0gZWxlbWVudCBET00gb2JqZWN0XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVuZGVyaW5nTW9kdWxlXG4gICAqL1xuICBhdHRhY2hUb0NhbnZhcyhlbGVtZW50KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5yZW5kZXJlci5kb21FbGVtZW50O1xuXG4gICAgLy8gYXR0YWNoIHRvIG5ldyBwYXJlbnQgd29ybGQgZG9tXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc3RvcFxuICAgKiBAZGVzY3JpcHRpb24gU3RvcHMgcmVuZGVyTG9vcCBhbmQgZWZmZWN0IGxvb3BzXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVuZGVyaW5nTW9kdWxlXG4gICAqL1xuICBzdG9wKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyTG9vcC5zdG9wKCk7XG4gICAgdGhpcy5lZmZlY3RzLmZvckVhY2gobG9vcCA9PiBsb29wLnN0b3AoKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwbGF5XG4gICAqIEBkZXNjcmlwdGlvbiBSZXN1bWVzIHJlbmRlckxvb3AgYW5kIGVmZmVjdCBsb29wc1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlJlbmRlcmluZ01vZHVsZVxuICAgKi9cbiAgcGxheSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyTG9vcC5zdGFydCgpO1xuICAgIHRoaXMuZWZmZWN0cy5mb3JFYWNoKGxvb3AgPT4gbG9vcC5zdGFydCgpKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuZGVmaW5lKCdyZW5kZXJpbmcnKTtcbiAgICBtYW5hZ2VyLnNldCgncmVuZGVyZXInLCB0aGlzLnJlbmRlcmVyKTtcblxuICAgIHRoaXMuYXBwID0gbWFuYWdlci5oYW5kbGVyO1xuXG4gICAgdGhpcy5yZW5kZXJMb29wID0gdGhpcy5pbnRlZ3JhdGVSZW5kZXJlcihcbiAgICAgIG1hbmFnZXIuZ2V0KCdlbGVtZW50JyksXG4gICAgICBtYW5hZ2VyLmdldCgnc2NlbmUnKSxcbiAgICAgIG1hbmFnZXIuZ2V0KCdjYW1lcmEnKS5uYXRpdmVcbiAgICApO1xuXG4gICAgbWFuYWdlci51cGRhdGUoe1xuICAgICAgZWxlbWVudDogZWxlbWVudCA9PiB7XG4gICAgICAgIHRoaXMuYXR0YWNoVG9DYW52YXMoZWxlbWVudCk7XG4gICAgICB9LFxuICAgICAgc2NlbmU6IHNjZW5lID0+IHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgfSxcbiAgICAgIGNhbWVyYTogY2FtZXJhID0+IHtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmEubmF0aXZlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBzZWxmLnJlbmRlckxvb3Auc3RhcnQodGhpcyk7XG4gICAgc2VsZi5lZmZlY3RzLmZvckVhY2gobG9vcCA9PiBsb29wLnN0YXJ0KHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICogQGRlc2NyaXB0aW9uIERpc3Bvc2UgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5SZW5kZXJpbmdNb2R1bGVcbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5yZW5kZXJlci5mb3JjZUNvbnRleHRMb3NzKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFNjZW5lXG59IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBAY2xhc3MgU2NlbmVNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL2FwcFxuICogQHBhcmFtIHtCb29sZWFufSBbd2lsbFNjZW5lQmVSZXBsYWNlZD1mYWxzZV0gd2lsbFNjZW5lQmVSZXBsYWNlZCBzaG91bGQgYmUgdHJ1ZSBvbmx5IGlmIHlvdSBhcmUgZ29pbmcgdG8gb3ZlcndyaXRlIHNjZW5lIGRlcGVuZGVuY3kgZXZlbiB3aXRob3V0IHRoZSB1c2Ugb2YgZGVmYXVsdCBvbmUuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKi9cbmV4cG9ydCBjbGFzcyBTY2VuZU1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHdpbGxTY2VuZUJlUmVwbGFjZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuc2NlbmUgPSB3aWxsU2NlbmVCZVJlcGxhY2VkID8gbnVsbCA6IG5ldyBTY2VuZSgpO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5zZXQoJ3NjZW5lJywgdGhpcy5zY2VuZSk7XG4gIH1cblxuICBpbnRlZ3JhdGUoc2VsZikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgb2JqZWN0LnBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIG9iamVjdC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgY29uc3Qge25hdGl2ZX0gPSBvYmplY3Q7XG4gICAgICAgICAgaWYgKCFuYXRpdmUpIHJlamVjdCgpO1xuXG4gICAgICAgICAgY29uc3QgYWRkUHJvbWlzZSA9IHRoaXMuYXBwbHlCcmlkZ2Uoe29uQWRkOiBvYmplY3R9KS5vbkFkZDtcblxuICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5zY2VuZS5hZGQobmF0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuXG4gICAgICAgICAgICByZXNvbHZlKG9iamVjdCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChhZGRQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIGFkZFByb21pc2UudGhlbihyZXNvbHZlcik7XG4gICAgICAgICAgZWxzZSByZXNvbHZlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgc2VsZi5zY2VuZS5yZW1vdmUob2JqZWN0Lm5hdGl2ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0U2NlbmUgPSBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgIHNlbGYuc2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMubWFuYWdlci5zZXQoJ3NjZW5lJywgc2NlbmUpO1xuICAgIH07XG4gIH1cbn1cbiIsIi8vIGltcG9ydCB7YWRkUmVzaXplTGlzdGVuZXJ9IGZyb20gJ2RldGVjdC1lbGVtZW50LXJlc2l6ZSc7XG5cbi8qKlxuICogQGNsYXNzIFJlc2l6ZU1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17YXV0bzogdHJ1ZX1dIC0gSWYgYXV0byBpcyBzZXQgdG8gdHJ1ZSAtIHJlc2l6ZSB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIGNvbnRhaW5lciByZXNpemVzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNpemVNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdXRvOiB0cnVlXG4gICAgfSwgcGFyYW1zKTtcblxuICAgIHRoaXMuY2FsbGJhY2tzID0gW3RoaXMuc2V0U2l6ZS5iaW5kKHRoaXMpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb24gc2V0U2l6ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gc2V0cyB0aGUgcHJvdmlkZWQgd2lkdGggJiBoZWlnaHQgdG8gdGhlIHJlbmRlcmVyIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0xXSAtIFRoZSBwcm9taXNlIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIGEgcXVldWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTFdIC0gdGhhdCBpcyByZXNvbHZlZCB3aGVuIGFsbCBwcm9taXNlcyBjb21wbGV0ZWQuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVzaXplTW9kdWxlXG4gICAqL1xuICBzZXRTaXplKHdpZHRoID0gMSwgaGVpZ2h0ID0gMSkge1xuICAgIHRoaXMuY2FtZXJhLm5hdGl2ZS5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5uYXRpdmUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyaW5nKSB0aGlzLnJlbmRlcmluZy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdHJpZ2dlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXJzIHJlc2l6ZSB3aGVuIGNhbGxlZC4gd2lkdGggJiBoZWlnaHQgYXJlIGRldGVybWluZWQgYXV0b21hdGljYWxseVxuICAgKiBUaGlzIGludm9rZXMgZWFjaCBjYWxsYmFja3Mgd2l0aCB0aGUgbmV3IHdpZHRoIGFuZCBoZWlnaHQgYXMgcGFyYW1zXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVzaXplTW9kdWxlXG4gICAqL1xuICB0cmlnZ2VyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBvZmZzZXRXaWR0aCxcbiAgICAgICAgb2Zmc2V0SGVpZ2h0XG4gICAgICB9LFxuICAgICAgcmVzb2x1dGlvblxuICAgIH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgd2lkdGggPSBOdW1iZXIob2Zmc2V0V2lkdGggKiByZXNvbHV0aW9uLngpLnRvRml4ZWQoKTtcbiAgICBjb25zdCBoZWlnaHQgPSBOdW1iZXIob2Zmc2V0SGVpZ2h0ICogcmVzb2x1dGlvbi55KS50b0ZpeGVkKCk7XG5cbiAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIGNiKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkQXV0b3Jlc2l6ZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFNldHMgbW9kdWxlIHRvIGF1dG9yZXNpemUsIHRoaXMgYWRkcyBhbiBldmVudCBsaXN0ZW5lIG9uIHdpbmRvdyByZXNpemUgdG8gdHJpZ2dlciB0aGUgcmVzaXplXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUmVzaXplTW9kdWxlXG4gICAqL1xuICBhZGRBdXRvcmVzaXplKCkge1xuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcblxuICAgIGlmICh0aGlzLnBhcmFtcy5hdXRvKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy50cmlnZ2VyLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYWRkQ2FsbGJhY2tcbiAgICogQGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgY2FsbCBiYWNrIGZ1bmN0aW9uIHRvIHRoZSBleGlzdGluZyBjYWxsYmFja3MgbGlzdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBhZGRcbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5SZXNpemVNb2R1bGVcbiAgICovXG4gIGFkZENhbGxiYWNrKGZ1bmMpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ3Jlc2l6ZScpO1xuXG4gICAgdGhpcy5yZW5kZXJpbmcgPSBtYW5hZ2VyLmdldCgncmVuZGVyZXInKTtcbiAgICB0aGlzLmNhbWVyYSA9IG1hbmFnZXIuZ2V0KCdjYW1lcmEnKTtcblxuICAgIHRoaXMuZ2V0UmVzb2x1dGlvbiA9ICgpID0+IG1hbmFnZXIudXNlKCdyZW5kZXJpbmcnKS5wYXJhbXMucmVzb2x1dGlvbjtcbiAgICB0aGlzLmdldENvbnRhaW5lciA9ICgpID0+IG1hbmFnZXIuZ2V0KCdjb250YWluZXInKTtcblxuICAgIG1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyID0+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZEF1dG9yZXNpemUoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0UHJldmlvdXNMdW07XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdEN1cnJlbnRMdW07XFxyXFxudW5pZm9ybSBmbG9hdCBtaW5MdW1pbmFuY2U7XFxyXFxudW5pZm9ybSBmbG9hdCBkZWx0YTtcXHJcXG51bmlmb3JtIGZsb2F0IHRhdTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHRmbG9hdCBwcmV2aW91c0x1bSA9IHRleHR1cmUyRCh0UHJldmlvdXNMdW0sIHZVdiwgTUlQX0xFVkVMXzFYMSkucjtcXHJcXG5cXHRmbG9hdCBjdXJyZW50THVtID0gdGV4dHVyZTJEKHRDdXJyZW50THVtLCB2VXYsIE1JUF9MRVZFTF8xWDEpLnI7XFxyXFxuXFxyXFxuXFx0cHJldmlvdXNMdW0gPSBtYXgobWluTHVtaW5hbmNlLCBwcmV2aW91c0x1bSk7XFxyXFxuXFx0Y3VycmVudEx1bSA9IG1heChtaW5MdW1pbmFuY2UsIGN1cnJlbnRMdW0pO1xcclxcblxcclxcblxcdC8vIEFkYXB0IHRoZSBsdW1pbmFuY2UgdXNpbmcgUGF0dGFuYWlrJ3MgdGVjaG5pcXVlLlxcclxcblxcdGZsb2F0IGFkYXB0ZWRMdW0gPSBwcmV2aW91c0x1bSArIChjdXJyZW50THVtIC0gcHJldmlvdXNMdW0pICogKDEuMCAtIGV4cCgtZGVsdGEgKiB0YXUpKTtcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IuciA9IGFkYXB0ZWRMdW07XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFkYXB0aXZlIGx1bWlub3NpdHkgc2hhZGVyIG1hdGVyaWFsLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBBZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBhZGFwdGl2ZSBsdW1pbm9zaXR5IG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHRkZWZpbmVzOiB7XHJcblxyXG5cdFx0XHRcdE1JUF9MRVZFTF8xWDE6IFwiMC4wXCJcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0UHJldmlvdXNMdW06IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRDdXJyZW50THVtOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRtaW5MdW1pbmFuY2U6IG5ldyBVbmlmb3JtKDAuMDEpLFxyXG5cdFx0XHRcdGRlbHRhOiBuZXcgVW5pZm9ybSgwLjApLFxyXG5cdFx0XHRcdHRhdTogbmV3IFVuaWZvcm0oMS4wKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdERlcHRoO1xcclxcblxcclxcbnVuaWZvcm0gZmxvYXQgZm9jdXM7XFxyXFxudW5pZm9ybSBmbG9hdCBhc3BlY3Q7XFxyXFxudW5pZm9ybSBmbG9hdCBhcGVydHVyZTtcXHJcXG51bmlmb3JtIGZsb2F0IG1heEJsdXI7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG4jaWZuZGVmIFVTRV9MT0dERVBUSEJVRlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxwYWNraW5nPlxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjtcXHJcXG5cXHJcXG5cXHRmbG9hdCByZWFkRGVwdGgoc2FtcGxlcjJEIGRlcHRoU2FtcGxlciwgdmVjMiBjb29yZCkge1xcclxcblxcclxcblxcdFxcdGZsb2F0IGZyYWdDb29yZFogPSB0ZXh0dXJlMkQoZGVwdGhTYW1wbGVyLCBjb29yZCkueDtcXHJcXG5cXHRcXHRmbG9hdCB2aWV3WiA9IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGZyYWdDb29yZFosIGNhbWVyYU5lYXIsIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzIgYXNwZWN0Q29ycmVjdGlvbiA9IHZlYzIoMS4wLCBhc3BlY3QpO1xcclxcblxcclxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IHRleHR1cmUyRCh0RGVwdGgsIHZVdikueDtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IGRlcHRoID0gcmVhZERlcHRoKHREZXB0aCwgdlV2KTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRmbG9hdCBmYWN0b3IgPSBkZXB0aCAtIGZvY3VzO1xcclxcblxcclxcblxcdHZlYzIgZG9mQmx1ciA9IHZlYzIoY2xhbXAoZmFjdG9yICogYXBlcnR1cmUsIC1tYXhCbHVyLCBtYXhCbHVyKSk7XFxyXFxuXFxyXFxuXFx0dmVjMiBkb2ZibHVyOSA9IGRvZkJsdXIgKiAwLjk7XFxyXFxuXFx0dmVjMiBkb2ZibHVyNyA9IGRvZkJsdXIgKiAwLjc7XFxyXFxuXFx0dmVjMiBkb2ZibHVyNCA9IGRvZkJsdXIgKiAwLjQ7XFxyXFxuXFxyXFxuXFx0dmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXHJcXG5cXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4wLCAgIDAuNCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjE1LCAgMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMjksICAwLjI5KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4zNywgIDAuMTUpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjQwLCAgMC4wICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMzcsIC0wLjE1KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4yOSwgLTAuMjkpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjE1LCAtMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMCwgIC0wLjQgKSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC4xNSwgIDAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoIDAuMzcsICAwLjE1KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMigtMC40LCAgIDAuMCApICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjM3LCAtMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZkJsdXIpO1xcclxcblxcdGNvbG9yICs9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2ICsgKHZlYzIoLTAuMjksIC0wLjI5KSAqIGFzcGVjdENvcnJlY3Rpb24pICogZG9mQmx1cik7XFxyXFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgKyAodmVjMiggMC4xNSwgLTAuMzcpICogYXNwZWN0Q29ycmVjdGlvbikgKiBkb2ZCbHVyKTtcXHJcXG5cXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjE1LCAgMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjM3LCAgMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjM3LCAtMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjE1LCAtMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjE1LCAgMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjM3LCAgMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjM3LCAtMC4xNSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjE1LCAtMC4zNykgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI5KTtcXHJcXG5cXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjQwLCAgMC4wICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjI5LCAtMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjAsICAtMC40ICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjQsICAgMC4wICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAtMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjAsICAgMC40ICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI3KTtcXHJcXG5cXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjQsICAgMC4wICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjI5LCAtMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjAsICAtMC40ICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAgMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjQsICAgMC4wICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKC0wLjI5LCAtMC4yOSkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdiArICh2ZWMyKCAwLjAsICAgMC40ICkgKiBhc3BlY3RDb3JyZWN0aW9uKSAqIGRvZmJsdXI0KTtcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvciAvIDQxLjA7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIERlcHRoIG9mIEZpZWxkIHNoYWRlciAoQm9rZWgpLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBzaGFkZXIgY29kZSBieSBNYXJ0aW5zIFVwaXRpczpcclxuICogIGh0dHA6Ly9hcnRtYXJ0aW5zaC5ibG9nc3BvdC5jb20vMjAxMC8wMi9nbHNsLWxlbnMtYmx1ci1maWx0ZXItd2l0aC1ib2tlaC5odG1sXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEJva2VoTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWggbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBbY2FtZXJhXSAtIEEgY2FtZXJhLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZm9jdXM9MS4wXSAtIEZvY3VzIGRpc3RhbmNlLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hcGVydHVyZT0wLjAyNV0gLSBDYW1lcmEgYXBlcnR1cmUgc2NhbGUuIEJpZ2dlciB2YWx1ZXMgZm9yIHNoYWxsb3dlciBkZXB0aCBvZiBmaWVsZC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Qmx1cj0xLjBdIC0gTWF4aW11bSBibHVyIHN0cmVuZ3RoLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihjYW1lcmEgPSBudWxsLCBvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRpZihvcHRpb25zLmZvY3VzID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5mb2N1cyA9IDEuMDsgfVxyXG5cdFx0aWYob3B0aW9ucy5hcGVydHVyZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuYXBlcnR1cmUgPSAwLjAyNTsgfVxyXG5cdFx0aWYob3B0aW9ucy5tYXhCbHVyID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5tYXhCbHVyID0gMS4wOyB9XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJCb2tlaE1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHRjYW1lcmFOZWFyOiBuZXcgVW5pZm9ybSgwLjEpLFxyXG5cdFx0XHRcdGNhbWVyYUZhcjogbmV3IFVuaWZvcm0oMjAwMCksXHJcblx0XHRcdFx0YXNwZWN0OiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dERlcHRoOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHJcblx0XHRcdFx0Zm9jdXM6IG5ldyBVbmlmb3JtKG9wdGlvbnMuZm9jdXMpLFxyXG5cdFx0XHRcdGFwZXJ0dXJlOiBuZXcgVW5pZm9ybShvcHRpb25zLmFwZXJ0dXJlKSxcclxuXHRcdFx0XHRtYXhCbHVyOiBuZXcgVW5pZm9ybShvcHRpb25zLm1heEJsdXIpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoY2FtZXJhICE9PSBudWxsKSB7IHRoaXMuYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpOyB9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRvcHRzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXHJcblx0ICovXHJcblxyXG5cdGFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmFzcGVjdC52YWx1ZSA9IGNhbWVyYS5hc3BlY3Q7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjIsIFZlY3RvcjMgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGVwdGg7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXHJcXG51bmlmb3JtIHZlYzIgaGFsZlRleGVsU2l6ZTtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7XFxyXFxudW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBmb2NhbExlbmd0aDtcXHJcXG51bmlmb3JtIGZsb2F0IGZvY2FsU3RvcDtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IG1heEJsdXI7XFxyXFxudW5pZm9ybSB2ZWMzIGx1bWluYW5jZUNvZWZmaWNpZW50cztcXHJcXG51bmlmb3JtIGZsb2F0IGx1bWluYW5jZVRocmVzaG9sZDtcXHJcXG51bmlmb3JtIGZsb2F0IGx1bWluYW5jZUdhaW47XFxyXFxudW5pZm9ybSBmbG9hdCBiaWFzO1xcclxcbnVuaWZvcm0gZmxvYXQgZnJpbmdlO1xcclxcbnVuaWZvcm0gZmxvYXQgZGl0aGVyU3RyZW5ndGg7XFxyXFxuXFxyXFxuI2lmZGVmIFNIQURFUl9GT0NVU1xcclxcblxcclxcblxcdHVuaWZvcm0gdmVjMiBmb2N1c0Nvb3JkcztcXHJcXG5cXHJcXG4jZWxzZVxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgZm9jYWxEZXB0aDtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbiNpZm5kZWYgVVNFX0xPR0RFUFRIQlVGXFxyXFxuXFxyXFxuXFx0I2luY2x1ZGUgPHBhY2tpbmc+XFxyXFxuXFxyXFxuXFx0ZmxvYXQgcmVhZERlcHRoKHNhbXBsZXIyRCBkZXB0aFNhbXBsZXIsIHZlYzIgY29vcmQpIHtcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmcmFnQ29vcmRaID0gdGV4dHVyZTJEKGRlcHRoU2FtcGxlciwgY29vcmQpLng7XFxyXFxuXFx0XFx0ZmxvYXQgdmlld1ogPSBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WihmcmFnQ29vcmRaLCBjYW1lcmFOZWFyLCBjYW1lcmFGYXIpO1xcclxcblxcclxcblxcdFxcdHJldHVybiB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgodmlld1osIGNhbWVyYU5lYXIsIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZmRlZiBQRU5UQUdPTlxcclxcblxcclxcblxcdGZsb2F0IHBlbnRhKHZlYzIgY29vcmRzKSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzAgPSB2ZWM0KCAxLjAsICAgICAgICAgIDAuMCwgICAgICAgICAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzEgPSB2ZWM0KCAwLjMwOTAxNjk5NCwgIDAuOTUxMDU2NTE2LCAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzIgPSB2ZWM0KC0wLjgwOTAxNjk5NCwgIDAuNTg3Nzg1MjUyLCAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzMgPSB2ZWM0KC0wLjgwOTAxNjk5NCwgLTAuNTg3Nzg1MjUyLCAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzQgPSB2ZWM0KCAwLjMwOTAxNjk5NCwgLTAuOTUxMDU2NTE2LCAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBIUzUgPSB2ZWM0KCAwLjAsICAgICAgICAgIDAuMCwgICAgICAgICAxLjAsIDEuMCk7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgdmVjNCBPTkUgPSB2ZWM0KDEuMCk7XFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgUF9GRUFUSEVSID0gMC40O1xcclxcblxcdFxcdGNvbnN0IGZsb2F0IE5fRkVBVEhFUiA9IC1QX0ZFQVRIRVI7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgaW5Pck91dCA9IC00LjA7XFxyXFxuXFxyXFxuXFx0XFx0dmVjNCBQID0gdmVjNChjb29yZHMsIHZlYzIoUklOR1NfRkxPQVQgLSAxLjMpKTtcXHJcXG5cXHJcXG5cXHRcXHR2ZWM0IGRpc3QgPSB2ZWM0KFxcclxcblxcdFxcdFxcdGRvdChQLCBIUzApLFxcclxcblxcdFxcdFxcdGRvdChQLCBIUzEpLFxcclxcblxcdFxcdFxcdGRvdChQLCBIUzIpLFxcclxcblxcdFxcdFxcdGRvdChQLCBIUzMpXFxyXFxuXFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHRkaXN0ID0gc21vb3Roc3RlcChOX0ZFQVRIRVIsIFBfRkVBVEhFUiwgZGlzdCk7XFxyXFxuXFxyXFxuXFx0XFx0aW5Pck91dCArPSBkb3QoZGlzdCwgT05FKTtcXHJcXG5cXHJcXG5cXHRcXHRkaXN0LnggPSBkb3QoUCwgSFM0KTtcXHJcXG5cXHRcXHRkaXN0LnkgPSBIUzUudyAtIGFicyhQLnopO1xcclxcblxcclxcblxcdFxcdGRpc3QgPSBzbW9vdGhzdGVwKE5fRkVBVEhFUiwgUF9GRUFUSEVSLCBkaXN0KTtcXHJcXG5cXHRcXHRpbk9yT3V0ICs9IGRpc3QueDtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gY2xhbXAoaW5Pck91dCwgMC4wLCAxLjApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgU0hPV19GT0NVU1xcclxcblxcclxcblxcdHZlYzMgZGVidWdGb2N1cyh2ZWMzIGMsIGZsb2F0IGJsdXIsIGZsb2F0IGRlcHRoKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZWRnZSA9IDAuMDAyICogZGVwdGg7XFxyXFxuXFx0XFx0ZmxvYXQgbSA9IGNsYW1wKHNtb290aHN0ZXAoMC4wLCBlZGdlLCBibHVyKSwgMC4wLCAxLjApO1xcclxcblxcdFxcdGZsb2F0IGUgPSBjbGFtcChzbW9vdGhzdGVwKDEuMCAtIGVkZ2UsIDEuMCwgYmx1ciksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG5cXHRcXHRjID0gbWl4KGMsIHZlYzMoMS4wLCAwLjUsIDAuMCksICgxLjAgLSBtKSAqIDAuNik7XFxyXFxuXFx0XFx0YyA9IG1peChjLCB2ZWMzKDAuMCwgMC41LCAxLjApLCAoKDEuMCAtIGUpIC0gKDEuMCAtIG0pKSAqIDAuMik7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIGM7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZmRlZiBWSUdORVRURVxcclxcblxcclxcblxcdGZsb2F0IHZpZ25ldHRlKCkge1xcclxcblxcclxcblxcdFxcdGNvbnN0IHZlYzIgQ0VOVEVSID0gdmVjMigwLjUpO1xcclxcblxcclxcblxcdFxcdGNvbnN0IGZsb2F0IFZJR05FVFRFX09VVCA9IDEuMztcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBWSUdORVRURV9JTiA9IDAuMDtcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBWSUdORVRURV9GQURFID0gMjIuMDsgXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZCA9IGRpc3RhbmNlKHZVdiwgQ0VOVEVSKTtcXHJcXG5cXHRcXHRkID0gc21vb3Roc3RlcChWSUdORVRURV9PVVQgKyAoZm9jYWxTdG9wIC8gVklHTkVUVEVfRkFERSksIFZJR05FVFRFX0lOICsgKGZvY2FsU3RvcCAvIFZJR05FVFRFX0ZBREUpLCBkKTtcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gY2xhbXAoZCwgMC4wLCAxLjApO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG52ZWMyIHJhbmQodmVjMiBjb29yZCkge1xcclxcblxcclxcblxcdHZlYzIgbm9pc2U7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIE5PSVNFXFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgYSA9IDEyLjk4OTg7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgYiA9IDc4LjIzMztcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBjID0gNDM3NTguNTQ1MztcXHJcXG5cXHJcXG5cXHRcXHRub2lzZS54ID0gY2xhbXAoZnJhY3Qoc2luKG1vZChkb3QoY29vcmQsIHZlYzIoYSwgYikpLCAzLjE0KSkgKiBjKSwgMC4wLCAxLjApICogMi4wIC0gMS4wO1xcclxcblxcdFxcdG5vaXNlLnkgPSBjbGFtcChmcmFjdChzaW4obW9kKGRvdChjb29yZCwgdmVjMihhLCBiKSAqIDIuMCksIDMuMTQpKSAqIGMpLCAwLjAsIDEuMCkgKiAyLjAgLSAxLjA7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRub2lzZS54ID0gKChmcmFjdCgxLjAgLSBjb29yZC5zICogaGFsZlRleGVsU2l6ZS54KSAqIDAuMjUpICsgKGZyYWN0KGNvb3JkLnQgKiBoYWxmVGV4ZWxTaXplLnkpICogMC43NSkpICogMi4wIC0gMS4wO1xcclxcblxcdFxcdG5vaXNlLnkgPSAoKGZyYWN0KDEuMCAtIGNvb3JkLnMgKiBoYWxmVGV4ZWxTaXplLngpICogMC43NSkgKyAoZnJhY3QoY29vcmQudCAqIGhhbGZUZXhlbFNpemUueSkgKiAwLjI1KSkgKiAyLjAgLSAxLjA7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0cmV0dXJuIG5vaXNlO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52ZWMzIHByb2Nlc3NUZXhlbCh2ZWMyIGNvb3JkcywgZmxvYXQgYmx1cikge1xcclxcblxcclxcblxcdHZlYzMgYztcXHJcXG5cXHRjLnIgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvb3JkcyArIHZlYzIoMC4wLCAxLjApICogdGV4ZWxTaXplICogZnJpbmdlICogYmx1cikucjtcXHJcXG5cXHRjLmcgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvb3JkcyArIHZlYzIoLTAuODY2LCAtMC41KSAqIHRleGVsU2l6ZSAqIGZyaW5nZSAqIGJsdXIpLmc7XFxyXFxuXFx0Yy5iID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZHMgKyB2ZWMyKDAuODY2LCAtMC41KSAqIHRleGVsU2l6ZSAqIGZyaW5nZSAqIGJsdXIpLmI7XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIHRoZSBsdW1pbmFuY2Ugb2YgdGhlIGNvbnN0cnVjdGVkIGNvbG91ci5cXHJcXG5cXHRmbG9hdCBsdW1pbmFuY2UgPSBkb3QoYywgbHVtaW5hbmNlQ29lZmZpY2llbnRzKTtcXHJcXG5cXHRmbG9hdCB0aHJlc2hvbGQgPSBtYXgoKGx1bWluYW5jZSAtIGx1bWluYW5jZVRocmVzaG9sZCkgKiBsdW1pbmFuY2VHYWluLCAwLjApO1xcclxcblxcclxcblxcdHJldHVybiBjICsgbWl4KHZlYzMoMC4wKSwgYywgdGhyZXNob2xkICogYmx1cik7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IGxpbmVhcml6ZShmbG9hdCBkZXB0aCkge1xcclxcblxcclxcblxcdHJldHVybiAtY2FtZXJhRmFyICogY2FtZXJhTmVhciAvIChkZXB0aCAqIChjYW1lcmFGYXIgLSBjYW1lcmFOZWFyKSAtIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IGdhdGhlcihmbG9hdCBpLCBmbG9hdCBqLCBmbG9hdCByaW5nU2FtcGxlcywgaW5vdXQgdmVjMyBjb2xvciwgZmxvYXQgdywgZmxvYXQgaCwgZmxvYXQgYmx1cikge1xcclxcblxcclxcblxcdGNvbnN0IGZsb2F0IFRXT19QSSA9IDYuMjgzMTg1MzE7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgc3RlcCA9IFRXT19QSSAvIHJpbmdTYW1wbGVzO1xcclxcblxcdGZsb2F0IHB3ID0gY29zKGogKiBzdGVwKSAqIGk7XFxyXFxuXFx0ZmxvYXQgcGggPSBzaW4oaiAqIHN0ZXApICogaTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgUEVOVEFHT05cXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBwID0gcGVudGEodmVjMihwdywgcGgpKTtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IHAgPSAxLjA7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Y29sb3IgKz0gcHJvY2Vzc1RleGVsKHZVdiArIHZlYzIocHcgKiB3LCBwaCAqIGgpLCBibHVyKSAqIG1peCgxLjAsIGkgLyBSSU5HU19GTE9BVCwgYmlhcykgKiBwO1xcclxcblxcclxcblxcdHJldHVybiBtaXgoMS4wLCBpIC8gUklOR1NfRkxPQVQsIGJpYXMpICogcDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IGxpbmVhcml6ZSh0ZXh0dXJlMkQodERlcHRoLCB2VXYpLngpO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSBsaW5lYXJpemUocmVhZERlcHRoKHREZXB0aCwgdlV2KSk7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmZGVmIFNIQURFUl9GT0NVU1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHRcXHRcXHRmbG9hdCBmRGVwdGggPSBsaW5lYXJpemUodGV4dHVyZTJEKHREZXB0aCwgZm9jdXNDb29yZHMpLngpO1xcclxcblxcclxcblxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgZkRlcHRoID0gbGluZWFyaXplKHJlYWREZXB0aCh0RGVwdGgsIGZvY3VzQ29vcmRzKSk7XFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmRGVwdGggPSBmb2NhbERlcHRoO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBNQU5VQUxfRE9GXFxyXFxuXFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgbkRvRlN0YXJ0ID0gMS4wOyBcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBuRG9GRGlzdCA9IDIuMDtcXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBmRG9GU3RhcnQgPSAxLjA7XFxyXFxuXFx0XFx0Y29uc3QgZmxvYXQgZkRvRkRpc3QgPSAzLjA7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgZm9jYWxQbGFuZSA9IGRlcHRoIC0gZkRlcHRoO1xcclxcblxcdFxcdGZsb2F0IGZhckRvRiA9IChmb2NhbFBsYW5lIC0gZkRvRlN0YXJ0KSAvIGZEb0ZEaXN0O1xcclxcblxcdFxcdGZsb2F0IG5lYXJEb0YgPSAoLWZvY2FsUGxhbmUgLSBuRG9GU3RhcnQpIC8gbkRvRkRpc3Q7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgYmx1ciA9IChmb2NhbFBsYW5lID4gMC4wKSA/IGZhckRvRiA6IG5lYXJEb0Y7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRjb25zdCBmbG9hdCBDSVJDTEVfT0ZfQ09ORlVTSU9OID0gMC4wMzsgLy8gMzVtbSBmaWxtID0gMC4wM21tIENvQy5cXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBmb2NhbFBsYW5lTU0gPSBmRGVwdGggKiAxMDAwLjA7XFxyXFxuXFx0XFx0ZmxvYXQgZGVwdGhNTSA9IGRlcHRoICogMTAwMC4wO1xcclxcblxcclxcblxcdFxcdGZsb2F0IGZvY2FsUGxhbmUgPSAoZGVwdGhNTSAqIGZvY2FsTGVuZ3RoKSAvIChkZXB0aE1NIC0gZm9jYWxMZW5ndGgpO1xcclxcblxcdFxcdGZsb2F0IGZhckRvRiA9IChmb2NhbFBsYW5lTU0gKiBmb2NhbExlbmd0aCkgLyAoZm9jYWxQbGFuZU1NIC0gZm9jYWxMZW5ndGgpO1xcclxcblxcdFxcdGZsb2F0IG5lYXJEb0YgPSAoZm9jYWxQbGFuZU1NIC0gZm9jYWxMZW5ndGgpIC8gKGZvY2FsUGxhbmVNTSAqIGZvY2FsU3RvcCAqIENJUkNMRV9PRl9DT05GVVNJT04pO1xcclxcblxcclxcblxcdFxcdGZsb2F0IGJsdXIgPSBhYnMoZm9jYWxQbGFuZSAtIGZhckRvRikgKiBuZWFyRG9GO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdGJsdXIgPSBjbGFtcChibHVyLCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuXFx0Ly8gRGl0aGVyaW5nLlxcclxcblxcdHZlYzIgbm9pc2UgPSByYW5kKHZVdikgKiBkaXRoZXJTdHJlbmd0aCAqIGJsdXI7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgYmx1ckZhY3RvclggPSB0ZXhlbFNpemUueCAqIGJsdXIgKiBtYXhCbHVyICsgbm9pc2UueDtcXHJcXG5cXHRmbG9hdCBibHVyRmFjdG9yWSA9IHRleGVsU2l6ZS55ICogYmx1ciAqIG1heEJsdXIgKyBub2lzZS55O1xcclxcblxcclxcblxcdGNvbnN0IGludCBNQVhfUklOR19TQU1QTEVTID0gUklOR1NfSU5UICogU0FNUExFU19JTlQ7XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRpb24gb2YgZmluYWwgY29sb3IuXFxyXFxuXFx0dmVjNCBjb2xvcjtcXHJcXG5cXHJcXG5cXHRpZihibHVyIDwgMC4wNSkge1xcclxcblxcclxcblxcdFxcdGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcclxcblxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0Y29sb3IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgcyA9IDEuMDtcXHJcXG5cXHRcXHRpbnQgcmluZ1NhbXBsZXM7XFxyXFxuXFxyXFxuXFx0XFx0Zm9yKGludCBpID0gMTsgaSA8PSBSSU5HU19JTlQ7ICsraSkge1xcclxcblxcclxcblxcdFxcdFxcdHJpbmdTYW1wbGVzID0gaSAqIFNBTVBMRVNfSU5UO1xcclxcblxcclxcblxcdFxcdFxcdC8vIENvbnN0YW50IGxvb3AuXFxyXFxuXFx0XFx0XFx0Zm9yKGludCBqID0gMDsgaiA8IE1BWF9SSU5HX1NBTVBMRVM7ICsraikge1xcclxcblxcclxcblxcdFxcdFxcdFxcdC8vIEJyZWFrIGVhcmxpZXIuXFxyXFxuXFx0XFx0XFx0XFx0aWYoaiA+PSByaW5nU2FtcGxlcykgeyBicmVhazsgfVxcclxcblxcclxcblxcdFxcdFxcdFxcdHMgKz0gZ2F0aGVyKGZsb2F0KGkpLCBmbG9hdChqKSwgZmxvYXQocmluZ1NhbXBsZXMpLCBjb2xvci5yZ2IsIGJsdXJGYWN0b3JYLCBibHVyRmFjdG9yWSwgYmx1cik7XFxyXFxuXFxyXFxuXFx0XFx0XFx0fVxcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHRjb2xvci5yZ2IgLz0gczsgLy8gRGl2aWRlIGJ5IHNhbXBsZSBjb3VudC5cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0I2lmZGVmIFNIT1dfRk9DVVNcXHJcXG5cXHJcXG5cXHRcXHRjb2xvci5yZ2IgPSBkZWJ1Z0ZvY3VzKGNvbG9yLnJnYiwgYmx1ciwgZGVwdGgpO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBWSUdORVRURVxcclxcblxcclxcblxcdFxcdGNvbG9yLnJnYiAqPSB2aWduZXR0ZSgpO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBEZXB0aCBvZiBGaWVsZCBzaGFkZXIgdmVyc2lvbiAyLjQuXHJcbiAqXHJcbiAqIE9yaWdpbmFsIHNoYWRlciBjb2RlIGJ5IE1hcnRpbnMgVXBpdGlzOlxyXG4gKiAgaHR0cDovL2JsZW5kZXJhcnRpc3RzLm9yZy9mb3J1bS9zaG93dGhyZWFkLnBocD8yMzc0ODgtR0xTTC1kZXB0aC1vZi1maWVsZC13aXRoLWJva2VoLXYyLTQtKHVwZGF0ZSlcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQm9rZWgyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWgyIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gW2NhbWVyYV0gLSBUaGUgbWFpbiBjYW1lcmEuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtvcHRpb25zLnRleGVsU2l6ZV0gLSBUaGUgYWJzb2x1dGUgc2NyZWVuIHRleGVsIHNpemUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaG93Rm9jdXM9ZmFsc2VdIC0gV2hldGhlciB0aGUgZm9jdXMgcG9pbnQgc2hvdWxkIGJlIGhpZ2hsaWdodGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFudWFsRG9GPWZhbHNlXSAtIEVuYWJsZXMgbWFudWFsIGRlcHRoIG9mIGZpZWxkIGJsdXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aWduZXR0ZT1mYWxzZV0gLSBFbmFibGVzIGEgdmlnbmV0dGUgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucGVudGFnb249ZmFsc2VdIC0gRW5hYmxlIHRvIHVzZSBhIHBlbnRhZ29uYWwgc2hhcGUgdG8gc2NhbGUgZ2F0aGVyZWQgdGV4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hhZGVyRm9jdXM9dHJ1ZV0gLSBEaXNhYmxlIGlmIHlvdSBjb21wdXRlIHlvdXIgb3duIGZvY2FsRGVwdGggKGluIG1ldHJlcyEpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9pc2U9dHJ1ZV0gLSBEaXNhYmxlIGlmIHlvdSBkb24ndCB3YW50IG5vaXNlIHBhdHRlcm5zIGZvciBkaXRoZXJpbmcuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdGlmKG9wdGlvbnMucmluZ3MgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnJpbmdzID0gMzsgfVxyXG5cdFx0aWYob3B0aW9ucy5zYW1wbGVzID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5zYW1wbGVzID0gMjsgfVxyXG5cdFx0aWYob3B0aW9ucy5zaG93Rm9jdXMgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNob3dGb2N1cyA9IGZhbHNlOyB9XHJcblx0XHRpZihvcHRpb25zLnNob3dGb2N1cyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2hvd0ZvY3VzID0gZmFsc2U7IH1cclxuXHRcdGlmKG9wdGlvbnMubWFudWFsRG9GID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5tYW51YWxEb0YgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy52aWduZXR0ZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMudmlnbmV0dGUgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5wZW50YWdvbiA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMucGVudGFnb24gPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5zaGFkZXJGb2N1cyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2hhZGVyRm9jdXMgPSB0cnVlOyB9XHJcblx0XHRpZihvcHRpb25zLm5vaXNlID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5ub2lzZSA9IHRydWU7IH1cclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkJva2VoMk1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHRkZWZpbmVzOiB7XHJcblxyXG5cdFx0XHRcdFJJTkdTX0lOVDogb3B0aW9ucy5yaW5ncy50b0ZpeGVkKDApLFxyXG5cdFx0XHRcdFJJTkdTX0ZMT0FUOiBvcHRpb25zLnJpbmdzLnRvRml4ZWQoMSksXHJcblx0XHRcdFx0U0FNUExFU19JTlQ6IG9wdGlvbnMuc2FtcGxlcy50b0ZpeGVkKDApLFxyXG5cdFx0XHRcdFNBTVBMRVNfRkxPQVQ6IG9wdGlvbnMuc2FtcGxlcy50b0ZpeGVkKDEpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHREZXB0aDogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdHRleGVsU2l6ZTogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjIoKSksXHJcblx0XHRcdFx0aGFsZlRleGVsU2l6ZTogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjIoKSksXHJcblxyXG5cdFx0XHRcdGNhbWVyYU5lYXI6IG5ldyBVbmlmb3JtKDAuMSksXHJcblx0XHRcdFx0Y2FtZXJhRmFyOiBuZXcgVW5pZm9ybSgyMDAwKSxcclxuXHJcblx0XHRcdFx0Zm9jYWxMZW5ndGg6IG5ldyBVbmlmb3JtKDI0LjApLFxyXG5cdFx0XHRcdGZvY2FsU3RvcDogbmV3IFVuaWZvcm0oMC45KSxcclxuXHJcblx0XHRcdFx0bWF4Qmx1cjogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRsdW1pbmFuY2VUaHJlc2hvbGQ6IG5ldyBVbmlmb3JtKDAuNSksXHJcblx0XHRcdFx0bHVtaW5hbmNlR2FpbjogbmV3IFVuaWZvcm0oMi4wKSxcclxuXHRcdFx0XHRsdW1pbmFuY2VDb2VmZmljaWVudHM6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKSxcclxuXHRcdFx0XHRiaWFzOiBuZXcgVW5pZm9ybSgwLjUpLFxyXG5cdFx0XHRcdGZyaW5nZTogbmV3IFVuaWZvcm0oMC43KSxcclxuXHRcdFx0XHRkaXRoZXJTdHJlbmd0aDogbmV3IFVuaWZvcm0oMC4wMDAxKSxcclxuXHJcblx0XHRcdFx0Zm9jdXNDb29yZHM6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKDAuNSwgMC41KSksXHJcblx0XHRcdFx0Zm9jYWxEZXB0aDogbmV3IFVuaWZvcm0oMS4wKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmKG9wdGlvbnMuc2hvd0ZvY3VzKSB7IHRoaXMuZGVmaW5lcy5TSE9XX0ZPQ1VTID0gXCIxXCI7IH1cclxuXHRcdGlmKG9wdGlvbnMubWFudWFsRG9GKSB7IHRoaXMuZGVmaW5lcy5NQU5VQUxfRE9GID0gXCIxXCI7IH1cclxuXHRcdGlmKG9wdGlvbnMudmlnbmV0dGUpIHsgdGhpcy5kZWZpbmVzLlZJR05FVFRFID0gXCIxXCI7IH1cclxuXHRcdGlmKG9wdGlvbnMucGVudGFnb24pIHsgdGhpcy5kZWZpbmVzLlBFTlRBR09OID0gXCIxXCI7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2hhZGVyRm9jdXMpIHsgdGhpcy5kZWZpbmVzLlNIQURFUl9GT0NVUyA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLm5vaXNlKSB7IHRoaXMuZGVmaW5lcy5OT0lTRSA9IFwiMVwiOyB9XHJcblxyXG5cdFx0aWYob3B0aW9ucy50ZXhlbFNpemUgIT09IHVuZGVmaW5lZCkgeyB0aGlzLnNldFRleGVsU2l6ZShvcHRpb25zLnRleGVsU2l6ZS54LCBvcHRpb25zLnRleGVsU2l6ZS55KTsgfVxyXG5cdFx0aWYoY2FtZXJhICE9PSBudWxsKSB7IHRoaXMuYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpOyB9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgdGV4ZWwgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIHRleGVsIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gVGhlIHRleGVsIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0VGV4ZWxTaXplKHgsIHkpIHtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSk7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmhhbGZUZXhlbFNpemUudmFsdWUuc2V0KHgsIHkpLm11bHRpcGx5U2NhbGFyKDAuNSk7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRvcHRzIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmUgYW5kIHRoZSBmb2NhbCBsZW5ndGggb2YgdGhlIGdpdmVuIGNhbWVyYS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS5cclxuXHQgKi9cclxuXHJcblx0YWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpIHtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcclxuXHRcdHRoaXMudW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHRcdHRoaXMudW5pZm9ybXMuZm9jYWxMZW5ndGgudmFsdWUgPSBjYW1lcmEuZ2V0Rm9jYWxMZW5ndGgoKTsgLy8gdW5pdDogbW0uXHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMjtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHkxO1xcclxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTI7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbDEgPSBvcGFjaXR5MSAqIHRleHR1cmUyRCh0ZXh0dXJlMSwgdlV2KTtcXHJcXG5cXHR2ZWM0IHRleGVsMiA9IG9wYWNpdHkyICogdGV4dHVyZTJEKHRleHR1cmUyLCB2VXYpO1xcclxcblxcclxcblxcdCNpZmRlZiBTQ1JFRU5fTU9ERVxcclxcblxcclxcblxcdFxcdHZlYzMgaW52VGV4ZWwxID0gdmVjMygxLjApIC0gdGV4ZWwxLnJnYjtcXHJcXG5cXHRcXHR2ZWMzIGludlRleGVsMiA9IHZlYzMoMS4wKSAtIHRleGVsMi5yZ2I7XFxyXFxuXFxyXFxuXFx0XFx0dmVjNCBjb2xvciA9IHZlYzQoXFxyXFxuXFx0XFx0XFx0dmVjMygxLjApIC0gaW52VGV4ZWwxICogaW52VGV4ZWwyLFxcclxcblxcdFxcdFxcdHRleGVsMS5hICsgdGV4ZWwyLmFcXHJcXG5cXHRcXHQpO1xcclxcblxcclxcblxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0dmVjNCBjb2xvciA9IHRleGVsMSArIHRleGVsMjtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBtYXRlcmlhbCBmb3IgY29tYmluaW5nIHR3byB0ZXh0dXJlcy5cclxuICpcclxuICogVGhpcyBtYXRlcmlhbCBzdXBwb3J0cyB0aGUgdHdvIGJsZW5kIG1vZGVzIEFkZCBhbmQgU2NyZWVuLlxyXG4gKlxyXG4gKiBJbiBTY3JlZW4gbW9kZSwgdGhlIHR3byB0ZXh0dXJlcyBhcmUgZWZmZWN0aXZlbHkgcHJvamVjdGVkIG9uIGEgd2hpdGUgc2NyZWVuXHJcbiAqIHNpbXVsdGFuZW91c2x5LiBJbiBBZGQgbW9kZSwgdGhlIHRleHR1cmVzIGFyZSBzaW1wbHkgYWRkZWQgdG9nZXRoZXIgd2hpY2hcclxuICogb2Z0ZW4gcHJvZHVjZXMgdW5kZXNpcmVkLCB3YXNoZWQgb3V0IHJlc3VsdHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbWJpbmVNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBjb21iaW5lIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc2NyZWVuTW9kZT1mYWxzZV0gLSBXaGV0aGVyIHRoZSBzY3JlZW4gYmxlbmQgbW9kZSBzaG91bGQgYmUgdXNlZC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Ioc2NyZWVuTW9kZSA9IGZhbHNlKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJDb21iaW5lTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUxOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0ZXh0dXJlMjogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdG9wYWNpdHkxOiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdG9wYWNpdHkyOiBuZXcgVW5pZm9ybSgxLjApXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoc2NyZWVuTW9kZSkgeyB0aGlzLmRlZmluZXMuU0NSRUVOX01PREUgPSBcIjFcIjsgfVxyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjA7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjE7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjI7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjM7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdC8vIFNhbXBsZSB0b3AgbGVmdCB0ZXhlbC5cXHJcXG5cXHR2ZWM0IHN1bSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2MCk7XFxyXFxuXFxyXFxuXFx0Ly8gU2FtcGxlIHRvcCByaWdodCB0ZXhlbC5cXHJcXG5cXHRzdW0gKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYxKTtcXHJcXG5cXHJcXG5cXHQvLyBTYW1wbGUgYm90dG9tIHJpZ2h0IHRleGVsLlxcclxcblxcdHN1bSArPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdjIpO1xcclxcblxcclxcblxcdC8vIFNhbXBsZSBib3R0b20gbGVmdCB0ZXhlbC5cXHJcXG5cXHRzdW0gKz0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYzKTtcXHJcXG5cXHJcXG5cXHQvLyBDb21wdXRlIHRoZSBhdmVyYWdlLlxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHN1bSAqIDAuMjU7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxyXFxudW5pZm9ybSB2ZWMyIGhhbGZUZXhlbFNpemU7XFxyXFxudW5pZm9ybSBmbG9hdCBrZXJuZWw7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjA7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjE7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjI7XFxyXFxudmFyeWluZyB2ZWMyIHZVdjM7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzIgZFV2ID0gKHRleGVsU2l6ZSAqIHZlYzIoa2VybmVsKSkgKyBoYWxmVGV4ZWxTaXplO1xcclxcblxcclxcblxcdHZVdjAgPSB2ZWMyKHV2LnggLSBkVXYueCwgdXYueSArIGRVdi55KTtcXHJcXG5cXHR2VXYxID0gdmVjMih1di54ICsgZFV2LngsIHV2LnkgKyBkVXYueSk7XFxyXFxuXFx0dlV2MiA9IHZlYzIodXYueCArIGRVdi54LCB1di55IC0gZFV2LnkpO1xcclxcblxcdHZVdjMgPSB2ZWMyKHV2LnggLSBkVXYueCwgdXYueSAtIGRVdi55KTtcXHJcXG5cXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBbiBvcHRpbWlzZWQgY29udm9sdXRpb24gc2hhZGVyIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBCYXNlZCBvbiB0aGUgR0RDMjAwMyBQcmVzZW50YXRpb24gYnkgTWFzYWtpIEthd2FzZSwgQnVua2FzaGEgR2FtZXM6XHJcbiAqICBGcmFtZSBCdWZmZXIgUG9zdHByb2Nlc3NpbmcgRWZmZWN0cyBpbiBET1VCTEUtUy5ULkUuQS5MIChXcmVja2xlc3MpXHJcbiAqIGFuZCBhbiBhcnRpY2xlIGJ5IEZpbGlwIFN0cnVnYXIsIEludGVsOlxyXG4gKiAgQW4gaW52ZXN0aWdhdGlvbiBvZiBmYXN0IHJlYWwtdGltZSBHUFUtYmFzZWQgaW1hZ2UgYmx1ciBhbGdvcml0aG1zXHJcbiAqXHJcbiAqIEZ1cnRoZXIgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIEFwcGxlJ3NcclxuICogW0Jlc3QgUHJhY3RpY2VzIGZvciBTaGFkZXJzXShodHRwczovL2dvby5nbC9sbVJvTTUpLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBDb252b2x1dGlvbk1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNvbnZvbHV0aW9uIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtWZWN0b3IyfSBbdGV4ZWxTaXplXSAtIFRoZSBhYnNvbHV0ZSBzY3JlZW4gdGV4ZWwgc2l6ZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IodGV4ZWxTaXplID0gbmV3IFZlY3RvcjIoKSkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiQ29udm9sdXRpb25NYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRleGVsU2l6ZTogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjIoKSksXHJcblx0XHRcdFx0aGFsZlRleGVsU2l6ZTogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjIoKSksXHJcblx0XHRcdFx0a2VybmVsOiBuZXcgVW5pZm9ybSgwLjApXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5zZXRUZXhlbFNpemUodGV4ZWxTaXplLngsIHRleGVsU2l6ZS55KTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjdXJyZW50IGtlcm5lbCBzaXplLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdFx0ICogQGRlZmF1bHQgS2VybmVsU2l6ZS5MQVJHRVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5rZXJuZWxTaXplID0gS2VybmVsU2l6ZS5MQVJHRTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBrZXJuZWwuXHJcblx0ICpcclxuXHQgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IFRoZSBrZXJuZWwuXHJcblx0ICovXHJcblxyXG5cdGdldEtlcm5lbCgpIHsgcmV0dXJuIGtlcm5lbFByZXNldHNbdGhpcy5rZXJuZWxTaXplXTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSB0ZXhlbCBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgdGV4ZWwgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdGV4ZWwgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRUZXhlbFNpemUoeCwgeSkge1xyXG5cclxuXHRcdHRoaXMudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldCh4LCB5KTtcclxuXHRcdHRoaXMudW5pZm9ybXMuaGFsZlRleGVsU2l6ZS52YWx1ZS5zZXQoeCwgeSkubXVsdGlwbHlTY2FsYXIoMC41KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBLYXdhc2UgYmx1ciBrZXJuZWwgcHJlc2V0cy5cclxuICpcclxuICogQHR5cGUge0Zsb2F0MzJBcnJheVtdfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmNvbnN0IGtlcm5lbFByZXNldHMgPSBbXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjBdKSxcclxuXHRuZXcgRmxvYXQzMkFycmF5KFswLjAsIDEuMCwgMS4wXSksXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAxLjAsIDEuMCwgMi4wXSksXHJcblx0bmV3IEZsb2F0MzJBcnJheShbMC4wLCAxLjAsIDIuMCwgMi4wLCAzLjBdKSxcclxuXHRuZXcgRmxvYXQzMkFycmF5KFswLjAsIDEuMCwgMi4wLCAzLjAsIDQuMCwgNC4wLCA1LjBdKSxcclxuXHRuZXcgRmxvYXQzMkFycmF5KFswLjAsIDEuMCwgMi4wLCAzLjAsIDQuMCwgNS4wLCA3LjAsIDguMCwgOS4wLCAxMC4wXSlcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBBIGtlcm5lbCBzaXplIGVudW1lcmF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gVkVSWV9TTUFMTCAtIEEgdmVyeSBzbWFsbCBrZXJuZWwgdGhhdCBtYXRjaGVzIGEgN3g3IEdhdXNzIGJsdXIga2VybmVsLlxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gU01BTEwgLSBBIHNtYWxsIGtlcm5lbCB0aGF0IG1hdGNoZXMgYSAxNXgxNSBHYXVzcyBibHVyIGtlcm5lbC5cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IE1FRElVTSAtIEEgbWVkaXVtIHNpemVkIGtlcm5lbCB0aGF0IG1hdGNoZXMgYSAyM3gyMyBHYXVzcyBibHVyIGtlcm5lbC5cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IExBUkdFIC0gQSBsYXJnZSBrZXJuZWwgdGhhdCBtYXRjaGVzIGEgMzV4MzUgR2F1c3MgYmx1ciBrZXJuZWwuXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBWRVJZX0xBUkdFIC0gQSB2ZXJ5IGxhcmdlIGtlcm5lbCB0aGF0IG1hdGNoZXMgYSA2M3g2MyBHYXVzcyBibHVyIGtlcm5lbC5cclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IEhVR0UgLSBBIGh1Z2Uga2VybmVsIHRoYXQgbWF0Y2hlcyBhIDEyN3gxMjcgR2F1c3MgYmx1ciBrZXJuZWwuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IEtlcm5lbFNpemUgPSB7XHJcblxyXG5cdFZFUllfU01BTEw6IDAsXHJcblx0U01BTEw6IDEsXHJcblx0TUVESVVNOiAyLFxyXG5cdExBUkdFOiAzLFxyXG5cdFZFUllfTEFSR0U6IDQsXHJcblx0SFVHRTogNVxyXG5cclxufTtcclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBvcGFjaXR5ICogdGV4ZWw7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgc2ltcGxlIGNvcHkgc2hhZGVyIG1hdGVyaWFsLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBDb3B5TWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY29weSBtYXRlcmlhbC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJDb3B5TWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRvcGFjaXR5OiBuZXcgVW5pZm9ybSgxLjApXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0gfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGVwdGg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG4jaWZuZGVmIFVTRV9MT0dERVBUSEJVRlxcclxcblxcclxcblxcdCNpbmNsdWRlIDxwYWNraW5nPlxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXHJcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjtcXHJcXG5cXHJcXG5cXHRmbG9hdCByZWFkRGVwdGgoc2FtcGxlcjJEIGRlcHRoU2FtcGxlciwgdmVjMiBjb29yZCkge1xcclxcblxcclxcblxcdFxcdGZsb2F0IGZyYWdDb29yZFogPSB0ZXh0dXJlMkQoZGVwdGhTYW1wbGVyLCBjb29yZCkueDtcXHJcXG5cXHRcXHRmbG9hdCB2aWV3WiA9IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKGZyYWdDb29yZFosIGNhbWVyYU5lYXIsIGNhbWVyYUZhcik7XFxyXFxuXFxyXFxuXFx0XFx0cmV0dXJuIHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCh2aWV3WiwgY2FtZXJhTmVhciwgY2FtZXJhRmFyKTtcXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IHRleHR1cmUyRCh0RGVwdGgsIHZVdikueDtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IGRlcHRoID0gcmVhZERlcHRoKHREZXB0aCwgdlV2KTtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGRlcHRoLCBkZXB0aCwgZGVwdGgsIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIEEgZGVwdGggc2hhZGVyIG1hdGVyaWFsLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBEZXB0aE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGRlcHRoIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gW2NhbWVyYV0gLSBBIGNhbWVyYS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY2FtZXJhID0gbnVsbCkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiRGVwdGhNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0Y2FtZXJhTmVhcjogbmV3IFVuaWZvcm0oMC4xKSxcclxuXHRcdFx0XHRjYW1lcmFGYXI6IG5ldyBVbmlmb3JtKDIwMDApLFxyXG5cclxuXHRcdFx0XHR0RGVwdGg6IG5ldyBVbmlmb3JtKG51bGwpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYoY2FtZXJhICE9PSBudWxsKSB7IHRoaXMuYWRvcHRDYW1lcmFTZXR0aW5ncyhjYW1lcmEpOyB9XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRvcHRzIHRoZSBzZXR0aW5ncyBvZiB0aGUgZ2l2ZW4gY2FtZXJhLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhIC0gQSBjYW1lcmEuXHJcblx0ICovXHJcblxyXG5cdGFkb3B0Q2FtZXJhU2V0dGluZ3MoY2FtZXJhKSB7XHJcblxyXG5cdFx0dGhpcy51bmlmb3Jtcy5jYW1lcmFOZWFyLnZhbHVlID0gY2FtZXJhLm5lYXI7XHJcblx0XHR0aGlzLnVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjQgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG5cXHJcXG51bmlmb3JtIGZsb2F0IGFuZ2xlO1xcclxcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxyXFxudW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzIgdlV2UGF0dGVybjtcXHJcXG5cXHJcXG5mbG9hdCBwYXR0ZXJuKCkge1xcclxcblxcclxcblxcdGZsb2F0IHMgPSBzaW4oYW5nbGUpO1xcclxcblxcdGZsb2F0IGMgPSBjb3MoYW5nbGUpO1xcclxcblxcclxcblxcdHZlYzIgcG9pbnQgPSB2ZWMyKGMgKiB2VXZQYXR0ZXJuLnggLSBzICogdlV2UGF0dGVybi55LCBzICogdlV2UGF0dGVybi54ICsgYyAqIHZVdlBhdHRlcm4ueSkgKiBzY2FsZTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gKHNpbihwb2ludC54KSAqIHNpbihwb2ludC55KSkgKiA0LjA7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcdHZlYzMgY29sb3IgPSB0ZXhlbC5yZ2I7XFxyXFxuXFxyXFxuXFx0I2lmZGVmIEFWRVJBR0VcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IHZlYzMoKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjApO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdGNvbG9yID0gdmVjMyhjb2xvciAqIDEwLjAgLSA1LjAgKyBwYXR0ZXJuKCkpO1xcclxcblxcdGNvbG9yID0gdGV4ZWwucmdiICsgKGNvbG9yIC0gdGV4ZWwucmdiKSAqIGludGVuc2l0eTtcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCB0ZXhlbC5hKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgdmVjMiB2VXZQYXR0ZXJuO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHR2VXZQYXR0ZXJuID0gdXYgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHk7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBkb3Qgc2NyZWVuIHNoYWRlciBtYXRlcmlhbC5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRG90U2NyZWVuTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZG90IHNjcmVlbiBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F2ZXJhZ2U9ZmFsc2VdIC0gV2hldGhlciB0aGUgc2hhZGVyIHNob3VsZCBvdXRwdXQgdGhlIGNvbG91ciBhdmVyYWdlIChibGFjayBhbmQgd2hpdGUpLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihhdmVyYWdlID0gZmFsc2UpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkRvdFNjcmVlbk1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdGFuZ2xlOiBuZXcgVW5pZm9ybSgxLjU3KSxcclxuXHRcdFx0XHRzY2FsZTogbmV3IFVuaWZvcm0oMS4wKSxcclxuXHRcdFx0XHRpbnRlbnNpdHk6IG5ldyBVbmlmb3JtKDEuMCksXHJcblxyXG5cdFx0XHRcdG9mZnNldFJlcGVhdDogbmV3IFVuaWZvcm0obmV3IFZlY3RvcjQoMC41LCAwLjUsIDEuMCwgMS4wKSlcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZihhdmVyYWdlKSB7IHRoaXMuZGVmaW5lcy5BVkVSQUdFID0gXCIxXCI7IH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gZmxvYXQgdGltZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbiNpZmRlZiBOT0lTRVxcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgbm9pc2VJbnRlbnNpdHk7XFxyXFxuXFxyXFxuI2VuZGlmXFxyXFxuXFxyXFxuI2lmZGVmIFNDQU5MSU5FU1xcclxcblxcclxcblxcdHVuaWZvcm0gZmxvYXQgc2NhbmxpbmVJbnRlbnNpdHk7XFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBzY2FubGluZUNvdW50O1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbiNpZmRlZiBHUkVZU0NBTEVcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIHZlYzMgbHVtaW5hbmNlQ29lZmZpY2llbnRzO1xcclxcblxcdHVuaWZvcm0gZmxvYXQgZ3JleXNjYWxlSW50ZW5zaXR5O1xcclxcblxcclxcbiNlbGlmIGRlZmluZWQoU0VQSUEpXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBzZXBpYUludGVuc2l0eTtcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG4jaWZkZWYgVklHTkVUVEVcXHJcXG5cXHJcXG5cXHR1bmlmb3JtIGZsb2F0IHZpZ25ldHRlT2Zmc2V0O1xcclxcblxcdHVuaWZvcm0gZmxvYXQgdmlnbmV0dGVEYXJrbmVzcztcXHJcXG5cXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHR2ZWMzIGNvbG9yID0gdGV4ZWwucmdiO1xcclxcblxcclxcblxcdCNpZmRlZiBTQ1JFRU5fTU9ERVxcclxcblxcclxcblxcdFxcdHZlYzMgaW52Q29sb3I7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmZGVmIE5PSVNFXFxyXFxuXFxyXFxuXFx0XFx0ZmxvYXQgeCA9IHZVdi54ICogdlV2LnkgKiB0aW1lICogMTAwMC4wO1xcclxcblxcdFxcdHggPSBtb2QoeCwgMTMuMCkgKiBtb2QoeCwgMTIzLjApO1xcclxcblxcdFxcdHggPSBtb2QoeCwgMC4wMSk7XFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBub2lzZSA9IHRleGVsLnJnYiAqIGNsYW1wKDAuMSArIHggKiAxMDAuMCwgMC4wLCAxLjApICogbm9pc2VJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIFNDUkVFTl9NT0RFXFxyXFxuXFxyXFxuXFx0XFx0XFx0aW52Q29sb3IgPSB2ZWMzKDEuMCkgLSBjb2xvcjtcXHJcXG5cXHRcXHRcXHR2ZWMzIGludk5vaXNlID0gdmVjMygxLjApIC0gbm9pc2U7XFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3IgPSB2ZWMzKDEuMCkgLSBpbnZDb2xvciAqIGludk5vaXNlO1xcclxcblxcclxcblxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3IgKz0gbm9pc2U7XFxyXFxuXFxyXFxuXFx0XFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0I2lmZGVmIFNDQU5MSU5FU1xcclxcblxcclxcblxcdFxcdHZlYzIgc2wgPSB2ZWMyKHNpbih2VXYueSAqIHNjYW5saW5lQ291bnQpLCBjb3ModlV2LnkgKiBzY2FubGluZUNvdW50KSk7XFxyXFxuXFx0XFx0dmVjMyBzY2FubGluZXMgPSB0ZXhlbC5yZ2IgKiB2ZWMzKHNsLngsIHNsLnksIHNsLngpICogc2NhbmxpbmVJbnRlbnNpdHk7XFxyXFxuXFxyXFxuXFx0XFx0I2lmZGVmIFNDUkVFTl9NT0RFXFxyXFxuXFxyXFxuXFx0XFx0XFx0aW52Q29sb3IgPSB2ZWMzKDEuMCkgLSBjb2xvcjtcXHJcXG5cXHRcXHRcXHR2ZWMzIGludlNjYW5saW5lcyA9IHZlYzMoMS4wKSAtIHNjYW5saW5lcztcXHJcXG5cXHJcXG5cXHRcXHRcXHRjb2xvciA9IHZlYzMoMS4wKSAtIGludkNvbG9yICogaW52U2NhbmxpbmVzO1xcclxcblxcclxcblxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0Y29sb3IgKz0gc2NhbmxpbmVzO1xcclxcblxcclxcblxcdFxcdCNlbmRpZlxcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBHUkVZU0NBTEVcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IG1peChjb2xvciwgdmVjMyhkb3QoY29sb3IsIGx1bWluYW5jZUNvZWZmaWNpZW50cykpLCBncmV5c2NhbGVJbnRlbnNpdHkpO1xcclxcblxcclxcblxcdCNlbGlmIGRlZmluZWQoU0VQSUEpXFxyXFxuXFxyXFxuXFx0XFx0dmVjMyBjID0gY29sb3IucmdiO1xcclxcblxcclxcblxcdFxcdGNvbG9yLnIgPSBkb3QoYywgdmVjMygxLjAgLSAwLjYwNyAqIHNlcGlhSW50ZW5zaXR5LCAwLjc2OSAqIHNlcGlhSW50ZW5zaXR5LCAwLjE4OSAqIHNlcGlhSW50ZW5zaXR5KSk7XFxyXFxuXFx0XFx0Y29sb3IuZyA9IGRvdChjLCB2ZWMzKDAuMzQ5ICogc2VwaWFJbnRlbnNpdHksIDEuMCAtIDAuMzE0ICogc2VwaWFJbnRlbnNpdHksIDAuMTY4ICogc2VwaWFJbnRlbnNpdHkpKTtcXHJcXG5cXHRcXHRjb2xvci5iID0gZG90KGMsIHZlYzMoMC4yNzIgKiBzZXBpYUludGVuc2l0eSwgMC41MzQgKiBzZXBpYUludGVuc2l0eSwgMS4wIC0gMC44NjkgKiBzZXBpYUludGVuc2l0eSkpO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcblxcdCNpZmRlZiBWSUdORVRURVxcclxcblxcclxcblxcdFxcdGNvbnN0IHZlYzIgY2VudGVyID0gdmVjMigwLjUpO1xcclxcblxcclxcblxcdFxcdCNpZmRlZiBFU0tJTFxcclxcblxcclxcblxcdFxcdFxcdHZlYzIgdXYgPSAodlV2IC0gY2VudGVyKSAqIHZlYzIodmlnbmV0dGVPZmZzZXQpO1xcclxcblxcdFxcdFxcdGNvbG9yID0gbWl4KGNvbG9yLnJnYiwgdmVjMygxLjAgLSB2aWduZXR0ZURhcmtuZXNzKSwgZG90KHV2LCB1dikpO1xcclxcblxcclxcblxcdFxcdCNlbHNlXFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHZVdiwgY2VudGVyKTtcXHJcXG5cXHRcXHRcXHRjb2xvciAqPSBzbW9vdGhzdGVwKDAuOCwgdmlnbmV0dGVPZmZzZXQgKiAwLjc5OSwgZGlzdCAqICh2aWduZXR0ZURhcmtuZXNzICsgdmlnbmV0dGVPZmZzZXQpKTtcXHJcXG5cXHJcXG5cXHRcXHQjZW5kaWZcXHRcXHRcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNsYW1wKGNvbG9yLCAwLjAsIDEuMCksIHRleGVsLmEpO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIGNpbmVtYXRpYyBzaGFkZXIgdGhhdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIGVmZmVjdHM6XHJcbiAqICAtIEZpbG0gR3JhaW5cclxuICogIC0gU2NhbmxpbmVzXHJcbiAqICAtIFZpZ25ldHRlXHJcbiAqICAtIEdyZXlzY2FsZVxyXG4gKiAgLSBTZXBpYVxyXG4gKlxyXG4gKiBPcmlnaW5hbCBzY2FubGluZXMgYWxnb3JpdGhtIGJ5IFBhdCBcIkhhd3Rob3JuZVwiIFNoZWFyb24uXHJcbiAqICBodHRwOi8vd3d3LnRydWV2aXNpb24zZC5jb20vZm9ydW1zL3Nob3djYXNlL3N0YXRpY25vaXNlX2NvbG9yYmxhY2t3aGl0ZV9zY2FubGluZV9zaGFkZXJzLXQxODY5OC4wLmh0bWxcclxuICpcclxuICogT3B0aW1pc2VkIHNjYW5saW5lcyBhbmQgbm9pc2Ugd2l0aCBpbnRlbnNpdHkgc2NhbGluZyBieSBHZW9yZyBcIkxldmlhdGhhblwiXHJcbiAqIFN0ZWlucm9oZGVyLiBUaGlzIHZlcnNpb24gd2FzIHByb3ZpZGVkIHVuZGVyIGEgQ3JlYXRpdmUgQ29tbW9ucyBBdHRyaWJ1dGlvblxyXG4gKiAzLjAgTGljZW5zZTogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wLlxyXG4gKlxyXG4gKiBUaGUgc2VwaWEgZWZmZWN0IGlzIGJhc2VkIG9uOlxyXG4gKiAgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanNcclxuICpcclxuICogVGhlIHZpZ25ldHRlIGNvZGUgaXMgYmFzZWQgb24gUGFpbnRFZmZlY3QgcG9zdHByb2Nlc3MgZnJvbSByby5tZTpcclxuICogIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC8zLWRyZWFtcy1vZi1ibGFjay9zb3VyY2UvYnJvd3NlL2RlcGxveS9qcy9lZmZlY3RzL1BhaW50RWZmZWN0LmpzXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEZpbG1NYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmaWxtIG1hdGVyaWFsLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLiBEaXNhYmxlZCBlZmZlY3RzIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBzaGFkZXIgYW5kIGhhdmUgbm8gbmVnYXRpdmUgaW1wYWN0IG9uIHBlcmZvcm1hbmNlLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ3JleXNjYWxlPWZhbHNlXSAtIEVuYWJsZSBncmV5c2NhbGUgZWZmZWN0LiBHcmV5c2NhbGUgYW5kIHNlcGlhIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXBpYT1mYWxzZV0gLSBFbmFibGUgc2VwaWEgZWZmZWN0LiBHcmV5c2NhbGUgYW5kIHNlcGlhIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aWduZXR0ZT1mYWxzZV0gLSBBcHBseSB2aWduZXR0ZSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lc2tpbD1mYWxzZV0gLSBVc2UgRXNraWwncyB2aWduZXR0ZSBhcHByb2FjaC4gVGhlIGRlZmF1bHQgbG9va3MgZHVzdHkgd2hpbGUgRXNraWwgbG9va3MgYnVybmVkIG91dC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNjcmVlbk1vZGU9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBzY3JlZW4gYmxlbmQgbW9kZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9pc2UgYW5kIHNjYW5saW5lcy4gQm90aCBvZiB0aGVzZSBlZmZlY3RzIGFyZSBjb21wdXRlZCBpbmRlcGVuZGVudGx5LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9pc2U9dHJ1ZV0gLSBTaG93IG5vaXNlLWJhc2VkIGZpbG0gZ3JhaW4uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY2FubGluZXM9dHJ1ZV0gLSBTaG93IHNjYW5saW5lcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubm9pc2VJbnRlbnNpdHk9MC41XSAtIFRoZSBub2lzZSBpbnRlbnNpdHkuIDAuMCB0byAxLjAuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYW5saW5lSW50ZW5zaXR5PTAuMDVdIC0gVGhlIHNjYW5saW5lIGludGVuc2l0eS4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ3JleXNjYWxlSW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBncmV5c2NhbGUgZWZmZWN0LiAwLjAgdG8gMS4wLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZXBpYUludGVuc2l0eT0xLjBdIC0gVGhlIGludGVuc2l0eSBvZiB0aGUgc2VwaWEgZWZmZWN0LiAwLjAgdG8gMS4wLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWduZXR0ZU9mZnNldD0xLjBdIC0gVGhlIG9mZnNldCBvZiB0aGUgdmlnbmV0dGUgZWZmZWN0LiAwLjAgdG8gMS4wLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWduZXR0ZURhcmtuZXNzPTEuMF0gLSBUaGUgZGFya25lc3Mgb2YgdGhlIHZpZ25ldHRlIGVmZmVjdC4gMC4wIHRvIDEuMC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5zY3JlZW5Nb2RlID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5zY3JlZW5Nb2RlID0gdHJ1ZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5ub2lzZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMubm9pc2UgPSB0cnVlOyB9XHJcblx0XHRpZihvcHRpb25zLnNjYW5saW5lcyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2NhbmxpbmVzID0gdHJ1ZTsgfVxyXG5cclxuXHRcdGlmKG9wdGlvbnMuZ3JleXNjYWxlID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5ncmV5c2NhbGUgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5zZXBpYSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuc2VwaWEgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy52aWduZXR0ZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMudmlnbmV0dGUgPSBmYWxzZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5lc2tpbCA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMuZXNraWwgPSBmYWxzZTsgfVxyXG5cclxuXHRcdGlmKG9wdGlvbnMubm9pc2VJbnRlbnNpdHkgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLm5vaXNlSW50ZW5zaXR5ID0gMC41OyB9XHJcblx0XHRpZihvcHRpb25zLnNjYW5saW5lSW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5zY2FubGluZUludGVuc2l0eSA9IDAuMDU7IH1cclxuXHRcdGlmKG9wdGlvbnMuZ3JleXNjYWxlSW50ZW5zaXR5ID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5ncmV5c2NhbGVJbnRlbnNpdHkgPSAxLjA7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2VwaWFJbnRlbnNpdHkgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLnNlcGlhSW50ZW5zaXR5ID0gMS4wOyB9XHJcblxyXG5cdFx0aWYob3B0aW9ucy52aWduZXR0ZU9mZnNldCA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMudmlnbmV0dGVPZmZzZXQgPSAxLjA7IH1cclxuXHRcdGlmKG9wdGlvbnMudmlnbmV0dGVEYXJrbmVzcyA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMudmlnbmV0dGVEYXJrbmVzcyA9IDEuMDsgfVxyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiRmlsbU1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dGltZTogbmV3IFVuaWZvcm0oMC4wKSxcclxuXHJcblx0XHRcdFx0bm9pc2VJbnRlbnNpdHk6IG5ldyBVbmlmb3JtKG9wdGlvbnMubm9pc2VJbnRlbnNpdHkpLFxyXG5cdFx0XHRcdHNjYW5saW5lSW50ZW5zaXR5OiBuZXcgVW5pZm9ybShvcHRpb25zLnNjYW5saW5lSW50ZW5zaXR5KSxcclxuXHRcdFx0XHRzY2FubGluZUNvdW50OiBuZXcgVW5pZm9ybSgwLjApLFxyXG5cclxuXHRcdFx0XHRsdW1pbmFuY2VDb2VmZmljaWVudHM6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKSxcclxuXHRcdFx0XHRncmV5c2NhbGVJbnRlbnNpdHk6IG5ldyBVbmlmb3JtKG9wdGlvbnMuZ3JleXNjYWxlSW50ZW5zaXR5KSxcclxuXHRcdFx0XHRzZXBpYUludGVuc2l0eTogbmV3IFVuaWZvcm0ob3B0aW9ucy5zZXBpYUludGVuc2l0eSksXHJcblxyXG5cdFx0XHRcdHZpZ25ldHRlT2Zmc2V0OiBuZXcgVW5pZm9ybShvcHRpb25zLnZpZ25ldHRlT2Zmc2V0KSxcclxuXHRcdFx0XHR2aWduZXR0ZURhcmtuZXNzOiBuZXcgVW5pZm9ybShvcHRpb25zLnZpZ25ldHRlRGFya25lc3MpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5ncmV5c2NhbGUpIHsgdGhpcy5kZWZpbmVzLkdSRVlTQ0FMRSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnNlcGlhKSB7IHRoaXMuZGVmaW5lcy5TRVBJQSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnZpZ25ldHRlKSB7IHRoaXMuZGVmaW5lcy5WSUdORVRURSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLmVza2lsKSB7IHRoaXMuZGVmaW5lcy5FU0tJTCA9IFwiMVwiOyB9XHJcblxyXG5cdFx0aWYob3B0aW9ucy5zY3JlZW5Nb2RlKSB7IHRoaXMuZGVmaW5lcy5TQ1JFRU5fTU9ERSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLm5vaXNlKSB7IHRoaXMuZGVmaW5lcy5OT0lTRSA9IFwiMVwiOyB9XHJcblx0XHRpZihvcHRpb25zLnNjYW5saW5lcykgeyB0aGlzLmRlZmluZXMuU0NBTkxJTkVTID0gXCIxXCI7IH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHRQZXJ0dXJiO1xcclxcblxcclxcbnVuaWZvcm0gYm9vbCBhY3RpdmU7XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBhbW91bnQ7XFxyXFxudW5pZm9ybSBmbG9hdCBhbmdsZTtcXHJcXG51bmlmb3JtIGZsb2F0IHNlZWQ7XFxyXFxudW5pZm9ybSBmbG9hdCBzZWVkWDtcXHJcXG51bmlmb3JtIGZsb2F0IHNlZWRZO1xcclxcbnVuaWZvcm0gZmxvYXQgZGlzdG9ydGlvblg7XFxyXFxudW5pZm9ybSBmbG9hdCBkaXN0b3J0aW9uWTtcXHJcXG51bmlmb3JtIGZsb2F0IGNvbFM7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG5mbG9hdCByYW5kKHZlYzIgdGMpIHtcXHJcXG5cXHJcXG5cXHRjb25zdCBmbG9hdCBhID0gMTIuOTg5ODtcXHJcXG5cXHRjb25zdCBmbG9hdCBiID0gNzguMjMzO1xcclxcblxcdGNvbnN0IGZsb2F0IGMgPSA0Mzc1OC41NDUzO1xcclxcblxcclxcblxcdGZsb2F0IGR0ID0gZG90KHRjLCB2ZWMyKGEsIGIpKTtcXHJcXG5cXHRmbG9hdCBzbiA9IG1vZChkdCwgMy4xNCk7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzIgY29vcmQgPSB2VXY7XFxyXFxuXFxyXFxuXFx0ZmxvYXQgeHMsIHlzO1xcclxcblxcdHZlYzQgbm9ybWFsO1xcclxcblxcclxcblxcdHZlYzIgb2Zmc2V0O1xcclxcblxcdHZlYzQgY3IsIGNnYSwgY2I7XFxyXFxuXFx0dmVjNCBzbm93LCBjb2xvcjtcXHJcXG5cXHJcXG5cXHRmbG9hdCBzeCwgc3k7XFxyXFxuXFxyXFxuXFx0aWYoYWN0aXZlKSB7XFxyXFxuXFxyXFxuXFx0XFx0eHMgPSBmbG9vcihnbF9GcmFnQ29vcmQueCAvIDAuNSk7XFxyXFxuXFx0XFx0eXMgPSBmbG9vcihnbF9GcmFnQ29vcmQueSAvIDAuNSk7XFxyXFxuXFxyXFxuXFx0XFx0bm9ybWFsID0gdGV4dHVyZTJEKHRQZXJ0dXJiLCBjb29yZCAqIHNlZWQgKiBzZWVkKTtcXHJcXG5cXHJcXG5cXHRcXHRpZihjb29yZC55IDwgZGlzdG9ydGlvblggKyBjb2xTICYmIGNvb3JkLnkgPiBkaXN0b3J0aW9uWCAtIGNvbFMgKiBzZWVkKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0c3ggPSBjbGFtcChjZWlsKHNlZWRYKSwgMC4wLCAxLjApO1xcclxcblxcdFxcdFxcdGNvb3JkLnkgPSBzeCAqICgxLjAgLSAoY29vcmQueSArIGRpc3RvcnRpb25ZKSkgKyAoMS4wIC0gc3gpICogZGlzdG9ydGlvblk7XFxyXFxuXFxyXFxuXFx0XFx0fVxcclxcblxcclxcblxcdFxcdGlmKGNvb3JkLnggPCBkaXN0b3J0aW9uWSArIGNvbFMgJiYgY29vcmQueCA+IGRpc3RvcnRpb25ZIC0gY29sUyAqIHNlZWQpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRzeSA9IGNsYW1wKGNlaWwoc2VlZFkpLCAwLjAsIDEuMCk7XFxyXFxuXFx0XFx0XFx0Y29vcmQueCA9IHN5ICogZGlzdG9ydGlvblggKyAoMS4wIC0gc3kpICogKDEuMCAtIChjb29yZC54ICsgZGlzdG9ydGlvblgpKTtcXHJcXG5cXHJcXG5cXHRcXHR9XFxyXFxuXFxyXFxuXFx0XFx0Y29vcmQueCArPSBub3JtYWwueCAqIHNlZWRYICogKHNlZWQgLyA1LjApO1xcclxcblxcdFxcdGNvb3JkLnkgKz0gbm9ybWFsLnkgKiBzZWVkWSAqIChzZWVkIC8gNS4wKTtcXHJcXG5cXHJcXG5cXHRcXHRvZmZzZXQgPSBhbW91bnQgKiB2ZWMyKGNvcyhhbmdsZSksIHNpbihhbmdsZSkpO1xcclxcblxcclxcblxcdFxcdGNyID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZCArIG9mZnNldCk7XFxyXFxuXFx0XFx0Y2dhID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZCk7XFxyXFxuXFx0XFx0Y2IgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIGNvb3JkIC0gb2Zmc2V0KTtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IHZlYzQoY3IuciwgY2dhLmcsIGNiLmIsIGNnYS5hKTtcXHJcXG5cXHRcXHRzbm93ID0gMjAwLjAgKiBhbW91bnQgKiB2ZWM0KHJhbmQodmVjMih4cyAqIHNlZWQsIHlzICogc2VlZCAqIDUwLjApKSAqIDAuMik7XFxyXFxuXFx0XFx0Y29sb3IgKz0gc25vdztcXHJcXG5cXHJcXG5cXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdGNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBnbGl0Y2ggc2hhZGVyIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBSZWZlcmVuY2U6XHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vc3RhZmZhbnRhbi91bml0eWdsaXRjaFxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBHbGl0Y2hNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBnbGl0Y2ggbWF0ZXJpYWwuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cclxuXHRcdHN1cGVyKHtcclxuXHJcblx0XHRcdHR5cGU6IFwiR2xpdGNoTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0UGVydHVyYjogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdGFjdGl2ZTogbmV3IFVuaWZvcm0oMSksXHJcblxyXG5cdFx0XHRcdGFtb3VudDogbmV3IFVuaWZvcm0oMC44KSxcclxuXHRcdFx0XHRhbmdsZTogbmV3IFVuaWZvcm0oMC4wMiksXHJcblx0XHRcdFx0c2VlZDogbmV3IFVuaWZvcm0oMC4wMiksXHJcblx0XHRcdFx0c2VlZFg6IG5ldyBVbmlmb3JtKDAuMDIpLFxyXG5cdFx0XHRcdHNlZWRZOiBuZXcgVW5pZm9ybSgwLjAyKSxcclxuXHRcdFx0XHRkaXN0b3J0aW9uWDogbmV3IFVuaWZvcm0oMC41KSxcclxuXHRcdFx0XHRkaXN0b3J0aW9uWTogbmV3IFVuaWZvcm0oMC42KSxcclxuXHRcdFx0XHRjb2xTOiBuZXcgVW5pZm9ybSgwLjA1KVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSB2ZWMzIGxpZ2h0UG9zaXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBmbG9hdCBleHBvc3VyZTtcXHJcXG51bmlmb3JtIGZsb2F0IGRlY2F5O1xcclxcbnVuaWZvcm0gZmxvYXQgZGVuc2l0eTtcXHJcXG51bmlmb3JtIGZsb2F0IHdlaWdodDtcXHJcXG51bmlmb3JtIGZsb2F0IGNsYW1wTWF4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzIgdGV4Q29vcmQgPSB2VXY7XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIHZlY3RvciBmcm9tIHBpeGVsIHRvIGxpZ2h0IHNvdXJjZSBpbiBzY3JlZW4gc3BhY2UuXFxyXFxuXFx0dmVjMiBkZWx0YVRleENvb3JkID0gdGV4Q29vcmQgLSBsaWdodFBvc2l0aW9uLnN0O1xcclxcblxcdGRlbHRhVGV4Q29vcmQgKj0gMS4wIC8gTlVNX1NBTVBMRVNfRkxPQVQgKiBkZW5zaXR5O1xcclxcblxcclxcblxcdC8vIEEgZGVjcmVhc2luZyBpbGx1bWluYXRpb24gZmFjdG9yLlxcclxcblxcdGZsb2F0IGlsbHVtaW5hdGlvbkRlY2F5ID0gMS4wO1xcclxcblxcclxcblxcdHZlYzQgc2FtcGxlO1xcclxcblxcdHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxyXFxuXFxyXFxuXFx0Ly8gRXN0aW1hdGUgdGhlIHByb2JhYmlsaXR5IG9mIG9jY2x1c2lvbiBhdCBlYWNoIHBpeGVsIGJ5IHN1bW1pbmcgc2FtcGxlcyBhbG9uZyBhIHJheSB0byB0aGUgbGlnaHQgc291cmNlLlxcclxcblxcdGZvcihpbnQgaSA9IDA7IGkgPCBOVU1fU0FNUExFU19JTlQ7ICsraSkge1xcclxcblxcclxcblxcdFxcdHRleENvb3JkIC09IGRlbHRhVGV4Q29vcmQ7XFxyXFxuXFx0XFx0c2FtcGxlID0gdGV4dHVyZTJEKHREaWZmdXNlLCB0ZXhDb29yZCk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gQXBwbHkgc2FtcGxlIGF0dGVudWF0aW9uIHNjYWxlL2RlY2F5IGZhY3RvcnMuXFxyXFxuXFx0XFx0c2FtcGxlICo9IGlsbHVtaW5hdGlvbkRlY2F5ICogd2VpZ2h0O1xcclxcblxcclxcblxcdFxcdGNvbG9yICs9IHNhbXBsZTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBVcGRhdGUgZXhwb25lbnRpYWwgZGVjYXkgZmFjdG9yLlxcclxcblxcdFxcdGlsbHVtaW5hdGlvbkRlY2F5ICo9IGRlY2F5O1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHRnbF9GcmFnQ29sb3IgPSBjbGFtcChjb2xvciAqIGV4cG9zdXJlLCAwLjAsIGNsYW1wTWF4KTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogQSBjcmVwdXNjdWxhciByYXlzIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogUmVmZXJlbmNlczpcclxuICpcclxuICogVGhpYmF1dCBEZXNwb3VsYWluLCAyMDEyOlxyXG4gKiAgWyhXZWJHTCkgVm9sdW1ldHJpYyBMaWdodCBBcHByb3hpbWF0aW9uIGluIFRocmVlLmpzXShcclxuICogIGh0dHA6Ly9ia2NvcmUuY29tL2Jsb2cvM2Qvd2ViZ2wtdGhyZWUtanMtdm9sdW1ldHJpYy1saWdodC1nb2RyYXlzLmh0bWwpXHJcbiAqXHJcbiAqIE52aWRpYSwgR1BVIEdlbXMgMywgMjAwODpcclxuICogIFtDaGFwdGVyIDEzLiBWb2x1bWV0cmljIExpZ2h0IFNjYXR0ZXJpbmcgYXMgYSBQb3N0LVByb2Nlc3NdKFxyXG4gKiAgaHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9ncHVnZW1zL0dQVUdlbXMzL2dwdWdlbXMzX2NoMTMuaHRtbClcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgR29kUmF5c01hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGdvZCByYXlzIG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkdvZFJheXNNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0ZGVmaW5lczoge1xyXG5cclxuXHRcdFx0XHROVU1fU0FNUExFU19GTE9BVDogXCI2MC4wXCIsXHJcblx0XHRcdFx0TlVNX1NBTVBMRVNfSU5UOiBcIjYwXCJcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0bGlnaHRQb3NpdGlvbjogbmV3IFVuaWZvcm0obnVsbCksXHJcblxyXG5cdFx0XHRcdGV4cG9zdXJlOiBuZXcgVW5pZm9ybSgwLjYpLFxyXG5cdFx0XHRcdGRlY2F5OiBuZXcgVW5pZm9ybSgwLjkzKSxcclxuXHRcdFx0XHRkZW5zaXR5OiBuZXcgVW5pZm9ybSgwLjk2KSxcclxuXHRcdFx0XHR3ZWlnaHQ6IG5ldyBVbmlmb3JtKDAuNCksXHJcblx0XHRcdFx0Y2xhbXBNYXg6IG5ldyBVbmlmb3JtKDEuMClcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMiwgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gZmxvYXQgZGlzdGluY3Rpb247XFxyXFxudW5pZm9ybSB2ZWMyIHJhbmdlO1xcclxcbnVuaWZvcm0gdmVjMyBsdW1pbmFuY2VDb2VmZmljaWVudHM7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2KTtcXHJcXG5cXHRmbG9hdCB2ID0gZG90KHRleGVsLnJnYiwgbHVtaW5hbmNlQ29lZmZpY2llbnRzKTtcXHJcXG5cXHJcXG5cXHQjaWZkZWYgUkFOR0VcXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBsb3cgPSBzdGVwKHJhbmdlLngsIHYpO1xcclxcblxcdFxcdGZsb2F0IGhpZ2ggPSBzdGVwKHYsIHJhbmdlLnkpO1xcclxcblxcclxcblxcdFxcdC8vIEFwcGx5IHRoZSBtYXNrLlxcclxcblxcdFxcdHYgKj0gbG93ICogaGlnaDtcXHJcXG5cXHJcXG5cXHQjZW5kaWZcXHJcXG5cXHJcXG5cXHR2ID0gcG93KGFicyh2KSwgZGlzdGluY3Rpb24pO1xcclxcblxcclxcblxcdCNpZmRlZiBDT0xPUlxcclxcblxcclxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQodGV4ZWwucmdiICogdiwgdGV4ZWwuYSk7XFxyXFxuXFxyXFxuXFx0I2Vsc2VcXHJcXG5cXHJcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHYsIHYsIHYsIHRleGVsLmEpO1xcclxcblxcclxcblxcdCNlbmRpZlxcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIGx1bWlub3NpdHkgc2hhZGVyIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBUaGlzIHNoYWRlciBwcm9kdWNlcyBhIGdyZXlzY2FsZSBsdW1pbmFuY2UgbWFwIHRoYXQgZGVzY3JpYmVzIHRoZSBhYnNvbHV0ZVxyXG4gKiBhbW91bnQgb2YgbGlnaHQgZW1pdHRlZCBieSBhIHNjZW5lLiBJdCBjYW4gYWxzbyBiZSBjb25maWd1cmVkIHRvIG91dHB1dFxyXG4gKiBjb2xvdXJzIHRoYXQgYXJlIHNjYWxlZCB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgbHVtaW5hbmNlIHZhbHVlLiBBZGRpdGlvbmFsbHksXHJcbiAqIGEgcmFuZ2UgbWF5IGJlIHByb3ZpZGVkIHRvIG1hc2sgb3V0IHVuZGVzaXJlZCB0ZXhlbHMuXHJcbiAqXHJcbiAqIFRoZSBhbHBoYSBjaGFubmVsIHdpbGwgcmVtYWluIHVuYWZmZWN0ZWQgaW4gYWxsIGNhc2VzLlxyXG4gKlxyXG4gKiBPbiBsdW1pbmFuY2UgY29lZmZpY2llbnRzOlxyXG4gKiAgaHR0cDovL3d3dy5wb3ludG9uLmNvbS9ub3Rlcy9jb2xvdXJfYW5kX2dhbW1hL0NvbG9yRkFRLmh0bWwjUlRGVG9DOVxyXG4gKlxyXG4gKiBDb2VmZmljaWVudHMgZm9yIGRpZmZlcmVudCBjb2xvdXIgc3BhY2VzOlxyXG4gKiAgaHR0cHM6Ly9oc3RvLm9yZy9nZXRwcm8vaGFici9wb3N0X2ltYWdlcy8yYWIvNjlkLzA4NC8yYWI2OWQwODRmOWE1OTdlMDMyNjI0YmNkNzRkNTdhNy5wbmdcclxuICpcclxuICogTHVtaW5hbmNlIHJhbmdlIHJlZmVyZW5jZTpcclxuICogIGh0dHBzOi8vY3ljbGluZzc0LmNvbS8yMDA3LzA1LzIzL3lvdXItZmlyc3Qtc2hhZGVyLyMuVnR5OUZma3JMNFpcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgTHVtaW5vc2l0eU1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGx1bWlub3NpdHkgbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb2xvcj1mYWxzZV0gLSBEZWZpbmVzIHdoZXRoZXIgdGhlIHNoYWRlciBzaG91bGQgb3V0cHV0IGNvbG91cnMgc2NhbGVkIHdpdGggdGhlaXIgbHVtaW5hbmNlIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3JhbmdlXSAtIElmIHByb3ZpZGVkLCB0aGUgc2hhZGVyIHdpbGwgbWFzayBvdXQgdGV4ZWxzIHRoYXQgYXJlbid0IGluIHRoZSBzcGVjaWZpZWQgbHVtaW5hbmNlIHJhbmdlLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihjb2xvciA9IGZhbHNlLCByYW5nZSA9IG51bGwpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIkx1bWlub3NpdHlNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdGRpc3RpbmN0aW9uOiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdHJhbmdlOiBuZXcgVW5pZm9ybSgocmFuZ2UgIT09IG51bGwpID8gcmFuZ2UgOiBuZXcgVmVjdG9yMigpKSxcclxuXHRcdFx0XHRsdW1pbmFuY2VDb2VmZmljaWVudHM6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IzKDAuMjEyNiwgMC43MTUyLCAwLjA3MjIpKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXhcclxuXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZihjb2xvcikgeyB0aGlzLmRlZmluZXMuQ09MT1IgPSBcIjFcIjsgfVxyXG5cdFx0aWYocmFuZ2UgIT09IG51bGwpIHsgdGhpcy5kZWZpbmVzLlJBTkdFID0gXCIxXCI7IH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgVW5pZm9ybSwgVmVjdG9yMiB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gZmxvYXQgZ3JhbnVsYXJpdHk7XFxyXFxudW5pZm9ybSBmbG9hdCBkeDtcXHJcXG51bmlmb3JtIGZsb2F0IGR5O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzQgdGV4ZWw7XFxyXFxuXFxyXFxuXFx0aWYoZ3JhbnVsYXJpdHkgPiAwLjApIHtcXHJcXG5cXHJcXG5cXHRcXHR2ZWMyIGNvb3JkID0gdmVjMihcXHJcXG5cXHRcXHRcXHRkeCAqIChmbG9vcih2VXYueCAvIGR4KSArIDAuNSksXFxyXFxuXFx0XFx0XFx0ZHkgKiAoZmxvb3IodlV2LnkgLyBkeSkgKyAwLjUpXFxyXFxuXFx0XFx0KTtcXHJcXG5cXHJcXG5cXHRcXHR0ZXhlbCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmQpO1xcclxcblxcclxcblxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0dGV4ZWwgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdik7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHRleGVsO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ2YXJ5aW5nIHZlYzIgdlV2O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBpeGVsYXRpb24gc2hhZGVyIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBzaGFkZXIgY29kZSBieSBSb2JlcnQgQ2FzYW5vdmE6XHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vcm9iZXJ0Y2FzYW5vdmEvcGl4ZWxhdGUtc2hhZGVyXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFBpeGVsYXRpb25NYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwaXhlbGF0aW9uIG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIlBpeGVsYXRpb25NYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdGdyYW51bGFyaXR5OiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdHJlc29sdXRpb246IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKDEuMCwgMS4wKSksXHJcblx0XHRcdFx0ZHg6IG5ldyBVbmlmb3JtKDEuMCksXHJcblx0XHRcdFx0ZHk6IG5ldyBVbmlmb3JtKDEuMClcclxuXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZnJhZ21lbnQsXHJcblx0XHRcdHZlcnRleFNoYWRlcjogdmVydGV4LFxyXG5cclxuXHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXHJcblx0XHRcdGRlcHRoVGVzdDogZmFsc2VcclxuXHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRnZXQgZ3JhbnVsYXJpdHkoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdyYW51bGFyaXR5LnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEEgaGlnaGVyIHZhbHVlIHlpZWxkcyBjb2Fyc2VyIHZpc3VhbHMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgZ3JhbnVsYXJpdHkoeCkge1xyXG5cclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcclxuXHRcdGNvbnN0IHJlc29sdXRpb24gPSB1bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlO1xyXG5cclxuXHRcdHVuaWZvcm1zLmdyYW51bGFyaXR5LnZhbHVlID0geDtcclxuXHRcdHVuaWZvcm1zLmR4LnZhbHVlID0geCAvIHJlc29sdXRpb24ueDtcclxuXHRcdHVuaWZvcm1zLmR5LnZhbHVlID0geCAvIHJlc29sdXRpb24ueTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSByZXNvbHV0aW9uLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRSZXNvbHV0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUuc2V0KHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0dGhpcy5ncmFudWxhcml0eSA9IHRoaXMuZ3JhbnVsYXJpdHk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmNvbnN0IGZyYWdtZW50ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xcclxcbnVuaWZvcm0gdmVjMiBjZW50ZXI7XFxyXFxudW5pZm9ybSBmbG9hdCBhc3BlY3Q7XFxyXFxudW5pZm9ybSBmbG9hdCB3YXZlU2l6ZTtcXHJcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXHJcXG51bmlmb3JtIGZsb2F0IG1heFJhZGl1cztcXHJcXG51bmlmb3JtIGZsb2F0IGFtcGxpdHVkZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgZmxvYXQgdlNpemU7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZlYzIgYXNwZWN0Q29ycmVjdGlvbiA9IHZlYzIoYXNwZWN0LCAxLjApO1xcclxcblxcclxcblxcdHZlYzIgZGlmZmVyZW5jZSA9IHZVdiAqIGFzcGVjdENvcnJlY3Rpb24gLSBjZW50ZXIgKiBhc3BlY3RDb3JyZWN0aW9uO1xcclxcblxcdGZsb2F0IGRpc3RhbmNlID0gc3FydChkb3QoZGlmZmVyZW5jZSwgZGlmZmVyZW5jZSkpICogdlNpemU7XFxyXFxuXFxyXFxuXFx0dmVjMiBkaXNwbGFjZW1lbnQgPSB2ZWMyKDAuMCk7XFxyXFxuXFxyXFxuXFx0aWYoZGlzdGFuY2UgPiByYWRpdXMpIHtcXHJcXG5cXHJcXG5cXHRcXHRpZihkaXN0YW5jZSA8IHJhZGl1cyArIHdhdmVTaXplKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZmxvYXQgYW5nbGUgPSAoZGlzdGFuY2UgLSByYWRpdXMpICogUEkyIC8gd2F2ZVNpemU7XFxyXFxuXFx0XFx0XFx0ZmxvYXQgY29zU2luID0gKDEuMCAtIGNvcyhhbmdsZSkpICogMC41O1xcclxcblxcclxcblxcdFxcdFxcdGZsb2F0IGV4dGVudCA9IG1heFJhZGl1cyArIHdhdmVTaXplO1xcclxcblxcdFxcdFxcdGZsb2F0IGRlY2F5ID0gbWF4KGV4dGVudCAtIGRpc3RhbmNlICogZGlzdGFuY2UsIDAuMCkgLyBleHRlbnQ7XFxyXFxuXFxyXFxuXFx0XFx0XFx0ZGlzcGxhY2VtZW50ID0gKChjb3NTaW4gKiBhbXBsaXR1ZGUgKiBkaWZmZXJlbmNlKSAvIGRpc3RhbmNlKSAqIGRlY2F5O1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYgLSBkaXNwbGFjZW1lbnQpO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxyXFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcXHJcXG51bmlmb3JtIGZsb2F0IGNhbWVyYURpc3RhbmNlO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyBmbG9hdCB2U2l6ZTtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0dlNpemUgPSAoMC4xICogY2FtZXJhRGlzdGFuY2UpIC8gc2l6ZTtcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuXHJcbi8qKlxyXG4gKiBBIHNob2NrIHdhdmUgc2hhZGVyIG1hdGVyaWFsLlxyXG4gKlxyXG4gKiBCYXNlZCBvbiBhIEdpc3QgYnkgSmVhbi1QaGlsaXBwZSBTYXJkYTpcclxuICogIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2pwc2FyZGEvMzNjZWE2N2E5ZjJlY2IwYTBlZGFcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU2hvY2tXYXZlTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2hvY2sgd2F2ZSBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2F2ZVNpemU9MC4yXSAtIFRoZSB3YXZlIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFtcGxpdHVkZT0wLjA1XSAtIFRoZSBkaXN0b3J0aW9uIGFtcGxpdHVkZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5tYXhSYWRpdXMgPT09IHVuZGVmaW5lZCkgeyBvcHRpb25zLm1heFJhZGl1cyA9IDEuMDsgfVxyXG5cdFx0aWYob3B0aW9ucy53YXZlU2l6ZSA9PT0gdW5kZWZpbmVkKSB7IG9wdGlvbnMud2F2ZVNpemUgPSAwLjI7IH1cclxuXHRcdGlmKG9wdGlvbnMuYW1wbGl0dWRlID09PSB1bmRlZmluZWQpIHsgb3B0aW9ucy5hbXBsaXR1ZGUgPSAwLjA1OyB9XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJTaG9ja1dhdmVNYXRlcmlhbFwiLFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cclxuXHRcdFx0XHRjZW50ZXI6IG5ldyBVbmlmb3JtKG5ldyBWZWN0b3IyKDAuNSwgMC41KSksXHJcblx0XHRcdFx0YXNwZWN0OiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdGNhbWVyYURpc3RhbmNlOiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cclxuXHRcdFx0XHRzaXplOiBuZXcgVW5pZm9ybSgxLjApLFxyXG5cdFx0XHRcdHJhZGl1czogbmV3IFVuaWZvcm0oLW9wdGlvbnMud2F2ZVNpemUpLFxyXG5cdFx0XHRcdG1heFJhZGl1czogbmV3IFVuaWZvcm0ob3B0aW9ucy5tYXhSYWRpdXMpLFxyXG5cdFx0XHRcdHdhdmVTaXplOiBuZXcgVW5pZm9ybShvcHRpb25zLndhdmVTaXplKSxcclxuXHRcdFx0XHRhbXBsaXR1ZGU6IG5ldyBVbmlmb3JtKG9wdGlvbnMuYW1wbGl0dWRlKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdFdlaWdodHM7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMyIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlV2O1xcclxcbnZhcnlpbmcgdmVjNCB2T2Zmc2V0O1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHQvLyBGZXRjaCB0aGUgYmxlbmRpbmcgd2VpZ2h0cyBmb3IgY3VycmVudCBwaXhlbC5cXHJcXG5cXHR2ZWM0IGE7XFxyXFxuXFx0YS54eiA9IHRleHR1cmUyRCh0V2VpZ2h0cywgdlV2KS54ejtcXHJcXG5cXHRhLnkgPSB0ZXh0dXJlMkQodFdlaWdodHMsIHZPZmZzZXQuencpLmc7XFxyXFxuXFx0YS53ID0gdGV4dHVyZTJEKHRXZWlnaHRzLCB2T2Zmc2V0Lnh5KS5hO1xcclxcblxcclxcblxcdHZlYzQgY29sb3I7XFxyXFxuXFxyXFxuXFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgYW55IGJsZW5kaW5nIHdlaWdodCB3aXRoIGEgdmFsdWUgZ3JlYXRlciB0aGFuIDAuMC5cXHJcXG5cXHRpZihkb3QoYSwgdmVjNCgxLjApKSA8IDFlLTUpIHtcXHJcXG5cXHJcXG5cXHRcXHRjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2LCAwLjApO1xcclxcblxcclxcblxcdH0gZWxzZSB7XFxyXFxuXFxyXFxuXFx0XFx0LyogVXAgdG8gZm91ciBsaW5lcyBjYW4gYmUgY3Jvc3NpbmcgYSBwaXhlbCAob25lIHRocm91Z2ggZWFjaCBlZGdlKS4gV2UgZmF2b3JcXHJcXG5cXHRcXHQgKiBibGVuZGluZyBieSBjaG9vc2luZyB0aGUgbGluZSB3aXRoIHRoZSBtYXhpbXVtIHdlaWdodCBmb3IgZWFjaCBkaXJlY3Rpb24uXFxyXFxuXFx0XFx0ICovXFxyXFxuXFxyXFxuXFx0XFx0dmVjMiBvZmZzZXQ7XFxyXFxuXFx0XFx0b2Zmc2V0LnggPSBhLmEgPiBhLmIgPyBhLmEgOiAtYS5iOyAvLyBMZWZ0IHZzLiByaWdodC5cXHJcXG5cXHRcXHRvZmZzZXQueSA9IGEuZyA+IGEuciA/IC1hLmcgOiBhLnI7IC8vIFRvcCB2cy4gYm90dG9tIChjaGFuZ2VkIHNpZ25zKS5cXHJcXG5cXHJcXG5cXHRcXHQvLyBUaGVuIHdlIGdvIGluIHRoZSBkaXJlY3Rpb24gdGhhdCBoYXMgdGhlIG1heGltdW0gd2VpZ2h0IChob3Jpem9udGFsIHZzLiB2ZXJ0aWNhbCkuXFxyXFxuXFx0XFx0aWYoYWJzKG9mZnNldC54KSA+IGFicyhvZmZzZXQueSkpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHRvZmZzZXQueSA9IDAuMDtcXHJcXG5cXHJcXG5cXHRcXHR9IGVsc2Uge1xcclxcblxcclxcblxcdFxcdFxcdG9mZnNldC54ID0gMC4wO1xcclxcblxcclxcblxcdFxcdH1cXHJcXG5cXHJcXG5cXHRcXHQvLyBGZXRjaCB0aGUgb3Bwb3NpdGUgY29sb3IgYW5kIGxlcnAgYnkgaGFuZC5cXHJcXG5cXHRcXHRjb2xvciA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdlV2LCAwLjApO1xcclxcblxcdFxcdHZlYzIgY29vcmQgPSB2VXYgKyBzaWduKG9mZnNldCkgKiB0ZXhlbFNpemU7XFxyXFxuXFx0XFx0dmVjNCBvcHBvc2l0ZUNvbG9yID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZCwgMC4wKTtcXHJcXG5cXHRcXHRmbG9hdCBzID0gYWJzKG9mZnNldC54KSA+IGFicyhvZmZzZXQueSkgPyBhYnMob2Zmc2V0LngpIDogYWJzKG9mZnNldC55KTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBHYW1tYSBjb3JyZWN0aW9uLlxcclxcblxcdFxcdGNvbG9yLnJnYiA9IHBvdyhhYnMoY29sb3IucmdiKSwgdmVjMygyLjIpKTtcXHJcXG5cXHRcXHRvcHBvc2l0ZUNvbG9yLnJnYiA9IHBvdyhhYnMob3Bwb3NpdGVDb2xvci5yZ2IpLCB2ZWMzKDIuMikpO1xcclxcblxcdFxcdGNvbG9yID0gbWl4KGNvbG9yLCBvcHBvc2l0ZUNvbG9yLCBzKTtcXHJcXG5cXHRcXHRjb2xvci5yZ2IgPSBwb3coYWJzKGNvbG9yLnJnYiksIHZlYzMoMS4wIC8gMi4yKSk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWM0IHZPZmZzZXQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcclxcblxcdHZPZmZzZXQgPSB1di54eXh5ICsgdGV4ZWxTaXplLnh5eHkgKiB2ZWM0KDEuMCwgMC4wLCAwLjAsIC0xLjApOyAvLyBDaGFuZ2VkIHNpZ24gaW4gVyBjb21wb25lbnQuXFxyXFxuXFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogU3VicGl4ZWwgTW9ycGhvbG9naWNhbCBBbnRpYWxpYXNpbmcuXHJcbiAqXHJcbiAqIFRoaXMgbWF0ZXJpYWwgaXMgdXNlZCB0byByZW5kZXIgdGhlIGZpbmFsIGFudGlhbGlhc2luZy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU01BQUJsZW5kTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgU01BQSBibGVuZCBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgYWJzb2x1dGUgc2NyZWVuIHRleGVsIHNpemUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyKCkpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIlNNQUFCbGVuZE1hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHR1bmlmb3Jtczoge1xyXG5cclxuXHRcdFx0XHR0RGlmZnVzZTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dFdlaWdodHM6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRleGVsU2l6ZTogbmV3IFVuaWZvcm0odGV4ZWxTaXplKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IyIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzQgdk9mZnNldFszXTtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0Y29uc3QgdmVjMiBUSFJFU0hPTEQgPSB2ZWMyKEVER0VfVEhSRVNIT0xEKTtcXHJcXG5cXHJcXG5cXHQvLyBDYWxjdWxhdGUgY29sb3IgZGVsdGFzLlxcclxcblxcdHZlYzQgZGVsdGE7XFxyXFxuXFx0dmVjMyBjID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpLnJnYjtcXHJcXG5cXHJcXG5cXHR2ZWMzIGNMZWZ0ID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2T2Zmc2V0WzBdLnh5KS5yZ2I7XFxyXFxuXFx0dmVjMyB0ID0gYWJzKGMgLSBjTGVmdCk7XFxyXFxuXFx0ZGVsdGEueCA9IG1heChtYXgodC5yLCB0LmcpLCB0LmIpO1xcclxcblxcclxcblxcdHZlYzMgY1RvcCA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdk9mZnNldFswXS56dykucmdiO1xcclxcblxcdHQgPSBhYnMoYyAtIGNUb3ApO1xcclxcblxcdGRlbHRhLnkgPSBtYXgobWF4KHQuciwgdC5nKSwgdC5iKTtcXHJcXG5cXHJcXG5cXHQvLyBXZSBkbyB0aGUgdXN1YWwgdGhyZXNob2xkLlxcclxcblxcdHZlYzIgZWRnZXMgPSBzdGVwKFRIUkVTSE9MRCwgZGVsdGEueHkpO1xcclxcblxcclxcblxcdC8vIFRoZW4gZGlzY2FyZCBpZiB0aGVyZSBpcyBubyBlZGdlLlxcclxcblxcdGlmKGRvdChlZGdlcywgdmVjMigxLjApKSA9PSAwLjApIHtcXHJcXG5cXHJcXG5cXHRcXHRkaXNjYXJkO1xcclxcblxcclxcblxcdH1cXHJcXG5cXHJcXG5cXHQvLyBDYWxjdWxhdGUgcmlnaHQgYW5kIGJvdHRvbSBkZWx0YXMuXFxyXFxuXFx0dmVjMyBjUmlnaHQgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZPZmZzZXRbMV0ueHkpLnJnYjtcXHJcXG5cXHR0ID0gYWJzKGMgLSBjUmlnaHQpO1xcclxcblxcdGRlbHRhLnogPSBtYXgobWF4KHQuciwgdC5nKSwgdC5iKTtcXHJcXG5cXHJcXG5cXHR2ZWMzIGNCb3R0b20gID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2T2Zmc2V0WzFdLnp3KS5yZ2I7XFxyXFxuXFx0dCA9IGFicyhjIC0gY0JvdHRvbSk7XFxyXFxuXFx0ZGVsdGEudyA9IG1heChtYXgodC5yLCB0LmcpLCB0LmIpO1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSB0aGUgbWF4aW11bSBkZWx0YSBpbiB0aGUgZGlyZWN0IG5laWdoYm9yaG9vZC5cXHJcXG5cXHRmbG9hdCBtYXhEZWx0YSA9IG1heChtYXgobWF4KGRlbHRhLngsIGRlbHRhLnkpLCBkZWx0YS56KSwgZGVsdGEudyk7XFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIGxlZnQtbGVmdCBhbmQgdG9wLXRvcCBkZWx0YXMuXFxyXFxuXFx0dmVjMyBjTGVmdExlZnQgID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2T2Zmc2V0WzJdLnh5KS5yZ2I7XFxyXFxuXFx0dCA9IGFicyhjIC0gY0xlZnRMZWZ0KTtcXHJcXG5cXHRkZWx0YS56ID0gbWF4KG1heCh0LnIsIHQuZyksIHQuYik7XFxyXFxuXFxyXFxuXFx0dmVjMyBjVG9wVG9wID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2T2Zmc2V0WzJdLnp3KS5yZ2I7XFxyXFxuXFx0dCA9IGFicyhjIC0gY1RvcFRvcCk7XFxyXFxuXFx0ZGVsdGEudyA9IG1heChtYXgodC5yLCB0LmcpLCB0LmIpO1xcclxcblxcclxcblxcdC8vIENhbGN1bGF0ZSB0aGUgZmluYWwgbWF4aW11bSBkZWx0YS5cXHJcXG5cXHRtYXhEZWx0YSA9IG1heChtYXgobWF4RGVsdGEsIGRlbHRhLnopLCBkZWx0YS53KTtcXHJcXG5cXHJcXG5cXHQvLyBMb2NhbCBjb250cmFzdCBhZGFwdGF0aW9uIGluIGFjdGlvbi5cXHJcXG5cXHRlZGdlcy54eSAqPSBzdGVwKDAuNSAqIG1heERlbHRhLCBkZWx0YS54eSk7XFxyXFxuXFxyXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChlZGdlcywgMC4wLCAwLjApO1xcclxcblxcclxcbn1cXHJcXG5cIjtcclxuY29uc3QgdmVydGV4ID0gXCJ1bmlmb3JtIHZlYzIgdGV4ZWxTaXplO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxudmFyeWluZyB2ZWM0IHZPZmZzZXRbM107XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcblxcclxcblxcdHZVdiA9IHV2O1xcclxcblxcclxcblxcdHZPZmZzZXRbMF0gPSB1di54eXh5ICsgdGV4ZWxTaXplLnh5eHkgKiB2ZWM0KC0xLjAsIDAuMCwgMC4wLCAxLjApOyAvLyBDaGFuZ2VkIHNpZ24gaW4gVyBjb21wb25lbnQuXFxyXFxuXFx0dk9mZnNldFsxXSA9IHV2Lnh5eHkgKyB0ZXhlbFNpemUueHl4eSAqIHZlYzQoMS4wLCAwLjAsIDAuMCwgLTEuMCk7IC8vIENoYW5nZWQgc2lnbiBpbiBXIGNvbXBvbmVudC5cXHJcXG5cXHR2T2Zmc2V0WzJdID0gdXYueHl4eSArIHRleGVsU2l6ZS54eXh5ICogdmVjNCgtMi4wLCAwLjAsIDAuMCwgMi4wKTsgLy8gQ2hhbmdlZCBzaWduIGluIFcgY29tcG9uZW50LlxcclxcblxcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIFN1YnBpeGVsIE1vcnBob2xvZ2ljYWwgQW50aWFsaWFzaW5nLlxyXG4gKlxyXG4gKiBUaGlzIG1hdGVyaWFsIGRldGVjdHMgZWRnZXMgaW4gYSBjb2xvciB0ZXh0dXJlLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBTTUFBQ29sb3JFZGdlc01hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFNNQUEgY29sb3IgZWRnZXMgbWF0ZXJpYWwuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1ZlY3RvcjJ9IFt0ZXhlbFNpemVdIC0gVGhlIGFic29sdXRlIHNjcmVlbiB0ZXhlbCBzaXplLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3Rvcih0ZXhlbFNpemUgPSBuZXcgVmVjdG9yMigpKSB7XHJcblxyXG5cdFx0c3VwZXIoe1xyXG5cclxuXHRcdFx0dHlwZTogXCJTTUFBQ29sb3JFZGdlc01hdGVyaWFsXCIsXHJcblxyXG5cdFx0XHRkZWZpbmVzOiB7XHJcblxyXG5cdFx0XHRcdEVER0VfVEhSRVNIT0xEOiBcIjAuMVwiXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0dW5pZm9ybXM6IHtcclxuXHJcblx0XHRcdFx0dERpZmZ1c2U6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdHRleGVsU2l6ZTogbmV3IFVuaWZvcm0odGV4ZWxTaXplKVxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudCxcclxuXHRcdFx0dmVydGV4U2hhZGVyOiB2ZXJ0ZXgsXHJcblxyXG5cdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZVxyXG5cclxuXHRcdH0pO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFLQUFBQUl3Q0FJQUFBQ09WUGNRQUFDQmVrbEVRVlI0MnUzOVc0eGxXWHJuaC8zV1d2dWNpSXpNckt4clY4LzByV2JZMCtTUUZLY2I0b3dJa1NJRkNqWTlBQzFCVC9MWUJvelJpK0VYK2NWKzhJTXNZQWFDd1JjQndqek1pdzJqQVd0Z3dDOFdSNVE4bURGSFpMTkhUYXJaR3JMSkpsbHQxVzJxS3JzdW1aV1pjVHZuN0wzVzU0ZTF2clhYM3Z1Y2lMUFBPUkZSMVhFMkVvbW9yQjBuVnV6Ly9yNzFyZS95LzFlTXZiNENiM04xMXhWL1BQLzJ2NFVCQXdKRy83SDh1cng2LzI1L0dmOE81aHlwTVEwRUVFUXdBcUxmb04vWis5N2YvU1crL052Y2dRazRzR0JKSzZIN040UEZWTCtLK2UwTjExeU5ma0t2d1Vkd2RsVUFYUEhITDM4b2ExNWYvaS80NkloNlN1TVNQbUxBWUF3eVJLbjdkZk1HSDk3amFNRkJZQ0pVZ290SUMyWUFkdStMeVc5dnZ1YnhBUDhrQUw4SC9rb0F1T0tQMytxNit4R25kNWtkWUNlRUNuR0lKVml3R0pNQWtRS2ZEdkIzV1p4akxLR2g4VlNDQ3pod0VXQnBNYzUva0JiamF3VDRIbndKZmhyK3BQQkl1N3V1K09PVG85dnNtdFFjbmlNQkdrS0ZkNGpEV01TQ1JVcExqSllOSmtNK0lSelErUFF2SWVBTVRyQlMyTEVpYWlSOWIvNVB1VDZBcC9BY2ZBRk80WTNkQTNERkg3L1ZTK004azRiYUVBUWZNSTRRZmJWRERHSVJnN0dLYUlZNTJxQWpUQWdUdkdCQVBHSUlnaE9DWUFVckdGTmd6QTdRM1FoZ0N3ZndBbndlNXZEZWpnRzQ0by9mYm0xQzVabFlRdlFEQVJQQUlRR3hDV0JNK3dXbDM3WlFFU2I0Z0ltZXhHTURvdWhHTHgxQ3N0MFNhYTRiNEFxTzRIazRneG8rM0RIQVYvbngyN3AzSnppUE0ycFZnb2lpYTVNZEV6Q0dVTHBySU43Z0VFZVE1SVF4RUJCQlFueGhzRGI1YXVHbUFBWWNITUE5ZUFBejhQQm9sOC94aWo5K0M0RGpsaW00Z0pqV2N3WkJoQ0JnTUlJWXhHQVZJa0gzWnRjQnVMZHRSRk1Xc1BHb1k5ck4rSG9Camk5VkJZZHdEMlpRZzRjbk83T1NxL3o0clU1S0tkd1ZiRkFqTm9qQ1F6VGxDTFBGU3h0YW13aDJqTVVjRWdnMldtLzZYZ0VySUJoQmNrUXRHTjNDemJWYWNFUmdDbmZnTHN3aG52cWY3UXlBcS96NHJSWm0xWWdsWUUzYWZmR0lUYVpzZEllMkZtTUlwbk9DYXAyNUk2anQya0N3Q1cwRDF1QUQ5c1pjdE5HWGNRSUhDa0lORFFnYzc4YUNyK3pqdHczQlUvaWpkcHczemhDd2NhT053QnZkZVMyWVpLa0pOSnNNUGYySktFdkMyOFJYeHhJMEFTSnl6UUNqQ0VRck80UTdzRkFyRXpqWmhhRmM0Y2R2Ky9KRmRLVUxNNHB4MERmVUJJMmhJc3kwNkJxTGhHVFFFVmRiZkFJWlhZTVBlc3E2Vm9DSElDelV5andJbk80WTQxMS8vTFlMczZURGE5d3ZnMkNDMnJFbGdBbnBUQnppVGh4YUwyMk1ZaHpma2doejZHQXMyVkhiYmRNOTFWWnUxTUVFcHVwTU13S3lWVGI1aWo5K3U0VkpHLzVFZ0VNTW1GRjAxY0ZhaTNpc1JiS2J6YitZYVUvTVFiQW0yWFNNb1VQQW12WnpidUtZUklGQXBidGxyZkZ1VUdkNnZxMmhYTm5INzhaTGgvaUZoc1FHM1Q0RDFpYjdrNUNDNnZZMERDYnRyb2hnTEVJQ2xYaUd0bDEwemMwQ25FR0loaGF0TEJ2YTdOUDU4VHZ3MHFFOHlXaEFSTFE4aDQrQWhRU1ArSTRGNXhvVStWaWxHUkpzNnduUzdydXRpLzRLdkFZL0NmZGdxanNNeTRwZjhmb2RRTzgvZ251WDNmLzN4aTNvbTEvaDdUSHIrY28zeDkzUFA5K0ZCVWZiTlVqY2pFbWhjcmtUKzhLN21sN1YxMEpvMDVtcElFRnkxTm1DSld4OVNJS0t0K0VqQUw0RXo4RUJWT0I2aGF2dVQvckJ5UHZIWEsrOXpVY2ZjYmIyNTQrOWZ5ZEprblluUnIxb0dmZGFpQWdweHUxUngvUmVrOEtJU2Z0eDNMK0Rmc0xXQUFObjhIdncwL0FGZUFHTzlERlYzYzZEK0NjV2JMOERqOWU3ZitUMWs4QVp2L2Q3K1BYV00vWitWdmRDckl2dUFLTzA5UnBFRVFKTTBDaTYrQjR4aFRXcjRjWk5PdmhrdGFidzB0YTByU0ptcXozWXc1L0FLWHdlbm9kN2NBaFRtQlNQS2Y2SkJkdkg4SVAxN2g5NXBYcXc1MC8rQkZuajg4ZmV2NE5jaHlhSzQ3T1BoaHRJOFJGU3ZBZkRTTmgwQ2swcDJnTHhHa2liNU5Kai9KV0NyOTBFV1FKdndCek80QUhjZ3p0d0FGTjFldkhQVVZHd2ZYT04rMGRlYlQxWWVHT045WXk5LzYzWCtPZ3Vpd21oSWhRaEQ3bDRzTXFsRzNEODZTdWMzcVdaNHJXakkxWDd1MFl0dzZ4M3JJTWVJT1BEcHJmZTJYek5neWo2UGFoaEJqTzRDM2U2cHVEZ1hyZGcrLzVsOTQ4dkYzYnF3WmV0Wit6OVJ4OXpkSVk1cEluUEs0TmswdCtsNTJ4ZEsyQjQ1UWQ4N25NOGZzRDVFZlVoSWNKY0VSdzRSZHFxSDdZZGU1VjdtMXZoTm10ZWRrejZFRHpVTUYvMmpKWVdiQys0Znp6QS9ZKy84UFBIM2o5ZGNCQVBJUlA4SkxYZDVCcEF1MDNhemlPTDNWVkhaenozQ1hXRFBXZCtTSDJBbnhJcVFvVFpwbzlDa2M2SElyRmJBYnpObWxjZzhBZzhORkREQWhiSnZUQlpYYkM5NFA3dDY4RVhmdjZvKzIxZ1V0UEVUVTdiYmtMeHZOS1JGRzIrS1h6dnRPYm9uUFA0ckJ2c2dtYUtqNDA0RGxzaEZvbGUxR2xmaDAyZkU3YllSN2RaODJvVGV3SUJHbjFNZDZDRzZZVUYyNlgzNzZvZXZPTHp4OTV2aFVtZ2JsSTZMQlp3VENEWTd2TXEwb3A1V1ZYZ3NPYk9YSisxeDNxYUJsOWoxRmVMeGJoVTl3MUYrV2liYTZzMVgvVEJ6MUxuVWZ1WURpNHIyQzY5ZjFmMTRCV2ZQK3ArVzJHRkt1QzlwaGNFTE1ZUlJMdXI5REVaVFVkRUgraUVxV2RhTTdYNFdPb1BHSStaWUQyK3djUSt5K2lvSFVaOWRURGJBcnp4bWkvYkpJOUJORDBZbmQ2bEJkdmUvYnV0Qnc4K2YvVDlEM0FCYTNBRzhXM1ZQWDRoQmluK2JqOGRNTW1TcHA1cGc3Zko2eHJCRkUyV1FRRVduVjhRZzNGYkFXellmTTFyUkVFbm12a04ybzErYWNHMmQvOXU2OEdEeng5MXYzbUFqYjF6a3BxVDIxT2lwUEtPMGI5VE81VzBuVGRPbUFRbTBUT2J0czNhQktnd0FSdG9QRGlDVDBnSGd3bmJBcnp4bXRjTGMwOEhnRjFhc04wQzRNcy9mdkQ1SSs3UGhmcXlYRS9iN1JiYnJHeVJRUlQ5QVJaY3dBVW1nZG96MGVoSjlGbjdRQWhVamhEQVFTdzBiVjNUM1diTmE1OWp6bWlQNkdzV2JHWERYMnl0ank4K2Y5VDk3ZmlCUHE5WWVMZEJteXVpelpIYXFYSVRuWGlNVUVFVmNKN0s0ajNCRlB1cnRCNGJpeFc4d1Rwd2VMOERDOTVzeldNT3F1Y0ZZR3NXYkdVN3AzVHh4eGVmUCtyK29UVmt0eFkwdjVoYnEzS2lPS1luWThkZEpWU0J4dU1NVmZmTmJ4d0lPRVJTaHN0NzNIWjc4RFpySHBtSm1IM0s2c0d6MGZlM1VVajBleVJyU0NHVFRjK3JqVk5vR3pOU3YwNXNyQXhVQmg4SWhxQ2hpUWdWTklJQkgzQVZQbnJzblhRWmJMVG04YW1tdjhlVlhuL3ZXcGFUZW01SVhSbHQrVS9MQTIxemhTYjljeWU2amNPZkNuT3doSUFZWEFNVlRVTlYwUWhWaGE5eGpnQTI3T0RKYkxibWl0dDN0Uk44MGxxRzZOL2toZ290NFpWbE95TzRXTmczT0lNemhJWlFwVUVIaWVnMmltNkY5MWhCM0kydHVicWw2QllOTjlIajVTN0cwRzJ0YWhzbEJXS0RuT2lJdnVBRUR6YWtEUUtETkZRVDZnYm44RTJ5NEJCdWJNMjMwWUlwQm5EYk1hK3kzZHgwbjFTMEJ0dUc2MmxDQ1h3Y1kwRjcyVDFWUlIzdDJPTmNzbURqYm16TnQ5UkZzMkxPMmhRTnliMDIySmlzYUk4ckFXdXc0SEkzRnVBSWhaZE9HSWNkakxKdnZPYnFscHF2V1RKbm5RYnlpLzFNOU84VXhXaEJzLy9INDJJMHExWWIvWFBHT056Y21tK3JpMTcybUhLdlpCcEhrSmFOSno2djlqeHFpa2xEajNVNENBMnVncEFhWU1XcU5Yc2RYYm1KTmQ5ZWdDbkpFc3BoWE5NK01uSzNtMEZDSjVTMWttSnBhM0RnUFZiblFuUEdXSURzcFc5b3piY080Sy85TGtmYVFPMktIdXFsZkZYU2JkTnpjRWN3b3FORUZFOXpjSVh1OS82bi95bS9CQy9DM2FKTHpFS1B1WVZsYkZuZmhaOGtjV3hWM2RidjRiS2wyODU2NndEKzhDNTNhdzQ5bFRBQnA5UFdic0Ira25mYy9MaTNlVml6ZjV2di94bXZuUEtnNWlod0tFd2xyY0hxdWN1VmNWT3hFdjhhSDM3RTNacXBaeXBVdWxySEV0SVdLVXIrdHhIZytvalpER2x3bnFta0dsemNWaTFkTGlOU0ppSGpmYlJOT1B3S3B4OVRWZFRuM0swNURCeDRwc0lrNEVpOGFDa0phaFJnZmZrNFluRVhlMDdUNEgyUlIxdTI3RTZ3ZlFzQkRvZlVnakZVRm53QzJBaVZ0QSswNUoyenBpREsyT2EwYzVmbUFlY04xaUp6bXBxRlp4cVlCQ1loRlRDc1VORW1VbkljWjZhRUE1clFWaEV5d0c2dzdIU1cwMlhmT29CbFFtand1bE9GUUFnNjZTdkpibHJURVgxWXRKM3VHMTVUL0JIMU9mT1FldVI4Zy9jMGdkcFQ1ZngyU0ticzlFZkhUS2RNOEExR2FKUkhMVkl3aGNHeXlkWnNiaWZBRlZLbDVFTUtOVTJIcnlvKzA2QmVUZ3FueHpZalRoVnlTRGlrYnRKUGllY283NWxZZktBSk9NRVpCVGpvSVR1V0hYWFpWaGNVRElTMmhwaVhIVjlLdTR1NDRiTjVPWUxET2tKbzh3K3hKU01iaEJSSEVkRXM5SlpVQ2tRclBNQXZhSHlMa3hna0VIeGlOa3gveDJZQjBtR3NROEVVV2ovc3RXNVlMaHRTNVNNdSsvWUJiTlBEQ2tHVFV5Yk44a3JSTEJHUGxaa1ZPQTBqK2ExK3JreVFLV0dhUEhQTFpPa0poaW9RWW5WWjJoUzN6VnhNdGdDNDZLdVJ3YkpOZDluVjJQSGdiMzZGMTk0ZWNmL1lldTJ2QUZlNW5tL2JSQkZyblk0QmF1RThFUm1aUkZVbjBrOGhiZnRpVllTS01FbWUyZEpDSlNDR1lBbE5xaDg3YlhPUGRVa0d5MjRQNmQxbGwyMU1CcXF4NDhGdnY4WkhIOEhaRlk3ai91QXExeE1KVUZxQ1NVbEpQbU5iSWlOc213dU1zL3E5Q010c1pzRk82U3ByekNTMVo3UUw4eENRQ2xFZWxwalRkdURNc21XRDhTMVBUMTUyQnR2bUlHdlVlREEveVJuODN1L3gwLzRxeG9QSGp4K1BYWTlwcVg5YmdNdmgvTno5a3BQNHBPZTEvZllmM2F4VWlNZEhMbFBwWkNOamd0TkZBaGNIRUR4VHVtTk9OaEhyQmR1Vyt2T3lZKys3MFdXblBYajk4ZUE0a090L21qLzVFMDVsOStPNG84ZVB4NjdIRnF5QytxU1NueXNlbHFqWkdhVksyVGFkYkZMUFdBUTROQmhIcURDQ1Y3T1RwbzM0QWxTU3lsUHRJZGQyQUpabHl6WVFyREo1bGNXR05jZUQ4MEN1blBMR0d6c2ZEKzd3UmI5NU5ldkpJNWRvY1EzdGdDeXI1YkdueWFQUmxtd05zRkVMVmlPT3g5bG9lYkdOcTJtb0RPS3BITFZQNWFsMmN5bVdIYmtmekdYTDdrZlJsNDRIOXdaeTMzdHZ0K1BCL1huZjkzZStuaDVabFUxOHdDaVJVYTltN2tpYjlMWXVPaytodWRRTmJ4d20wQVFxYmZsb2ltYUIybE01ZkNoZXgreWxNd3VUYmZtWFF0bVdsZW5abGpiZFhUTHVPeGpJL2ZEREhZNEhqeDgvSHJzZTB6WGZQRnhiVU4xa0txU0NDU2s1MG0wQWp0eDN1YjlYSEJLSFhFU2I4aU82RStxR3l0RjRuTzBPRzNTWHpiSmxoeEJuS3RLeWwwTnd5Ymp2WUNEMzBhTWRqZ2VQSHo4ZXU1NlNWVEJiZ3hKTWxpUTNPYXV3ZzBRSHhYRTJFei9FSVJlTGRRajQyR3piNENMUzBZSkQ5eFV4N2JzaTB2Smk1bVViVzFRekwwaDBQRmsxN3J0aUlQZkprNTJNQjQ4ZlB4NjducEpKd3lyQmEyUkNDUVJUYkdaU1BDeFRQT2lORDRHMnBZeU9RNGg0aklOSUpoNXdGVTFORlp0K0lzWjU5TFNuRHFCaloyYXdiT2t1K3lJbnVuTGNkOFZBN3JObk94a1BIajkrUEdZOUIwTVdKSk5vek9KbWxnbHZETVhERW96ZGhRV2Jncy9VNm9CYW5HekxyZFNOTm5aRmpPa21iaTViTnQxbFg3SkxMaG4zdlhBZzkvaDR5L0hnOGVQSEk5ZHpRTUVrV0NnZFJmWXlrWUtua1A3RDRySXVqc3VqYUtQQnNCNTR2RTJUUzAwY2N2RlkvVHRoN0pYZXExaHorcWdWeTA0c0FKYXdUc3ZPa25IZkN3ZHlUMDYySEE4ZVAzNDhaajB2ZG9YRjRwaWxLYTJCUk9lZCs5Znl3OXJXUlhlVEZYRVNNT2FudkRaZkp1SmFTWG91UWRNZERKWnRla1pjTEx2RWVLMDRkOG00NzRVRHVhZW5XNDRIang4L1huczlZWXFacHN6R1dCM0FOLzRWSHcrazdXU0Z0SjNRaWN1cWIvTmxWbWdYV3N4aDU3MHhnMlV3eFV3M1dmTzZCNW5PdU84YUE3bG5aeHVQQjQ4ZlB4NnpubTFpNGJzZmNiYXB0RjN6TlQ3OGVGUHR3aTFPYUNOT3FwMXgzelVHY3MvUE4rK0FHRDErZk1YclNWbTJiYVR0UGhQYWhiUGhBNzF3SUhkMmJYelJhNjluRyszQ3JhVHRQaXZhaFYvNTV0WFdnOGZ5UlkvOUFkc1k4VmJTZHA4VjdjS3JyZ2RmTS8vejZJTFFGdEoybnhIdHdtdW9CNC9rZjc0K2dMZVJ0dnZNYUJkZVN6MzQrdmlmeDBZRzIwamJmVGEwQzYrdEhyd2UvL05tT0cwTDhFYlNkcDhSN2NMcnJRZS85OTZPK2FpM3VqUU9za3BUTlVMYTdqT2pYWGo5OWVDZDhsSHZvRml3c2JUZFowYTc4UHJyd1R2bG85NjZwTHVSdEIyZkZlM0NtNm9IUDlrTkgvVzJGcnl4dE4xblRMdndSdXJCTytLajNwV1hIaWR0eDJkRnUvQm02OEZiODFIdnlrdVBscmI3TEdrWDNtdzllR3MrNmgxWThNYlNkamVnWGNndVFMam1ldkRwVFFMTXh0SjJONk5keUJadTlBYnJ3VnZ3VVcrTGJ0ZVVMVXBDZHFtMEhUZWxYYmhOUGU4RzY4R2I4bEZ2VmZZZlNOdXh2clRkVFdvWGJvekF6ZGFEWnpma29yT2oxb3hWeGxJTWxwU0lscExydDhENGhyUUwxN3orYzNoNmhVL3d2NFEvdXRwczQrYm0rNlAvaEljZjBKd1E1b1FHUEJMMGVLUFRZRVhUVytlTC8yREtuNzNKOUJUWFlBTkc1N2h6MWNFTXZpVmYvNHRmNWIvNkM1cFRRa01JV29BcTdoVHBPSmp0QU00cHhLdTV2ZzV2WGVVcnRJMDkvTW8vNUgrNHorTXA1eFVMaDdjRW0yUWJSUDJ0RklLUjdXTTNmUGYvalozU1dDcUxNMmw0TnhJRDV6QjcySFFYdjNqai84bUxSNXhYTkE1djhFYkZRRXo3UHBSZmwxK01CL2hsQU42NXFnRG4zd1RnSDEzaEs3VDU5Ym1QK05JeDFTSEhVODRuTE9JVHQzaVZ6OG1OTytsUHJqR0FuQkZxbWlvTm4xbVR5azF0YTQ3UjZkNE1yWDd0anJuallVcGRVYnYyclZyNllwVmZzR0c1OEFHOEFoOWV5VU44Q1g0V2ZnVitHOExWV1BER2IrWmQ0Y1U1ODRDdHFTYk1LeGF1eFRnK2R5bi9Ma1ZnQStJUjhLSHRlamVGS1J0VG1MTHB4TjZtWVZMall4d1hmNXgyVm9maVpjcC9sd0trNHdHT3BZRG5vSVpQZGcvQUFid01meDArZ2U5ZGdadllqdXFLZTRIbkdueWtZbzVUdkpiRzBWajEySmFnUmh3S2E0NEg5NVNoa1phNVJ5TEdHZGZZdkc3YXcxVHNGNmlhcFBBUzI5bU5TM05tc1RRWkNtZ1R6RndnTDN1cENUZ3RCVFJ3dkdNQUtyZ0xuNGV2d2luOCthZkpSY2ZmKzhpelVHVU02M0dPT3VBczN0Smt3N0o0a3lvTnJlcXJwTzZjWUxRZUZVZDdUVHByNVlPVExjOVJVVW9nVU9WSlExR1lKYUZMQVcwb1RtS3lZUzQ2Wm9vUDRTNEVPTjN4UTV6QzgvQ1g0Q25NNGMxUEU4QXBleHBvWXV6cWxQM2Q0UzNPSlA4WkRLN2NLV05hVGxxbWdEaWlId2wxWXNFNDF3MXpUNGlSVG0zREJxeHZPVXNiTUtLRGEvRUh4YWd0bnRhMDcyZWpjM0RPSWg1b2p2aDhsM3RrMUpGL0FWNkZVNmpoM1U4SHdFYXpMZ2RDTFlTUStNWWlBSTJsdG9ta3p0dFViMGdHSGRTVVVnc0lZalR6TEczbU9iWDRGQlJhWXRwRFZOWnJpaDlUZ1RlWU9CeHNFbk4xZ09DVE04QnN3L2llTWM3NXc5a3VBVDZBKy9BaUhHdk4vK0duNEtSa2l1enBOTkRZaERHRm5kV1JwRTZTVmZtOFU1YnhuU2dWVjJqcmc2SkNLbW5lcWV5OFZNRmdxMitBTS9pNEw0UlViZlNpMjdsTlhaN1I3VzlSVGNxL3E5Zms0WHczQU1RZDRJNWlmQVp6OEZjVnRtOVNBb20vZHlONGxjekpRVy9rQzQyWnJIZ2NDb0lmMW9WTUtrVkl0bU1CaTljT2VOSEdMcU9aaytRcVFtcmJjNVltWWd4RUxVVU4zNXoyaW9oc3RnZkxJRm1jTVY3czRDRm1JNzRMOStFRm1Hc2krdEduQU9ENFlrOWdJcG8wMVk0Y0E0M0JXR3lnTWRyNFlaZWtHM09CSVVYWE51a3ZKUzh0cWEwNmUrbFNEQ3RucXFNRnU2aFdIWENGK1dhWXQ2NG05UUJtTnhpN0lveTdEK2ZhMXlIdytGTUFjUHQ3U3lzRkx0b0c0UFhBazdKT0EzYUF4QlJxVWlBZFU5WXA1bEszSExTUkZ0T2ltMHNhOGV1RXQwOHh2S2pZanplSjJHVTdZYXdleHJuS0k5dG1vYkluakZYQ2V3cHdyaVk5K1JSNGFhZXpGaE1oR0NwcEt3b20wQ2hyZ0ZsS3p5UEtrR2xUVzFZUXJFOUhKcXU4aEtHZ01jNmhWaTVRUnEwUFp4TmZyWU5nRTY0dXRtUnY2S0tIUnB4ZjZWRFVhT3ZOUDVqQ0V4NXExODVNeS83Ukt6NjlVUXUyaW01azQvZW93bnB4WnhOTHdpWjFBWlRPMlpqV2prVTl1YUIySEZuNlEzdTBKY3NTeC9xVjloVEVBcFJ6ZUJMREpRWHhZbVRucTdiZExhMyt1cUZyeExKNXcxVGVobk5IeDVFQ3ZDaDJnMmMzaEhINVlzZmRhU0tkZHp0ZmpRNmltS0ZHU3lGd2xMenhFR1BwNnI1SWV2VmprMUFNeDN3TXFpMU54RFZqTEJpUHM5dGJzQ2tJWTV3ZTUvTUwyMnpyQ1NjRnhuTnR6c3I5V2NjM0NuRCtwWU8rNFZYWGlERTBvYy92UVEvZkRLM29QRVNKTVlYTm1KYS9EdWxvSlprY1RwY1lFOGxJSDhEejhESk1peW5OQzg2TWIybE5hYXFQLytMN2YyZmNFL3lQNy9MZGU4eGZnU09kTXh2T2l4WmYvOXAzK000aFQxK0YrekFweGc5WGZVdllqYzhxWDJsZk9PcEsyZ05SdEI0ZmxwRnU5RlRLQ3AyWEpSZ1huWDZvbHAxenlZalRLSlNrR21MRTJOalVyMWJ4Rk00QWVBQUhCVUZJZVNMcVhSK052SC9NOWZPbmZIek9EMnZDU3lRSkt6ZmdzQ2greWkvTW1jMzVGMmZVcnc3bWlXMzNXOWhCRDF2cHVVb2pGcGhJeXZnN2FUZW95bURrSWtlVzNYTEhtZ3VNemJJQUplak42QjVNRHJoaXBFMnk2U29GUk8vQUsvQWNISFpITklmaVdyRWUvQzZjcjNmL3lPdnJRS0Irek1NNTUvR1FkTERzUitpZnI1Rml1dSsveStNNzhMek9FNWRzTnVYQzNQWXZZV2Q4Tlh2cGhMU2tKSWFzcmxEMi9IT3FRK1JqY1JkaktUR1dZaGhWVW00eXhseWlHUHVNc1pSN3NNQ0hVQmVUdU5XQTdpZitpZlhnYy9ob3ZmdEhYcy9EVitGdndlK2Y4c2h6TWlNY3dlRmdCbHkzLy92d0pmZzVBTjQ0NTBmbjFIZDFSbTFhQkx1MjJEeTN5M0gyK09xTWVta2JHWjRqb3pjRGpKZjY1OTZ4T0xwQzBlTVRIYktueEx4SDI3dVovYk1UR3Myak9hTU9ZNG04N0NmUXdGMGR3NTNvYTFrODBKUnV6L1hnUys4ZlgzTjlBZjRxUElNZnpLZ0NwNEg1VERHZTlHR2VGUHpTc1p6ODBTbFBUeFhqZ3dKbUM0NW5qemd0MnZiUTRiNE9BZFVLNC92V2hPOGQ4djZFRThmTVVzZmFrWGJQcEZKZUxzMnViTS9xZG0vbGEzV1A5MXVXaHhYSGpvV2h5UlVxMmlKLys1bUE3M3p3SUlvK0xvWi9TZ3ZJUmpBZDFJTXZ2bjk4UGZnT3ZBSmZoaG04c2NBS1ZXRHVhUmFLOGFROWY3dnVQREg2Qmo0N1pYYXU3cnFZSjY2bVREd0VEVTZsTGJDakNLMHFUWHlsNW1uRG9lTlJ4YW5qM0ZKYmFrc1RrMGZhWHhIeExyc3NnUGtXQjlMbkEvTUZsZVhjSm96emp3c1V2VUcwWC9RQ3ZlNTFxa01EWHA5bXRjeU95M3J3QmZkdlZKSzdENi9BQ1N6ZzNSb3J1SXE1VURlRVNmRW1WY2xEeG5uaVU4MnZ4TUx0Y2VEMGhHWld6Qk5QTU0valNQbmUyT1ZhdGlUS1VwWTV2WTdnYzBMZFVBV2VXTTV0SCtPMkk2NkFPV3c5eFQyQnV5UlZMR2RvREhVc1ZSWE9vL2MrWmRSWHZGZm54V3lJVjR1cEZMQ2w5ZUFMN2g4WnYwUUg4Unk4cEEyY0h6UXBHZXNjdFZBMzdadGtsQlRnSGp5dmRTZUtZL1Jady9rSk1rMFkyNWNTTlJXU2lnUXRsVUxQVHcra3p1SlBlWUVrWGpRUnBvR1pvYllzTEY3OXB5ZDFkTVJISW5iZ0ZUWnFOTGhEcWlJc1ROcG9leDJXTGN5MC9YNnJIY2RNTVF2RlNkNWRXQSsrNFA3eHY4OWRlQUNubXIzNnVHbEw2OWJSQ0w2QlNac1M2YzBUVTJUS0s1Z3RXQ3pnQU9Pd1FjdXJxazlqOHdodnppWlNNTGNxNWhidXdCRXNZam9wVUJrcXcxeVlCR3BMQTk3U1JFbEVteDVNQ0luQlk1dmdMazk0aUtxU1dtaElHbWtKNEJpOW00TDY0NUo2OEx5WTR3c0ZZQmZVZzVmZVAvNmdXV201OElFbUtRTTg5aHE3S3NaTmFLdFA1VHh4clVaWlZrTm1NSnRqYktyR3hMTkViSFBKeGhxeTdsQW1iQzMyWnFlRjZsVGFrblJXY1lhRnBmTFVCaC9yd2FReWNDQ0ptVzE1S3N0djZqUkh5SkZyeTJDMWFoa2tJVzBMTzc1czYxK293eEsxeTNYcXdlWDltNVlMTTJEUEZlT2puL2lpcUNLSit5S1hGOHQ1WWwva05zcWFTQ3J5eFBxNXhXVEZJYVA4S1NXMFJZeHF1cGFVZjBSY1ROU1NkSlpHY0tZZFlBNmtkdHJ0bXlCY2tmS1h3cWswcEhwVUhsd1dhZmZqTlJCWUZQVURXYThlM0x0L28wUjBDZGlzS0RNODljWDBwdlJIRWZNOGNhNHQwczJYeDRrZ285MU1QUUovMGM5TVFZcTBjbzhNQmg3YnoxZmlvMFVVSExSNGFBSU92T21vWU82a3dsRVZPRFNTVGxpV3RPdEg2c1BrcnRjdEY5WnRKOUdJZXJCc2t2aGRWUzVjRk52OXMxQlUwQWJkVWdkSzRGRytkUm5qRm1EVHpuaVJNZFpPMVFoek1LMzU1dmlnYmRrcHo5UDZxalVHRTVKMnFBY1htd0oyMGNaVWlBRDB6K3BHTXg2eGt6SmttRWY0MEhyNHFaZlZnMlh6RjlZT3lvVjVCanpWa1VKbmdLZjhsZ05Zd0tFQ0VIckNORHJXWnpNbGZsUzN5QmhyL0lueW9VZ0JjL2xLVDRweFZyckM2ZzFZd2NjZUszQm1OeFpjQXR6M2o1RUlwcWd1aDlINndjMDExWU43NWNLRExwRkR4dXdrclBRbVV3VzRLVGJqOW1aVHdCd0xxNGFRTVVaYkhtMXJ5bEo0NmR6UjBkdWEybjNSWUNXWnNpSFJPZXl3eUpHUjdtWEtscHJ5eUNpb3VZNTZzRmtCV0Vua0VCL3JhZWgvU3c0MTYyS2V1QXhNUXBFa3p5NWFsTVk1d2FtTXNXS0tydFcyV3BFV05uUmVaV09OS1dqcmRzS1phcnBGanFDc2xxNzczUExtRWhNNDQ4UGMzK0ZLcjErOTR2di9yZnc0dEVjdStsS1RCZTRrWlNkaWpCcnlrd3Y5dmJDTVBjTFFUeWdCanpWY2tTTFBSVkdzbHFkdW53SjRvZWd0Rk9ZYjRTd3hOZ1dMQ21EN1Q5a1ZqVHY1WURncG8wWEJtTjM0Wi9yRUhwMHNneXo3bG5nc3JtNGx2TW0yTXIxek5PSllKNWN1eHVReHdNR0pxL1RQNWVtbGI4ZnNRQlp2aUs0dDhoRkwremJodGxwd2FSU3hRUldmZUVUanVhdVBzZEd4c0JWZE83bm1QNHh2elNvVDI5cFJsN2tHcXorazI2QjNPeTBZTlYrU1hiYlFhczFjdEMvR2Fyc2tSZEZwS2N6VkFGMVpYbkxjcGFNdXpWZTZsWjJnLzFuZGN2T1ZnUkczc2RVQVkxYktENmFjaGlqTVBkTXhWNG11S1ZvclNwaURIaXR1SDdyU1RzN24vNHk1RGhSWG80RlZCTjR2Ty96YkFjeGhFTnpHYkhDelUvOThNY3g1ZTdhMzFrV2p3OUZDZS96TmVZeVFqWnNXYjF1YzdVMzNwTjRNamk2aENMaGl2cWZhOVNzNnhMZzAzMUFnZmVzQS9sOTltOWZndm5hRjlKb0U2YllLbWtHTkszYVBiSEI5NnczK0RueEZtNGhzMGRyTHNrN1U4a2YvTi9DdndRTnRsbG5hMHJqcTYxc0g4TDgwSEF1dndIMXR2QnkyQ2hxV1NDYVlUYUdOMTlzVHZsZnpGRDZuK2lLVGJ2dGF5ZnJmZTl1ZVdoNkdKRm94TGRyN1Y3MmE1WnB2SGNDUER6bWEwd1RPNEVnYkx5ZWR4c3RPODFuNTdMWUJPQnp5ZnNPaFVLc1cxSjFCQjV2ci90ejhSeXFPRnlsUVA5VHZzdDJKQUxzQzVsc0g4UHlRNDBEVjRBTnpZYTRkZWROaUtOUjFzK3gyd3diUjdxNC80Y1R4cUVrNExXRGViZmlzdW8zNkpYTGlXRmpPdExybE5XaDNLMXJSUzR4dkhjRE5sRm5ObVdCQkFsNVNXYUwzb1BPZm52YnI1cGRqVm5FYWVCSlNZanVMRWt5TExzV2hLY2NhZG1PcGhaa09QZ1ZkYWxqMlFwU21mT3NBRGhNV0UyWkJ1NCtFRUpJNHdLVEF1Q29DNHh3UWJXWEJsdHB4YmprWEp0S3h4YWJvOWU3dHlobGdiNmdObFNiVXBNaCtsL0ZhcXpWd2V3R3U4QlcxWng3cFRwUURKVWpiOHRzVVRXNitHRFhiTW4zbUxiWGxYSmlHZGdneEZBb1VydFBTM3dFNE5rMDJVWkcyT096bGs3ZlJzN2k5NVFDTG8zRTBqdHJqbk03U1IzdVMxcDRxdFMybko1T3d0UVZIZ092QXJMQkZpalpVVjlRdFNsOGRBWTVkMEUwaE0wdzNIUzJEcEllQjZtL0ExK0hmaEpjR1VxNHNPeEgreDNmNStWTytEczlyWU5JN3pQWE9ZV1BydGY4YllNeDZmdU9BWDVqek5SMFBkc3VPTitYMWY3RUVSeE1KSm9VNkdrVEVXQnZWb2xWbGI1bGgzdEtDZzZXeDFJYmFNRGRKKzlzVUNjNUtDNDZoS0dDazNJVk9TNFRDcWRCTmZVczdLZDRpWGYyUmpuVC9MTHlzSnkzWERjSExoL3ZkZTN4OERvR3Z3Z3NhNjd2Qms5MUc1UGUvSGJPZTd4d3ltME5YYnRpdXVEa0dPMklKRGg5b1F2SjRjWTR2ZG9xTER1b0g5WmwyRi9vZnNla244bGt1aElsaFFjZmZVdFNqeXRGeXArK3A2TmlFN1JxeC9sb2RnS1ZvY2VFcC9DUDRGZmpycXVaYVR0ajJBdkg1Sy95d3BuN00zNEsvU3NvWURBZElONDQ4STEvMC93dmVXMjg5VDEvbFg1eEJ6YzhONUlhSHIwWE1PUWRIc0lrRHVKRmlmajIwcEJtNWp6d1V2OWUyRmh3UnN2aEFiYWxDSXVJdzNiaEppaFkzcDZuVEZGSVpnaVNZamZUZjNhWHVPam1lR240YlBvR3Z3bCtDRnpUUmN6Qkl1SEJFZUltSGMzNy9sR2Z3WlIwY1h6VkRPdmFLZk5IdndlK3N1Wjc3MUsveS9YY0Jsc29OOTk2SnBCaG9FMnRvWXhPem5ORU9TNVRKYzZJZDVHRVhManJXbytMRVdHTnBQRFU0V0F3c0lSUk91KzF2TSswb1czN3ovTUJOOWtxSG5TQXJ3UGZnRko3Q3EvQWkzSWU3ZzduY21JMDl2OHNqenc5bXpPQUVYb0lIeFVSdWVhQWNlNVY4MGYvRE91dVp3SE04dnNNYjV3QnpPRldNN3d5bVRYUEFFdm00dmNGcFoydXQwVlpSamtpUDJNbG1MZDZESXBiR1NpSE9qZG5VSE45MGhSWW1oVG5tdmh6cDFpS0ROaitiN3Q1aGk3OWxXR3dRK0hOOVJzZkZNeTBGWGJFd2hmdWN6S2dDYnl4WXdCbWNGaGh2by83YTQ0ditpM1hXY3dEUDg2UHpwR1FZZFdoN2NzUDVkQnZaMWpOemR4QzhwQkd1eHFTVzV2dzQwbkJwajVKaE13dk96TjBSV3FFUkhNcjRMdjFrV1g4NHhMUjgzMEczajZ5cVoxYThVc3RUbFcrcUpQT1orc1o3eFpQS1RKTGhpTk9BRmQ2dGsranJUSDMxbmNMT3hpZDgrbnpSYjEyOEhoVWNydS95MFduNmlUMjU0WVBDNkZ0VlNJTW9XMnNrNzI3QWh2VHRyV0taVHZnc21ja2ZYWVpXZU5SWHgvM1lRMk9VeExEcmJIdE4xMUl3cmdYVDZjOGRBVER3TG5pWXd4ek80Unp1UXFUS1NDNWdBb2ZNWjFRQkszelE0SldvYkZiY3ZKbTg3RksrNkpYckthaExuNTRtM3ArTWNYenpZdFA4VkYvUXBKdWgxT3dpZUVsRW9JMXBSeFBTMDlGQnJrcTJ0V0NVNTkrSGRoTnRUSXFLbThFQnJ3MlJUT0VEcEczSUtvMlk3bUZkTG0zWmVWall3VncxMW8vb3puY2VNdmU0Q2dNZk55bS91dEEvZC9JTE1SN2dwWHpSeTllRHNnTGNnYnM4TzJWYTFMMHp6SWR3R0dlbVRCdXdST0hlb01TaGtVYzdQK0lTWTNLSDVaWmVXcU84bUZUeFFZZVhUTnV6dnZLNUZHUGRRZnV1MDBEd1lGWTlkeWhjdEV0K09KRGRudWNmcG15aHpVSnpmc0pqcjI5bDhTMGJYQmZ3UlM5WlQyNnRtTUlkWnVjY2g1WmJvTXozTmlvM25JT3NZSENHb0RUNGtVQTlNaVhFcDlYc3VpMVM4dGgva2JXSXJNQnhER0xvZFdVUUlXY3ZuWHkrOU0yM3hQaVNNT2lSUHFNK1lNWGtVTjNnWEZyWkp3WEd6VWFNcEpmeVJTOVpUMGxQZThUcFNjdVJsYk1IZVVtbGFLRG9OdXk2MmlXTlRXTkZZam94Rnp1SnM4b1IrUmhSeDdPNFNWTlNYcGEwWkpRMEsxTEFIRFErRDlJZXBrTVhwY3NxNUVWQ3ZDbEJVSXpEaERveUt3RHcxTGM1OUdiVGVPUml2dWd3MUljdWFFT2FHV2RObStQczVmUTcvdG0wRGpNZWdxM3lNM3ZiNWoxMnFVSWQ1VVpEMm94RFNFV09aTVNxRmwvVys1b3luV0RhL2FJMDR0SlJRMmVUWHVzZzg2U1FWdS9ud1NZd3BXNndMamxxSXp3THV4R0l2b0F2dWwwUFMrWk56MC9ha3AvcG5pTy84SkRuR3lhQ2t6YmhsNlljcW1LLzY5cHJ4UHF0cHgyK0ttOWFsOXNqTCtyd01nSHc0akUvQzgvSFEzbTF2QnVMMWZsZGJ6ZDhtT3VlVko5MnN5cWRFWTRLSmpTQ2RlM21jUncyVEE2c3p4ZWRuK3p3aFpNcHMwWHJxRXNpVWpuQzFodzBURUxDMkVrN3VBQWR6Y2hlWHYxQllMYWdzcHhwelNBb1paVXNJeklxMzVNbkZROURPcmxOQjMwanEzTDRwa2hjY0tVQUE4L29jdk4xUnp4OVF5T3RFUnM0Q1ZzSlJLL0RGNzFrUFlyeFlzR3NtNlJNaDRjcHM1ZzFET21NNTRMeTFpaTBIZDNZL0JNazhWV0ZnQlZtaHFya0pDUEJIQW9sd1phV3pMUjlWYjdiY1dkWDlOeVVZRSt1QjJCS2Z1YWVCVWNqRGxqYllWWTREZHRzVld2elJaZFdueVV6RHBqTmwxRHUzYWxvQWpWSlRORHBjSU9WVmhySEZGNjZsTGZKTDF6SnI5UFEybkZKU0JhS29EZStzQXZMdWZaVkhWelloN1cwaC9jNkFBWis3VHZqNnE5ajY4Ry9jVENTLzNuMXZMS0had05pK1ArcFMwV2taTk1CTVVsK0xETHVpRTRvbVp5NzFyM1VGTXdOSlYrVkovR0M1aXhWVWtCU3RzVDRnR0toMEdtNE95M3F2cTdMYm1xMjRuUGREdURSOWRlUjExWHpQNHZGdTNUWXpmbkl5aVNWbWdpelVZR3FrSVhOZEtUWTlwZ2I5RDJJeDV0MCtOSGtWekNkVTAzc3VXa2tWWkFvQ09OQ24wVDM1Z0FlVzM4ZGU0M21mOTdzTU9wU3ZqNGFhMUtZVW01OFVTSTdXeHhlczAzYkFaZFJ6azZVdGJ6TWFDUTZJeE8wZHk3WCtYc2pvRDE2aHBzQmVHejlkZnpIaitSL0hwOG5DeFpScWtFRFRhQ0tDU3l3amlhb01KMVRJVEU5ZWc3SnFucThITDZnRHdpWmIwdTBWMFJyL3JtdnFqeEt1YUxDWDdaV1hUdkFZK3V2bTN6OENQN256VnBuZ3FySnBaS3dXbkNVakl2aVlWbGlybEdPelBMSTNTTVZ5cC9lbHZCVWpqRGtOaHJ0dWZGRkVyUThwbWRTbGJLMTZ0b0JIbHQvSFY4dUhNWC92RUdBTGtWM1JKUkVpU2xvcHh3ZE1YT1pQTForaXgra0FIcE1LSWs4VXRFMXlndHF1dHR3eE5ocGhySVoxSUJ6akdGM0lJR3hHY0JqNnE4YkhKQkc4VDl2ZHNvV3JURkV1ZWJFWnVWeGhoQ2xINlA1Wm84OU9HOWZ3SE5qdE5RVHBEMFRHOVBKTEVZcXZFWTZSbHh5K1paR2ZMMEFqNjIvYm5RQ1hwLy9lZU00S3pmUVZKYmdNUWJVamxNRkltNlRwY2ZXbFpqZTdOQlNWNklzRVZtdW1XSWJqaWxvVXpRWDlPellkbzhMMXdqdzJQcnJwaW1PTmZtZk55ektrbHJnbkVrU3pUNVFXWVFXNDBZU2h5enFzUm1NWGJ2VnhLdEd1WXlNS2FVMXVnZW5MRG01SWx5NGlUMTRmUDExTXgreEp2K3paM012bmZkRnF4VTNhMVcvRlRCNG0zUWZzeWMxWFVjZFZoRGVVRFpYU0ZISExRai9ZNWp0QzdacU0wQ1hHd0I0YlAxMWkzTGhPdnpQR3lnWXRpVUJpd1FWLzR3Rk8wbWFqaWpHc2FmSHlSTHUweUc2cTM1Y0wxck9wVnhyMnM1Y00yakpZTUNkYzEwQWo2cS9ibFJwV0ovLytkbW01cHNNbDBLQTIrQUZSeDlqTWUyV2JDNGpReG5pa2Q0RFU4VHdValJWYWNnZGxobXIzYnBkZHp1Sjl6WHFyMnhueEpmelAyOVJleGR0akRWWnF6a3FhNlB5dmNvakdyZmtYaUo4U0V0bWwvbllza2ljdjBpdmx4YnFqZW13VWpNdzVldmRnOGZVWDluT2lDL2xmOTRRMmk3TVVSazluVzFNU2o1ajhlQXlWNnk1Q04yUzZxYm53M3ZkQTFJd3ErWE9TQ2w2NjN1ZE4zSXpMbnJ0K3VzMjVjSTErWjgzU1hRVWxkcVFxMGI1WE9UMTdiR3BMZDZzc04xVk1QZjhjK2pHOEwzTmVDbk1kRitSYTNmUmE5ZGZ0MzkvTHVaLzN2d0hvSHJxR21RRmFmbWlRdzZleXpNeFMwNUs0Ykw5dUErU0tVUXpDblNEa3FPR29rWHlKdmJnSi9CSEkrcXZZNjkvLzRybDIwTnNtSzJvdTJkVHN5SUFMdi85MS84bjNQMkFhbzcxV0ZHaThLS3YxZlJDNStKNjdRLzUwNy9FL1NPc2hxTjVUc21ZSWpWdCtrY2pBeDk4aXovNFNhb2piSVYxcmV4RTcvQzI5SGNZRC9EWDRhMHJCT0Y1VlR1N29tc2IxMUwvQVdjVmxjVlpIU3NxR3VYTExwOWhhOEkvL3czTXYrVDRFdzduVEJzbWdhcG9Dck5GT2JJY040cGYvT2IvbXJ2SFRHcXFnQXVwTDhxV2pXUFM5bS8zMWpBZTREakErNCt1Q29Rb1Qvek96bHJOZDNxZDRTZHBoRnhzVXZZd0dXYlRXdElTYzN3Tk9XSCtrSEJNZmM2a3BtcHdQZ0hXd3FhU1VHMlpXV2hlWU9HUUdhSEIrZVEva242YjNwT2dMVitPRFNuOTR3RHZyOEJ2YjcwL0xMdWlQUEVyOE9HVldmRG1yNDVQWnljY0Vtc1ZYWkdlMXBSTlg5U1U1K0FWUWtOVElWUENIRi9qR215REM5ajRSOUxmV2NRdmZpRVRtZ01NVUNNTjF1TkNha2t3ZVpzb3dkWW9iaU1TbG5LQTkzdTdOelRYbFNmZStTVmJmblBRWG1nOUxwWUFReHB3RXRPTnlFeWF1ZVdNNEZQamp5akczdU9hRm1CVFdETmdCWEdFaVFwc2FXaG5BcUlpakIwN0Rsc3kzZlVHZVA5ODl4YldreWYrRkYyU05FdFQxRTBmNERZWVZseEZsYmFTTVBJUk1rLzNpTVU1cE1FMlNJV0p2amNrY2llYmtRdUlSUnloVXZrSGcvaVVsakc1a3pWb2c1aFY3dklsQ3VCcm1saHZnUGZOSFFNOGxDZitGRUdzWWJNSUJDMHFDOWEwdXV5MndMWFZiTEJhUDVrakhva0NSeGFwa1F5ekk0UUVjd2dZSFJaQnArWEVGVHFYRnVOVnpNdGpYTEpnWDRnQWlkMjRIandjNE4zZHRWU2UrTk5pd1Ryekg0V1ZVT2xEb2JVcXIxRnVBZ1lsbGM4cG16b1ZyRUxSSFNJVzhWaVB4Tnk0eHdqQnB5UjU1STZKMjIwcVFUWllSNGd1dlVJQ0ppU3ByOWdGRmxlNFJjRi9PTUI3QlJpWDhzU2ZocE5TTzNsdkVaQ1FmTFVWVEtUNzhFazFMUkxoV04reUx5VG5wOHFXVVo0NmI2dnhkUkdYZkhWcXgzZUk3NVlhTGE0aU5OaUs0Tk9XN3dQVzZsaGJTT0Y5L005cXc4ZS9hb0IzZDE1NnFUenhwOHBYeDVCS0FzWVNUT0lJaVBrcDY4R21UcTdzWnR2eXpCUWFSTE54SVorcGFvekhXb0xGZUV4SWhSQnJXaXRIQ0FIckNGNy90aGhEOEpoWXo4NHdnOTNRUlY4OHdMdUxZOHpGOHNRMzZxRjFKNDU1Yk9sZ25FTGZzaEtWeFlPWEtWdUt4MGphajIyc2N6VFFxUHF0Vi9YRGdwc3dtR1RXV01TRHczc3N5VXVuTExyVlBHallSc0g1Z2dIZUhTV2lWOGtUMzN5Y0ZTZk1na29PSzhhcEN5ZTBKNlZXNkdPWXZmZmdVOVJXc3VrRWkya1VWMm5sNGRPWVV6UmlrOXA3YmNBNGdnZEo1M0x4S2NFZTE3QjFSOGVxQWQ3ZE9lcFY4c1RYZjVsaGVqb0w4NWhVZGhEZGtuUHRLSEZobGpPVCtiZHEwaHhibTM1cDJuYzgrSmExSXcrdEp5a2dwMEVXdUFBWll3TVZ3YWM1S3pZTXNsaHZnSGRIUnJ4S252aFRZY2ZLc3hUeHRURVRrakhPN3JyM3pqb1YyNWxBUUhycXBWN2JUaXkyYVhNbVVoVEJuS1M5MWpodFIzR0VvRjBvTG5XaFdObllndGNjNE4wRnhsY2dUN3l6M1RnTklLa3NjeDlqdFYxWktwV1crVWIxdGMxZU92NXVjZGdweCtGSnk5cGdiTEU3eER5WGIvZitoTEhWR2VpdEhPaTZBN3libzNzRjhzUzd3N2NnZGswbkphT24zaExqM3V5RDBacDVwYXpGSVVYVXB1VFRVMThkMUVQa0RvWDhTa21XVG5WSW96RWRiVGNaam9xeGhOSGYxSnJTUy9BY3ZIalovU01IaEwvN2k1eitQT3NUVWgvOEJ2TmZZTVRBOG4reVUvTWxUWnhTSkRSU3RxdkV1TFFLV3dEY3RNVFFvZ1VEeVFSb1RRRzVLYzZvUVJFMXlWMWpDQTdyaTdqZFp5SzBzWVRSakNSMEhubmQreTduSHhOZ1RVTHF3Kzh3ajBtUUt4cFl2aGptOXVTVXhnK1RUeTdzMkd0TFVHY3l3aFhTS1pOMjc1R3NxbGNsWDkwSjZiUkkxYW91eG1nTDdRME5lbjV6aU04MFNxTUlvOGNTT28rOFhwbFQvNURITldzU1VyLzZsTE4vUVEzckR5ekxydUVXNWVucGY3S3Fab1NoRWR1dVNGT1Y3RExYN1llK0dtWGI2L2huTk5xS3NWWHVNREZwYjlZOWVIM0M2TkdFenVPdUkzZ3BNSC9JNmUrekRpSDFmWGkxNXQzdkExY3pzTHdzMFRHRXRtUEVKZGlpRlB3bHdLYmdMSEFGazRQNlp5UGR5bVlZSEdFMGR1dHNDaFFCbDJKY0JGbHJFa1kvTjViUWVYUTE4Z2p1bnVNZk1mc0JseEpTeDNuaU80ODVmd080ZkdENVQvKzNmUFFxa25lV1Zkd253LzNiTVBrVzlXYnFnK2lDNzY1WmsreGNUOThpYktaYzJFZGdIY0xvRjhjU09vL09jOGZTK095RVVMRjRnNHNKcVhWY21mTWZzYzdBOHYxL3lmR1htTDlJNkZuNXBSd1poc1B2MFR4Rk5sQWZaQ3ZHK09vaGk4MlVDNWYvMklzSm8wY1RPbTlZckRvS2hGUEVVci9MQllUVU5odDl6ZWxIWERxd2ZQQ0l3NG93cDNtT2NJUWNMdHRXWEZlM1ZaL2o1SDNjSWMwRzZvUGJDUis2WTJ4RjJFQzVjR1VtNndLQzV0R0V6aHNXcXc1aE5pZFVpS1g1Z0ZXRTFHWGg0L1FwbHc0c1Z6T214OVF4VTc4ZzNFRjZ3blpsRU40RnpKMVFQU0xFWnoxS2ZYQzd2ZDhzc0dkSWJOVVlwVng0VWFweUZVSHpKb1RPbzFNY1NrZU5uMU01TURRZnM0cVF1aGhYNXZRWkZ3OHN1d1dUY3lZVGdpb0lTazJZZG1raGVoRzRQa0U3dzUxaW55QUdHYVUrdUNYQURhYkd6SlIxZm4zbHdrdHkwYXNJbzhjUk9tOVZ5MWcweUR4eHRQdkhEQW1wdStQS25NOEl4MXd3c0d3OTFZSnFodGVhV2dqWUJtbVFpZWJtU3B3S0t6RTE5aHg3amt6U1dPbTY2b1Bielo4WWo2a3hWU3BZalZBdXZMellNQ1JvM29UUWVjT09qamdpM05RNGw5SzUvaE9HaE5UZGNXVk9UcmxnWU5rRVhJTmJwQ2tCUnlxaHArTGRSQjNnME9VNnJNZlcySFBDRkZNVjluU3ArdUIyd29lcGRiTEJ1SlF5YXcvWkZ5c1hybFh3SHhJMGIwTG92RWtpT3BYR0ExSWphZ2YrS1VOQzZyS05hOWJRbkxGcVlOa0VuTWMxdUpyZzJ1NjRFTFBCSHBrZ1dibXdLcEpvRGhNd05iYkd6QXA3WWczMXdTMlQ1ckd0eml0NTlQcktoZXNXRzU1MENacEhFenB2Mk5HUmF4bE5qYk1xcG1FSXp5Z0pxUWZqeXB5Y3MycGcyY1MyUlk5cjhIVXFrcWRFZ0tUV3RXVEtvUnZPQlBEWUJsdGphMlNPMFJHank5VUh0eHdSakExMXVqYktGK3RpNWNJUjllQ254VWc2b3dpZHR5b1U1dEs0TkxqaTVRM0hDdGl5RjJJcUxHWXNIVmlPWFRYT1l4dWNEcUcwSHl0dHFZQUtxWW8zS1RZMWVreURYUkFtMkFXaDlKbXNWaC9jY2c5V0oyRThZakcyMDFzUHE1VUx4eFg4bjNYTFh1TUluYmZ0Mm1rODByUkdqQ0djdEo4L0dGZG1FUTlVZzRGbEUxbGwxWTdqdGlyYXFtNUZlMDRWVjhsdlNWQkw4aGlQcmZGVmQ4KzdRSDNRYnUyaXBUVmk4Y3ZTR2l2Yzljajh5dkgxMVlNSGROU0VSdHVPc2xNOTdmZVlGT1BLekdjc0k0elcwWUdBYlRBT2F4Q254ZGZpWVVtVldzbHhpSWJsQ2VBWXI5VllSMWdNN0dtb1ByaWx1blN4eGVUM0ROLzJlQlE5SDExK25rMWFkbjZWSzcxKzUrSmZjdDQvZWwxMC83S0JaZk5yeVV1bldTQ1B4UEVDazFyZE92MVdWU3JRbXBDK1RsNDZZRDNpa1FZY3B1blNRZ3pWQjJWSEZoeEhWR0tEZ01FWTVHTGxRblA3Rk1Eenc3SWFjQVduTzZzQnIxMnUrWGFuVzJBTzB3UThwa25uRmhzTDdLWUlxaGtFUG1FWEZrd2FONUtRcGhia1VtRzcyd2d3N1dTbTlSaUw5UVQ5MjVoa2ppVklJaHBoRlM5SEtJNi84UUFqbHBYcWc5VzJDMGFweWFWRHdLUXdyd0xZM2o2QURSMTNaeVVOQnlRWEhRdTZSWTA5SHU2ek1xWFJhTlpHUy9LRUpzMGNKRWU5VkgxUWR2QlNKdjloMDllaVJteTBWMnVKY3FIY1NoY2R2YlNOZzVmeGtlbmtWcHJYTTlyRFZuWDI0L3k5TVZ0bmN2YktZNzA2YW5ObDNBU2xsOWE0M1VpYWNWcXVYR2h2cTRzMkZQNjJOR0tmUUxJUVl1OXExV21kTWZtVXJER3Q4ZURTMGNYb3pIL2ZqbVVINkpydXZtNTBoQkRTYUVVLzJSdTJMRU4vZGwwMDZUU2MvZzd0ZkpFUnhHTXNnRFVFcjEwNHBmV0g5bFFhTitNNEtXUWp3WmJWYzJyWlZOSHN5SGFsMjN3WnRJczJKSnF0SWMvV0xYWFJGQ3BKa2ZFOWp2V2xmRmJzTlE5cFA1WkJTMHpLaDRSMGFNRmoxSWpUY1RudmkwWnoycnQ3TmR2UWIybWdianUxcGxzSDhNbWJuRWs3S2JLMGIrd0MyaXkzYVgzc3pXOHhlWnZEd0VUNmhXWll3cVRYU1NHK3dNRVRLdW0wRHEvcSt4NjJndDJ1YTJwcEFvMzA5VFJrOVRQYXpmVjNxTDlIOHo3dWhHcUdxeE5WZy9GS3gwSEJsOU9WVU9SbjhROEp4OWdGdHRHUVVEcjN0emNYWDl4R2dOMEVwek45bWRaM0dBVHRQaEwrQ2p4RkRta2VFVTZ4NTZrcVpSdXNMekFMWFZxa0NON3pNRWNxd2pteXdEUTZPaHlVZTBYYW8xUXB5bmNyZzZ3S3A5WGZXRHNhWnBsRWx2US9iM3Nkd2VlZ2hvcndCRGxIemdrMUptTWMvd2lFUklDVnkyVkpGZE1qRnVMUVNwM1MwVzMrc25ndDJuandOZ0xzc0ZHVlFkSjB0dTBLSDRreTFMVzR5cmJrdWFBNkl5OW96L3FFTU1YTU1EV3lJSGhzQXlGWmMycGVWOWhjN2tpS3ZmVUx4Q2w5aWRkZlJLMWY4a2s5cXZiZE9vQnRPZzdaa09aNU1zR3JTSHNva2dMWFVwOXk4OHNtbml3V3l1RlNJUlZtanBsZ2EzeUQ4VWlqNVFTMVppTTRVM1F3NVFsU20yYlhqRmU2anp6QkZ0cGcrL1lCYkxBV0c3T1B5bk5qbEN3NjVmdWtHTmRrSlJmN3lNMWZPeFZ6YnhPSlZvY0ZvWUlhR3dIMjJtSVFrcnZ1MUUybkd1ZWJ4SWdXOVU5VFNpdWtQR1UrTHQrK2MzREpQS2h5aEVFYlhDUUxVcGFlMmV4aUt5NnRNUGU5bURSQkZDRU1UV3J0d3hOOHF2dUdudDZNb2loS1dTNU5TeUJoYkg4U3RYb0F6OFBMT3JSZ0x0T1QvKzR2Y3UrN3ZETG5xTnZ6dE9xN2ZtZDhzTW1ZOVh6bjF6ajhEcTgrWFZkdTJOdjBJSXlTZ0VkUW8zeFZIcHMzUTVpM2ZMRnNWNGFpcXpBaUJoYmdNREVkMXVoOHFaWitsd2hqa2dva2tPSXY0eE5KbXluY2RmVVV6Z0I0b0ZNQnRpdTcxWHVtcHovUCtjZlVQK1Nsd0ZFeHdXVzYycjdiK0xTUHhxeG4vZ3ZNWjV6OUMxNnQxNVViTmxxK2piR0p0Y283cDh3YllsTDRhbFN5ZldkZXV1MGo3SkEzSkZOdVZBd3RzdDdGN0ZoV0JiUEZOS0lVT1JuZFd0THJhRkxtTXU3S0ZWRERPenFrZWFpTjMzWUFXL3I3NndSNFhETi95TjF6N2hlalBhdTA2RWRka1MvNlhUaGZjejFmSS80SzczNmZPNDh2bHh0MlBYSllGYWVVa0ZTOFUxNVhFMzQyOHhkdG4ya2M4R1FsZjF2a0lhTlJSbk9NdkxUV3JaYkVsRUhlTFdpMW8wZGxLUEFoMU1WZ2JiVnF1UEo1K0NyOExVNS9ILytJMlFsSElVMkNsWE05Rzh2N1JyN29jL2hvemZVVWdzUG5iM0QrSSs3V0Y4a05POTJHWTBTTnZ1eGlFKzJCdDhwclZKVGt6RTY0c2ZPc3R4dXdmeFVVb3lrOFZqY1Rsc3FlMnFJVFNGb1NqNkVwZDRLc1Q2QlpPV210Z0UzaEJmaXI4SXpaRHdnVjRaVFp2RDhWdlBIRVJvOHYrdkwxREFTSFR6L2k5T2xLdWVIRGpLNVJueC9KQjFWYjFpb1hkQnJhMTZkbXQ3ZGdpazEweUEvRndKU1ZZNlhqQTNveTRTcU0yZnJxRFBQU1JNZXg5cXMzWFF0b1d4TWo3L0VyOEdXWXNYZ2phVno0T1l1bVAyKzlrYnh2bnkvNmt2V3NFQncrZmNiNWJJbmM4QVBkaHBPU3MwMXRFcUlrb2laamJBcUtNcnVMYkpZZGRIdUhGUkl5SmNiZEVkYmwyc1ZMYXlTeWd1bnV0Qmc5NlkyL0pqS1JDZHlIVitBRUZ0VHZJcGJLSVhPYW1rbllTaUI2S1YvMEpldFpJVGdjamprNVpkYXNrQnRXTzg2VUYwYXA2b3pHWEprMldOaVJVbENQRmlyNjZsemRtL1NMU3VLN0VVZFB6OGYxejI5U2txNkYxZlhnOCs1VVZSNmJzem5jUDRUbjRLVWtrZEo4VUZDWTF6UjFpOFJtTC9xUUwzcmxlaTRUSEc3T09EbG5La280b0kwMWtkM0NhTTA4SWExOGtDM0dOb1ZhTzlpRGgraFd4U3lUWEZBQlhvYXU3UTZxOU94WWcvT1ZFTXc2amRidFNySjljQmNld0dtYVptZytidmtVblVVYUdyK1pmbk1INDVJdmV2bDYxaE1jWHN4WUxGVHUxaFRtMnpWaUNwN3UwbzVsKzJQU1VoOWJEajZGZ1l5cHVmQkRocUsyK29Ya2l1SEZIUjN6ZmorOVB0QThvUjB4bnFYOHFuK3N4M2JGT0RTYmJGMFg4RVV2V1E4akJJY2pvNWJSbUxPbGpETnRjcU50T2U3NTZoM2wwVmhLYTloRGQybDFlcW1zbmgwTU5NVC9DcW54NkJJbnVtaExUOGx1bGp6UTUzUmlKZUEvMGR4ZTVOSzBvMmZBMStHTFhyNmVOUVdITlVPSnNzUWFUUmxHcExIS0w5ZkQrSXJRelRPTVpTOWZOUUQ0QW5STlZ4dlRkakMrZkpkY0REV1FjeUIwMEIwdDlCRHdUeFhnYUFmekRaL0RCWHpSbmZXTUZSd3VOcW9jT21YNk9LTmtZNjNoNW4vZkZjQjI4TWNWSHFuWFpWSTI3SzBpNHJETE5FOWxES1YvclQrdWRWYkQ4ZEZGdTJHR1o4bU90MGtBWGNvWDNaa0lXVnR3K01OZjVOalIyRmJpdlJPSG1oVjEvcGoyZWd2L2ZNR0lPV1RJV3JWM0F2OE45aW1WOUlXbWwzNkg2Y1VqcUVXTnY5YU5jK3ZlYjJzSDQ2UFJhSFN1TUJ4dnRXK3R3eGN0cTB6K1FzSGh1eDhRN3JDWTRDdDhscXN4N2M2U3kwZGw1VDg5ckllRXVaS29WY3RJazFoTnBmYXZFUjZ5eUgxVnZtM01ic1VIeTRhYjRoV3IvT1pQY3NSQnBobmFWNjUvWmNkWVBOTndzak4vZGpsZjlOcUN3OVU1RXhDUGNkaEt4VWdMU21mUk9wTHA0V1NVcjhvamR3Ym5jYnZDZithL1l6UmFFYzZRT3ZYY0dPMjU2VFhjNUxhYjlQT3ZCK0FXWTdQaWdXWWp6aGlmYm92dXVuelJhd3NPMjRacVFRQXFndUJ0bXBtUEI3eXNYSmZ5RERhVi9hUEdpbGxnejFNZFFnNHU1TVlhRXRCTk5IRmprUmxTcGQ2NWxwNGhkMkFWUFRmYlY3RkdweUlPZm1OYy9YVnNQZmc3dnphUy8zbmt2TEw1OTNBTkx2TXVSTUdwUUloaUY3a1VFVzlRRHBBVWJUV1lCY2JwNFdwYWNISFkxYWFjcVF5akdaUzlISTN5Q0JUOWtVWkpoVk9EK3pVRHZFSDlkZFIxMWZ6UGNURFE1VGxnQjBLd3FkWFNhdms5QkMwcEtwMFdtY3Vvd1N3MDdWWG1YQzVndXpTYTRwMFV2UncybGJEaVlVeDBFeEpKUnpXemk2R204Y25Fa2ZYWHNkY0cvTS9qQUphMCtibUNnZG1ROUNZbE5sU1laT0tpeG1Sc2dpRnhrcm1XNGwzS2RGS3YxRE04dGs2V3hQWUpaaFVVemNkOEtkdGdydy9na2ZYWERUNythdm1mVmFrMzJxaHRrZzZOVmRVUzV3Z2tydTFZeklrU2R1VFcxRkR3VldWM0pRVkpWdWllVGMweTRpRHBGd2M3L0J2U2FsdktkUU04c3Y2NjJjZXZ6Lys4c1FWbmpWQVQwVzJ3TGxsdzFKaU1oSlJ4Z0RqQ2pMUXNPelNGU2dacXg3bEFXMUpXMGUwM3lBRDNhc0MrR0QzTmJRaGJlK21ONUdYSDFGODNLRE9NNG4vZTVKSXVINE5wZFFBUnJGUEJWcHRVTmNqajRjVk1jRlNSVEUyTnBSMUxFWWJZTW1mV3BYZ1A5S2VqYVBzTFVodXZMQ3NWWHpuQUc5ZGZ4OVNSMXVkLzNoWmRDTEhiMUdNZFBxUkpncURtbTc2bUhidk9YRHRpTzJRUFVjS28vVFdrUTBpMkpGWHBCb283dmlqMWkxTHAzQURBbytxdkczVjByTS8vdkZublRFNGh4ZDVLYS9Db3I1WUVkc0xWSnlLdERnVm9IZ3RXMTFwV1Nqb2xQTk1ucmxyVmo5RnYyUW42MHR3TXdLUHFyK04vd3ZyOHo1dFpjRHNEcnYwNnRrcXl6RVNNODVZY3Y2WEJXQTJiaXJsTkNYckk2VmJEMmx4MkwwdlFPMFFWVFZWTEg0U0U2N2Znc2ZWWHY4bjdzejcvODVaN2NNdGJFNmYwODh3U2FSNGtDa0NtMTBzNnBLYkpoZnFpVU5HTHErMGdMV0M2ZVVBWkZQbkxqd3F0S2Q4RXdHdldYNTl0N2lQVzRYL2VBTjFzdmdSVlNZOTkwWVpnMDZCRDFvaExNdHlGVEk0cEtUSnNTOXhSRXE5RU9hUFdpTzJncG1zNzM5N3g2blFKa2JoK0Z6MnEvcnFSUk9YNi9NOGJKcnFsVlc0bDZKRXB0S2VVRnVNWVVidENRN0NJdHRwR2M2TVk5M3gxcjF2Z0FuUlh2WTVjdndXUHFiOXVXUW0rbFA5NVF4ZE5NZVdoT3ExeDBEYjU1QzdHY1V2MlpVdU42bjhpS3pzdk94aWJDLy9ZZnM5TmE4cjJSbHowMnZYWERUNTdGUC96Smk2Ni9FSlNtc0pLYThReG5vcVczVkxRK2paVlV0SndKOFBOWDFOUUN3Zk5nZGhoSEQ5b243UGRSZHJkR1BGMjhySnIxRiszTEJkZXl2Kzh5WWZMb01ZZXQxdlg0dXBOQWpWdndPVVdubE5YSlhsa3prNUlsNmtxZW9pTDBDMDdxbm8rL0NZQlhxLyt1dGxuc3o3L016dnkwdG1JNHptNGFnMjNQUk4zdC9DV3J5b1VWSkdtKzUrSzhSSjBWOEhjODgvWEhVWC9IZmlBcTd0K0JIK3g2djh0NDM4ZW5XbWRKd0ZBNlpJTnJpTEdLdi85NWY4bFQ5L0ZueUExTk1WRXZReWFYdXUrZ3ozNmYvREQ3M0U0cHdxcExjdm0vbzBWbGU3OG4vLytML05Qdm9lZnAxcFRKeWU2ZTRBL0QwODJGRVJhNS9vcGVIOXpwdmgxM2NObTE5LzR2L0xEZTV4TVdUaThJMFRhMHFLbEsyN0FTL3YzL3IrL3gvMkdPOUsyYzdrVk1vbkRwcTcvL2pjNVBLQ3hlTlBwRlZ6YVJyMDF3RjhDNFB1NzZoWHVYMThINExkdVRyNzlndXVGRDNuNUJIZkkrWlJGaFk4dzI5VFloYmJMaS9idkJkcUtFNGZVZ2cxcEJLblYzRkVhQ1dPV3lBK20zV3BPUlpyL2orOVRLSnRXOHlCVEYyL1pFT0RJOS9RYXZIa1ZkR0ZwL1BqbjRRK3U1aFhhcHNQNXNPSCtPWFhBMUxpS3VxSnhpTU5iaFRrYmRKVEN5NGxsRXQ2Tm5xUlQ0ZGhnMVYzbmJkcm02ZFlNZWNBMXlUT0w0UFdURTlMNVZ6UEZsTEJDdmxHNThBaGVobk40dUhzQVlpbnlKK0FaL05rVnZFTGJmT0JVdU9PNXN5QklFdGlxSFUxazlYZUlTWDVic2ltcmtVVWhuR0R4b3VyTjhTZ1VzQ1pWdEt5R2J5R3pIWGRqT2hzQXZPQXN3U1J5SUJkZFJkRVpXUDZHWmhOSy95andldzllaEJvKzNqRUFEdTdBeTJuOG1EYytUUzdhd1VIZzBPTXpSMExBQmhxTEQ0aEpFaC9CRUd5QmRHbFNKb1hZWHRyKzNIUzRpanpWcGdpMHBhV1h0ZHJ1R1RrblhCeisxMXFUMVEyaW54YVR6UUNPNDZQM2xmTHB5UzRmb3UyUEgvUHVwd1pnQ3hOaEdsajRJdlV1V0VzVGtxTVdtNmk0eENTTWM5TjFSRFFvQ1ZjdUdJdEovTVJXZWZhaXMrM3N5bm93aS9kRVNnSmpraWxuV25CVEd2UldtYXc4b1IxNTI1N3Q3Q0htQ2Y4SE9uN2N3STgrTlFCWE1CRW1BYThQTVJlbXJOQ0VoTEdFaERRS2NHWldTMzE5Qlg5UEZCRXdHVGJSQmhMYkRjYVYzZHJGY0RxazVrQ1RkMkpGMVdwMEhyYXFCeDhVMHd3QlRuYnBDYWR3QkEvZ1RIL0NEcmNDczkzTFY4RTBZbG1tY3lRUlFuakJhOEpFU21HVWZJaksvN2ZrYURKcG1EMlFwdEZOVkpVMWJidElBampXUWl6ZXBPS3B0UmpielI5S2FnNnhabU1MTGpIT3RjTFQzVHg5by8wRWNUVDFYTjNFNDV1MjRBaXdFeXBESlhpaEtqUXhqTHByRXdjbVJLY2xhRE5aQ1Zxci9WOG1ZV3lGQURidXNpWTVodmdGb1UydmlvNDlSZ0pMbjVPc1JlUkZONnRhYmVldGlpeTBWN0tGSFQzSHlaTHg0OTF1OTVzbjRLMVFRU1BLTTloTlQwd01WdkFXYnpEU1Zkckt3NHpSalpNeUpJSGtmcTFWQVZDRGwvYlVoTktsR3EwekdyMDUrWUFjZVhWUEN0dFZrMG9xalZ3TVB0K0JCZWZ4NHlQdEdWa1VzcVkzQ0hEUGlDTTVuZ3VwVXdDZGJrcGQ4a2JQckNXSGhrbXRJS0xFZXRGMjQ5OWVTMWpabElQR1lubGNQWGVNMktEOXZMUzBiVzNrdFlOcVVsbHBLTG41WnJzeGxJenh2RHU1ZUh4ekdMY3RrWkxFWTRQZ1NPZzJJVVZWY1VPTnpVREJFcFJhTW9YTm1VYzB0RlpyVFpxdWlMeUt4clNtM0R2SVc5RmlsK0FraFh1NVBoRVB4OW1VTndxeXBEdlpXZEtsaElKUVk3dm4yT3NubUJlT1duWVowbTFpd2JidzFVNjBieTVvbTQ3aUhSVjZmT2d6ak1mL0RBWnJsUDQwWjdzeXhwTEswbEowZ3FhQUsxYzJLUUt1N3RhYlRYa0xGejBzQ2Z0dXdYKytNeU5lTm42OGs1QnVxMjNZUWhVaDBTTlRKYTFpb1EwcDRuVUcyeTBYaWxGMUpxT0RxZEltbG9QUzRCcDExMURFV1QwakpqVnY5NXVYOUJCVjdlQjNiVVdjdTBhY1NWTTIzWVpkZDhSOFViUVV4Sjl3ZHUzb011aGR0OTI5TUUrbWg2SlhKOGRpMlJ4YlRpNlRickRxdXFWNGFVS1IyaXdUNmFaYnlPd0VYTjNEVXNXcjhIbjRFaHdOeUh1WEhoNy9wZGFVanRSN3ZuRGgvZDhjOXhEL3M1ZjUwMWVRMStDdURpQ3ZHaGsxQU4vNFRmNzRSZnhQd0QzdG9MYXJSMHpOdHNuUHptUzY0S0lSazg2MWRNV0NVOEFyYXNHOVQ5SDBaQnBzREduanRBT00yKy9MdUliMmlJVUdYTmdsNVptS0QvVHc4VGxhQXVpaGFGUDV5cncxOHY0eDE4OTh6SWRQK0REQVgxYk0zR0FNdlBnUlAvY0puM3pDVzAxM25yaEhrcklUeXZZdXdPVWtjSHVLbFJTVzVDNnJ6SWRZNHBwbkY3SjhhQUpiUWVwZ2JKWUJqQ1k5dXNHWERLUXhxN1JaZmg5ZWc1ZDFVSE1WQVRSYUQvNEJISzkzLzFpQWdZWi8ranFQbjhEbjRVRXhtV3JwYTMrWk9LNk12TTNiandmenhOV0EyZGhzOCs1MVhIU1BKaWFBaEdTcFdldkVzNXhITFhjRUdGWFlpQ09OeVNIM2ZQV3E5M0pJc0JpU1d2V3ljM0NBTitFY1hvVDdyQ1NBTmxvUFBvYTMxcnQvNVBVQS9ncDhRL2pERDNoeXJqemxSOFZrYW5mT3ZCMVhQdWJ0MTd2enhBZmRTVmJEMXB6QW5mZ3lGM3ljYWRPVE9UWGhwRVVvTEMxSFp5TkdXM2R0bWplWGdyMnI1NkpObVJ3ZE5OV2FRVkJkZGQ2cmg0TWh2aUVCOUVGUkQvN1JHdmVQdkNid0FMNE14L0Q2TTU0MWhITzREM2U3ZzZQYWZkY1pWdzY4OXo3TkdUd281b203QThzUGhjY1Q2cUtjbDlOSmw5YU0vOWtYK2U1OUhoMXlQcUd1Q0NaeHVJVGNzbU5hSjVGN2QwcTZKM0g0OFRPMS8rTTU3MDg1cTJpY2R1MlUrVzM2TGRsbHo5QWdpdjRZR2xqb0VOOTA4RXp2RE9yQkY5OC92dEp3Q0MvQkYyQUc3NXh4RW1qbU1JY2p4YmpvYXhxT0szLzRoUE9aemhNUEJwWVBHNDRDTTBkVFZtMUxqTHRVV1dWejFCY2Y4dEV4MHpzOE8yQTJZVkhSeEtZT2l5L2FPVm9BYU11MGk3dWJ1NDNuamptZDRpYk1IVTFzSURIYVFOS3JaTkQvRlpZZGs1NG9DWGV0anE3RTdJVmw5ZUFMN3Qrb0hud1hYdEx4NDRjenpvUkZIQnp0WVZ3dEgxZCtOT01rdXBaNU1UTStnVW1xOTBYK0JoOXpqUmxtYVErbTdZTXFVTC92ZWVtY2VjQXRPSjB5cTFKblZsTjI3ZGkyRTArS2xwMXRBSjRLUncxZU1JN2FKanNPM1I4a1BTSTNmVUZYbklPZmRRZTg2c0lJVnRXREw3aC8vT2s2dmo4dndEazA4TkVjSTh6ejdPaEJ5K1d3YWx6WmVaNCswWG5pUmZzdDlwQUpxUUhER0x6VlEycGhlWm5udjFPV2h3TzQzL0FnY3ZBRVhFVlZwYTRkYjlzR3ZOSzh3amFFTkhrZkZRNENpNWk3ZHFuUWxQb0xRckhYWkR2TzNCSVhaYkpPQnJPYUViTUw2c0ZMNzk4STRGaEtpaGpITXNQakJVWllDTUZyNm52YUFyeHFYUG40bENhK2NIZlNhMmNQMjdnM1ozemlZVFJyY2JRTkdMUW1HRjNGM2NCZHp6elg3QUlMeDBJQjlyYnduOWt4MkcxRlczSW5pYytaTElzVnZLUjhad2ZqMGwxZmtxbzhMV1kxTTNJWDE0T1gzcjlSS1RJTytkOVh6QUk4cVJQR1BuLzROQzJuNm80ck44WEo4MlRPSXZ1VkE4ekxLVUhSRmdCQ2V0bERabHFSMWdMS2pTMzl4b0U3QnQ4VXZBNkJ4dUVEalUzdEZzRWlqZ0ErNjE1dG1aa1hLcWlFRU5yaDQxaUxERFpOcTRwS1RXUjNMWmZub3M4MUxPdU5hMTVjRDk1NnZMTXNKZDFycVlwNTFnRFVRcU1ZbTJYc3huVWhEMmpnMURNN1NldUp4eGdybXBmSVNTWFZJSklTNXFKSlN2SlBFUTQ5RFFUVkliWVdKOVFXYS9FMitjL29QSzFkcm1DN1dTZkpSTktCTzVZanZjcDdHYzNkbW1JL1hoMWtEVEV1aVNuV3FRZjM3aCtmVE1oR25EZjZkc1M4U1FmUVdscXF3WFhHbGMvUEVaL1NDNW10eklWMG5Bc2hsUWRNL0x2VXRZdXRyRVovWStFQUZ0cTFrMjh6UWhPd0xyMUFJZUFOemhGOHQ5cXpUZFpmMnFSS082TVdFOW9oQll3aWJiT21yRnRObWczbWNTK3RCMjh4djJ1S2QvYWdZQ3ZPUCtHa1NjKzBscjdSWHp5dWZMN1Fia1VwakxqRVdGTHFPSWtBR3UyQjB0TmxPOUVhdTJXMXFjT1V2VlJnS3p5cEtJUVo1S0kzcTBNTHpxVE5SWXFpWk9xbXRxbG9JUmxta0JIVnBIbVJZVjYvSGl4Yk82VUM0N0tPRkpub01yVnlyN3dZeitTbFc2R1VhZ2hZYlkxSTZra3hBMlcxZlNKb2tVZFNoMkxRMUdBaW1SR20wTVQrdXU1N0g1bDdRZ09XeEVScE85bW9MUlBnVHRxdVdDZkZsR2xJalFhUmx5OW9kbXpNT1dZK0lCTzV0QjRzVy8wK1ZXR1VoMzJxWWs3OUVpZFdLcmpXdWlMcGlWTkdGV0ZSSlZrdHllWFdtYmdCQnpWbDhhblB1WHlOSmxCSk9sS0xUZ0FiaS9FWUhWSHhXaURhVlIwNkduSFFOcEpjV2NLMmpKdGlDZkcyc0VITHp1STY2c0dyTUs0N25QSUluUG51Nzk5OTM1YU9LMmN2bXZ1YnJFMzhaelpqckVMQ21YTTJoTTdVY3BYRDJvQzMrRUNWcDd4dEl1eHB0SjBqVXIzc0JtQlM0N1RWeGx2SjFTcWIvRTB1TGR2TGowbExyMjl5cGRkL2VNWDNmNmxyeEdsS3dLUXhFR3Z3MHFIYmtid3JGM3VIS3dWRU5iSVYyd1oxM2tORUY2ekQreDI0YUxOTWZEVENiRFBuRWlrWkZ5VE50dHhXQlhEYUJ1TThLdEkycm1hTWRVWTdjWGNVUHN0cVRHdkJHU3JGV0lwTk1mYmRlYTk5MGJ2QU9DMVlYMHFiYzZzbURTMW1QeFNKb1c0ZndFWHZqTW1obGlqRFJxNnFhbGU2YUpFdUZHb3BwWURvQkVMUXpMQnVoL21aTng3amtpbnYwRXRuVXA1MGxPOWhiTks1N2xaYU1BV3VXUjVZbzkva1l3Y1lJMHQ0Z1dNNDdVbW5sM1ltcGVCUHFTeU5wM0s3czJEU0FTLzM5S1J1RU4yYlM0eHZvd1YzZEZSTXgvVkZjcDJZcDh3Mm5UTzloQ1h0SEcxa0YxTDRLbHJKcjJ3S2Z5cTc3UjdNS3BGS3pXbFk5VWtoWXh5SFdXNm5CV1BhdWR2RUFsM0NHY05wU1hQWjZSOUJiQnRJbDZjSEwzZ0lCaSs0MkNZWHFDeDFnZkdXZTdBcDBoM2x1eVhkdDFNS3k0WVVUOXhTRjAxRzE2WUVkV3NvdVc5bWdESGQzdmV5QTk3SCtZYTQ3Wm1FYnFNWTcyb1B6dENHdkswb25MNDRBdmdDNDlzYVpLa1dSejR2ZVdsakUxRkhqYlJKYVd2NlpLS3RsODc1aDRDemlGQ1poRzVyeDd0ZWZzbDBhUlQxYk1IWmptOGR3TC82dTd3Q1J5c2FRYmxRb0c1eUFRTjV6cGF0TU5ZLyt5Zjh6K0dMY0gvUW4waVgyVzJvRWZYUDRHdndRSHVJTDlBWUduYU8zenFBWDY5NDZua2dxWk5uVWh4NDNESWRRdE1GZU9Qcmd5L3kzWWQ4NUhsSld3akxGa1Uza0Z3cTI4eFBudVBoTVdlUyt0RExWOU90bGxxN3BRQ2YzdVhKRE45d0ZEaVVUZ2VmSGFpWWJkZmkzYjN1OCtpWTZUbnpoZ2VoSTFMVGU4bGNkN3Mxd0pTektiYWhDUnhLS3p0VExYc3RHQWl1M2E2clB1UXM1cGs5VFdBYW41ZjBCWm1HZjdZbHh6emsvQTdQQXM0UVBQUEFIZUZRMmhiRkhzemxnWnVLWnNKY1VtYkRDNDBzRVU0MDNjRWpjenN0T0V5cGErWXhldkw0UUJDOG9SWXFXZEs2YjdzSzI1dGZFK29EWmd0T1EySmc4VDQxSEdjQkU2ZlRXSG40SnRIY3U5Uzd1WWdVNUtTQ2tsL21jbnErNS9ZQlhPRXI2bENVQ3dPVE9NMXRhT0k4bVN4eDFOc0NYQkVtTEtiTUFnNU1rd2JMbXBCYUZPUHJOU2xPMkhuTGlFcVczdEhFd2Q4QWVpUUxtbisyZ3hqQzNrNkF4UkVxdktjSmJURXpscExpdzRyTlpLNm9KZGlkYk1NR1g5RlVMS3IwQWtXKzJxREVQQk5ObTVRQXQySWsybmZ0TldIZXR1Ym9zSExvMm5HNHZRQTdHa2NWQ2dWQ2dhRGl4SHFvOVVVbjFBNk9zaGFwYU5SL0xQUllGVjhzaVQxY0N0SkUway8zV3RhTlN1VVpZS1Buc1ZJVzB4WFduTVV4cTUrRW40S3Z3L01xUW1WWG5BWGo5Wis5ek05OHpNL0FneTdGL3FxajJOaDY3YjhIakZuUFAzaUJuL3RrcGR6d0VKWC93aEljUVVYT2Fpa2VsaUNSR1VrN3Rpd0Ywckl0d01FaGprWjMwOWhpa0ZvUkFtTFRwRVhXdUhTNnkrYW0vS0IvZk01MGFMRWhHblNNd2tweHpPb3Y0SDBBdmdvdndKMWlHekRMdEpuLzlCVStmQUlOZndVZTZGSFNMaHU4M3ZpVi8rL0hyT2VQWCtTVFQyQjl1V0dick1ISExsZFJCbGhTL0NKUW1jUnhKRnFaaWNhMDFYaXhBWnNZaUgxdW9sWnhMclIvU2d4VklKamtwUVA0UEU5c0U1OUxLTHI3a2x0U0JvZ1M1dHlzenpIOEZ2dzgvQVM4ck5PZzB4VVM5ZklhSHdiKzZldDhRL2d5dktSamY1T3VzT3pHeDhldkEvQlA0SVAxMXVOL2dyY2E1TzBsY3NQTEo1WWp3STRRa0pCT0hhMFdkTVpZR3hQYmgyVzJuUjl2M1d4RVdxZ3AvRzMrNlZaYlJMU0FBWjNCaGRoQWFVTDMzVlVTdzl5akVzdmJhUTl1NEEvZ0dYd1pYb0VIT3VVMUdTajJjaGYrTW8rZjhJY2ZjQXhmSUtWbXl1blJiWVFWbm9ldndnZnczVFhYY3crK3hOdVA0Zmh5dWVFVU50dEVkdVJWYUR0dGRkb1AwZVN4TGUyTEVOazZpdFl4bHJ4Qk5CWXJOTktTUW1lYUxjbTljOFVzYUI1V3lPNjY3NXl5UUlBV1NEcEJWb0EvZ3htY3dFdndvRHYwbTU4VUU3Z0huK2ZKT2E4L1l3YW44RUtSZmpzb3BGODNlQ2dsWC9TZnI3T2VhUm9RZnZ0MUNHdklEY2NINUJDdncxc1dJelJHQy82NnQwVlRjTFpRWnRtNlBsQWFzYk9KOWl3V3RVbzdiaWt0VFNJUHhuUjI0anhQMVpLYXFxKzJSY1hNOU9yQkFtL0FBczdoREo1Yk5tR2IrS0lmd0NzOGEzam5qQnJPRmVNakhTQ2RiS3IrMnVPTGZuT2Q5ZWlBOEh2dnd3cTU0VmJQMk9xd2tCNDhZdGM0WUVPaUgydlRYcW9kYWJmV0VPenNvNHF4ZGJxRDVMNnRidE5QRUNxYmhuQTcwOERaSDRRT0pVWHFTY21VbGtzN090NkZCdVp3M24ybUViYVVYN2tEenhIT09RazhuS1dNekF6dTZaWjhzT0Z3NFJLKzZQY3VYbzl0QjRTYk16NThBcGZLRFhmM3N6ak5JSWJHcEQ1VEtUUnhHa0VNTGpMbCtLM3dsV1hCc0NVeElEVStqYk9peXNFU3FBeTFNR1VKcFhnd2JUV3pOT1ZFemlJWFpySitWSXp0bDFQVUJ4VFNvMGR3bjJiT21mRFJQRDNUUlRHbGZiQ0p2TzlLdnVoTDFoTUhoQjl3UHVQUkxHSGNkT1dHMnhjMFUrNWJRdEFKVDBuUlRld1hMMXBnazIrclpBZGVXbXozanhBcWZOUVFkelRsYkY4dUo1ZWNFSVd2VGtldkFIcHd6N3c3OFF1amxEL0xyNDkxYkQ4LzF2aE0yeXJVUVJyV1hOUVk0ZkdpbGZjdE1XWWpMNzJVTC9xUzllaUE4RW1OODhuYk5kb3VyK1BCYmJBak9qSWE0aUJoZkZnNnJ4ZUtkRUdjTDZwM0VXUjFRcTJRa2hzMkRybmtSbm1OOXRHMkVBcW1nUHc2aG9MN096YTdCKzNTQ3JSOXRSZnRrbytMc2YyRi9ta1RuZE4yTG16dU1jS1R1ai9tWDIrNFZhM2tpMTYrbm5KWStTN01lZnBraWR4d25WKzR3a1hIOFRLblgwdHNZellwMjlET09vU1cxbmY3blRoMmFrWWlXbWNKT3VUaWRTYXFFU3JUWXB3akpKTlZHUXIrckxJN1dzcWVySFc2S3Avb00ycEt1VjdUMVFZOWdqcWxacDQxL1dmS3BsNTZGVi8wa3ZYUUZSeWVRODN4YVR1NUU4cDVkTlAzZFVGMzRpaHlJM0dTcGVDc3l3U2gyMlpKZFd0bzl3aW5ocWlmYjdWUnZna3R4cDEzdnlqclMwRWp2clJmWjYydXlxZGRTV2FXWWx3VFBBdEpaMm9aM2ovU2dpL21pKzZ2cHplc2ZBY1dOQTBuOHhWeXc5MEdWRkd1WmpUWEVReSs2R2ZMR0xNTEw1MjNmNUUwT214VmpEb091UmlIOTFSS1UrdnRvQ3RIN1RnbXZCTHZ0RlhXTFcxNUg5R1RkVnc4b3c0SWxSTGVIRUNOOXltMWU5SzBJK0NibmhndjRZdSthRDJIYVFKODBYRHFPelNHQVY0KzR5Q3FCeHJzSkFYNlpUSW9YMzZRbnZ6aGh6ek1mRlcyZFpWTE9KZm8wemJjZTVPdndYTUZhWjgxbU9ubFRWWHBEWnNRTnVvWVd2ZWtldEtiNSs2Sk9Pc2dYK05UbTdINDlmVVRseCtXTHVXTDdxeG5PRmg0QnhwbUp4MHAyZ0R6QS9CVUFSdVM2cGhSK3BVc1k3TU1ib0FIeDV4TnNTVmZWWmNZU3dxQ0tycW9uN3pNKzhlY0NrZVM0bm0zcklOdWFXdlZObk1SSTFJUnB4VHF4OFBaVVowQnIvVUVkdW8zQjNoTnZtZ1pmczlnUVBqOHZJT3hkMmtuZGlyM2F3dko2Qkx2b1V1T2ZGV05ZQjBMUjFPUUpvVXlTS2I5SWxPQng3NHExK0FEQzJHNnJPZG1GZEpjRDhCa2Z1YWxBK0Jkak9PelA5dVVoR1VFWC9Ud2hac1VkdXdScjh3TnVYS3VyQ2l4TEJncFFJMG1EYkpyOWRJcVV1Vis5Mm5na0paN3hkdUNrMnlaS2JmV3JIMVZCaVRnOVZkenNnUmpXM0NWWEN2QXdEZCtjMXo5ZFd3OStCKzhNSkwvZVkxNVpRL0hxdlR3VmRzWm41V1FzZ1JSbk1hV2FlY3UzakZ2TUJFbWdnK0ZKRlpzblNsMHpqQjlPcVBZYUJEN3Ftb1Z5SW1GdnppNDF1c2VzVjBqdWxhQVI5ZGZSMTVYenY5c0VydVJEeWsxbmIrUWFMVTY3VDg4NUdUbHM2WWdjWStVaU1hMjVNL3B3R3JiQ2Z6a3ZSM2Uwamp0dWFGdG53dWFnSFRTYjV5N2JvQkgxMTlIWGh2d1A0ODdqSkxzTEo0WG5Va0hYNXNMYlM2MWRwaUFYUm9aU0NyRkorRWpwZVUzcHVWZml0bmdZTm82UEpyQWlnS2t0bXdqeVFkWnBmcTMwbW10dWxhQXg5WmZ4MTVYenYrY3lldWlCRlVzOXpxOEtxK1hCOWE0UFZ2cGgzR1Y0RTN5OEhFTkpyTjU1SDFYMnA4VnlxU0t3VnVzSkRLelhPWnpwbFdkekJVRks5ZStCNCt1djQ2OHh2SS9iNXh0U0FrQkhRYVB2dHFXemxsVnZFT3hQYnVpRTYrajJwdmpjS3Nidkk3dHhuUkVyZ2ZIN0xkWHFqcTBJb2tLemdhMTRHelEyM1NTYkNRdk82citPcjdTTUlyL2VmT2trcVNkTW5qOW1CeDJEUnNpWTI5VWo2K3FLOVpyc3NDS2FwdFI2SEtVUmR3VVllVVdBMmtQelZLUU84a3UyblUzQW5ocy9YV2tCeDNGLzd3SnRDVFRUSUtmdHRodWUxdHk5eHZOWUxZL3pvNUtTYkl1S2JYcGJFZFN5ZVJ5WWRBSXdLWTJuZXlvYzMrazFYVWF1ZllnYTNUOWRhTVV4L3I4ejFzMTBJVGtuSU8wa3VvTXQrVEI4akswbHBheXFxanNKMnF0WEFZd0JVOTMyemluaW1nbWQ2bVRSRG5RZnI4OHEzNk5BSSt0djI0RThQcjh6eHRhc0JxeDAreEhIOUhobHJ3c3h4TlVmS09IUWFaQklUTmYwdWNjajhHWGlWbVhBdVBFQUtTZE4vNEdMSGhzL1hXajkyZE4vdWV0TnVCTW5WUitYV0RjMjVKTGpvNU1nNUlaSXEyMjZ0bUNzaXAyelpsaUwyMTNZclRsTDJoY0ZqcENkdXlpbTNNNy9lQjE2cS9ibFFzdjVYL2VzRFJidEplYWJMSW9zV3kzeWNhdndMaHR4ZFd6Yk1tSGlCVGlWakpvNmxDTGpYWnNpN3A5UEVQbnNxNlg2d2Q0YlAxMWkwckQ1ZnpQbS8wQTZicnJJc2xsZW5aczBsQ0psVTRhYmFrUjU5ZW5aS3JLZTNCWmloYlR4bHlaMnpsMStnMHd2Z21BMTY2L2Jod0RyY24vN0RkejBlV1p1SnZmU0VTdWc2Tnpac294M1owNEZJeHowbVVqTXdWT09WVHExQ1EwQWhkYkJHVmRqRy9DZ3NmVVg3ZXNKbDNLLzd5dFdIUnY2ODNwcmFXLzhpRE9DcVdMTGhwbGpEWTFacHpLNzVRaWFab09UcExLbDYwYXVIUy85N29CWHJ2K3VtVTkrRkwrNStOdExGZ2pxVkxDZGJtajdwWTV6UENQTE9ITkN3WEdPY0xxdU9oaThDbUNXdmJjdU83M1htTVVQYWIrdWczQTYvQS83OEJ3ZTBiY1MyK3RnSG40SjVweVMyV2JPY2swRjUxVnEzTGNqaEx2WjY3cDFBQmJhTDJINjdiZzc4QmZqS2kvanIzK1QvQUJWM2lsTG1OWFRJMlNwdnhXQnR0Ni9aLy9EMHovRlhhR2JTQmd5bHpsc0VHcCs1Ly94cmQ0L2FlNGQ4RFVVamxzbGZJWVMzdDA2SFpwdmZRdHZ2ME43QUhXcXRqUDJwVzA4UUQvRkx5Ly9kYTM4dm84UE5sS0hmNXkzN0R4ZGZlL29qNGtWSWdGcTNrb0xSZVNSNzZXL2J4Ly9uOWs4am9uWnh6V1RBTlZ3RW5pRHNnODdzT1NkL3o3Ly9Qdk1wM2pRaXB0R1ZXRlgyY2FlenpBWHdmZ3R6WVV2YnIwaW96czMyYzNVZ2U3dmFySCtDTkU2Y3ZFWW16YlBaOWhNYVlEZGpLNFYyaWVjZjZFY0ViZFVEVlVBUmRhMkt6Ty9KdEN1RGJOUUIvaVRlTDBFRzFKU08xamJYUytuTHh0UE1EUHcxZmg1K0VQcmdTRUtFLzhHcnk1QTczdWk4N0FteHdkYXR5TUVCQ1BOT0NTS1VlUloyUDZNeWI1TVJ2Z0NIbUE5eXdzTWlmVStBWVhjQjZYYTVHaWJVQzVUU3llcnh5aDBqNlFnTFZwZHloZkFyUlRUTHFRandlNEhPRDlzOTJENEFwNTRvZFhBUEJXTEF3QjAyaWdHNUtrYytwaU40bHZPRElGR0FaZ1QrRU80U2kxczdmalNSN3ZjUUVUVWtSbTlPK01YeW85T1loZmU0eHQ5U1RRMnBjWlJMYXlDVjkwYjREM2pSMERZQWZ5eEorZXl3ZzJJTDdOVE1YbmE3Uy9ScFE2M0poV0VNOFU0MVp5UUdqd3NWUzBRQnJFS0x1OHh3WnNiaTR3TGNDVCtPR2lkUElPQ2UxUGlTYzlRdCtnbyt2WXFCN2NHK0I5ZDhjQUQrV0pQejBBbTJneFhnVTlJbmVPcURwQUFYT3NPbHRWdU16cGRha0pYcmRQQ3pYaU5WVXBDZU9vczVjeG5wUVQzOUcrWFZMaHMxb3NRVnZKS1BaeU5xOEhEd2Q0ZDdwTkR1V0pQeFZYN01TenFVRFU2Z2ZhZEtpTmxVRlR6TGVGSEhEbHpPNGtwYTdhaUtoQlBHS3dPcXhzQkFtWWtPSXBpcHlYY1FTUGxSVGYrVGlpMFUzRUpHYVpzREVSMnFvQjNoMmh1MHFlK05Od1Vvb1lVOHk1bUlMYkplNk91WCsyRlRLeTdiaWVUREFlbWFReVEwQ1B0aGxqU1dPK3htRkRJWWlFU2pNNXhLZDZJazVsdkxxNUdyUTNhQ01Mdm1DQTl3b3dMdVdKYjl4RjU5aFZWUDZPMENyQmkzWmpaU05PdlJ5K0k2a2xOVlJKWVJCYUV6ZE4raW1pVVhROGlWRjhmc3ArVzRKWHc3V0lTVzdmRGg3bHB0V2tDd1o0ZDdRVFh5QlBmSk1ZSzdTaWpqRnBwR25sSVZKQkpCWWo3ZVV3dGlQMUlCWEdJMVhDc2pOcGJqRU5WcFNBSjJocTJMVHl3RWx5M2hVWWF6dDMxSjh3MithaUx4M2czZm9oWGl4UGZPTVltNnpDR3M5TFZvOU1vVzNNQ0pFN1I1dS9Xc09JanJxQm9IVU8wYkpFOXZ4QnBiaHNkMytOYjQvdnRQQ1o0b1pZQ2l0TmVZdUMvOFVEdkR2eTBxdmtpVy9jZ3FOcVJ5enFTWmEvczBtcU5HanRLT29UbTE0elpwVWF1aVFnVmZxdFFpWmpxN1EyN0pOYVNLNUV4UmNyR0NYTzFGSlloNmpSNkNGcUs3YlpkUVo0dDhnMHJTbFBmUDFSZEJ0cWFhOWRpcXR6SmtROWR1U3J5aTJiclFYYnhEd2JSVXBGTUJIalJqOCtOdDdHREtndnBoOW9rVzdMWDQ3Z3UwU3BHbm5GUTFTMWxZbGRPc0M3aFl0ZVI1NzRadUtzN0VpMWxCc2ZkejdJWm94enpDVm1tVnFhU3lTelFiQlZBV0RlaytONGpoOUUvNFZxWnJKalB3aXY5QkMxWGN2T1dnTzgyNzVDVnlCUHZBdFRWbERKZlprYVpHVTdOcHFCb2dBai94RUhrZUF1SmloV1lDeEdONmU4KzlKdFNlZ0ZYRjFUcmhoTEdQMWZhazNwZWJnUHoxOTIvOGdCNGQvNldUNytHZFlucEg3aEgvREp6ekZpWVBuL3ZqVzBTZ05wVE51UElab0FFWnY4dGxHdzQrUkx4eStaam5LYTVOZEZvQzdVYVcwYWR1b1lzZTYrYlhnMURMZzZVZlJZd21oR0VqcVB2Rjc1VTU1OFNBTnJFbEsvK01kcFh2bXFCcGFYT2EvTVRaYWExRE9jU2lMYXc5ajBOTk5zdDNjKzYzYzdFS1Rwa3ZLSHp1NmJQYlAwUmt1SEFWY2JSWThpalA0Nk1JYlFlZVQxbWhBKzVQVi9pbnlEZFFpcGY4TFR2TVhid3ZvRHk3SXJ1RE5WWktUZlY0Q1RTUlVZZHliVUNuR1U3S1VURHhMZ0NrbnFVbTVhQVc2LzFwNmVNc09Zc3BoTHpzSHJFMFkvUDViUWVkeDFGLzR5UEhuTUIzL0lPb1RVOStCTDhQaHRqdUZLQnBaWG5ZTkp4VHV2KzJYcW9sS1IyVVFnSGhTNW5vdnV4VnlTSmhCTlJGM1NvS0sxWFpiYlhqVndXTnlPamxxV0pqcldKSXkrUDViUWVkeWxkTlNjUCtIWjYxeEtTSzNqeXJ6K05pSEcxaGNPTEwvK1ArUERGMmdPa2VrS0dpTldLZ0orOFoveDhJdjREZFFIemNwWnlGNHYxOUkyN3c5L3lQR0RGUXZtRXBLdHF2L1RMaVdNZm40c29mTW05ZUFIOEFvMHp6aDdoNHNKcVl0eFpkNS9EN2hrWVBuZUR6bDVpZGx6TkhjSUIwalZsUSs4VUx6dy9uYzUvb2p6bDJqdUUwYXBEN0xSbkp4ZTA0ZE16MmlPQ0ZOdEdGcFR1WEE1QWhjVFJvOG1kTjRrejMwblZqRUM0WVRaUXk0Z3BDN0dsVGxyZVBLaEdzS0tnZVhwQ1llTzBNQWQvR0g3eUtRVWxYUExPYXNPSDNGblNwaGpIdUR2RXU0Z0I4ZzY2b05idHI2ZU1iRklBNGZJQkprZ2F5b1hyaXcyWEVEUVBKclFlUk9BbFk2YWVZT2NNZitJVllUVTNYRmxadWZNSGluR3l3YVczWUxwT2JWQkFzYmpGNFFKTXNWVVNheWprNHZvUHNISk9RZlBXRGhDZ0RubURsNlhJUmVyRDI0SHNHdHc4NlJNSE9MdlZTSHJLQmRlVkUyNmdLQjVOS0h6YUl3TE9tcnFCV0pZWkRMaEFTRzE2YzBUbitDZFJoV0RnV1hucVJaVVRuUElIdU1KVGZMVnBrb1l5NUN6eWxIVlRHWk1Ud2tHQW8ySEJsa1FwbHJKWDZVK3VGMXdaejJ1d1MxU1ExMklxV2FQdU80YmFaYUVGQmR1a2tzSm1rY1RPbStZSlN2b3FQRnp4RkEvWVVoSXZXeGNtU2RQV1RXd2JBS1ZwNnJ4VHRQRlVaZktJd3B6bTRJb01mYVlRTFdnbWxHNUZNRTJnZEJnbStKN0orcnRTL1hCYmFWTHNSN2JwUFFucE1GbG8yZG9XYVZjZUhrOStNa3lndVpOQ0oxSGUra3VIVFd5UUF6Tk01WVNVZy9HbFRrOVp1bkFzZzFxRUxWT2hVU0FLMExBQklKSExLYnFhRWJIWkxMMVZBM1ZncW9pT0tYWWlTK0hSeWFFS2dzZklxWDY0SFlXYkxSWHkvcVdveWxJVjlndWRMMU9XQk5nQmdUTm14QTZiNHR4RFQ0Z2kzUmk3eEZTTHh0WHBtbVluekFjV0RaZ1k4ZDUwM0xGb2d6NXNib25EZ2tLY3hHc1dzRTFPSStyY1F0bGdCQkNTT0tEMW10cVlwSVU4Y1R2Qm1BVDB5WmUrelV6ZVk5MmZZalR0R2lwWExodVIwZVBvSGswb2ZOV0JYK2xvOFo3cEFaRGs4bUV3NUw3ZFZ5WlpvRS9wVGV3Ykk2U05iaUFMNXhleWdXNHhQUnVMQ0diaGNPNFJJZVRNRllIRUprWXlFTzlIbUpmWE1ERWovTGFINzgxd0hIWkV0cVNRLzY5VW5HcHpIN0xLSUFaRURTUEpuVGVzSlRVYStyd1RlcEk5ZExKRWF3WVYrWmtSbjlnK1FpckQ4dkY4TXEwakZRMjlqczZrQ1MzRTEralpJaGdQTmFuSGRIRnFGdlBKTEhxRndRcWJJQTRqaER4Y05zT0NDUUxEb21hTC9kcjVseUphSlU2RnhQRmpPM0pPaDNrVk1jUk9vOHUrQytqbzA1R2pNRjNQMy9GdURMbjV4Mk0wNHhYVUxQd2FTNmhCWWtpK01yTWRaSlNnUEhsY0I3bkNSNWJKOUtyNUFDVW45ams1a2l2ZGQ4dGs5NVNPR3J0cXU5bHIySWhLNjVadEVsN1pLcnA3RHJxd1pmUlVTTjFlbDcrN05KeFpieXdPQzhuZU5LVGNoNXZzVEVNTnNvQ0NxSEJDcUlQUmpJUGttMEJqdkZPREd0dG85OXJDbCtkM3dtSGtXMEZQZHBadEM3TU1jVnRHRlFqSkxYNWJkUTIreDl5cGRjMzEzdWo4eGxzcmZ1TGdXWHoxY1JoWnZKWVgwaU5WQlJjVmNtQ1haczZhRWYzUlFGMldJL1RjQ2JLbUdVM0lPb0RKR0RkRHViMCtoWWNrdDZQbEd1MkJjeG1oYlRkai9rbGhjY0xHSk1jcVJqTUpQMWpXMkVUcUxTV0ovMjlNQW9PUmx1Sis2TFBmZkJaYmk1Z3FpNWg2Y2F0UXBtT1Q3L09GZjVVb3JScEx6Q3FjTWx0Qkxod2QxYXJlM2t6dHJTelhPMExVYlhSUWNkTGgvUmRTWitzd1JtODE5UkVEcnRxekM0ZXM2R3c0SkNLbFNuallWcG8weGVxMzNQckFEYkZMTDNSdUNtT2JWbVBOKzI0a2ZhK0FvakR1TTR1bUtlMlF3Q2Y2RU45MDZId2p1amFpdERzNW8wczF5K2szbGdiVDJXMmk3RkpkbndiTFhoSlVCcS85bGlUY3RTbUZDLzBPcVVpbmIwUWRkVFdhbXRqYkhSRnVXSko2TnBxWjh2TzNmWkozN0RiKzJHa2FQWUxHSHM3WFRUZGlGUUo2OFNrVkpGVm1ZNk1jUjVVeWNmbE5Dc2NjSEZhVjlGTmJSNE50dEx4dzRwUTd3SmQwNjZaMG9oVmJ6aWhheEhWRXhkL2F5MDRveFVLV3QrQXNkaVE5T1V5WjJrcnpOMTlJWkl3YWZTVEZnSUJuTVY3M0FEajdWL0s4dTFNYVkyc0pwMkhXbTBmNDF0cXdhakV2ZEhXT0pzNTEwTWFBcU40YW9TaVBDWHROMktTaTQ2ZFV4SGRhTXF1YXI4Mk8xeDVqcWhER3ZxbW9FOUxmeGNZM3pxQTcveDNIQTY3cjlaRzRPNkN1eHUxMi8rVFArZUxQK0krSEVycUREQ0RWbUJETzRsYXJ1ak5lN3g4b20yck11ZzBNWDByTDErSVd3ZHdmUitwMVROVHlObVZKODVsald6Yld1R3Y4L0M3SEQvaXpqa0hOWk5ZbGhaY1VPS1Z6S0ZVeHN4eE4va2F4Kzh6UFdQU0ZLdzgwckpyOVRpenlqM28xZ0VzZHdnV0dveFBlekRkWjFUU0VORTFkTGROdnVLTCtJODRueEtlc1pneFhWQTFWQTFPY0w0OWRGbHBGVjV5Sk1oenlDbU5RK2E0QnF1c1BKMmJCK3hvOFY5dTN4NDhWVklFUFMvbWMzRHZBYlh5b1lyNlZnRGZoNWRvNWhoSE9DWE1xQlpVUGhXWWJXWkVDd1ZKbGpMZ01VV09DQjRNVXVNYXhHTlVRRFZJNTBUUStTM2tGZ0ljdTJxS2tOU0hWb00wU0hzZ29aeFAyZDVISDhCOXdvT2s0eDViUGtLdEFIdWNac2R5a2p4dUlwYlVyU0lMZ3JUOEc3RzVvQ1crSzA5OTBvN0UzVDZBZFc0VGlsSDVrRGpkcytINjRrUzBtejI0Z3J0d2x6REhCSnFJOFlKUUV4b3RQdm9DNEpCcTBsRWpqUWt5Qlo4b0gyTG5Sc1E0SHUxUXNnRFRKYk84ZlFEbmxsaXRreHVWc2tvaUtiUkY5Vnd6TUR2eEhBZHdCN21EOXlDcGxoSEZFeVVXSHgzV3R3Q2JTTU1UQ1VDY0VtU0dsZzRnVFhrSHBaWFdRN2twem5LM0VtQ0hpWElucW5ka1FqdW5HNWt4VEtFZUd5ZTdqV3o5Y3lNUjJtR2lGUTE1RU5SQlRiQ3ArR2g4NnZBeUFTZGdtSnEyTUM2aG9BRFEzR29zUDBRSGJuTUhqeUJRdlFxZmh5L0JVYmVIZDVXWS9HLzlMSy84S2E4SmQ3VUZlTldFWnZ6UGI0NThEbjhER0xPZTMvd0dMLzR4UCtIWGxSdCtNMVBFMmlMaFI4dCtsZmd4c3VoN0FmTzJBT2Yrb3dXaFNaUllRYmQ2MjJoYnBLV0t1VStYdXZOelAwT3NlUkRhK21PYmdESEpVU2MvcEt4MzFRZEtmZlE1T0lKcHQ4R1dqbGdUd01jL3c1TVBDUi95bDFYQzJhMll1dDU0U3ZPdE1ldjU1T2Y0NUJPYXQ5YVdHMjdwMlpWT1JSdm5FazFocVdNVlVtcWE3UzJZdHZsSXBzcHVGMXB0MHN5dVpTMk5WMTRtVWlkQ1NmelF6ZytLcXZJWUNNbGpJeDJZSzJBTzM0Zlg0R1dkdTV4Y0lBYjhNelR3K2ovbHlXTStEdy9nanM0R0Q2ZWhOZ0E0OGtYL0FJN1hYTS9YQU40V0hyKzludHl3cW9DYWtDcW1LUDBybVFySkpFRXJHMlVwZzFKT2JyMDFsS1F5NGpza1dhbEtZZkovRURMTXBqTlNIRkVVQWRlMmZsdGFEZ21yTmFXUTkrQUFiOEk1dktqejNMMW4xTHJpQi9CWGtHL3d3Ujl5L29SWDRMbGlvSEE0THpQMmluelJ4L0RXbXV0UndlRmplUDN0TmVTR2xhRTFGZGUwT1MxMXlPcG1iSXAydS9qRjFuMlJSWnZpSk0weUJUM0labDJIV0ltS2pRT3hJeWVVMzI1Yi9xV3lVOU1vajFvMDd0UzBHN3FKRG9HSGc1bTh5ZUN4TW9FSDhHVTQ1dG5yTk04NEQybDI5N0RROXQxWVA3amtpLzdSbXV0UndlRUE3Ny9IV1hPaDNIQ3hrUmdsZERRa0FqTlRNbDJJbG9jMXFONUpmSmVlVGx5VFJ6eFVSVGRuMUl4djJ1S2pzMTJBYmRFV2xCdG1WZGsyazdGRndqMDdQQ1o5WEF3VzNkRys4eEt6TkZyNEVud0JacHk5UXpoaDNqRFhlYkJwWWNwdW80ZlE0NHUrZkQxZHdlRW5Iekk3djB4dXVPQUxSVVY4clhwRnlmU1RRWWtoZDdJSG0wN2pweWhsa0NtSTBBTFlxUFRwVXhYUyt6NGpnRGoxUGZsdm16NWVjdUl0cElCeHlUSHBTVEdXZDlnMUFwZkQvYnZ3VWhMNG5UMUV6cWdYN2N4ZkNjTm1iM21QTC9xaTlTd1RISjQ5b2o1WkxqY2NiVEczcFJtbFlpNkpDRzBtUXJBdDEraTJVWFRaMmR2OUlsUXBONW5hTVl0dmlhWGxUckZwb01zbDNiT0FGRWE4c3FQajJXQ01yeDNZang5OXFGd081OUF3L3dneCtIbHFOejhvWnZBM2V4UkR2dWhMMWpNUUhQYU9KMCtYeUEzZnAxT2ZNM3FPYkVWZGh4anZ5bnhOTVhRVjQrR0p5dk9FRnFlUUJhSWJiTzdpNjNycHhDbHRkWlNoUEZ4a2pNMkZQVmtuM1RHK1JwOXBPM2wyUnpGZWdHZnhHREhJQWg4U3RlUjBDNEhvcFh6UkY2MW5oZUR3NlRGTjA1RWJ2cThNM1ZLS3BHampPNnI3bmh1ZFRFR010WU05MkhURGFSMUZETVhKMWVUaHNiS2Z5d3lvV3dyelJTWGtjNTFmbEczdklpZDYyaDI5YkljRmJUR2hmVitmYWFCK29oajdkUE4wQzJlMmxDOTYrWG91RkJ5ZW45QXN1bkxESlo5ejdORXhpVWMwT3VvWVc2VVprSXl4MllVUjJ6Ni9UaVJqeUtNeDVHYmJqTEh2SHVmN1ltdEtnaGYzNExKZng2M1lnOHZydk4yekM3bFkweDB0dktlem80SG1HWURVK0dhYjZkRkwrS0k3NjFsRGNOaWZjakxycnI5TFdaSmN0RzFGZlUxdXdob1FFMjJPYmpkZmtTelk2M0NiVTVoenMyMVdlVGRkSDJCYUwxMUdpN2xWZGx4UDFua3hxaG5LaFZZNmtuUzNFUGdWR2cxSnBONWNQL2hpdnVqT2VsaFhjUGo4SEMvTHlJNk1rdGVWamxvbEJkTW1GM2EzRGJzdUFZaEw0NGR4enRoV1NOMDY1eHhVZDU1TG1mMHdSYk9ZT3FIMDkvbzlXYk8yVnRGZGFNYjRxQmd0RkpvVDFTcW9OOHdQWE1vWExiM3AxUFVFaHhmbm5Mekd6QkkwS3U3RnhyS3NOSmovOGJuL0g4ZlBJVk9kM3JmcmtsVUIvRE9lTytua2doZ1NQenJsUHhsdUNNdE9uREw0WW1sNmRLMXIzdnNnTXhndFBPck1GVVpiRVViVGRJemlpNWJlcTcyRzRQRDBES253am1CVUxVVkZteTh0K2s3ZlozcEtjMFE0VUM2anBWUnFTOVVtdjhieHczNWZsWlZPVTFYN3Fram5oWmxzTWJrMjRxUTZIejdRY3VMNnNEQzBpSEhraTk2VWgyVWR2bWdabmpJdkV4eTJUZUpkTURaTlNiZFp5QUhlL1lkMXhzUWhIaUt6amg3R3hRNHlxTVBheXdQa2pNYW12cXJZcG1PN0tuYWQrWlFDNW1zQ3VBUFdVb3hyeFZockd2N2ErS0xYRmh5T05kVE1yWjdrZTIzcWlPNDBaSlV5emdZeVg1WHlMMG1WN05pVXpFczltanRiTU4wZEVScXd5QUpwaWdhZDBCMy96UlY3czRQSWZYU3U2WVYvTUs3K09yWWUvSnZmR01uL1BISmUyZnlVZHRuRnJLUk5wWFYwWTI1NTlhV1B0L0c0Qmx2alRNdFhsVklXQ25OeUEzWVFCRG1ZSW9kRno0MVB2WFBTYTZycTlsV1phd1o0ZFAxMTVIWFYvTS90bkZra3JCT2R6ZzZhUDRwSUQrTVpuVEoxU3V1QjZpWmx5aW94NEhUMnkzWUJ0a1VLV29vYWNCUVVEVHBqd2FEdDVwb0JIbDEvSFhsdHdQODg3bEtLWHhOVUV5UHFwR1R5QTY5OVVxWS9sdDl5R2RsVUtyYTBmRldTKzM2aXlsVldyQXlkN1V3MENaTTB6N3hLVE9kdXpuTElqRzJIeDhjRFBMYitPdks2QnY3bjFEWWNpNEN4VXVSeHJqQmMwYmI0dkQzck41WnozNm50TGI4M2VWSklCOExpSXpDbW42U01QamxYK3lObFRqdklHanMrUXpIUGY2MEFqNjIvanJ6RzhqOXZZTUZ0bTFWb1JXQ0pkbXc3ejlOMHQrYzhjeFpwUGVLNGFUUmljUzI1UWhyVnRVcDdVNTc4Y2hrNHEwNFd4NFlvUVNqRnJ5VWxwY1ExQWJ4Wi9YVk1rbklVLy9PR2w3UTZ6OVpweGkwKzN5RmhTa2pVRHBuQ0lVaExXVlgyM0tRK0w5dkt2RktJMFpXRlFna0RMdkJveWxySE5WbWF3MTB6d0NQcnI1dGxvZGZuZjk0RVduUTBsRlJXeThwVzlMYmtMc3lVVkRjMk5TVEhHRHRuRDF1TXRjaGpiQ2ViMW1weEZQMFliY0NsaHpkTHU2bGZPOEJqNnErYmRUMnN6Lys4U1pDVjdWSXh0dDBEVW45TDdyNGNMWVdEU1huc2VFcE9HRnV0eTBxYk9WbFM3Tk56czVGT0dKVXFRcGwyUTY0L3lCcFpmOTBzeGJFKy8vUEdkWjAySFNpcENibUQ2Tkl0bVE0TGs1WFVyR3BETWtoYk1tMlpWaGVOWVYrVmJVV1Rjdjk5KzJOeVgxVm9hZlN1QytBTjZxOWJGSU12NVgvZWFnTldYWnhFYTlKamxNd05XYjAwYWtHVWtTb2VwcDEveVJ1dXFIR2JVbjNVZEJTVHhCVTZTRVZrbHpXUlVrUG5kVnZ3MlBycnBqdnhPdnpQbXdIYzBocG1xODJucGk3R1JybzhkWHAwS1huVVFtaFpiUkw3TkVWcDF1dVptTzQ1dnV6S3NIcmt0UzNHTFdYT0RWancrdlhYTFl4NEhmN25qUlBkMGkzYW9BR1g2VzI5R25hVjVZZHlEajlURmtha2plN0dIWXpEb09iZmRkSHRPU3BvaTJTbXpKSHJCM2hNL1hVRERFYnhQMi9vb3NzemNSbGVoV1hVdnpIdjRUcEJWa3RIcXdlbkZvOHVMVm15NERLTGE1ZDNSdExybXJNM2FNRnIxMTgzRTRzZXdmKzg1VldlZzFjNWFnMjc2TlpyTTlJSlZOY21MRXZETmFWNjJhcSsxNElBT0dGc0J0OTczUmE4WHYxMVl6WHdOZm1mdDdKZzJvUytYT3lvQzgvY3d6aTY2RGhtZ2szOGtVbVAxQ1VpWVdPWDFicEQyeldYdDJGQ3A3dXE4NzAzQVBBYTlkZk5kc2NSL00vYlpMSXlvdVZ4cUpmZVd2RzlKZStKVmNrSFE5K0NJOU5XeHorYmxYL0tZWXZPNW4ydEFQL3ZybFo3KzgvaDl5KzlxZUIvSG50OTY3ZTVtZXZYMTByQUxEV0svL0ZhQVQ1TVhkQlhkUDBDL0JBZXM3OTJjNDBIK0FpQXAxZTFvSDhIZ0g5NGcvTHR0eDFncDYzb3AxZXlvTS9Cdnc1L0cvN3hGYnFKUGNDWG5tQml3RFBiL1lLTzRGWDRPanlDYjI4OWRiMi9Ob3FpY3c0aTdONlRWdG96OHROd0RIKzh4L2k2QWU3bG1hUVZFTnpKRmIzRGkvQkZlQXd6K0lzOVNqZVF5U3BQcWJMRmxObXl6NDd6NWEvQUYrQVlGdkRtSHFpYlNYVEV6b1Q0R2MzT0FMYXFBUDRLUEZVSjZuKzF4K3JHQU02WmQ3OGJnSjBhOFFONEdVNjE0dnh3RDllMUFteTZDY3NrTnJjekx4MUpJcDZIRTVVWkQvREJIckZyMm9ObGdHNE9kdjIyNkJvZG9yeWpHSjlxMlQvQVIzdlFyc09DUzBjdFhaaTNydUxsaHBGREpZbDRIbVl0alFDUDlyaGRuNHN1eVNMS0R0NndMY0M1Mmg4eFBsY2pqdTFmbit5aHV3NExac0FHVXVvMmI0RngyVXdRdTc3dXFSSFhHdGc5MmFOM3RRQ2JGZXhjMHVrOTN2aFRYYmN0Nnk3TXVsTHljb1Vsang4bmdETUJnMXR2SmpBYXpwRW1PdHhsemNsdmoxdlFmMVR4N1FsUERwR3BxZ3RkU0t6L2Q5L2hkeTF2VGZGSFNtQzlkR0RaYkxpZXp6N0FjODAxSGlyR1pzV2p5ZGZaeVB2SFhML1k4TWp6ZzhCeFRaaXV3S3o0RWI4c0JFOXp6bnN6bWp2RndIS1BJV1Vud2hxZlZSY2Q0Q2swSzZhdGU0OG0xb09mclgzL3lPdHZBc0o4enNQQU04OXNqbmRkbXVMdURQalg5QnUvTDd4N3hwTXpGazZuV3R5UWZQZzI3OEduNEFla3oyWmdPbVU5ZUozN1IxNHZ3RS9CTDhHM2FpYkNpV01XV0RRMFp0a1BNbmxjR2VBdS9BZys4WnllY1U1QlB1eTJJTEQrc1FxeVpoQUttbjdYWmQraklNVE45ZUJMN3g5NXhWTFNYNE9uOEVjTmxYRHFtQmxxUzEzakc0THBtR2JrRi8wQ25PaTNIOEVUT0lYem1ubXRiMGExNlR6eGoxc1V2UUNCaVhaR0R0bUIzS0FlZlBIOTR4Y1VhLzZ2d1JuODBHT0Z5akVYRnBiYTRBMWU4S1FmRkYrMjU5dHg1WFM0ZWdZbjhmUXNMR3JxR3JIYnp0cit1QnlUYWhXdUwxTlVHYkRwc25yd0JmZVBQd0hISWY5WDRSbk00WjJBQldkeFVCbHFRMlB3aHVEeG9TMHZ2cUIxSnpTMFA0aDJuQS9RZ1Ryc0pGbitZM0FPanM5SkZDMDdDR1dYMW9OWDNUL3lIT3pnRGp3UG4xUE0zZzlKazlsWnJNRXB4bmxQbUJianlvMitLRlhSVTUyVEpNLzJBTGNZNTdSVXpqT2JianF4VncrKzRQNlJBT2Y1OHBjVnN3OURhamUzaHRyaVlycERPb25yZTNDdWRTZTZiZmtURWdIQkh1RGl5dTVNQ3NjN0JIaFlEeDdlUHhManFpZ1hac3craWpNSEZodXdCbXRvVFB0T3hPclR2WUpEbkM3NWRuVWJoZnd1L1pXOUFnWWQrcGVMNjhIRCswZW1LcXVpWEhoV2pKZy9VcmtKWXp1aWFMM0U5YUkveXRyQ3ZBZDRHY1laTUNrU1F4ZlVnM3YzajhjNGU5MGo1WlRQZHZtSkpHSG5PQ0kybkhTODA4MVgwMTNwSHVCbFYxZ0IyTVgxWU5tV0xIcXFHTi9UV21HMHk2Y2xKV3RoeE5VbDQ4cTM4Qmk4dnRNS3l6enBGZFNEaHhaNVdCQTVaTHQ4SnYzODk1RGR1QmxnYlBZQWo4QzRCOGhPNjhGRGtvaDVseWRDNEZpV3ZCT1ZxallkcWppTHY5MnQ4eVBEanJEYWlIZFVEMTVxa1NVUlNHbVhKd09NU3hXQVhZd3IzemFBdWZKNjZsKzk0dnYzQU8rdlBjRDdhdy93L3RvRHZMLzJBTyt2UGNEN2F3L3dIdUQ5dFFkNGYrMEIzbDk3Z1BmWEh1RDl0UWQ0ZiswQjNsOTdnRzhMd1A4Ry9BTDhPL0E1T0NxMFlzMktJZHYvcU9JWEcvNG12RkFNRjE2Z1pEKzJYdnUvQjhhczUrOGJmbGxXeWcwemFOTzViZlhqNnZmaGh3RDg2L0FxM05mUlM5dDlXUG5oZm52Q0l3L0NUOEdMY0ZUTW5wbnRkRi96OVYrUFdjL3ZXb0lIK0ZMM1pudjU3UGl0Y2RHUDRSL0MzNGF2dzVmZ1JWVUluQ3dic24xeXlBOEM4em0vQkg4TlhvWG5WRTZ3VlBqZGVDSTM4a1gvMytDdDlkYnoxcFRtSEZSdStIbTRPOUNoM2Nscjk5bmVneGZ3aitFUi9EUjhFVjZCNStEdVFPblRnVXc1cm5rWStGYk5VM2dOWGgwby9KWVR1V092eUJmOUZ2elg2NjNISC9IZWpPOEx3QWw4SGw1WUxUZDhxN3NxQTN3Ymp1RXhmQUZlZ1Fkd2Z5RG9Ta1dZOHN3ekVmNm80UXlld2VmZytjSE5icU1RcnVTTC91L1dXYytFNWc3dm5uRVhnRG1jRGVTR2IvRjRjQmNDZ1QrR0dSekRVM2haWWJ1ckF0OVRFdEhnYk02Sm94Sis2Tk16elRjZjZjMmJ5Y3YyK0tLL2YrbDZMQnp3NUl3ZnFaSmhBM000NzJwV1QvYWpLeG5qdjRBRm5NRXBuQlRQTkQ2czJKN3FIYlBBcWNNSzc0VDJtWjRWR0I5dUpBNDY1SXQrL2VMMVdLaFlPRDd4SE9rcjFhaks3ZDBDNCtrZTRIeTlxWFp3cGdMcitabm0vdU5Gdzh4UU9TeThIOUl6alVyZDkrQklmZW5ZYXlsZjlGc1hyOGZCQWFkblBJRURuYThJQmN3bHhudUEwL1d2NkdBV1BkN2RESUtqTWRTV3VlQXNCajRNN1RPZDA2cUJid0R3S3I3b2xldXhNT0VjVHVFWlRIV3ZEWVVPN2FIcUFlMEJicStIRUZSek96N1dWb1REUWtWZHM3QTRzSUl4ZkNRZENlZkZSb0lPRi9ORkwxbVBhYi9udk9ha1NML1ExYUZ0TnBVYi9uRk9WWDZnenlnLzFuSVN5RGZVaHNva0l6YUJSOUt4bTgwczVtSys2UDU2aWwxalhpYzduaFF4c3hTbTNPd0JIbDRmRmRMcWk2NG5EUVp2cUUyYXQ3Y1dBcC9JVnZyTjYvQkZMMW1QaFlyR01CZk9pNFB5anVTR2Y2d0JCaDdwL0ZaVGdoQ05XR2dNemxCYnJOSm9QSlgybVc1bXdaZnlSZmZYbzdPRmk1cFpjUzRxWlVybFZpcHRyWHR3K0dRb3loRFBTK0FOamNHQk5SaUxDUURQWlBNSHVpWmZkRnBQU1RjUXd3S1lkUk5xcGtqbTdBRmVlVDBwSnpBTGdvN2c4WVlHck1IUzBpb2N5K1lUbTJ2eVJVdnZwWENJcFE1cGU2NjZUSnJjeWduU2NVZi9wME5Ecy9pQUkvbnFESEM4VG1RVDh4M05GOTFsNzZvRGRRR3d1NjFaNkUwQUJ2N3VPMWRiZi8zN1psditady9QYmg4ZjFzNEF2dXI2NjU3LytZWUJ2dXI2NjU3LytZWUJ2dXI2NjU3LytZWUJ2dXI2NjU3LythWUJ2dUw2NjU3LytWTUE4RlhXWC9mOHp6Y044QlhYWC9mOHp6Y05NRmRiZjkzelAzOEtMUGlLNjY5Ny91ZWJ0dUFycnIvdStaOXZHbUN1c1A2NjUzLysxRmp3VmRaZjkvelBON29IWDMzOWRjLy9mTk11K2lycnIzdis1MCtCaStacTY2OTcvdWViQS9qejhQdWRmOWh0L2ZXdjUxN0ovWFV6QVA4Qy9CQWVYOVdDRHJVcFozL2RFTUJ4Z1BjZmJ0VFZ2c1lWNVluMzJ1MDNCM0FjNFAzYjhJK3Z4TkJLZWVMOWRSTUFsd084Mzk1OXFHTzc4c1Q3NjlvQjdnM3cvdkdWWUZ6S0UrK3Y2d1Y0T01EN0Y3dGNrRmttVDd5L3JoSGdwUU84Yis0WTQ2WHl4UHZydWdCZU5jQjdCUmlYOHNUNzY3b0F2bUNBOXdvQUhzb1Q3NityQkpqTEJuaDN0eE92a2lmZVgxZHN3WmNPOEc2TjdzWHl4UHZyNmkzNDBnSGUzVG5xVmZMRSsrdUtBYjUwZ0hjWExuclg4c1I3Z05kUFJxd3p3THU3WS9GTzVZbjNBSzlqWENNR2VIZGd4RHVWSjc1VkFJOGxqUDdQQWIzL1JmamNaZmVQSEJCKzc5ZHBmcEgxQ2FuTjMwZCttVDFoOUdxQXh4SkdNNUxRZWVRMStUYitFUUpyRWxMYjM4VkhROTRUUnE5MDBhTUlvOGNTT28rOERwOFFmc0I4enBxRTFOTzNPSTlacmoxaDlFVjc4UHFFMFdNSm5VZGVVNkUrSmp5ay9oYnJFRklmZVdidklkOEg5b1RSRndkWmF4Skd2emlXMEhuMGdxWUIvd3laMFB3Umx4SlNUK0JPdzltNzdBbWoxNGlpMXlHTS90eFlRdWROMHFEekdlNEVxZkEvNUdKQ2Fnc0hjUGFFUFdIMGVzZWtTd21qUnhNNmI1SkVjWjR3dzUwaWx2QU9GeEJTeDR5TFcrQS9ZVThZdmZZNStBTEM2TkdFemh0bXlab0Zab2Fyd0JMZVp4VWh0WTRyYzNiS25qQjZUS0pqRlVIekpvVE9vekYyWUJwc2pjeXhEZ3poUTFZUlVzZTgrSjR3ZW53bWF5bEI4MmhDNXcwem9SWFVOWGFSQm1TTVFVcWlXU1drTHNhVnFjL1pFMGFQVEZVdUpXZ2VUZWk4U2ZMWlFlTXhOYVpTSXpiSUk0YUUxTm1yMTNQMmhOSGpjOUU5Z3VZTkNaMDMyWWxOd0VTTUxjWmlMUUhrRTRhRTFCRmcweUFSNHoxaDlBaUFHUkEwanlaMDN0eUl4V01hak1QV0JJc3hZSkNubElUVTVTaGlIWWRaOTRUUjR3Q21TeGc5anRCNUt5UEdZenltQVlleFdFTXdBUElzQWRZZFY2YU9ibU5QR0QwYVlMb0V6YU1KblRjMFlncytZRHcwR0F0cXhCamt1UDM4Yk1SV0NIbjczeE5Hano3NVA3M1dlbkNFSm5od3lWZTNBRWU4VHRLZEpjWWhCbDk3d3VoTkFPYks2Nmx2RC85SjlOUzc1djE3d3VpdEFONWZlNEQzMXg3Zy9iVUhlSC90QWQ1ZmU0RDNBTyt2UGNEN2F3L3cvdG9EdkwvMkFPK3ZQY0Q3YXcvdy90b0R2QWQ0Zi8yNEFCelo4bytLTHNTTFMrUHYvVHFUYjNQNGhLbFFyVEdoK2ZiSUJUMEF4cXpubmIrTC9WMm1iM0hrTjVNYi9uRUhlSzdkNEljRGxkNmxtRFcvaUg5RStBSDFNZE93L0psdTJUMXhObVk5OHN2NHdIbkQ3RDN1Tkh1NTRXVXVPc0JUYlF1dkJzUFQvVWZ6TnhHWXp3a1A4YytZejNDK3IvaTZEY3lSTC9yWit1dFJ3V0g1UG1mdmN2WUV0OWpMRFMvYmcwL0I2NERXS3JRTThBTDhGUHdTOWJlUUNlNkVNS05aWUpvbDM3akJNeTM1b3RkYXowQncySC9DMlNtYzcrV0dCMEhXREVMQm1PQnlBM3I1UU9ObzRWK0RwelIvaEZTNFU4d01XMVBYTkI0VE9xWXo5dXJ4UlYrK250V0N3L1U1OVR5OWViZFdicmdmUlM5QVlLS042M1pva1pWeWdyOEdaL2dmSWhaWElYUHNBbE5qUE9MQmJ5NWMxZU9Mdm1ROWx3a095NXg2UVYxajVUWXFwUzA1SnRVZ1VIVXA1dG9IR3NWZm40Tlg0Um5NQ2UrQXhUcHdtQXBUWXhxTXh3ZkNlSkdqcFh6UkY2MW5iY0hoVUJQcVd6ZTlzdndjSEorUzZOUHNjS3JFanVnNzhEeDhMajNUOEQ0WXhHSWR4bUpjd2hpMzRmelpVcjdvbGV2WkN3NXZrT2hvQ2xxNXpCUFpBbnlnRC9UbDlFekRoNmtsM1Zoc0hZY0RFYitoQ3RKU3Z1aVY2OWtMRG0rV3ljck9UQXJIbUI1L1ZZeVA2ak9WandnR2F3azJ6UU9hVGNjMUwrYUxYcktldmVEd1pxbEtydzhVOVkxcDY2dUs4ZEV6ZFl3QmVVUUFZN0RieVlOZXpCZmRXUTk3d2VFdEFLWVFnMnhKSWt1dmVBVDNkWWVMR0grU2hyV053WmdOMGIyWUw3cXpucjNnOEpZQW81YlFCemlQang3QlBaMGQ5UkNRcDRVWmJuRmR6QmRkb3I0WEhONEtZTXJCMnFIRlJJenpjTEFIUVo1dGhlNW92dWk5NFBDV0FQZWZhWW54SWR6UndkSENidVI0Qit0Yml5OTZMemk4RTREN3o3UzBtRVBkK2VxTzNjVDUzWjBZOFNWODBYdkI0WjBBREppL2Y3WDExM2YrN3A3LytVWUJ2dXI2NjU3LytZWUJ2dXI2NjU3LythWUJ2dUw2NjU3LythWUJ2dUw2NjU3LythWUJ2dUw2NjU3LythWUJ2dUw2NjU3LytWTUE4RlhXWC9mOHo1OE9nSyt5L3JybmY3NVJnTG5hK3V1ZS8vbFRBL0NWMVYvMy9NODM3YUt2dnY2NjUzKytVUXZtYXV1dmUvN25Ud2ZBVjFOLzNmTS9menIyNEN1dXYrNzVuejhGRm54bDlkYzkvL01Pci84L2dsaXh3UnVVZk00QUFBQUFTVVZPUks1Q1lJST1cIjtcclxuIiwiZXhwb3J0IGRlZmF1bHQgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUVJQUFBQWhDQUFBQUFCSVh5TEFBQUFBT0VsRVFWUkl4Mk5nR0FXallCU01nbEV3RUlDUkVZUmdGQlpCcURDU0xBMk1HUFVJVlFFVEU5aU5VQXFMUjVnSWVvUUtSZ3dYandBQUduNEF0YUZlWUxFQUFBQUFTVVZPUks1Q1lJST1cIjtcclxuIiwiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFVuaWZvcm0sIFZlY3RvcjIgfSBmcm9tIFwidGhyZWVcIjtcclxuXHJcbmltcG9ydCBhcmVhSW1hZ2UgZnJvbSBcIi4vaW1hZ2VzL3NtYWEvYXJlYUltYWdlLmpzXCI7XHJcbmltcG9ydCBzZWFyY2hJbWFnZSBmcm9tIFwiLi9pbWFnZXMvc21hYS9zZWFyY2hJbWFnZS5qc1wiO1xyXG5cclxuY29uc3QgZnJhZ21lbnQgPSBcIiNkZWZpbmUgc2FtcGxlTGV2ZWxaZXJvT2Zmc2V0KHQsIGNvb3JkLCBvZmZzZXQpIHRleHR1cmUyRCh0LCBjb29yZCArIGZsb2F0KG9mZnNldCkgKiB0ZXhlbFNpemUsIDAuMClcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0QXJlYTtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB0U2VhcmNoO1xcclxcblxcclxcbnVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzQgdk9mZnNldFszXTtcXHJcXG52YXJ5aW5nIHZlYzIgdlBpeENvb3JkO1xcclxcblxcclxcbnZlYzIgcm91bmQodmVjMiB4KSB7XFxyXFxuXFxyXFxuXFx0cmV0dXJuIHNpZ24oeCkgKiBmbG9vcihhYnMoeCkgKyAwLjUpO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG5mbG9hdCBzZWFyY2hMZW5ndGgodmVjMiBlLCBmbG9hdCBiaWFzLCBmbG9hdCBzY2FsZSkge1xcclxcblxcclxcblxcdC8vIE5vdCByZXF1aXJlZCBpZiB0U2VhcmNoIGFjY2Vzc2VzIGFyZSBzZXQgdG8gcG9pbnQuXFxyXFxuXFx0Ly8gY29uc3QgdmVjMiBTRUFSQ0hfVEVYX1BJWEVMX1NJWkUgPSAxLjAgLyB2ZWMyKDY2LjAsIDMzLjApO1xcclxcblxcdC8vIGUgPSB2ZWMyKGJpYXMsIDAuMCkgKyAwLjUgKiBTRUFSQ0hfVEVYX1BJWEVMX1NJWkUgKyBlICogdmVjMihzY2FsZSwgMS4wKSAqIHZlYzIoNjQuMCwgMzIuMCkgKiBTRUFSQ0hfVEVYX1BJWEVMX1NJWkU7XFxyXFxuXFxyXFxuXFx0ZS5yID0gYmlhcyArIGUuciAqIHNjYWxlO1xcclxcblxcclxcblxcdHJldHVybiAyNTUuMCAqIHRleHR1cmUyRCh0U2VhcmNoLCBlLCAwLjApLnI7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IHNlYXJjaFhMZWZ0KHZlYzIgdGV4Q29vcmQsIGZsb2F0IGVuZCkge1xcclxcblxcclxcblxcdC8qIEBQU0VVRE9fR0FUSEVSNFxcclxcblxcdCAqIFRoaXMgdGV4Q29vcmQgaGFzIGJlZW4gb2Zmc2V0IGJ5ICgtMC4yNSwgLTAuMTI1KSBpbiB0aGUgdmVydGV4IHNoYWRlciB0b1xcclxcblxcdCAqIHNhbXBsZSBiZXR3ZWVuIGVkZ2UsIHRodXMgZmV0Y2hpbmcgZm91ciBlZGdlcyBpbiBhIHJvdy5cXHJcXG5cXHQgKiBTYW1wbGluZyB3aXRoIGRpZmZlcmVudCBvZmZzZXRzIGluIGVhY2ggZGlyZWN0aW9uIGFsbG93cyB0byBkaXNhbWJpZ3VhdGVcXHJcXG5cXHQgKiB3aGljaCBlZGdlcyBhcmUgYWN0aXZlIGZyb20gdGhlIGZvdXIgZmV0Y2hlZCBvbmVzLlxcclxcblxcdCAqL1xcclxcblxcclxcblxcdHZlYzIgZSA9IHZlYzIoMC4wLCAxLjApO1xcclxcblxcclxcblxcdGZvcihpbnQgaSA9IDA7IGkgPCBTTUFBX01BWF9TRUFSQ0hfU1RFUFNfSU5UOyArK2kpIHtcXHJcXG5cXHJcXG5cXHRcXHRlID0gdGV4dHVyZTJEKHREaWZmdXNlLCB0ZXhDb29yZCwgMC4wKS5yZztcXHJcXG5cXHRcXHR0ZXhDb29yZCAtPSB2ZWMyKDIuMCwgMC4wKSAqIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRpZighKHRleENvb3JkLnggPiBlbmQgJiYgZS5nID4gMC44MjgxICYmIGUuciA9PSAwLjApKSB7IGJyZWFrOyB9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdC8vIENvcnJlY3QgdGhlIHByZXZpb3VzbHkgYXBwbGllZCBvZmZzZXQgKC0wLjI1LCAtMC4xMjUpLlxcclxcblxcdHRleENvb3JkLnggKz0gMC4yNSAqIHRleGVsU2l6ZS54O1xcclxcblxcclxcblxcdC8vIFRoZSBzZWFyY2hlcyBhcmUgYmlhc2VkIGJ5IDEsIHNvIGFkanVzdCB0aGUgY29vcmRzIGFjY29yZGluZ2x5LlxcclxcblxcdHRleENvb3JkLnggKz0gdGV4ZWxTaXplLng7XFxyXFxuXFxyXFxuXFx0Ly8gRGlzYW1iaWd1YXRlIHRoZSBsZW5ndGggYWRkZWQgYnkgdGhlIGxhc3Qgc3RlcC5cXHJcXG5cXHR0ZXhDb29yZC54ICs9IDIuMCAqIHRleGVsU2l6ZS54OyAvLyBVbmRvIGxhc3Qgc3RlcC5cXHJcXG5cXHR0ZXhDb29yZC54IC09IHRleGVsU2l6ZS54ICogc2VhcmNoTGVuZ3RoKGUsIDAuMCwgMC41KTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gdGV4Q29vcmQueDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgc2VhcmNoWFJpZ2h0KHZlYzIgdGV4Q29vcmQsIGZsb2F0IGVuZCkge1xcclxcblxcclxcblxcdHZlYzIgZSA9IHZlYzIoMC4wLCAxLjApO1xcclxcblxcclxcblxcdGZvcihpbnQgaSA9IDA7IGkgPCBTTUFBX01BWF9TRUFSQ0hfU1RFUFNfSU5UOyArK2kpIHtcXHJcXG5cXHJcXG5cXHRcXHRlID0gdGV4dHVyZTJEKHREaWZmdXNlLCB0ZXhDb29yZCwgMC4wKS5yZztcXHJcXG5cXHRcXHR0ZXhDb29yZCArPSB2ZWMyKDIuMCwgMC4wKSAqIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG5cXHRcXHRpZighKHRleENvb3JkLnggPCBlbmQgJiYgZS5nID4gMC44MjgxICYmIGUuciA9PSAwLjApKSB7IGJyZWFrOyB9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdHRleENvb3JkLnggLT0gMC4yNSAqIHRleGVsU2l6ZS54O1xcclxcblxcdHRleENvb3JkLnggLT0gdGV4ZWxTaXplLng7XFxyXFxuXFx0dGV4Q29vcmQueCAtPSAyLjAgKiB0ZXhlbFNpemUueDtcXHJcXG5cXHR0ZXhDb29yZC54ICs9IHRleGVsU2l6ZS54ICogc2VhcmNoTGVuZ3RoKGUsIDAuNSwgMC41KTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gdGV4Q29vcmQueDtcXHJcXG5cXHJcXG59XFxyXFxuXFxyXFxuZmxvYXQgc2VhcmNoWVVwKHZlYzIgdGV4Q29vcmQsIGZsb2F0IGVuZCkge1xcclxcblxcclxcblxcdHZlYzIgZSA9IHZlYzIoMS4wLCAwLjApO1xcclxcblxcclxcblxcdGZvcihpbnQgaSA9IDA7IGkgPCBTTUFBX01BWF9TRUFSQ0hfU1RFUFNfSU5UOyArK2kpIHtcXHJcXG5cXHJcXG5cXHRcXHRlID0gdGV4dHVyZTJEKHREaWZmdXNlLCB0ZXhDb29yZCwgMC4wKS5yZztcXHJcXG5cXHRcXHR0ZXhDb29yZCArPSB2ZWMyKDAuMCwgMi4wKSAqIHRleGVsU2l6ZTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcclxcblxcdFxcdGlmKCEodGV4Q29vcmQueSA+IGVuZCAmJiBlLnIgPiAwLjgyODEgJiYgZS5nID09IDAuMCkpIHsgYnJlYWs7IH1cXHJcXG5cXHJcXG5cXHR9XFxyXFxuXFxyXFxuXFx0dGV4Q29vcmQueSAtPSAwLjI1ICogdGV4ZWxTaXplLnk7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHR0ZXhDb29yZC55IC09IHRleGVsU2l6ZS55OyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFx0dGV4Q29vcmQueSAtPSAyLjAgKiB0ZXhlbFNpemUueTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcdHRleENvb3JkLnkgKz0gdGV4ZWxTaXplLnkgKiBzZWFyY2hMZW5ndGgoZS5nciwgMC4wLCAwLjUpOyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFxyXFxuXFx0cmV0dXJuIHRleENvb3JkLnk7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbmZsb2F0IHNlYXJjaFlEb3duKHZlYzIgdGV4Q29vcmQsIGZsb2F0IGVuZCkge1xcclxcblxcclxcblxcdHZlYzIgZSA9IHZlYzIoMS4wLCAwLjApO1xcclxcblxcclxcblxcdGZvcihpbnQgaSA9IDA7IGkgPCBTTUFBX01BWF9TRUFSQ0hfU1RFUFNfSU5UOyArK2kgKSB7XFxyXFxuXFxyXFxuXFx0XFx0ZSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgdGV4Q29vcmQsIDAuMCkucmc7XFxyXFxuXFx0XFx0dGV4Q29vcmQgLT0gdmVjMigwLjAsIDIuMCkgKiB0ZXhlbFNpemU7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHJcXG5cXHRcXHRpZighKHRleENvb3JkLnkgPCBlbmQgJiYgZS5yID4gMC44MjgxICYmIGUuZyA9PSAwLjApKSB7IGJyZWFrOyB9XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdHRleENvb3JkLnkgKz0gMC4yNSAqIHRleGVsU2l6ZS55OyAvLyBDaGFuZ2VkIHNpZ24uXFxyXFxuXFx0dGV4Q29vcmQueSArPSB0ZXhlbFNpemUueTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcdHRleENvb3JkLnkgKz0gMi4wICogdGV4ZWxTaXplLnk7IC8vIENoYW5nZWQgc2lnbi5cXHJcXG5cXHR0ZXhDb29yZC55IC09IHRleGVsU2l6ZS55ICogc2VhcmNoTGVuZ3RoKGUuZ3IsIDAuNSwgMC41KTsgLy8gQ2hhbmdlZCBzaWduLlxcclxcblxcclxcblxcdHJldHVybiB0ZXhDb29yZC55O1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52ZWMyIGFyZWEodmVjMiBkaXN0LCBmbG9hdCBlMSwgZmxvYXQgZTIsIGZsb2F0IG9mZnNldCkge1xcclxcblxcclxcblxcdC8vIFJvdW5kaW5nIHByZXZlbnRzIHByZWNpc2lvbiBlcnJvcnMgb2YgYmlsaW5lYXIgZmlsdGVyaW5nLlxcclxcblxcdHZlYzIgdGV4Q29vcmQgPSBTTUFBX0FSRUFURVhfTUFYX0RJU1RBTkNFICogcm91bmQoNC4wICogdmVjMihlMSwgZTIpKSArIGRpc3Q7XFxyXFxuXFxyXFxuXFx0Ly8gU2NhbGUgYW5kIGJpYXMgZm9yIHRleGVsIHNwYWNlIHRyYW5zbGF0aW9uLlxcclxcblxcdHRleENvb3JkID0gU01BQV9BUkVBVEVYX1BJWEVMX1NJWkUgKiB0ZXhDb29yZCArICgwLjUgKiBTTUFBX0FSRUFURVhfUElYRUxfU0laRSk7XFxyXFxuXFxyXFxuXFx0Ly8gTW92ZSB0byBwcm9wZXIgcGxhY2UsIGFjY29yZGluZyB0byB0aGUgc3VicGl4ZWwgb2Zmc2V0LlxcclxcblxcdHRleENvb3JkLnkgKz0gU01BQV9BUkVBVEVYX1NVQlRFWF9TSVpFICogb2Zmc2V0O1xcclxcblxcclxcblxcdHJldHVybiB0ZXh0dXJlMkQodEFyZWEsIHRleENvb3JkLCAwLjApLnJnO1xcclxcblxcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dmVjNCB3ZWlnaHRzID0gdmVjNCgwLjApO1xcclxcblxcdHZlYzQgc3Vic2FtcGxlSW5kaWNlcyA9IHZlYzQoMC4wKTtcXHJcXG5cXHR2ZWMyIGUgPSB0ZXh0dXJlMkQodERpZmZ1c2UsIHZVdikucmc7XFxyXFxuXFxyXFxuXFx0aWYoZS5nID4gMC4wKSB7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRWRnZSBhdCBub3J0aC5cXHJcXG5cXHRcXHR2ZWMyIGQ7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmluZCB0aGUgZGlzdGFuY2UgdG8gdGhlIGxlZnQuXFxyXFxuXFx0XFx0dmVjMiBjb29yZHM7XFxyXFxuXFx0XFx0Y29vcmRzLnggPSBzZWFyY2hYTGVmdCh2T2Zmc2V0WzBdLnh5LCB2T2Zmc2V0WzJdLngpO1xcclxcblxcdFxcdGNvb3Jkcy55ID0gdk9mZnNldFsxXS55OyAvLyB2T2Zmc2V0WzFdLnkgPSB2VXYueSAtIDAuMjUgKiB0ZXhlbFNpemUueSAoQENST1NTSU5HX09GRlNFVClcXHJcXG5cXHRcXHRkLnggPSBjb29yZHMueDtcXHJcXG5cXHJcXG5cXHRcXHQvKiBOb3cgZmV0Y2ggdGhlIGxlZnQgY3Jvc3NpbmcgZWRnZXMsIHR3byBhdCBhIHRpbWUgdXNpbmcgYmlsaW5lYXIgZmlsdGVyaW5nLlxcclxcblxcdFxcdFNhbXBsaW5nIGF0IC0wLjI1IChzZWUgQENST1NTSU5HX09GRlNFVCkgZW5hYmxlcyB0byBkaXNjZXJuIHdoYXQgdmFsdWUgZWFjaCBlZGdlIGhhcy4gKi9cXHJcXG5cXHJcXG5cXHRcXHRmbG9hdCBlMSA9IHRleHR1cmUyRCh0RGlmZnVzZSwgY29vcmRzLCAwLjApLnI7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmluZCB0aGUgZGlzdGFuY2UgdG8gdGhlIHJpZ2h0LlxcclxcblxcdFxcdGNvb3Jkcy54ID0gc2VhcmNoWFJpZ2h0KHZPZmZzZXRbMF0uencsIHZPZmZzZXRbMl0ueSk7XFxyXFxuXFx0XFx0ZC55ID0gY29vcmRzLng7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gVHJhbnNsYXRlIGRpc3RhbmNlcyB0byBwaXhlbCB1bml0cyBmb3IgYmV0dGVyIGludGVybGVhdmUgYXJpdGhtZXRpYyBhbmQgbWVtb3J5IGFjY2Vzc2VzLlxcclxcblxcdFxcdGQgPSBkIC8gdGV4ZWxTaXplLnggLSB2UGl4Q29vcmQueDtcXHJcXG5cXHJcXG5cXHRcXHQvLyBUaGUgYXJlYSBiZWxvdyBuZWVkcyBhIHNxcnQsIGFzIHRoZSBhcmVhcyB0ZXh0dXJlIGlzIGNvbXByZXNzZWQgcXVhZHJhdGljYWxseS5cXHJcXG5cXHRcXHR2ZWMyIHNxcnREID0gc3FydChhYnMoZCkpO1xcclxcblxcclxcblxcdFxcdC8vIEZldGNoIHRoZSByaWdodCBjcm9zc2luZyBlZGdlcy5cXHJcXG5cXHRcXHRjb29yZHMueSAtPSB0ZXhlbFNpemUueTsgLy8gV2ViR0wgcG9ydCBub3RlOiBBZGRlZC5cXHJcXG5cXHRcXHRmbG9hdCBlMiA9IHNhbXBsZUxldmVsWmVyb09mZnNldCh0RGlmZnVzZSwgY29vcmRzLCBpdmVjMigxLCAwKSkucjtcXHJcXG5cXHJcXG5cXHRcXHQvLyBQYXR0ZXJuIHJlY29nbmlzZWQsIG5vdyBnZXQgdGhlIGFjdHVhbCBhcmVhLlxcclxcblxcdFxcdHdlaWdodHMucmcgPSBhcmVhKHNxcnRELCBlMSwgZTIsIHN1YnNhbXBsZUluZGljZXMueSk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGlmKGUuciA+IDAuMCkge1xcclxcblxcclxcblxcdFxcdC8vIEVkZ2UgYXQgd2VzdC5cXHJcXG5cXHRcXHR2ZWMyIGQ7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmluZCB0aGUgZGlzdGFuY2UgdG8gdGhlIHRvcC5cXHJcXG5cXHRcXHR2ZWMyIGNvb3JkcztcXHJcXG5cXHJcXG5cXHRcXHRjb29yZHMueSA9IHNlYXJjaFlVcCh2T2Zmc2V0WzFdLnh5LCB2T2Zmc2V0WzJdLnopO1xcclxcblxcdFxcdGNvb3Jkcy54ID0gdk9mZnNldFswXS54OyAvLyB2T2Zmc2V0WzFdLnggPSB2VXYueCAtIDAuMjUgKiB0ZXhlbFNpemUueDtcXHJcXG5cXHRcXHRkLnggPSBjb29yZHMueTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBGZXRjaCB0aGUgdG9wIGNyb3NzaW5nIGVkZ2VzLlxcclxcblxcdFxcdGZsb2F0IGUxID0gdGV4dHVyZTJEKHREaWZmdXNlLCBjb29yZHMsIDAuMCkuZztcXHJcXG5cXHJcXG5cXHRcXHQvLyBGaW5kIHRoZSBkaXN0YW5jZSB0byB0aGUgYm90dG9tLlxcclxcblxcdFxcdGNvb3Jkcy55ID0gc2VhcmNoWURvd24odk9mZnNldFsxXS56dywgdk9mZnNldFsyXS53KTtcXHJcXG5cXHRcXHRkLnkgPSBjb29yZHMueTtcXHJcXG5cXHJcXG5cXHRcXHQvLyBEaXN0YW5jZXMgaW4gcGl4ZWwgdW5pdHMuXFxyXFxuXFx0XFx0ZCA9IGQgLyB0ZXhlbFNpemUueSAtIHZQaXhDb29yZC55O1xcclxcblxcclxcblxcdFxcdC8vIFRoZSBhcmVhIGJlbG93IG5lZWRzIGEgc3FydCwgYXMgdGhlIGFyZWFzIHRleHR1cmUgaXMgY29tcHJlc3NlZCBxdWFkcmF0aWNhbGx5LlxcclxcblxcdFxcdHZlYzIgc3FydEQgPSBzcXJ0KGFicyhkKSk7XFxyXFxuXFxyXFxuXFx0XFx0Ly8gRmV0Y2ggdGhlIGJvdHRvbSBjcm9zc2luZyBlZGdlcy5cXHJcXG5cXHRcXHRjb29yZHMueSAtPSB0ZXhlbFNpemUueTsgLy8gV2ViR0wgcG9ydCBub3RlOiBBZGRlZC5cXHJcXG5cXHRcXHRmbG9hdCBlMiA9IHNhbXBsZUxldmVsWmVyb09mZnNldCh0RGlmZnVzZSwgY29vcmRzLCBpdmVjMigwLCAxKSkuZztcXHJcXG5cXHJcXG5cXHRcXHQvLyBHZXQgdGhlIGFyZWEgZm9yIHRoaXMgZGlyZWN0aW9uLlxcclxcblxcdFxcdHdlaWdodHMuYmEgPSBhcmVhKHNxcnRELCBlMSwgZTIsIHN1YnNhbXBsZUluZGljZXMueCk7XFxyXFxuXFxyXFxuXFx0fVxcclxcblxcclxcblxcdGdsX0ZyYWdDb2xvciA9IHdlaWdodHM7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5jb25zdCB2ZXJ0ZXggPSBcInVuaWZvcm0gdmVjMiB0ZXhlbFNpemU7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZVdjtcXHJcXG52YXJ5aW5nIHZlYzQgdk9mZnNldFszXTtcXHJcXG52YXJ5aW5nIHZlYzIgdlBpeENvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2VXYgPSB1djtcXHJcXG5cXHJcXG5cXHR2UGl4Q29vcmQgPSB1diAvIHRleGVsU2l6ZTtcXHJcXG5cXHJcXG5cXHQvLyBPZmZzZXRzIGZvciB0aGUgc2VhcmNoZXMgKHNlZSBAUFNFVURPX0dBVEhFUjQpLlxcclxcblxcdHZPZmZzZXRbMF0gPSB1di54eXh5ICsgdGV4ZWxTaXplLnh5eHkgKiB2ZWM0KC0wLjI1LCAwLjEyNSwgMS4yNSwgMC4xMjUpOyAvLyBDaGFuZ2VkIHNpZ24gaW4gWSBhbmQgVyBjb21wb25lbnRzLlxcclxcblxcdHZPZmZzZXRbMV0gPSB1di54eXh5ICsgdGV4ZWxTaXplLnh5eHkgKiB2ZWM0KC0wLjEyNSwgMC4yNSwgLTAuMTI1LCAtMS4yNSk7IC8vQ2hhbmdlZCBzaWduIGluIFkgYW5kIFcgY29tcG9uZW50cy5cXHJcXG5cXHJcXG5cXHQvLyBUaGlzIGluZGljYXRlcyB0aGUgZW5kcyBvZiB0aGUgbG9vcHMuXFxyXFxuXFx0dk9mZnNldFsyXSA9IHZlYzQodk9mZnNldFswXS54eiwgdk9mZnNldFsxXS55dykgKyB2ZWM0KC0yLjAsIDIuMCwgLTIuMCwgMi4wKSAqIHRleGVsU2l6ZS54eHl5ICogU01BQV9NQVhfU0VBUkNIX1NURVBTX0ZMT0FUO1xcclxcblxcclxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxyXFxuXFxyXFxufVxcclxcblwiO1xyXG5cclxuLyoqXHJcbiAqIFN1YnBpeGVsIE1vcnBob2xvZ2ljYWwgQW50aWFsaWFzaW5nLlxyXG4gKlxyXG4gKiBUaGlzIG1hdGVyaWFsIGNvbXB1dGVzIHdlaWdodHMgZm9yIGRldGVjdGVkIGVkZ2VzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBTTUFBV2VpZ2h0c01hdGVyaWFsIGV4dGVuZHMgU2hhZGVyTWF0ZXJpYWwge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IFNNQUEgd2VpZ2h0cyBtYXRlcmlhbC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7VmVjdG9yMn0gW3RleGVsU2l6ZV0gLSBUaGUgYWJzb2x1dGUgc2NyZWVuIHRleGVsIHNpemUuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHRleGVsU2l6ZSA9IG5ldyBWZWN0b3IyKCkpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIlNNQUFXZWlnaHRzTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHJcblx0XHRcdFx0U01BQV9NQVhfU0VBUkNIX1NURVBTX0lOVDogXCI4XCIsXHJcblx0XHRcdFx0U01BQV9NQVhfU0VBUkNIX1NURVBTX0ZMT0FUOiBcIjguMFwiLFxyXG5cclxuXHRcdFx0XHRTTUFBX0FSRUFURVhfTUFYX0RJU1RBTkNFOiBcIjE2LjBcIixcclxuXHJcblx0XHRcdFx0U01BQV9BUkVBVEVYX1BJWEVMX1NJWkU6IFwiKDEuMCAvIHZlYzIoMTYwLjAsIDU2MC4wKSlcIixcclxuXHRcdFx0XHRTTUFBX0FSRUFURVhfU1VCVEVYX1NJWkU6IFwiKDEuMCAvIDcuMClcIlxyXG5cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHR0QXJlYTogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dFNlYXJjaDogbmV3IFVuaWZvcm0obnVsbCksXHJcblx0XHRcdFx0dGV4ZWxTaXplOiBuZXcgVW5pZm9ybSh0ZXhlbFNpemUpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYXJlYSBwYXR0ZXJuIHJlY29nbml0aW9uIGltYWdlLiBFbmNvZGVkIGFzIGJhc2U2NC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5hcmVhSW1hZ2UgPSBhcmVhSW1hZ2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2VhcmNoIGltYWdlLiBFbmNvZGVkIGFzIGJhc2U2NC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zZWFyY2hJbWFnZSA9IHNlYXJjaEltYWdlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBVbmlmb3JtLCBWZWN0b3IzIH0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5jb25zdCBmcmFnbWVudCA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XFxyXFxudW5pZm9ybSBmbG9hdCBtaWRkbGVHcmV5O1xcclxcbnVuaWZvcm0gZmxvYXQgbWF4THVtaW5hbmNlO1xcclxcbnVuaWZvcm0gdmVjMyBsdW1pbmFuY2VDb2VmZmljaWVudHM7XFxyXFxuXFxyXFxuI2lmZGVmIEFEQVBURURfTFVNSU5BTkNFXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHVtaW5hbmNlTWFwO1xcclxcblxcclxcbiNlbHNlXFxyXFxuXFxyXFxuXFx0dW5pZm9ybSBmbG9hdCBhdmVyYWdlTHVtaW5hbmNlO1xcclxcblxcclxcbiNlbmRpZlxcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VXY7XFxyXFxuXFxyXFxudmVjMyB0b25lTWFwKHZlYzMgYykge1xcclxcblxcclxcblxcdCNpZmRlZiBBREFQVEVEX0xVTUlOQU5DRVxcclxcblxcclxcblxcdFxcdC8vIEdldCB0aGUgY2FsY3VsYXRlZCBhdmVyYWdlIGx1bWluYW5jZSBieSBzYW1wbGluZyB0aGUgY2VudGVyLlxcclxcblxcdFxcdGZsb2F0IGx1bUF2ZyA9IHRleHR1cmUyRChsdW1pbmFuY2VNYXAsIHZlYzIoMC41KSkucjtcXHJcXG5cXHJcXG5cXHQjZWxzZVxcclxcblxcclxcblxcdFxcdGZsb2F0IGx1bUF2ZyA9IGF2ZXJhZ2VMdW1pbmFuY2U7XFxyXFxuXFxyXFxuXFx0I2VuZGlmXFxyXFxuXFxyXFxuXFx0Ly8gQ2FsY3VsYXRlIHRoZSBsdW1pbmFuY2Ugb2YgdGhlIGN1cnJlbnQgcGl4ZWwuXFxyXFxuXFx0ZmxvYXQgbHVtUGl4ZWwgPSBkb3QoYywgbHVtaW5hbmNlQ29lZmZpY2llbnRzKTtcXHJcXG5cXHJcXG5cXHQvLyBBcHBseSB0aGUgbW9kaWZpZWQgb3BlcmF0b3IgKFJlaW5oYXJkIEVxLiA0KS5cXHJcXG5cXHRmbG9hdCBsdW1TY2FsZWQgPSAobHVtUGl4ZWwgKiBtaWRkbGVHcmV5KSAvIGx1bUF2ZztcXHJcXG5cXHJcXG5cXHRmbG9hdCBsdW1Db21wcmVzc2VkID0gKGx1bVNjYWxlZCAqICgxLjAgKyAobHVtU2NhbGVkIC8gKG1heEx1bWluYW5jZSAqIG1heEx1bWluYW5jZSkpKSkgLyAoMS4wICsgbHVtU2NhbGVkKTtcXHJcXG5cXHJcXG5cXHRyZXR1cm4gbHVtQ29tcHJlc3NlZCAqIGM7XFxyXFxuXFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG5cXHJcXG5cXHR2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHREaWZmdXNlLCB2VXYpO1xcclxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQodG9uZU1hcCh0ZXhlbC5yZ2IpLCB0ZXhlbC5hKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcbmNvbnN0IHZlcnRleCA9IFwidmFyeWluZyB2ZWMyIHZVdjtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuXFxyXFxuXFx0dlV2ID0gdXY7XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXHJcXG5cXHJcXG59XFxyXFxuXCI7XHJcblxyXG4vKipcclxuICogRnVsbC1zY3JlZW4gdG9uZS1tYXBwaW5nIHNoYWRlciBtYXRlcmlhbC5cclxuICpcclxuICogUmVmZXJlbmNlOlxyXG4gKiAgaHR0cDovL3d3dy5jaXMucml0LmVkdS9wZW9wbGUvZmFjdWx0eS9mZXJ3ZXJkYS9wdWJsaWNhdGlvbnMvc2lnMDJfcGFwZXIucGRmXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvbmVNYXBwaW5nTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdG9uZSBtYXBwaW5nIG1hdGVyaWFsLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHJcblx0XHRzdXBlcih7XHJcblxyXG5cdFx0XHR0eXBlOiBcIlRvbmVNYXBwaW5nTWF0ZXJpYWxcIixcclxuXHJcblx0XHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcdHREaWZmdXNlOiBuZXcgVW5pZm9ybShudWxsKSxcclxuXHRcdFx0XHRsdW1pbmFuY2VNYXA6IG5ldyBVbmlmb3JtKG51bGwpLFxyXG5cdFx0XHRcdGF2ZXJhZ2VMdW1pbmFuY2U6IG5ldyBVbmlmb3JtKDEuMCksXHJcblx0XHRcdFx0bHVtaW5hbmNlQ29lZmZpY2llbnRzOiBuZXcgVW5pZm9ybShuZXcgVmVjdG9yMygwLjIxMjYsIDAuNzE1MiwgMC4wNzIyKSksXHJcblx0XHRcdFx0bWF4THVtaW5hbmNlOiBuZXcgVW5pZm9ybSgxNi4wKSxcclxuXHRcdFx0XHRtaWRkbGVHcmV5OiBuZXcgVW5pZm9ybSgwLjYpXHJcblxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGZyYWdtZW50LFxyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcclxuXHJcblx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aFRlc3Q6IGZhbHNlXHJcblxyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiBzaGFkZXIgbWF0ZXJpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHBvc3QgcHJvY2Vzc2luZyBwYXNzZXMuXHJcbiAqXHJcbiAqIEBtb2R1bGUgcG9zdHByb2Nlc3NpbmcvbWF0ZXJpYWxzXHJcbiAqL1xyXG5cclxuZXhwb3J0IHsgQWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwgfSBmcm9tIFwiLi9BZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBCb2tlaE1hdGVyaWFsIH0gZnJvbSBcIi4vQm9rZWhNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBCb2tlaDJNYXRlcmlhbCB9IGZyb20gXCIuL0Jva2VoMk1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IENvbWJpbmVNYXRlcmlhbCB9IGZyb20gXCIuL0NvbWJpbmVNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBDb252b2x1dGlvbk1hdGVyaWFsLCBLZXJuZWxTaXplIH0gZnJvbSBcIi4vQ29udm9sdXRpb25NYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBDb3B5TWF0ZXJpYWwgfSBmcm9tIFwiLi9Db3B5TWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgRGVwdGhNYXRlcmlhbCB9IGZyb20gXCIuL0RlcHRoTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgRG90U2NyZWVuTWF0ZXJpYWwgfSBmcm9tIFwiLi9Eb3RTY3JlZW5NYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBGaWxtTWF0ZXJpYWwgfSBmcm9tIFwiLi9GaWxtTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgR2xpdGNoTWF0ZXJpYWwgfSBmcm9tIFwiLi9HbGl0Y2hNYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBHb2RSYXlzTWF0ZXJpYWwgfSBmcm9tIFwiLi9Hb2RSYXlzTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgTHVtaW5vc2l0eU1hdGVyaWFsIH0gZnJvbSBcIi4vTHVtaW5vc2l0eU1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IFBpeGVsYXRpb25NYXRlcmlhbCB9IGZyb20gXCIuL1BpeGVsYXRpb25NYXRlcmlhbC5qc1wiO1xyXG5leHBvcnQgeyBTaG9ja1dhdmVNYXRlcmlhbCB9IGZyb20gXCIuL1Nob2NrV2F2ZU1hdGVyaWFsLmpzXCI7XHJcbmV4cG9ydCB7IFNNQUFCbGVuZE1hdGVyaWFsIH0gZnJvbSBcIi4vU01BQUJsZW5kTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgU01BQUNvbG9yRWRnZXNNYXRlcmlhbCB9IGZyb20gXCIuL1NNQUFDb2xvckVkZ2VzTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgU01BQVdlaWdodHNNYXRlcmlhbCB9IGZyb20gXCIuL1NNQUFXZWlnaHRzTWF0ZXJpYWwuanNcIjtcclxuZXhwb3J0IHsgVG9uZU1hcHBpbmdNYXRlcmlhbCB9IGZyb20gXCIuL1RvbmVNYXBwaW5nTWF0ZXJpYWwuanNcIjtcclxuIiwiaW1wb3J0IHsgU2NlbmUsIE1lc2gsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgUGxhbmVCdWZmZXJHZW9tZXRyeSB9IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFic3RyYWN0IHBhc3MuXHJcbiAqXHJcbiAqIFBhc3NlcyB0aGF0IGRvIG5vdCByZWx5IG9uIHRoZSBkZXB0aCBidWZmZXIgc2hvdWxkIGV4cGxpY2l0bHkgZGlzYWJsZSB0aGVcclxuICogZGVwdGggdGVzdCBhbmQgZGVwdGggd3JpdGUgaW4gdGhlaXIgcmVzcGVjdGl2ZSBzaGFkZXIgbWF0ZXJpYWxzLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgYSB7QGxpbmsgUGFzcyNkaXNwb3NlfSBtZXRob2QgdGhhdCBmcmVlcyBtZW1vcnkgb25cclxuICogZGVtYW5kLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTY2VuZX0gW3NjZW5lXSAtIFRoZSBzY2VuZSB0byByZW5kZXIuXHJcblx0ICogQHBhcmFtIHtDYW1lcmF9IFtjYW1lcmFdIC0gVGhlIGNhbWVyYS5cclxuXHQgKiBAcGFyYW0ge01lc2h9IFtxdWFkXSAtIEEgcXVhZCB0aGF0IGZpbGxzIHRoZSBzY3JlZW4gdG8gcmVuZGVyIDJEIGZpbHRlciBlZmZlY3RzLiBTZXQgdGhpcyB0byBudWxsLCBpZiB5b3UgZG9uJ3QgbmVlZCBpdCAoc2VlIHtAbGluayBSZW5kZXJQYXNzfSkuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0c2NlbmUgPSBuZXcgU2NlbmUoKSxcclxuXHRcdGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLCAxKSxcclxuXHRcdHF1YWQgPSBuZXcgTWVzaChuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSgyLCAyKSwgbnVsbClcclxuXHQpIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc2NlbmUgdG8gcmVuZGVyLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTY2VuZX1cclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBkZWZhdWx0IG5ldyBTY2VuZSgpXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnNjZW5lID0gc2NlbmU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgY2FtZXJhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDYW1lcmF9XHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAZGVmYXVsdCBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMCwgMSlcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBxdWFkIG1lc2ggdGhhdCBmaWxscyB0aGUgc2NyZWVuLlxyXG5cdFx0ICpcclxuXHRcdCAqIEFzc2lnbiB5b3VyIHNoYWRlciBtYXRlcmlhbCB0byB0aGlzIG1lc2ghXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge01lc2h9XHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAZGVmYXVsdCBuZXcgTWVzaChuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSgyLCAyKSwgbnVsbClcclxuXHRcdCAqIEBleGFtcGxlIHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMubXlNYXRlcmlhbDtcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucXVhZCA9IHF1YWQ7XHJcblxyXG5cdFx0aWYodGhpcy5xdWFkICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHR0aGlzLnF1YWQuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYodGhpcy5zY2VuZSAhPT0gbnVsbCkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnNjZW5lLmFkZCh0aGlzLnF1YWQpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZWFkIGFuZCB3cml0ZSBidWZmZXJzIHNob3VsZCBiZSBzd2FwcGVkIGFmdGVyIHRoaXNcclxuXHRcdCAqIHBhc3MgaGFzIGZpbmlzaGVkIHJlbmRlcmluZy5cclxuXHRcdCAqXHJcblx0XHQgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIgc28gdGhhdCBhXHJcblx0XHQgKiBmb2xsb3dpbmcgcGFzcyBjYW4gZmluZCB0aGUgcmVzdWx0IGluIHRoZSByZWFkIGJ1ZmZlci5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogRW5hYmxlZCBmbGFnLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJlbmRlciB0byBzY3JlZW4gZmxhZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRvU2NyZWVuID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QgdGhhdCBtdXN0IGJlIG92ZXJyaWRkZW4uXHJcblx0ICpcclxuXHQgKiBAYWJzdHJhY3RcclxuXHQgKiBAdGhyb3dzIHtFcnJvcn0gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4uXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gQSByZWFkIGJ1ZmZlci4gQ29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgcGFzcy5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIEEgd3JpdGUgYnVmZmVyLiBOb3JtYWxseSB1c2VkIGFzIHRoZSByZW5kZXIgdGFyZ2V0IHdoZW4gdGhlIHJlYWQgYnVmZmVyIGlzIHVzZWQgYXMgaW5wdXQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkZWx0YV0gLSBUaGUgZGVsdGEgdGltZS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrQWN0aXZlXSAtIEluZGljYXRlcyB3aGV0aGVyIGEgc3RlbmNpbCB0ZXN0IG1hc2sgaXMgYWN0aXZlIG9yIG5vdC5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlciwgZGVsdGEsIG1hc2tBY3RpdmUpIHtcclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXIgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZCFcIik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIHlvdSB3YW50IHRvIGJlIGluZm9ybWVkIGFib3V0IHRoZSBtYWluXHJcblx0ICogcmVuZGVyIHNpemUuXHJcblx0ICpcclxuXHQgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCBiZWZvcmUgdGhpcyBwYXNzIGlzXHJcblx0ICogaW5pdGlhbGlzZWQgYW5kIGV2ZXJ5IHRpbWUgaXRzIG93biBzaXplIGlzIHVwZGF0ZWQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgcmVuZGVyZXIncyB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIHJlbmRlcmVyJ3MgaGVpZ2h0LlxyXG5cdCAqIEBleGFtcGxlIHRoaXMubXlSZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7fVxyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBpbml0aWFsaXNhdGlvbiB0YXNrcy5cclxuXHQgKlxyXG5cdCAqIEJ5IG92ZXJyaWRpbmcgdGhpcyBtZXRob2QgeW91IGdhaW4gYWNjZXNzIHRvIHRoZSByZW5kZXJlci4gWW91J2xsIGFsc28gYmVcclxuXHQgKiBhYmxlIHRvIGNvbmZpZ3VyZSB5b3VyIGN1c3RvbSByZW5kZXIgdGFyZ2V0cyB0byB1c2UgdGhlIGFwcHJvcHJpYXRlIGZvcm1hdFxyXG5cdCAqIChSR0Igb3IgUkdCQSkuXHJcblx0ICpcclxuXHQgKiBUaGUgcHJvdmlkZWQgcmVuZGVyZXIgY2FuIGJlIHVzZWQgdG8gd2FybSB1cCBzcGVjaWFsIG9mZi1zY3JlZW4gcmVuZGVyXHJcblx0ICogdGFyZ2V0cyBieSBwZXJmb3JtaW5nIGEgcHJlbGltaW5hcnkgcmVuZGVyIG9wZXJhdGlvbi5cclxuXHQgKlxyXG5cdCAqIFRoZSB7QGxpbmsgRWZmZWN0Q29tcG9zZXJ9IGNhbGxzIHRoaXMgbWV0aG9kIHdoZW4gdGhpcyBwYXNzIGlzIGFkZGVkIHRvIGl0c1xyXG5cdCAqIHF1ZXVlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXNlXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFscGhhIC0gV2hldGhlciB0aGUgcmVuZGVyZXIgdXNlcyB0aGUgYWxwaGEgY2hhbm5lbCBvciBub3QuXHJcblx0ICogQGV4YW1wbGUgaWYoIWFscGhhKSB7IHRoaXMubXlSZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7IH1cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpIHt9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFBlcmZvcm1zIGEgc2hhbGxvdyBzZWFyY2ggZm9yIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBkaXNwb3NlIG1ldGhvZCBhbmRcclxuXHQgKiBkZWxldGVzIHRoZW0uIFRoZSBwYXNzIHdpbGwgYmUgaW5vcGVyYXRpdmUgYWZ0ZXIgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCFcclxuXHQgKlxyXG5cdCAqIERpc3Bvc2FibGUgb2JqZWN0czpcclxuXHQgKiAgLSByZW5kZXIgdGFyZ2V0c1xyXG5cdCAqICAtIG1hdGVyaWFsc1xyXG5cdCAqICAtIHRleHR1cmVzXHJcblx0ICpcclxuXHQgKiBUaGUge0BsaW5rIEVmZmVjdENvbXBvc2VyfSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGl0IGlzIGJlaW5nIGRlc3Ryb3llZC5cclxuXHQgKiBZb3UgbWF5LCBob3dldmVyLCB1c2UgaXQgaW5kZXBlbmRlbnRseSB0byBmcmVlIG1lbW9yeSB3aGVuIHlvdSBhcmUgY2VydGFpblxyXG5cdCAqIHRoYXQgeW91IGRvbid0IG5lZWQgdGhpcyBwYXNzIGFueW1vcmUuXHJcblx0ICovXHJcblxyXG5cdGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0Y29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xyXG5cclxuXHRcdGxldCBrZXk7XHJcblxyXG5cdFx0Zm9yKGtleSBvZiBrZXlzKSB7XHJcblxyXG5cdFx0XHRpZih0aGlzW2tleV0gIT09IG51bGwgJiYgdHlwZW9mIHRoaXNba2V5XS5kaXNwb3NlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcblx0XHRcdFx0dGhpc1trZXldLmRpc3Bvc2UoKTtcclxuXHRcdFx0XHR0aGlzW2tleV0gPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIFJHQkZvcm1hdCwgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tIFwidGhyZWVcIjtcclxuaW1wb3J0IHsgQ29udm9sdXRpb25NYXRlcmlhbCwgS2VybmVsU2l6ZSB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGJsdXIgcGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQmx1clBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBibHVyIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHJlc29sdXRpb24gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4gcmVuZGVyIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5MQVJHRV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiQmx1clBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlbmRlciB0YXJnZXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYLnRleHR1cmUubmFtZSA9IFwiQmx1ci5UYXJnZXRYXCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFgudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgc2Vjb25kIHJlbmRlciB0YXJnZXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WSA9IHRoaXMucmVuZGVyVGFyZ2V0WC5jbG9uZSgpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WS50ZXh0dXJlLm5hbWUgPSBcIkJsdXIuVGFyZ2V0WVwiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlc29sdXRpb24gc2NhbGUuXHJcblx0XHQgKlxyXG5cdFx0ICogWW91IG5lZWQgdG8gY2FsbCB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjc2V0U2l6ZX0gYWZ0ZXIgY2hhbmdpbmcgdGhpc1xyXG5cdFx0ICogdmFsdWUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDAuNVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZXNvbHV0aW9uU2NhbGUgPSAob3B0aW9ucy5yZXNvbHV0aW9uU2NhbGUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnJlc29sdXRpb25TY2FsZSA6IDAuNTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY29udm9sdXRpb24gc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb252b2x1dGlvbk1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29udm9sdXRpb25NYXRlcmlhbCA9IG5ldyBDb252b2x1dGlvbk1hdGVyaWFsKCk7XHJcblxyXG5cdFx0dGhpcy5rZXJuZWxTaXplID0gb3B0aW9ucy5rZXJuZWxTaXplO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuY29udm9sdXRpb25NYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYWJzb2x1dGUgd2lkdGggb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0Z2V0IHdpZHRoKCkgeyByZXR1cm4gdGhpcy5yZW5kZXJUYXJnZXRYLndpZHRoOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBhYnNvbHV0ZSBoZWlnaHQgb2YgdGhlIGludGVybmFsIHJlbmRlciB0YXJnZXRzLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0Z2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0WC5oZWlnaHQ7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGtlcm5lbCBzaXplLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge0tlcm5lbFNpemV9XHJcblx0ICogQGRlZmF1bHQgS2VybmVsU2l6ZS5MQVJHRVxyXG5cdCAqL1xyXG5cclxuXHRnZXQga2VybmVsU2l6ZSgpIHsgcmV0dXJuIHRoaXMuY29udm9sdXRpb25NYXRlcmlhbC5rZXJuZWxTaXplOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQga2VybmVsU2l6ZSh4ID0gS2VybmVsU2l6ZS5MQVJHRSkgeyB0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwua2VybmVsU2l6ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQmx1cnMgdGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcclxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFggPSB0aGlzLnJlbmRlclRhcmdldFg7XHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRZID0gdGhpcy5yZW5kZXJUYXJnZXRZO1xyXG5cclxuXHRcdGNvbnN0IG1hdGVyaWFsID0gdGhpcy5jb252b2x1dGlvbk1hdGVyaWFsO1xyXG5cdFx0Y29uc3QgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcclxuXHRcdGNvbnN0IGtlcm5lbCA9IG1hdGVyaWFsLmdldEtlcm5lbCgpO1xyXG5cclxuXHRcdGxldCBsYXN0UlQgPSByZWFkQnVmZmVyO1xyXG5cdFx0bGV0IGRlc3RSVDtcclxuXHRcdGxldCBpLCBsO1xyXG5cclxuXHRcdC8vIEFwcGx5IHRoZSBtdWx0aS1wYXNzIGJsdXIuXHJcblx0XHRmb3IoaSA9IDAsIGwgPSBrZXJuZWwubGVuZ3RoIC0gMTsgaSA8IGw7ICsraSkge1xyXG5cclxuXHRcdFx0Ly8gQWx0ZXJuYXRlIGJldHdlZW4gdGFyZ2V0cy5cclxuXHRcdFx0ZGVzdFJUID0gKChpICUgMikgPT09IDApID8gcmVuZGVyVGFyZ2V0WCA6IHJlbmRlclRhcmdldFk7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5rZXJuZWwudmFsdWUgPSBrZXJuZWxbaV07XHJcblx0XHRcdHVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gbGFzdFJULnRleHR1cmU7XHJcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCBkZXN0UlQpO1xyXG5cclxuXHRcdFx0bGFzdFJUID0gZGVzdFJUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR1bmlmb3Jtcy5rZXJuZWwudmFsdWUgPSBrZXJuZWxbaV07XHJcblx0XHR1bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IGxhc3RSVC50ZXh0dXJlO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkanVzdHMgdGhlIGZvcm1hdCBvZiB0aGUgcmVuZGVyIHRhcmdldHMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpIHtcclxuXHJcblx0XHRpZighYWxwaGEpIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0WC50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXRZLnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdHdpZHRoID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcih3aWR0aCAqIHRoaXMucmVzb2x1dGlvblNjYWxlKSk7XHJcblx0XHRoZWlnaHQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXMucmVzb2x1dGlvblNjYWxlKSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFkuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0XHR0aGlzLmNvbnZvbHV0aW9uTWF0ZXJpYWwuc2V0VGV4ZWxTaXplKDEuMCAvIHdpZHRoLCAxLjAgLyBoZWlnaHQpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IExpbmVhckZpbHRlciwgUkdCRm9ybWF0LCBXZWJHTFJlbmRlclRhcmdldCB9IGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBDb21iaW5lTWF0ZXJpYWwsIEtlcm5lbFNpemUsIEx1bWlub3NpdHlNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgQmx1clBhc3MgfSBmcm9tIFwiLi9CbHVyUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgYmxvb20gcGFzcy5cclxuICpcclxuICogVGhpcyBwYXNzIHJlbmRlcnMgYSBzY2VuZSB3aXRoIHN1cGVyaW1wb3NlZCBibHVyIGJ5IHV0aWxpc2luZyB0aGUgZmFzdCBLYXdhc2VcclxuICogY29udm9sdXRpb24gYXBwcm9hY2guXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEJsb29tUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGJsb29tIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb25TY2FsZT0wLjVdIC0gVGhlIHJlbmRlciB0ZXh0dXJlIHJlc29sdXRpb24gc2NhbGUsIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4gcmVuZGVyIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmtlcm5lbFNpemU9S2VybmVsU2l6ZS5MQVJHRV0gLSBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaW50ZW5zaXR5PTEuMF0gLSBUaGUgc3RyZW5ndGggb2YgdGhlIGJsb29tIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGluY3Rpb249MS4wXSAtIFRoZSBsdW1pbmFuY2UgZGlzdGluY3Rpb24gZmFjdG9yLiBSYWlzZSB0aGlzIHZhbHVlIHRvIGJyaW5nIG91dCB0aGUgYnJpZ2h0ZXIgZWxlbWVudHMgaW4gdGhlIHNjZW5lLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY3JlZW5Nb2RlPXRydWVdIC0gV2hldGhlciB0aGUgc2NyZWVuIGJsZW5kIG1vZGUgc2hvdWxkIGJlIHVzZWQgZm9yIGNvbWJpbmluZyB0aGUgYmxvb20gdGV4dHVyZSB3aXRoIHRoZSBzY2VuZSBjb2xvcnMuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkJsb29tUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgYmx1ciBwYXNzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCbHVyUGFzc31cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmJsdXJQYXNzID0gbmV3IEJsdXJQYXNzKG9wdGlvbnMpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZW5kZXIgdGFyZ2V0LlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gXCJCbG9vbS5UYXJnZXRcIjtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGNvbWJpbmUgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb21iaW5lTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jb21iaW5lTWF0ZXJpYWwgPSBuZXcgQ29tYmluZU1hdGVyaWFsKChvcHRpb25zLnNjcmVlbk1vZGUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnNjcmVlbk1vZGUgOiB0cnVlKTtcclxuXHJcblx0XHR0aGlzLmludGVuc2l0eSA9IG9wdGlvbnMuaW50ZW5zaXR5O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBsdW1pbm9zaXR5IHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7THVtaW5vc2l0eU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubHVtaW5vc2l0eU1hdGVyaWFsID0gbmV3IEx1bWlub3NpdHlNYXRlcmlhbCh0cnVlKTtcclxuXHJcblx0XHR0aGlzLmRpc3RpbmN0aW9uID0gb3B0aW9ucy5kaXN0aW5jdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMC41XHJcblx0ICovXHJcblxyXG5cdGdldCByZXNvbHV0aW9uU2NhbGUoKSB7IHJldHVybiB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb25TY2FsZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBZb3UgbmVlZCB0byBjYWxsIHtAbGluayBFZmZlY3RDb21wb3NlciNzZXRTaXplfSBhZnRlciBjaGFuZ2luZyB0aGlzIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IHJlc29sdXRpb25TY2FsZSh4ID0gMC41KSB7IHRoaXMuYmx1clBhc3MucmVzb2x1dGlvblNjYWxlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqIEBkZWZhdWx0IEtlcm5lbFNpemUuTEFSR0VcclxuXHQgKi9cclxuXHJcblx0Z2V0IGtlcm5lbFNpemUoKSB7IHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge0tlcm5lbFNpemV9XHJcblx0ICovXHJcblxyXG5cdHNldCBrZXJuZWxTaXplKHggPSBLZXJuZWxTaXplLkxBUkdFKSB7IHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG92ZXJhbGwgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDEuMFxyXG5cdCAqL1xyXG5cclxuXHRnZXQgaW50ZW5zaXR5KCkgeyByZXR1cm4gdGhpcy5jb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMub3BhY2l0eTIudmFsdWU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IGludGVuc2l0eSh4ID0gMS4wKSB7IHRoaXMuY29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLm9wYWNpdHkyLnZhbHVlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbHVtaW5hbmNlIGRpc3RpbmN0aW9uIGZhY3Rvci5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMS4wXHJcblx0ICovXHJcblxyXG5cdGdldCBkaXN0aW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubHVtaW5vc2l0eU1hdGVyaWFsLnVuaWZvcm1zLmRpc3RpbmN0aW9uLnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBkaXN0aW5jdGlvbih4ID0gMS4wKSB7IHRoaXMubHVtaW5vc2l0eU1hdGVyaWFsLnVuaWZvcm1zLmRpc3RpbmN0aW9uLnZhbHVlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBFeHRyYWN0cyBhIGx1bWluYW5jZSBtYXAgZnJvbSB0aGUgcmVhZCBidWZmZXIsIGJsdXJzIGl0IGFuZCBjb21iaW5lcyBpdFxyXG5cdCAqIHdpdGggdGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IHF1YWQgPSB0aGlzLnF1YWQ7XHJcblx0XHRjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XHJcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHRcdGNvbnN0IGJsdXJQYXNzID0gdGhpcy5ibHVyUGFzcztcclxuXHJcblx0XHRjb25zdCBsdW1pbm9zaXR5TWF0ZXJpYWwgPSB0aGlzLmx1bWlub3NpdHlNYXRlcmlhbDtcclxuXHRcdGNvbnN0IGNvbWJpbmVNYXRlcmlhbCA9IHRoaXMuY29tYmluZU1hdGVyaWFsO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XHJcblxyXG5cdFx0Ly8gTHVtaW5hbmNlIGZpbHRlci5cclxuXHRcdHF1YWQubWF0ZXJpYWwgPSBsdW1pbm9zaXR5TWF0ZXJpYWw7XHJcblx0XHRsdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0KTtcclxuXHJcblx0XHQvLyBDb252b2x1dGlvbiBwaGFzZS5cclxuXHRcdGJsdXJQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0LCByZW5kZXJUYXJnZXQpO1xyXG5cclxuXHRcdC8vIFJlbmRlciB0aGUgb3JpZ2luYWwgc2NlbmUgd2l0aCBzdXBlcmltcG9zZWQgYmx1ci5cclxuXHRcdHF1YWQubWF0ZXJpYWwgPSBjb21iaW5lTWF0ZXJpYWw7XHJcblx0XHRjb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMudGV4dHVyZTEudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRjb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMudGV4dHVyZTIudmFsdWUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRqdXN0cyB0aGUgZm9ybWF0IG9mIHRoZSByZW5kZXIgdGFyZ2V0cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXNlKHJlbmRlcmVyLCBhbHBoYSkge1xyXG5cclxuXHRcdHRoaXMuYmx1clBhc3MuaW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpO1xyXG5cclxuXHRcdGlmKCFhbHBoYSkgeyB0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDsgfVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5ibHVyUGFzcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdHdpZHRoID0gdGhpcy5ibHVyUGFzcy53aWR0aDtcclxuXHRcdGhlaWdodCA9IHRoaXMuYmx1clBhc3MuaGVpZ2h0O1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQm9rZWhNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIERlcHRoIG9mIEZpZWxkIChEb0YpIHBhc3MgdXNpbmcgYSBib2tlaCBzaGFkZXIuXHJcbiAqXHJcbiAqIFRoaXMgcGFzcyByZXF1aXJlcyBhIHtAbGluayBFZmZlY3RDb21wb3NlciNkZXB0aFRleHR1cmV9LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBCb2tlaFBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBib2tlaCBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQZXJzcGVjdGl2ZUNhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLiBVc2VkIHRvIG9idGFpbiB0aGUgYXNwZWN0IHJhdGlvIGFuZCB0aGUgbmVhciBhbmQgZmFyIHBsYW5lIHNldHRpbmdzLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZvY3VzPTEuMF0gLSBGb2N1cyBkaXN0YW5jZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXBlcnR1cmU9MC4wMjVdIC0gQ2FtZXJhIGFwZXJ0dXJlIHNjYWxlLiBCaWdnZXIgdmFsdWVzIGZvciBzaGFsbG93ZXIgZGVwdGggb2YgZmllbGQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEJsdXI9MS4wXSAtIE1heGltdW0gYmx1ciBzdHJlbmd0aC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY2FtZXJhLCBvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJCb2tlaFBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGJva2VoIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9rZWhNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmJva2VoTWF0ZXJpYWwgPSBuZXcgQm9rZWhNYXRlcmlhbChjYW1lcmEsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuYm9rZWhNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnVuaWZvcm1zLnREZXB0aC52YWx1ZSA9IHJlYWRCdWZmZXIuZGVwdGhUZXh0dXJlO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLmJva2VoTWF0ZXJpYWwudW5pZm9ybXMuYXNwZWN0LnZhbHVlID0gd2lkdGggLyBoZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQm9rZWgyTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQW4gYWR2YW5jZWQgRGVwdGggb2YgRmllbGQgKERvRikgcGFzcy5cclxuICpcclxuICogWWllbGRzIG1vcmUgcmVhbGlzdGljIHJlc3VsdHMgYnV0IGlzIGFsc28gbW9yZSBkZW1hbmRpbmcuXHJcbiAqXHJcbiAqIFRoaXMgcGFzcyByZXF1aXJlcyBhIHtAbGluayBFZmZlY3RDb21wb3NlciNkZXB0aFRleHR1cmV9LlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBCb2tlaDJQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgYm9rZWgyIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1BlcnNwZWN0aXZlQ2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuIFVzZWQgdG8gb2J0YWluIHRoZSBmb2NhbCBsZW5ndGggYW5kIHRoZSBuZWFyIGFuZCBmYXIgcGxhbmUgc2V0dGluZ3MuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmluZ3M9M10gLSBUaGUgYW1vdW50IG9mIGJsdXIgcmluZ3MuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZXM9NF0gLSBUaGUgYW1vdW50IG9mIHNhbXBsZXMgcGVyIHJpbmcuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaG93Rm9jdXM9ZmFsc2VdIC0gV2hldGhlciB0aGUgZm9jdXMgcG9pbnQgc2hvdWxkIGJlIGhpZ2hsaWdodGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFudWFsRG9GPWZhbHNlXSAtIEVuYWJsZXMgbWFudWFsIGRlcHRoIG9mIGZpZWxkIGJsdXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aWduZXR0ZT1mYWxzZV0gLSBFbmFibGVzIGEgdmlnbmV0dGUgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucGVudGFnb249ZmFsc2VdIC0gRW5hYmxlIHRvIHVzZSBhIHBlbnRhZ29uYWwgc2hhcGUgdG8gc2NhbGUgZ2F0aGVyZWQgdGV4ZWxzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2hhZGVyRm9jdXM9dHJ1ZV0gLSBEaXNhYmxlIGlmIHlvdSBjb21wdXRlIHlvdXIgb3duIGZvY2FsRGVwdGggKGluIG1ldHJlcyEpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9pc2U9dHJ1ZV0gLSBEaXNhYmxlIGlmIHlvdSBkb24ndCB3YW50IG5vaXNlIHBhdHRlcm5zIGZvciBkaXRoZXJpbmcuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGNhbWVyYSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiQm9rZWgyUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgYm9rZWggc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb2tlaE1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYm9rZWhNYXRlcmlhbCA9IG5ldyBCb2tlaDJNYXRlcmlhbChjYW1lcmEsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuYm9rZWhNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0dGhpcy5ib2tlaE1hdGVyaWFsLnVuaWZvcm1zLnREZXB0aC52YWx1ZSA9IHJlYWRCdWZmZXIuZGVwdGhUZXh0dXJlO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLmJva2VoTWF0ZXJpYWwuc2V0VGV4ZWxTaXplKDEuMCAvIHdpZHRoLCAxLjAgLyBoZWlnaHQpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBwYXNzIHRoYXQgZGlzYWJsZXMgdGhlIHN0ZW5jaWwgbWFzay5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQ2xlYXJNYXNrUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGNsZWFyIG1hc2sgcGFzcy5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblxyXG5cdFx0c3VwZXIobnVsbCwgbnVsbCwgbnVsbCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkNsZWFyTWFza1Bhc3NcIjtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNhYmxlcyB0aGUgc3RlbmNpbCB0ZXN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyKSB7XHJcblxyXG5cdFx0cmVuZGVyZXIuc3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldFRlc3QoZmFsc2UpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogVXNlZCBmb3Igc2F2aW5nIHRoZSBvcmlnaW5hbCBjbGVhciBjb2xvciBvZiB0aGUgcmVuZGVyZXIuXHJcbiAqXHJcbiAqIEB0eXBlIENvbG9yXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICovXHJcblxyXG5jb25zdCBjb2xvciA9IG5ldyBDb2xvcigpO1xyXG5cclxuLyoqXHJcbiAqIEEgY2xlYXIgcGFzcy5cclxuICpcclxuICogWW91IGNhbiBwcmV2ZW50IHNwZWNpZmljIGJ1ZmZlcnMgZnJvbSBiZWluZyBjbGVhcmVkIGJ5IHNldHRpbmcgZWl0aGVyIHRoZVxyXG4gKiBhdXRvQ2xlYXJDb2xvciwgYXV0b0NsZWFyU3RlbmNpbCBvciBhdXRvQ2xlYXJEZXB0aCBwcm9wZXJ0aWVzIG9mIHRoZSByZW5kZXJlclxyXG4gKiB0byBmYWxzZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgQ2xlYXJQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgY2xlYXIgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtDb2xvcn0gW29wdGlvbnMuY2xlYXJDb2xvcj1udWxsXSAtIEFuIG92ZXJyaWRlIGNsZWFyIGNvbG9yLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGVhckFscGhhPTAuMF0gLSBBbiBvdmVycmlkZSBjbGVhciBhbHBoYS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIobnVsbCwgbnVsbCwgbnVsbCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIkNsZWFyUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ2xlYXIgY29sb3IuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NvbG9yfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jbGVhckNvbG9yID0gKG9wdGlvbnMuY2xlYXJDb2xvciAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY2xlYXJDb2xvciA6IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDbGVhciBhbHBoYS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMC4wXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNsZWFyQWxwaGEgPSAob3B0aW9ucy5jbGVhckFscGhhICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5jbGVhckFscGhhIDogMC4wO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyB0aGUgcmVhZCBidWZmZXIgb3IgdGhlIHNjcmVlbi5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyKSB7XHJcblxyXG5cdFx0Y29uc3QgY2xlYXJDb2xvciA9IHRoaXMuY2xlYXJDb2xvcjtcclxuXHJcblx0XHRsZXQgY2xlYXJBbHBoYTtcclxuXHJcblx0XHRpZihjbGVhckNvbG9yICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHRjb2xvci5jb3B5KHJlbmRlcmVyLmdldENsZWFyQ29sb3IoKSk7XHJcblx0XHRcdGNsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcblx0XHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoY2xlYXJDb2xvciwgdGhpcy5jbGVhckFscGhhKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogcmVhZEJ1ZmZlcik7XHJcblx0XHRyZW5kZXJlci5jbGVhcigpO1xyXG5cclxuXHRcdGlmKGNsZWFyQ29sb3IgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnNldENsZWFyQ29sb3IoY29sb3IsIGNsZWFyQWxwaGEpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBEb3RTY3JlZW5NYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGRvdCBzY3JlZW4gcGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRG90U2NyZWVuUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGRvdCBzY3JlZW4gcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYW5nbGU9MS41N10gLSBUaGUgYW5nbGUgb2YgdGhlIHBhdHRlcm4uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlPTEuMF0gLSBUaGUgc2NhbGUgb2YgdGhlIG92ZXJhbGwgZWZmZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5pbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF2ZXJhZ2U9ZmFsc2VdIC0gV2hldGhlciB0aGUgc2hhZGVyIHNob3VsZCBvdXRwdXQgYSBjb2xvdXIgYXZlcmFnZSAoYmxhY2sgYW5kIHdoaXRlKS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiRG90U2NyZWVuUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgZG90IHNjcmVlbiBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0RvdFNjcmVlbk1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgRG90U2NyZWVuTWF0ZXJpYWwob3B0aW9ucy5hdmVyYWdlKTtcclxuXHJcblx0XHRpZihvcHRpb25zLmFuZ2xlICE9PSB1bmRlZmluZWQpIHsgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IG9wdGlvbnMuYW5nbGU7IH1cclxuXHRcdGlmKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCkgeyB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnNjYWxlLnZhbHVlID0gb3B0aW9ucy5zY2FsZTsgfVxyXG5cdFx0aWYob3B0aW9ucy5pbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgeyB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmludGVuc2l0eS52YWx1ZSA9IG9wdGlvbnMuaW50ZW5zaXR5OyB9XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR3aWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoKTtcclxuXHRcdGhlaWdodCA9IE1hdGgubWF4KDEsIGhlaWdodCk7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUueiA9IHdpZHRoO1xyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUudyA9IGhlaWdodDtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBEZXB0aE1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgZGVwdGggcGFzcy5cclxuICpcclxuICogUmVhZHMgdGhlIGRlcHRoIGZyb20gYSBkZXB0aCB0ZXh0dXJlIGFuZCByZW5kZXJzIGl0LlxyXG4gKlxyXG4gKiBUaGlzIHBhc3MgcmVxdWlyZXMgYSB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjZGVwdGhUZXh0dXJlfS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRGVwdGhQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgZGVwdGggcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7UGVyc3BlY3RpdmVDYW1lcmF9IGNhbWVyYSAtIFRoZSBtYWluIGNhbWVyYS4gVXNlZCB0byBvYnRhaW4gdGhlIG5lYXIgYW5kIGZhciBwbGFuZSBzZXR0aW5ncy5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY2FtZXJhKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiRGVwdGhQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBkZXB0aCBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0RlcHRoTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5kZXB0aE1hdGVyaWFsID0gbmV3IERlcHRoTWF0ZXJpYWwoY2FtZXJhKTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLmRlcHRoTWF0ZXJpYWw7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdHRoaXMuZGVwdGhNYXRlcmlhbC51bmlmb3Jtcy50RGVwdGgudmFsdWUgPSByZWFkQnVmZmVyLmRlcHRoVGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEZpbG1NYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIGZpbG0gcGFzcy5cclxuICpcclxuICogUHJvdmlkZXMgdmFyaW91cyBjaW5lbWF0aWMgZWZmZWN0cy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRmlsbVBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBmaWxtIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuIERpc2FibGVkIGVmZmVjdHMgaGF2ZSBubyBuZWdhdGl2ZSBpbXBhY3Qgb24gcGVyZm9ybWFuY2UuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ncmV5c2NhbGU9ZmFsc2VdIC0gRW5hYmxlIGdyZXlzY2FsZSBlZmZlY3QuIEdyZXlzY2FsZSBhbmQgc2VwaWEgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcGlhPWZhbHNlXSAtIEVuYWJsZSBzZXBpYSBlZmZlY3QuIEdyZXlzY2FsZSBhbmQgc2VwaWEgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZpZ25ldHRlPWZhbHNlXSAtIEFwcGx5IHZpZ25ldHRlIGVmZmVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVza2lsPWZhbHNlXSAtIFVzZSBFc2tpbCdzIHZpZ25ldHRlIGFwcHJvYWNoLiBUaGUgZGVmYXVsdCBsb29rcyBkdXN0eSB3aGlsZSBFc2tpbCBsb29rcyBtb3JlIGJ1cm5lZCBvdXQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY3JlZW5Nb2RlPXRydWVdIC0gV2hldGhlciB0aGUgc2NyZWVuIGJsZW5kIG1vZGUgc2hvdWxkIGJlIHVzZWQgZm9yIG5vaXNlIGFuZCBzY2FubGluZXMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zY2FubGluZXM9dHJ1ZV0gLSBTaG93IHNjYW5saW5lcy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vaXNlPXRydWVdIC0gU2hvdyBub2lzZS1iYXNlZCBmaWxtIGdyYWluLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ub2lzZUludGVuc2l0eT0wLjVdIC0gVGhlIG5vaXNlIGludGVuc2l0eS4gMC4wIHRvIDEuMC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NhbmxpbmVJbnRlbnNpdHk9MC4wNV0gLSBUaGUgc2NhbmxpbmUgaW50ZW5zaXR5LiAwLjAgdG8gMS4wLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2FubGluZURlbnNpdHk9MS4wXSAtIFRoZSBudW1iZXIgb2Ygc2NhbmxpbmVzIGluIHBlcmNlbnQsIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4gaGVpZ2h0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5ncmV5c2NhbGVJbnRlbnNpdHk9MS4wXSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIGdyZXlzY2FsZSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNlcGlhSW50ZW5zaXR5PTEuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBzZXBpYSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZ25ldHRlT2Zmc2V0PTEuMF0gLSBUaGUgb2Zmc2V0IG9mIHRoZSB2aWduZXR0ZSBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZ25ldHRlRGFya25lc3M9MS4wXSAtIFRoZSBkYXJrbmVzcyBvZiB0aGUgdmlnbmV0dGUgZWZmZWN0LlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJGaWxtUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEZpbG0gc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtGaWxtTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBGaWxtTWF0ZXJpYWwob3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBhbW91bnQgb2Ygc2NhbmxpbmVzIGluIHBlcmNlbnQsIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW4gaGVpZ2h0LlxyXG5cdFx0ICpcclxuXHRcdCAqIFlvdSBuZWVkIHRvIGNhbGwge0BsaW5rIEVmZmVjdENvbXBvc2VyI3NldFNpemV9IGFmdGVyIGNoYW5naW5nIHRoaXNcclxuXHRcdCAqIHZhbHVlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAxLjI1XHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnNjYW5saW5lRGVuc2l0eSA9IChvcHRpb25zLnNjYW5saW5lRGVuc2l0eSA9PT0gdW5kZWZpbmVkKSA/IDEuMjUgOiBvcHRpb25zLnNjYW5saW5lRGVuc2l0eTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSAtIFRoZSByZW5kZXIgZGVsdGEgdGltZS5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlciwgZGVsdGEpIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy50aW1lLnZhbHVlICs9IGRlbHRhO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRqdXN0cyB0aGUgc2NhbmxpbmUgY291bnQgdXNpbmcgdGhlIHJlbmRlcmVyJ3MgaGVpZ2h0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLnNjYW5saW5lQ291bnQudmFsdWUgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHRoaXMuc2NhbmxpbmVEZW5zaXR5KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBEYXRhVGV4dHVyZSwgUkdCRm9ybWF0LCBGbG9hdFR5cGUgfSBmcm9tIFwidGhyZWVcIjtcclxuaW1wb3J0IHsgR2xpdGNoTWF0ZXJpYWwgfSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcbmltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvdyAtIFRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIC0gVGhlIGhpZ2hlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJhbmRvbSB2YWx1ZS5cclxuICovXHJcblxyXG5mdW5jdGlvbiByYW5kb21JbnQobG93LCBoaWdoKSB7XHJcblxyXG5cdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdyArIDEpKTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGZsb2F0IGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxvdyAtIFRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoIC0gVGhlIGhpZ2hlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJhbmRvbSB2YWx1ZS5cclxuICovXHJcblxyXG5mdW5jdGlvbiByYW5kb21GbG9hdChsb3csIGhpZ2gpIHtcclxuXHJcblx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdyk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQSBnbGl0Y2ggcGFzcy5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgR2xpdGNoUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGdsaXRjaCBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7VGV4dHVyZX0gW29wdGlvbnMucGVydHVyYk1hcF0gLSBBIHBlcnR1cmJhdGlvbiBtYXAuIElmIG5vbmUgaXMgcHJvdmlkZWQsIGEgbm9pc2UgdGV4dHVyZSB3aWxsIGJlIGNyZWF0ZWQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR0U2l6ZT02NF0gLSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIG5vaXNlIG1hcC4gV2lsbCBiZSBpZ25vcmVkIGlmIGEgcGVydHVyYmF0aW9uIG1hcCBpcyBwcm92aWRlZC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiR2xpdGNoUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEdsaXRjaCBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0dsaXRjaE1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgR2xpdGNoTWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBwZXJ0dXJiYXRpb24gbWFwLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtUZXh0dXJlfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5wZXJ0dXJiTWFwID0gKG9wdGlvbnMucGVydHVyYk1hcCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMucGVydHVyYk1hcCA6IHRoaXMuZ2VuZXJhdGVQZXJ0dXJiTWFwKG9wdGlvbnMuZHRTaXplKTtcclxuXHRcdHRoaXMucGVydHVyYk1hcC5uYW1lID0gXCJHbGl0Y2guUGVydHVyYmF0aW9uXCI7XHJcblx0XHR0aGlzLnBlcnR1cmJNYXAuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZWZmZWN0IG1vZGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0dsaXRjaE1vZGV9XHJcblx0XHQgKiBAZGVmYXVsdCBHbGl0Y2hNb2RlLlNQT1JBRElDXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm1vZGUgPSBHbGl0Y2hNb2RlLlNQT1JBRElDO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ291bnRlciBmb3IgZ2xpdGNoIGFjdGl2YXRpb24gYW5kIGRlYWN0aXZhdGlvbi5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY291bnRlciA9IDA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJhbmRvbSBicmVhayBwb2ludCBmb3IgdGhlIHNwb3JhZGljIGdsaXRjaCBhY3RpdmF0aW9uLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5icmVha1BvaW50ID0gcmFuZG9tSW50KDEyMCwgMjQwKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgY3VycmVudCBwZXJ0dXJiYXRpb24gbWFwLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblxyXG5cdGdldCBwZXJ0dXJiTWFwKCkgeyByZXR1cm4gdGhpcy50ZXh0dXJlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFzc2lnbmluZyBhIG5ldyBwZXJ0dXJiYXRpb24gbWFwIGRvZXMgbm90IGRlc3Ryb3kgdGhlIGN1cnJlbnQgb25lIVxyXG5cdCAqXHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblxyXG5cdHNldCBwZXJ0dXJiTWFwKHgpIHtcclxuXHJcblx0XHR0aGlzLnRleHR1cmUgPSB4O1xyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy50UGVydHVyYi52YWx1ZSA9IHg7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGVzdHJveXMgdGhlIGN1cnJlbnQgcGVydHVyYmF0aW9uIG1hcCBhbmQgcmVwbGFjZXMgaXQgd2l0aCBhIG5ldyBvbmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NpemU9NjRdIC0gVGhlIHRleHR1cmUgc2l6ZS5cclxuXHQgKiBAcmV0dXJuIHtEYXRhVGV4dHVyZX0gVGhlIHBlcnR1cmJhdGlvbiB0ZXh0dXJlLlxyXG5cdCAqL1xyXG5cclxuXHRnZW5lcmF0ZVBlcnR1cmJNYXAoc2l6ZSA9IDY0KSB7XHJcblxyXG5cdFx0Y29uc3QgcGl4ZWxzID0gc2l6ZSAqIHNpemU7XHJcblx0XHRjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShwaXhlbHMgKiAzKTtcclxuXHJcblx0XHRsZXQgZHQgPSB0aGlzLnBlcnR1cmJNYXA7XHJcblx0XHRsZXQgaSwgeDtcclxuXHJcblx0XHRmb3IoaSA9IDA7IGkgPCBwaXhlbHM7ICsraSkge1xyXG5cclxuXHRcdFx0eCA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdFx0XHRkYXRhW2kgKiAzXSA9IHg7XHJcblx0XHRcdGRhdGFbaSAqIDMgKyAxXSA9IHg7XHJcblx0XHRcdGRhdGFbaSAqIDMgKyAyXSA9IHg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKGR0ICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHRkdC5kaXNwb3NlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGR0ID0gbmV3IERhdGFUZXh0dXJlKGRhdGEsIHNpemUsIHNpemUsIFJHQkZvcm1hdCwgRmxvYXRUeXBlKTtcclxuXHRcdGR0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLnBlcnR1cmJNYXAgPSBkdDtcclxuXHJcblx0XHRyZXR1cm4gZHQ7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XHJcblx0XHRjb25zdCBjb3VudGVyID0gdGhpcy5jb3VudGVyO1xyXG5cdFx0Y29uc3QgYnJlYWtQb2ludCA9IHRoaXMuYnJlYWtQb2ludDtcclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gdGhpcy5tYXRlcmlhbC51bmlmb3JtcztcclxuXHJcblx0XHR1bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHVuaWZvcm1zLnNlZWQudmFsdWUgPSBNYXRoLnJhbmRvbSgpO1xyXG5cdFx0dW5pZm9ybXMuYWN0aXZlLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRpZihjb3VudGVyICUgYnJlYWtQb2ludCA9PT0gMCB8fCBtb2RlID09PSBHbGl0Y2hNb2RlLkNPTlNUQU5UX1dJTEQpIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmFtb3VudC52YWx1ZSA9IE1hdGgucmFuZG9tKCkgLyAzMC4wO1xyXG5cdFx0XHR1bmlmb3Jtcy5hbmdsZS52YWx1ZSA9IHJhbmRvbUZsb2F0KC1NYXRoLlBJLCBNYXRoLlBJKTtcclxuXHRcdFx0dW5pZm9ybXMuc2VlZFgudmFsdWUgPSByYW5kb21GbG9hdCgtMS4wLCAxLjApO1xyXG5cdFx0XHR1bmlmb3Jtcy5zZWVkWS52YWx1ZSA9IHJhbmRvbUZsb2F0KC0xLjAsIDEuMCk7XHJcblx0XHRcdHVuaWZvcm1zLmRpc3RvcnRpb25YLnZhbHVlID0gcmFuZG9tRmxvYXQoMC4wLCAxLjApO1xyXG5cdFx0XHR1bmlmb3Jtcy5kaXN0b3J0aW9uWS52YWx1ZSA9IHJhbmRvbUZsb2F0KDAuMCwgMS4wKTtcclxuXHJcblx0XHRcdHRoaXMuYnJlYWtQb2ludCA9IHJhbmRvbUludCgxMjAsIDI0MCk7XHJcblx0XHRcdHRoaXMuY291bnRlciA9IDA7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmKGNvdW50ZXIgJSBicmVha1BvaW50IDwgYnJlYWtQb2ludCAvIDUgfHwgbW9kZSA9PT0gR2xpdGNoTW9kZS5DT05TVEFOVF9NSUxEKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zLmFtb3VudC52YWx1ZSA9IE1hdGgucmFuZG9tKCkgLyA5MC4wO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmFuZ2xlLnZhbHVlID0gcmFuZG9tRmxvYXQoLU1hdGguUEksIE1hdGguUEkpO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RvcnRpb25YLnZhbHVlID0gcmFuZG9tRmxvYXQoMC4wLCAxLjApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLmRpc3RvcnRpb25ZLnZhbHVlID0gcmFuZG9tRmxvYXQoMC4wLCAxLjApO1xyXG5cdFx0XHRcdHVuaWZvcm1zLnNlZWRYLnZhbHVlID0gcmFuZG9tRmxvYXQoLTAuMywgMC4zKTtcclxuXHRcdFx0XHR1bmlmb3Jtcy5zZWVkWS52YWx1ZSA9IHJhbmRvbUZsb2F0KC0wLjMsIDAuMyk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBTcG9yYWRpYy5cclxuXHRcdFx0XHR1bmlmb3Jtcy5hY3RpdmUudmFsdWUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Kyt0aGlzLmNvdW50ZXI7XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZ2xpdGNoIG1vZGUgZW51bWVyYXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBTUE9SQURJQyAtIFNwb3JhZGljIGdsaXRjaGVzLlxyXG4gKiBAcHJvcGVydHkge051bWJlcn0gQ09OU1RBTlRfTUlMRCAtIENvbnN0YW50IG1pbGQgZ2xpdGNoZXMuXHJcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBDT05TVEFOVF9XSUxEIC0gQ29uc3RhbnQgd2lsZCBnbGl0Y2hlcy5cclxuICovXHJcblxyXG5leHBvcnQgY29uc3QgR2xpdGNoTW9kZSA9IHtcclxuXHJcblx0U1BPUkFESUM6IDAsXHJcblx0Q09OU1RBTlRfTUlMRDogMSxcclxuXHRDT05TVEFOVF9XSUxEOiAyXHJcblxyXG59O1xyXG4iLCJpbXBvcnQgeyBDbGVhclBhc3MgfSBmcm9tIFwiLi9DbGVhclBhc3MuanNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhc3MgdGhhdCByZW5kZXJzIGEgZ2l2ZW4gc2NlbmUgZGlyZWN0bHkgb24gc2NyZWVuIG9yIGludG8gdGhlIHJlYWQgYnVmZmVyXHJcbiAqIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlbmRlclBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyByZW5kZXIgcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIC0gVGhlIHNjZW5lIHRvIHJlbmRlci5cclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIGNhbWVyYSB0byB1c2UgdG8gcmVuZGVyIHRoZSBzY2VuZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7TWF0ZXJpYWx9IFtvcHRpb25zLm92ZXJyaWRlTWF0ZXJpYWw9bnVsbF0gLSBBbiBvdmVycmlkZSBtYXRlcmlhbCBmb3IgdGhlIHNjZW5lLlxyXG5cdCAqIEBwYXJhbSB7Q29sb3J9IFtvcHRpb25zLmNsZWFyQ29sb3I9bnVsbF0gLSBBbiBvdmVycmlkZSBjbGVhciBjb2xvci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xlYXJBbHBoYT0xLjBdIC0gQW4gb3ZlcnJpZGUgY2xlYXIgYWxwaGEuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGVhckRlcHRoPWZhbHNlXSAtIFdoZXRoZXIgZGVwdGggc2hvdWxkIGJlIGNsZWFyZWQgZXhwbGljaXRseS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsZWFyPXRydWVdIC0gV2hldGhlciBhbGwgYnVmZmVycyBzaG91bGQgYmUgY2xlYXJlZC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoc2NlbmUsIGNhbWVyYSwgbnVsbCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIlJlbmRlclBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY2xlYXIgcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q2xlYXJQYXNzfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jbGVhclBhc3MgPSBuZXcgQ2xlYXJQYXNzKG9wdGlvbnMpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gb3ZlcnJpZGUgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge01hdGVyaWFsfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gKG9wdGlvbnMub3ZlcnJpZGVNYXRlcmlhbCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMub3ZlcnJpZGVNYXRlcmlhbCA6IG51bGw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVwdGggYnVmZmVyIHNob3VsZCBiZSBjbGVhcmVkIGV4cGxpY2l0bHkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5jbGVhckRlcHRoID0gKG9wdGlvbnMuY2xlYXJEZXB0aCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuY2xlYXJEZXB0aCA6IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNvbG9yLCBkZXB0aCBhbmQgc3RlbmNpbCBidWZmZXJzIHNob3VsZCBiZSBjbGVhcmVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEV2ZW4gd2l0aCBjbGVhciBzZXQgdG8gdHJ1ZSB5b3UgY2FuIHByZXZlbnQgc3BlY2lmaWMgYnVmZmVycyBmcm9tIGJlaW5nXHJcblx0XHQgKiBjbGVhcmVkIGJ5IHNldHRpbmcgZWl0aGVyIHRoZSBhdXRvQ2xlYXJDb2xvciwgYXV0b0NsZWFyU3RlbmNpbCBvclxyXG5cdFx0ICogYXV0b0NsZWFyRGVwdGggcHJvcGVydGllcyBvZiB0aGUgcmVuZGVyZXIgdG8gZmFsc2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNsZWFyID0gKG9wdGlvbnMuY2xlYXIgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmNsZWFyIDogdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBzY2VuZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyKSB7XHJcblxyXG5cdFx0Y29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiByZWFkQnVmZmVyO1xyXG5cclxuXHRcdGlmKHRoaXMuY2xlYXIpIHtcclxuXHJcblx0XHRcdHRoaXMuY2xlYXJQYXNzLnJlbmRlcihyZW5kZXJlciwgdGFyZ2V0KTtcclxuXHJcblx0XHR9IGVsc2UgaWYodGhpcy5jbGVhckRlcHRoKSB7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuXHRcdFx0cmVuZGVyZXIuY2xlYXJEZXB0aCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRzY2VuZS5vdmVycmlkZU1hdGVyaWFsID0gdGhpcy5vdmVycmlkZU1hdGVyaWFsO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCB0aGlzLmNhbWVyYSwgdGFyZ2V0KTtcclxuXHRcdHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7XHJcblx0Q29sb3IsXHJcblx0TGluZWFyRmlsdGVyLFxyXG5cdE1lc2hCYXNpY01hdGVyaWFsLFxyXG5cdFJHQkZvcm1hdCxcclxuXHRTY2VuZSxcclxuXHRWZWN0b3IzLFxyXG5cdFdlYkdMUmVuZGVyVGFyZ2V0XHJcbn0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5pbXBvcnQgeyBDb21iaW5lTWF0ZXJpYWwsIEdvZFJheXNNYXRlcmlhbCwgS2VybmVsU2l6ZSB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gXCIuL1JlbmRlclBhc3MuanNcIjtcclxuaW1wb3J0IHsgQmx1clBhc3MgfSBmcm9tIFwiLi9CbHVyUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIENsYW1wcyBhIGdpdmVuIHZhbHVlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjbGFtcC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiAtIFRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggLSBUaGUgaGlnaGVzdCBwb3NzaWJsZSB2YWx1ZS5cclxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2xhbXBlZCB2YWx1ZS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcclxuXHJcblx0cmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgY3JlcHVzY3VsYXIgcmF5cyBwYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBHb2RSYXlzUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IGdvZCByYXlzIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSAtIFRoZSBtYWluIHNjZW5lLlxyXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgbWFpbiBjYW1lcmEuXHJcblx0ICogQHBhcmFtIHtPYmplY3QzRH0gbGlnaHRTb3VyY2UgLSBUaGUgbWFpbiBsaWdodCBzb3VyY2UuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFRoZSBvcHRpb25zLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZW5zaXR5PTAuOTZdIC0gVGhlIGRlbnNpdHkgb2YgdGhlIGxpZ2h0IHJheXMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlY2F5PTAuOTNdIC0gQW4gaWxsdW1pbmF0aW9uIGRlY2F5IGZhY3Rvci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2VpZ2h0PTAuNF0gLSBBIGxpZ2h0IHJheSB3ZWlnaHQgZmFjdG9yLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5leHBvc3VyZT0wLjZdIC0gQSBjb25zdGFudCBhdHRlbnVhdGlvbiBjb2VmZmljaWVudC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xhbXBNYXg9MS4wXSAtIEFuIHVwcGVyIGJvdW5kIGZvciB0aGUgc2F0dXJhdGlvbiBvZiB0aGUgb3ZlcmFsbCBlZmZlY3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmludGVuc2l0eT0xLjBdIC0gQSBjb25zdGFudCBmYWN0b3IgZm9yIGFkZGl0aXZlIGJsZW5kaW5nLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uU2NhbGU9MC41XSAtIFRoZSByZW5kZXIgdGV4dHVyZSByZXNvbHV0aW9uIHNjYWxlLCByZWxhdGl2ZSB0byB0aGUgc2NyZWVuIHJlbmRlciBzaXplLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5rZXJuZWxTaXplPUtlcm5lbFNpemUuTEFSR0VdIC0gVGhlIGJsdXIga2VybmVsIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhbXBsZXM9NjBdIC0gVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2NyZWVuTW9kZT10cnVlXSAtIFdoZXRoZXIgdGhlIHNjcmVlbiBibGVuZCBtb2RlIHNob3VsZCBiZSB1c2VkIGZvciBjb21iaW5pbmcgdGhlIGdvZCByYXlzIHRleHR1cmUgd2l0aCB0aGUgc2NlbmUgY29sb3JzLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihzY2VuZSwgY2FtZXJhLCBsaWdodFNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiR29kUmF5c1Bhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHNjZW5lIHRoYXQgb25seSBjb250YWlucyB0aGUgbGlnaHQgc291cmNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTY2VuZX1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmxpZ2h0U2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBtYWluIHNjZW5lLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTY2VuZX1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm1haW5TY2VuZSA9IHNjZW5lO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG1haW4gY2FtZXJhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDYW1lcmF9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tYWluQ2FtZXJhID0gY2FtZXJhO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBwYXNzIHRoYXQgb25seSByZW5kZXJzIHRoZSBsaWdodCBzb3VyY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1JlbmRlclBhc3N9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJQYXNzTGlnaHQgPSBuZXcgUmVuZGVyUGFzcyh0aGlzLmxpZ2h0U2NlbmUsIHRoaXMubWFpbkNhbWVyYSk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHBhc3MgdGhhdCByZW5kZXJzIHRoZSBtYXNrZWQgc2NlbmUgb3ZlciB0aGUgbGlnaHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1JlbmRlclBhc3N9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJQYXNzTWFzayA9IG5ldyBSZW5kZXJQYXNzKHRoaXMubWFpblNjZW5lLCB0aGlzLm1haW5DYW1lcmEsIHtcclxuXHRcdFx0b3ZlcnJpZGVNYXRlcmlhbDogbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4MDAwMDAwIH0pLFxyXG5cdFx0XHRjbGVhckNvbG9yOiBuZXcgQ29sb3IoMHgwMDAwMDApXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclBhc3NNYXNrLmNsZWFyID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGJsdXIgcGFzcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qmx1clBhc3N9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5ibHVyUGFzcyA9IG5ldyBCbHVyUGFzcyhvcHRpb25zKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVuZGVyIHRhcmdldC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRYID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcclxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRzdGVuY2lsQnVmZmVyOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhCdWZmZXI6IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFgudGV4dHVyZS5uYW1lID0gXCJHb2RSYXlzLlRhcmdldFhcIjtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzZWNvbmQgcmVuZGVyIHRhcmdldC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRZID0gdGhpcy5yZW5kZXJUYXJnZXRYLmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRZLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5UYXJnZXRZXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBtYXNrZWQgbGlnaHQgc2NlbmUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0TWFzayA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlclxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRNYXNrLnRleHR1cmUubmFtZSA9IFwiR29kUmF5cy5NYXNrXCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBsaWdodCBzb3VyY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge09iamVjdDNEfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5saWdodFNvdXJjZSA9IGxpZ2h0U291cmNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGxpZ2h0IHBvc2l0aW9uIGluIHNjcmVlbiBzcGFjZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7VmVjdG9yM31cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnNjcmVlblBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgZ29kIHJheXMgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtHb2RSYXlzTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5nb2RSYXlzTWF0ZXJpYWwgPSBuZXcgR29kUmF5c01hdGVyaWFsKCk7XHJcblx0XHR0aGlzLmdvZFJheXNNYXRlcmlhbC51bmlmb3Jtcy5saWdodFBvc2l0aW9uLnZhbHVlID0gdGhpcy5zY3JlZW5Qb3NpdGlvbjtcclxuXHJcblx0XHRpZihvcHRpb25zLmV4cG9zdXJlICE9PSB1bmRlZmluZWQpIHsgdGhpcy5nb2RSYXlzTWF0ZXJpYWwudW5pZm9ybXMuZXhwb3N1cmUudmFsdWUgPSBvcHRpb25zLmV4cG9zdXJlOyB9XHJcblx0XHRpZihvcHRpb25zLmRlbnNpdHkgIT09IHVuZGVmaW5lZCkgeyB0aGlzLmdvZFJheXNNYXRlcmlhbC51bmlmb3Jtcy5kZW5zaXR5LnZhbHVlID0gb3B0aW9ucy5kZW5zaXR5OyB9XHJcblx0XHRpZihvcHRpb25zLmRlY2F5ICE9PSB1bmRlZmluZWQpIHsgdGhpcy5nb2RSYXlzTWF0ZXJpYWwudW5pZm9ybXMuZGVjYXkudmFsdWUgPSBvcHRpb25zLmRlY2F5OyB9XHJcblx0XHRpZihvcHRpb25zLndlaWdodCAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuZ29kUmF5c01hdGVyaWFsLnVuaWZvcm1zLndlaWdodC52YWx1ZSA9IG9wdGlvbnMud2VpZ2h0OyB9XHJcblx0XHRpZihvcHRpb25zLmNsYW1wTWF4ICE9PSB1bmRlZmluZWQpIHsgdGhpcy5nb2RSYXlzTWF0ZXJpYWwudW5pZm9ybXMuY2xhbXBNYXgudmFsdWUgPSBvcHRpb25zLmNsYW1wTWF4OyB9XHJcblxyXG5cdFx0dGhpcy5zYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBjb21iaW5lIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29tYmluZU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29tYmluZU1hdGVyaWFsID0gbmV3IENvbWJpbmVNYXRlcmlhbCgob3B0aW9ucy5zY3JlZW5Nb2RlICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5zY3JlZW5Nb2RlIDogdHJ1ZSk7XHJcblxyXG5cdFx0dGhpcy5pbnRlbnNpdHkgPSBvcHRpb25zLmludGVuc2l0eTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVzb2x1dGlvbiBzY2FsZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMC41XHJcblx0ICovXHJcblxyXG5cdGdldCByZXNvbHV0aW9uU2NhbGUoKSB7IHJldHVybiB0aGlzLmJsdXJQYXNzLnJlc29sdXRpb25TY2FsZTsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBZb3UgbmVlZCB0byBjYWxsIHtAbGluayBFZmZlY3RDb21wb3NlciNzZXRTaXplfSBhZnRlciBjaGFuZ2luZyB0aGlzIHZhbHVlLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IHJlc29sdXRpb25TY2FsZSh4ID0gMC41KSB7IHRoaXMuYmx1clBhc3MucmVzb2x1dGlvblNjYWxlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgYmx1ciBrZXJuZWwgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtLZXJuZWxTaXplfVxyXG5cdCAqIEBkZWZhdWx0IEtlcm5lbFNpemUuTEFSR0VcclxuXHQgKi9cclxuXHJcblx0Z2V0IGtlcm5lbFNpemUoKSB7IHJldHVybiB0aGlzLmJsdXJQYXNzLmtlcm5lbFNpemU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge0tlcm5lbFNpemV9XHJcblx0ICovXHJcblxyXG5cdHNldCBrZXJuZWxTaXplKHggPSBLZXJuZWxTaXplLkxBUkdFKSB7IHRoaXMuYmx1clBhc3Mua2VybmVsU2l6ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG92ZXJhbGwgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDEuMFxyXG5cdCAqL1xyXG5cclxuXHRnZXQgaW50ZW5zaXR5KCkgeyByZXR1cm4gdGhpcy5jb21iaW5lTWF0ZXJpYWwudW5pZm9ybXMub3BhY2l0eTIudmFsdWU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKi9cclxuXHJcblx0c2V0IGludGVuc2l0eSh4ID0gMS4wKSB7IHRoaXMuY29tYmluZU1hdGVyaWFsLnVuaWZvcm1zLm9wYWNpdHkyLnZhbHVlID0geDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCA2MFxyXG5cdCAqL1xyXG5cclxuXHRnZXQgc2FtcGxlcygpIHsgcmV0dXJuIE51bWJlci5wYXJzZUludCh0aGlzLmdvZFJheXNNYXRlcmlhbC5kZWZpbmVzLk5VTV9TQU1QTEVTX0lOVCk7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyB2YWx1ZSBtdXN0IGJlIGNhcmVmdWxseSBjaG9zZW4uIEEgaGlnaGVyIHZhbHVlIGRpcmVjdGx5IGluY3JlYXNlcyB0aGVcclxuXHQgKiBHUFUgbG9hZC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBzYW1wbGVzKHggPSA2MCkge1xyXG5cclxuXHRcdHggPSBNYXRoLmZsb29yKHgpO1xyXG5cclxuXHRcdHRoaXMuZ29kUmF5c01hdGVyaWFsLmRlZmluZXMuTlVNX1NBTVBMRVNfRkxPQVQgPSB4LnRvRml4ZWQoMSk7XHJcblx0XHR0aGlzLmdvZFJheXNNYXRlcmlhbC5kZWZpbmVzLk5VTV9TQU1QTEVTX0lOVCA9IHgudG9GaXhlZCgwKTtcclxuXHRcdHRoaXMuZ29kUmF5c01hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBzY2VuZS5cclxuXHQgKlxyXG5cdCAqIFRoZSBnb2QgcmF5cyBwYXNzIGhhcyBmb3VyIHBoYXNlczpcclxuXHQgKlxyXG5cdCAqIE1hc2sgUGhhc2U6XHJcblx0ICogIEZpcnN0LCB0aGUgbGlnaHQgc291cmNlIGlzIHJlbmRlcmVkLiBUaGVuIHRoZSBzY2VuZSBpcyByZW5kZXJlZCBpbnRvIHRoZVxyXG5cdCAqICBzYW1lIGJ1ZmZlciB1c2luZyBhIG1hc2sgb3ZlcnJpZGUgbWF0ZXJpYWwgd2l0aCBkZXB0aCB0ZXN0IGVuYWJsZWQuXHJcblx0ICpcclxuXHQgKiBQcmVsaW1pbmFyeSBCbHVyIFBoYXNlOlxyXG5cdCAqICBUaGUgbWFza2VkIHNjZW5lIGlzIGJsdXJyZWQuXHJcblx0ICpcclxuXHQgKiBHb2QgUmF5cyBQaGFzZTpcclxuXHQgKiAgVGhlIGJsdXJyZWQgc2NlbmUgaXMgYmx1cnJlZCBhZ2FpbiwgYnV0IHRoaXMgdGltZSBhbG9uZyByYWRpYWwgbGluZXNcclxuXHQgKiAgdG93YXJkcyB0aGUgbGlnaHQgc291cmNlLlxyXG5cdCAqXHJcblx0ICogQ29tcG9zaXRlIFBoYXNlOlxyXG5cdCAqICBUaGUgZmluYWwgcmVzdWx0IGlzIGNvbWJpbmVkIHdpdGggdGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlcikge1xyXG5cclxuXHRcdGNvbnN0IHF1YWQgPSB0aGlzLnF1YWQ7XHJcblx0XHRjb25zdCBzY2VuZSA9IHRoaXMuc2NlbmU7XHJcblx0XHRjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuXHRcdGNvbnN0IG1haW5TY2VuZSA9IHRoaXMubWFpblNjZW5lO1xyXG5cclxuXHRcdGNvbnN0IGxpZ2h0U291cmNlID0gdGhpcy5saWdodFNvdXJjZTtcclxuXHRcdGNvbnN0IHNjcmVlblBvc2l0aW9uID0gdGhpcy5zY3JlZW5Qb3NpdGlvbjtcclxuXHJcblx0XHRjb25zdCBnb2RSYXlzTWF0ZXJpYWwgPSB0aGlzLmdvZFJheXNNYXRlcmlhbDtcclxuXHRcdGNvbnN0IGNvbWJpbmVNYXRlcmlhbCA9IHRoaXMuY29tYmluZU1hdGVyaWFsO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldE1hc2sgPSB0aGlzLnJlbmRlclRhcmdldE1hc2s7XHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRYID0gdGhpcy5yZW5kZXJUYXJnZXRYO1xyXG5cdFx0Y29uc3QgcmVuZGVyVGFyZ2V0WSA9IHRoaXMucmVuZGVyVGFyZ2V0WTtcclxuXHJcblx0XHRsZXQgYmFja2dyb3VuZCwgcGFyZW50O1xyXG5cclxuXHRcdC8vIENvbXB1dGUgdGhlIHNjcmVlbiBsaWdodCBwb3NpdGlvbiBhbmQgdHJhbnNsYXRlIGl0IHRvIFswLCAxXS5cclxuXHRcdHNjcmVlblBvc2l0aW9uLmNvcHkobGlnaHRTb3VyY2UucG9zaXRpb24pLnByb2plY3QodGhpcy5tYWluQ2FtZXJhKTtcclxuXHRcdHNjcmVlblBvc2l0aW9uLnggPSBjbGFtcCgoc2NyZWVuUG9zaXRpb24ueCArIDEuMCkgKiAwLjUsIDAuMCwgMS4wKTtcclxuXHRcdHNjcmVlblBvc2l0aW9uLnkgPSBjbGFtcCgoc2NyZWVuUG9zaXRpb24ueSArIDEuMCkgKiAwLjUsIDAuMCwgMS4wKTtcclxuXHJcblx0XHQvLyBSZW5kZXIgdGhlIG1hc2tlZCBzY2VuZS5cclxuXHRcdHBhcmVudCA9IGxpZ2h0U291cmNlLnBhcmVudDtcclxuXHRcdGJhY2tncm91bmQgPSBtYWluU2NlbmUuYmFja2dyb3VuZDtcclxuXHRcdG1haW5TY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcclxuXHRcdHRoaXMubGlnaHRTY2VuZS5hZGQobGlnaHRTb3VyY2UpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyUGFzc0xpZ2h0LnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TWFzayk7XHJcblx0XHR0aGlzLnJlbmRlclBhc3NNYXNrLnJlbmRlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0TWFzayk7XHJcblxyXG5cdFx0aWYocGFyZW50ICE9PSBudWxsKSB7XHJcblxyXG5cdFx0XHRwYXJlbnQuYWRkKGxpZ2h0U291cmNlKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bWFpblNjZW5lLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG5cclxuXHRcdC8vIENvbnZvbHV0aW9uIHBoYXNlLlxyXG5cdFx0dGhpcy5ibHVyUGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldE1hc2ssIHJlbmRlclRhcmdldFgpO1xyXG5cclxuXHRcdC8vIEdvZCByYXlzIHBhc3MuXHJcblx0XHRxdWFkLm1hdGVyaWFsID0gZ29kUmF5c01hdGVyaWFsO1xyXG5cdFx0Z29kUmF5c01hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVuZGVyVGFyZ2V0WC50ZXh0dXJlO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldFkpO1xyXG5cclxuXHRcdC8vIEZpbmFsIHBhc3MgLSBjb21wb3NpdGUgZ29kIHJheXMgb250byBjb2xvdXJzLlxyXG5cdFx0cXVhZC5tYXRlcmlhbCA9IGNvbWJpbmVNYXRlcmlhbDtcclxuXHRcdGNvbWJpbmVNYXRlcmlhbC51bmlmb3Jtcy50ZXh0dXJlMS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdGNvbWJpbmVNYXRlcmlhbC51bmlmb3Jtcy50ZXh0dXJlMi52YWx1ZSA9IHJlbmRlclRhcmdldFkudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRqdXN0cyB0aGUgZm9ybWF0IG9mIHRoZSByZW5kZXIgdGFyZ2V0cy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbHBoYSAtIFdoZXRoZXIgdGhlIHJlbmRlcmVyIHVzZXMgdGhlIGFscGhhIGNoYW5uZWwgb3Igbm90LlxyXG5cdCAqL1xyXG5cclxuXHRpbml0aWFsaXNlKHJlbmRlcmVyLCBhbHBoYSkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyUGFzc0xpZ2h0LmluaXRpYWxpc2UocmVuZGVyZXIsIGFscGhhKTtcclxuXHRcdHRoaXMucmVuZGVyUGFzc01hc2suaW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpO1xyXG5cdFx0dGhpcy5ibHVyUGFzcy5pbml0aWFsaXNlKHJlbmRlcmVyLCBhbHBoYSk7XHJcblxyXG5cdFx0aWYoIWFscGhhKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlclRhcmdldE1hc2sudGV4dHVyZS5mb3JtYXQgPSBSR0JGb3JtYXQ7XHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0WC50ZXh0dXJlLmZvcm1hdCA9IFJHQkZvcm1hdDtcclxuXHRcdFx0dGhpcy5yZW5kZXJUYXJnZXRZLnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyUGFzc0xpZ2h0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLnJlbmRlclBhc3NNYXNrLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLmJsdXJQYXNzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0d2lkdGggPSB0aGlzLmJsdXJQYXNzLndpZHRoO1xyXG5cdFx0aGVpZ2h0ID0gdGhpcy5ibHVyUGFzcy5oZWlnaHQ7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRNYXNrLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFguc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0WS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBtYXNrIHBhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hc2tQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgbWFzayBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTY2VuZX0gc2NlbmUgLSBUaGUgc2NlbmUgdG8gcmVuZGVyLlxyXG5cdCAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgLSBUaGUgY2FtZXJhIHRvIHVzZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3Ioc2NlbmUsIGNhbWVyYSkge1xyXG5cclxuXHRcdHN1cGVyKHNjZW5lLCBjYW1lcmEsIG51bGwpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJNYXNrUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogSW52ZXJzZSBmbGFnLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuaW52ZXJzZSA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU3RlbmNpbCBidWZmZXIgY2xlYXIgZmxhZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY2xlYXJTdGVuY2lsID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGVzIGEgc3RlbmNpbCBiaXQgbWFzay5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHRjb25zdCBjb250ZXh0ID0gcmVuZGVyZXIuY29udGV4dDtcclxuXHRcdGNvbnN0IHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XHJcblxyXG5cdFx0Y29uc3Qgc2NlbmUgPSB0aGlzLnNjZW5lO1xyXG5cdFx0Y29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcblxyXG5cdFx0Y29uc3Qgd3JpdGVWYWx1ZSA9IHRoaXMuaW52ZXJzZSA/IDAgOiAxO1xyXG5cdFx0Y29uc3QgY2xlYXJWYWx1ZSA9IDEgLSB3cml0ZVZhbHVlO1xyXG5cclxuXHRcdC8vIERvbid0IHVwZGF0ZSBjb2xvciBvciBkZXB0aC5cclxuXHRcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayhmYWxzZSk7XHJcblx0XHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soZmFsc2UpO1xyXG5cclxuXHRcdC8vIExvY2sgdGhlIGJ1ZmZlcnMuXHJcblx0XHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldExvY2tlZCh0cnVlKTtcclxuXHRcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TG9ja2VkKHRydWUpO1xyXG5cclxuXHRcdC8vIENvbmZpZ3VyZSB0aGUgc3RlbmNpbC5cclxuXHRcdHN0YXRlLmJ1ZmZlcnMuc3RlbmNpbC5zZXRUZXN0KHRydWUpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldE9wKGNvbnRleHQuUkVQTEFDRSwgY29udGV4dC5SRVBMQUNFLCBjb250ZXh0LlJFUExBQ0UpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldEZ1bmMoY29udGV4dC5BTFdBWVMsIHdyaXRlVmFsdWUsIDB4ZmZmZmZmZmYpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldENsZWFyKGNsZWFyVmFsdWUpO1xyXG5cclxuXHRcdC8vIENsZWFyIHRoZSBzdGVuY2lsLlxyXG5cdFx0aWYodGhpcy5jbGVhclN0ZW5jaWwpIHtcclxuXHJcblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZWFkQnVmZmVyKTtcclxuXHRcdFx0cmVuZGVyZXIuY2xlYXJTdGVuY2lsKCk7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQod3JpdGVCdWZmZXIpO1xyXG5cdFx0XHRyZW5kZXJlci5jbGVhclN0ZW5jaWwoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRHJhdyB0aGUgbWFzayBpbnRvIGJvdGggYnVmZmVycy5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCByZWFkQnVmZmVyKTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdFx0Ly8gVW5sb2NrIHRoZSBidWZmZXJzLlxyXG5cdFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRMb2NrZWQoZmFsc2UpO1xyXG5cdFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRMb2NrZWQoZmFsc2UpO1xyXG5cclxuXHRcdC8vIE9ubHkgcmVuZGVyIHdoZXJlIHRoZSBzdGVuY2lsIGlzIHNldCB0byAxLlxyXG5cdFx0c3RhdGUuYnVmZmVycy5zdGVuY2lsLnNldEZ1bmMoY29udGV4dC5FUVVBTCwgMSwgMHhmZmZmZmZmZik7XHJcblx0XHRzdGF0ZS5idWZmZXJzLnN0ZW5jaWwuc2V0T3AoY29udGV4dC5LRUVQLCBjb250ZXh0LktFRVAsIGNvbnRleHQuS0VFUCk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgUGl4ZWxhdGlvbk1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGl4ZWxhdGlvbiBwYXNzLlxyXG4gKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBQaXhlbGF0aW9uUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHBpeGVsYXRpb24gcGFzcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JhbnVsYXJpdHk9MzAuMF0gLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBlZmZlY3QuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKGdyYW51bGFyaXR5ID0gMzAuMCkge1xyXG5cclxuXHRcdHN1cGVyKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGlzIHBhc3MuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5hbWUgPSBcIlBpeGVsYXRpb25QYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBwaXhlbGF0aW9uIHNoYWRlciBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UGl4ZWxhdGlvbk1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucGl4ZWxhdGlvbk1hdGVyaWFsID0gbmV3IFBpeGVsYXRpb25NYXRlcmlhbCgpO1xyXG5cclxuXHRcdHRoaXMuZ3JhbnVsYXJpdHkgPSBncmFudWxhcml0eTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLnBpeGVsYXRpb25NYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcGl4ZWwgZ3JhbnVsYXJpdHkuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDMwLjBcclxuXHQgKi9cclxuXHJcblx0Z2V0IGdyYW51bGFyaXR5KCkgeyByZXR1cm4gdGhpcy5waXhlbGF0aW9uTWF0ZXJpYWwuZ3JhbnVsYXJpdHk7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQSBoaWdoZXIgdmFsdWUgeWllbGRzIGNvYXJzZXIgdmlzdWFscy5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBncmFudWxhcml0eSh4ID0gMzApIHtcclxuXHJcblx0XHR4ID0gTWF0aC5mbG9vcih4KTtcclxuXHJcblx0XHRpZih4ICUgMiA+IDApIHtcclxuXHJcblx0XHRcdHggKz0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5waXhlbGF0aW9uTWF0ZXJpYWwuZ3JhbnVsYXJpdHkgPSB4O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgdGhlIGVmZmVjdC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSB3cml0ZUJ1ZmZlciAtIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpIHtcclxuXHJcblx0XHR0aGlzLnBpeGVsYXRpb25NYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhpcyBwYXNzIHdpdGggdGhlIHJlbmRlcmVyJ3Mgc2l6ZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodC5cclxuXHQgKi9cclxuXHJcblx0c2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG5cdFx0dGhpcy5waXhlbGF0aW9uTWF0ZXJpYWwuc2V0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBMaW5lYXJGaWx0ZXIsIFJHQkZvcm1hdCwgV2ViR0xSZW5kZXJUYXJnZXQgfSBmcm9tIFwidGhyZWVcIjtcclxuaW1wb3J0IHsgQ29weU1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEEgcGFzcyB0aGF0IHJlbmRlcnMgdGhlIHJlc3VsdCBmcm9tIGEgcHJldmlvdXMgcGFzcyB0byBhbm90aGVyIHJlbmRlciB0YXJnZXQuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNhdmVQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgc2F2ZSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldF0gLSBUaGUgcmVuZGVyIHRhcmdldCB0byB1c2UgZm9yIHNhdmluZyB0aGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVzaXplPXRydWVdIC0gV2hldGhlciB0aGUgcmVuZGVyIHRhcmdldCBzaG91bGQgYWRqdXN0IHRvIHRoZSBzaXplIG9mIHRoZSByZWFkL3dyaXRlIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IocmVuZGVyVGFyZ2V0LCByZXNpemUgPSB0cnVlKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiU2F2ZVBhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENvcHkgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtDb3B5TWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlbmRlciB0YXJnZXQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXQgPSAocmVuZGVyVGFyZ2V0ICE9PSB1bmRlZmluZWQpID8gcmVuZGVyVGFyZ2V0IDogbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcclxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRzdGVuY2lsQnVmZmVyOiBmYWxzZSxcclxuXHRcdFx0ZGVwdGhCdWZmZXI6IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcIlNhdmUuVGFyZ2V0XCI7XHJcblx0XHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGJlIHJlc2l6ZWQgd2hlbiB0aGUgc2l6ZSBvZlxyXG5cdFx0ICogdGhlIGNvbXBvc2VyJ3MgcmVhZC93cml0ZSBidWZmZXIgY2hhbmdlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVzaXplID0gcmVzaXplO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNhdmVzIHRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gcmVhZEJ1ZmZlciAtIFRoZSByZWFkIGJ1ZmZlci5cclxuXHQgKi9cclxuXHJcblx0cmVuZGVyKHJlbmRlcmVyLCByZWFkQnVmZmVyKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVGFyZ2V0KTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBZGp1c3RzIHRoZSBmb3JtYXQgb2YgdGhlIHJlbmRlciB0YXJnZXQuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxwaGEgLSBXaGV0aGVyIHRoZSByZW5kZXJlciB1c2VzIHRoZSBhbHBoYSBjaGFubmVsIG9yIG5vdC5cclxuXHQgKi9cclxuXHJcblx0aW5pdGlhbGlzZShyZW5kZXJlciwgYWxwaGEpIHtcclxuXHJcblx0XHRpZighYWxwaGEpIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdGlmKHRoaXMucmVzaXplKSB7XHJcblxyXG5cdFx0XHR3aWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoKTtcclxuXHRcdFx0aGVpZ2h0ID0gTWF0aC5tYXgoMSwgaGVpZ2h0KTtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IFBhc3MgfSBmcm9tIFwiLi9QYXNzLmpzXCI7XHJcblxyXG4vKipcclxuICogQSBzaGFkZXIgcGFzcy5cclxuICpcclxuICogVXNlZCB0byByZW5kZXIgYW55IHNoYWRlciBtYXRlcmlhbCBhcyBhIDJEIGZpbHRlci5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU2hhZGVyUGFzcyBleHRlbmRzIFBhc3Mge1xyXG5cclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RzIGEgbmV3IHNoYWRlciBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTaGFkZXJNYXRlcmlhbH0gbWF0ZXJpYWwgLSBUaGUgc2hhZGVyIG1hdGVyaWFsIHRvIHVzZS5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHR1cmVJRD1cInREaWZmdXNlXCJdIC0gVGhlIHRleHR1cmUgdW5pZm9ybSBpZGVudGlmaWVyLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihtYXRlcmlhbCwgdGV4dHVyZUlEID0gXCJ0RGlmZnVzZVwiKSB7XHJcblxyXG5cdFx0c3VwZXIoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBuYW1lIG9mIHRoaXMgcGFzcy5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmFtZSA9IFwiU2hhZGVyUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBzaGFkZXIgbWF0ZXJpYWwgdG8gdXNlIGZvciByZW5kZXJpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1NoYWRlck1hdGVyaWFsfVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbmFtZSBvZiB0aGUgY29sb3Igc2FtcGxlciB1bmlmb3JtIG9mIHRoZSBnaXZlbiBtYXRlcmlhbC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgXCJ0RGlmZnVzZVwiXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnRleHR1cmVJRCA9IHRleHR1cmVJRDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIHRoZSBlZmZlY3QuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0aWYodGhpcy5tYXRlcmlhbC51bmlmb3Jtc1t0aGlzLnRleHR1cmVJRF0gIT09IHVuZGVmaW5lZCkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRlcmlhbC51bmlmb3Jtc1t0aGlzLnRleHR1cmVJRF0udmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBDb3B5TWF0ZXJpYWwsIFNob2NrV2F2ZU1hdGVyaWFsIH0gZnJvbSBcIi4uL21hdGVyaWFsc1wiO1xyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIEhhbGYgUEkuXHJcbiAqXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQGZpbmFsXHJcbiAqL1xyXG5cclxuY29uc3QgSEFMRl9QSSA9IE1hdGguUEkgKiAwLjU7XHJcblxyXG4vKipcclxuICogQSB2ZWN0b3IuXHJcbiAqXHJcbiAqIEB0eXBlIHtWZWN0b3IzfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc3RhdGljXHJcbiAqIEBmaW5hbFxyXG4gKi9cclxuXHJcbmNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xyXG5cclxuLyoqXHJcbiAqIEEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAdHlwZSB7VmVjdG9yM31cclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAZmluYWxcclxuICovXHJcblxyXG5jb25zdCBhYiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG4vKipcclxuICogQSBzaG9jayB3YXZlIHBhc3MuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIFNob2NrV2F2ZVBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBzaG9jayB3YXZlIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIC0gVGhlIG1haW4gY2FtZXJhLlxyXG5cdCAqIEBwYXJhbSB7VmVjdG9yM30gW2VwaWNlbnRlcl0gLSBUaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHNob2NrIHdhdmUgZXBpY2VudGVyLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9ucy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3BlZWQ9MS4wXSAtIFRoZSBhbmltYXRpb24gc3BlZWQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFJhZGl1cz0xLjBdIC0gVGhlIGV4dGVudCBvZiB0aGUgc2hvY2sgd2F2ZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2F2ZVNpemU9MC4yXSAtIFRoZSB3YXZlIHNpemUuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFtcGxpdHVkZT0wLjA1XSAtIFRoZSBkaXN0b3J0aW9uIGFtcGxpdHVkZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoY2FtZXJhLCBlcGljZW50ZXIgPSBuZXcgVmVjdG9yMygpLCBvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJTaG9ja1dhdmVQYXNzXCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHBhc3MgcmVuZGVycyB0byB0aGUgd3JpdGUgYnVmZmVyLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uZWVkc1N3YXAgPSB0cnVlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG1haW4gY2FtZXJhLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtPYmplY3QzRH1cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubWFpbkNhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBlcGljZW50ZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XHJcblx0XHQgKiBAZXhhbXBsZSBzaG9ja1dhdmVQYXNzLmVwaWNlbnRlciA9IG15TWVzaC5wb3NpdGlvbjtcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuZXBpY2VudGVyID0gZXBpY2VudGVyO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG9iamVjdCBwb3NpdGlvbiBpbiBzY3JlZW4gc3BhY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1ZlY3RvcjN9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5zY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgc3BlZWQgb2YgdGhlIHNob2NrIHdhdmUgYW5pbWF0aW9uLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAyLjBcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuc3BlZWQgPSAob3B0aW9ucy5zcGVlZCAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuc3BlZWQgOiAyLjA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHRpbWUgYWNjdW11bGF0b3IuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnRpbWUgPSAwLjA7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc2hvY2sgd2F2ZSBhbmltYXRpb24gaXMgYWN0aXZlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHNob2NrIHdhdmUgc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTaG9ja1dhdmVNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnNob2NrV2F2ZU1hdGVyaWFsID0gbmV3IFNob2NrV2F2ZU1hdGVyaWFsKG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuc2hvY2tXYXZlTWF0ZXJpYWwudW5pZm9ybXMuY2VudGVyLnZhbHVlID0gdGhpcy5zY3JlZW5Qb3NpdGlvbjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgY29weSBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NvcHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0cyB0aGUgc2hvY2sgd2F2ZS5cclxuXHQgKi9cclxuXHJcblx0ZXhwbG9kZSgpIHtcclxuXHJcblx0XHR0aGlzLnRpbWUgPSAwLjA7XHJcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgLSBUaGUgcmVuZGVyIGRlbHRhIHRpbWUuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIsIGRlbHRhKSB7XHJcblxyXG5cdFx0Y29uc3QgZXBpY2VudGVyID0gdGhpcy5lcGljZW50ZXI7XHJcblx0XHRjb25zdCBtYWluQ2FtZXJhID0gdGhpcy5tYWluQ2FtZXJhO1xyXG5cdFx0Y29uc3Qgc2NyZWVuUG9zaXRpb24gPSB0aGlzLnNjcmVlblBvc2l0aW9uO1xyXG5cclxuXHRcdGNvbnN0IHNob2NrV2F2ZU1hdGVyaWFsID0gdGhpcy5zaG9ja1dhdmVNYXRlcmlhbDtcclxuXHRcdGNvbnN0IHVuaWZvcm1zID0gc2hvY2tXYXZlTWF0ZXJpYWwudW5pZm9ybXM7XHJcblx0XHRjb25zdCBjZW50ZXIgPSB1bmlmb3Jtcy5jZW50ZXI7XHJcblx0XHRjb25zdCByYWRpdXMgPSB1bmlmb3Jtcy5yYWRpdXM7XHJcblx0XHRjb25zdCBtYXhSYWRpdXMgPSB1bmlmb3Jtcy5tYXhSYWRpdXM7XHJcblx0XHRjb25zdCB3YXZlU2l6ZSA9IHVuaWZvcm1zLndhdmVTaXplO1xyXG5cclxuXHRcdHRoaXMuY29weU1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5jb3B5TWF0ZXJpYWw7XHJcblxyXG5cdFx0aWYodGhpcy5hY3RpdmUpIHtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSBkaXJlY3Rpb24gdmVjdG9ycy5cclxuXHRcdFx0bWFpbkNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbih2KTtcclxuXHRcdFx0YWIuY29weShtYWluQ2FtZXJhLnBvc2l0aW9uKS5zdWIoZXBpY2VudGVyKTtcclxuXHJcblx0XHRcdC8vIERvbid0IHJlbmRlciB0aGUgZWZmZWN0IGlmIHRoZSBvYmplY3QgaXMgYmVoaW5kIHRoZSBjYW1lcmEuXHJcblx0XHRcdGlmKHYuYW5nbGVUbyhhYikgPiBIQUxGX1BJKSB7XHJcblxyXG5cdFx0XHRcdC8vIFNjYWxlIHRoZSBlZmZlY3QgYmFzZWQgb24gZGlzdGFuY2UgdG8gdGhlIG9iamVjdC5cclxuXHRcdFx0XHR1bmlmb3Jtcy5jYW1lcmFEaXN0YW5jZS52YWx1ZSA9IG1haW5DYW1lcmEucG9zaXRpb24uZGlzdGFuY2VUbyhlcGljZW50ZXIpO1xyXG5cclxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgdGhlIHNjcmVlbiBwb3NpdGlvbiBvZiB0aGUgZXBpY2VudGVyLlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoZXBpY2VudGVyKS5wcm9qZWN0KG1haW5DYW1lcmEpO1xyXG5cdFx0XHRcdGNlbnRlci52YWx1ZS54ID0gKHNjcmVlblBvc2l0aW9uLnggKyAxLjApICogMC41O1xyXG5cdFx0XHRcdGNlbnRlci52YWx1ZS55ID0gKHNjcmVlblBvc2l0aW9uLnkgKyAxLjApICogMC41O1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdFx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSBzaG9ja1dhdmVNYXRlcmlhbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVwZGF0ZSB0aGUgc2hvY2sgd2F2ZSByYWRpdXMgYmFzZWQgb24gdGltZS5cclxuXHRcdFx0dGhpcy50aW1lICs9IGRlbHRhICogdGhpcy5zcGVlZDtcclxuXHRcdFx0cmFkaXVzLnZhbHVlID0gdGhpcy50aW1lIC0gd2F2ZVNpemUudmFsdWU7XHJcblxyXG5cdFx0XHRpZihyYWRpdXMudmFsdWUgPj0gKG1heFJhZGl1cy52YWx1ZSArIHdhdmVTaXplLnZhbHVlKSAqIDIpIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRvU2NyZWVuID8gbnVsbCA6IHdyaXRlQnVmZmVyKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoaXMgcGFzcyB3aXRoIHRoZSByZW5kZXJlcidzIHNpemUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgd2lkdGguXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdHRoaXMuc2hvY2tXYXZlTWF0ZXJpYWwudW5pZm9ybXMuYXNwZWN0LnZhbHVlID0gd2lkdGggLyBoZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuXHRMaW5lYXJGaWx0ZXIsXHJcblx0TmVhcmVzdEZpbHRlcixcclxuXHRSR0JBRm9ybWF0LFxyXG5cdFJHQkZvcm1hdCxcclxuXHRUZXh0dXJlLFxyXG5cdFdlYkdMUmVuZGVyVGFyZ2V0XHJcbn0gZnJvbSBcInRocmVlXCI7XHJcblxyXG5pbXBvcnQgeyBTTUFBQmxlbmRNYXRlcmlhbCwgU01BQUNvbG9yRWRnZXNNYXRlcmlhbCwgU01BQVdlaWdodHNNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBTdWJwaXhlbCBNb3JwaG9sb2dpY2FsIEFudGlhbGlhc2luZyAoU01BQSkgdjIuOC5cclxuICpcclxuICogUHJlc2V0OiBTTUFBIDF4IE1lZGl1bSAod2l0aCBjb2xvciBlZGdlIGRldGVjdGlvbikuXHJcbiAqICBodHRwczovL2dpdGh1Yi5jb20vaXJ5b2t1L3NtYWEvcmVsZWFzZXMvdGFnL3YyLjhcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgU01BQVBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBTTUFBIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge0ltYWdlfSBJbWFnZSAtIFRoaXMgcGFzcyByZXF1aXJlcyBhbiBJbWFnZSBjbGFzcyB0byBjcmVhdGUgaW50ZXJuYWwgdGV4dHVyZXMuIFByb3ZpZGUgd2luZG93LkltYWdlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IoSW1hZ2UpIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJTTUFBUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBwYXNzIHJlbmRlcnMgdG8gdGhlIHdyaXRlIGJ1ZmZlci5cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMubmVlZHNTd2FwID0gdHJ1ZTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVuZGVyIHRhcmdldCBmb3IgdGhlIGNvbG9yIGVkZ2UgZGV0ZWN0aW9uLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtXZWJHTFJlbmRlclRhcmdldH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldENvbG9yRWRnZXMgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMSwgMSwge1xyXG5cdFx0XHRtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0Zm9ybWF0OiBSR0JGb3JtYXQsXHJcblx0XHRcdHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxyXG5cdFx0XHRkZXB0aEJ1ZmZlcjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0Q29sb3JFZGdlcy50ZXh0dXJlLm5hbWUgPSBcIlNNQUEuQ29sb3JFZGdlc1wiO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRDb2xvckVkZ2VzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBTTUFBIHdlaWdodHMuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cyA9IHRoaXMucmVuZGVyVGFyZ2V0Q29sb3JFZGdlcy5jbG9uZSgpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlLm5hbWUgPSBcIlNNQUEuV2VpZ2h0c1wiO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRXZWlnaHRzLnRleHR1cmUuZm9ybWF0ID0gUkdCQUZvcm1hdDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNNQUEgY29sb3IgZWRnZSBkZXRlY3Rpb24gc2hhZGVyIG1hdGVyaWFsLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTTUFBQ29sb3JFZGdlc01hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29sb3JFZGdlc01hdGVyaWFsID0gbmV3IFNNQUFDb2xvckVkZ2VzTWF0ZXJpYWwoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNNQUEgd2VpZ2h0cyBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1NNQUFXZWlnaHRzTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy53ZWlnaHRzTWF0ZXJpYWwgPSBuZXcgU01BQVdlaWdodHNNYXRlcmlhbCgpO1xyXG5cclxuXHRcdGNvbnN0IGFyZWFJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cdFx0YXJlYUltYWdlLnNyYyA9IHRoaXMud2VpZ2h0c01hdGVyaWFsLmFyZWFJbWFnZTtcclxuXHJcblx0XHRjb25zdCBhcmVhVGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XHJcblx0XHRhcmVhVGV4dHVyZS5pbWFnZSA9IGFyZWFJbWFnZTtcclxuXHRcdGFyZWFUZXh0dXJlLm5hbWUgPSBcIlNNQUEuQXJlYVwiO1xyXG5cdFx0YXJlYVRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cdFx0YXJlYVRleHR1cmUuZm9ybWF0ID0gUkdCRm9ybWF0O1xyXG5cdFx0YXJlYVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHRhcmVhVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRhcmVhVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHRcdGNvbnN0IHNlYXJjaEltYWdlID0gbmV3IEltYWdlKCk7XHJcblx0XHRzZWFyY2hJbWFnZS5zcmMgPSB0aGlzLndlaWdodHNNYXRlcmlhbC5zZWFyY2hJbWFnZTtcclxuXHJcblx0XHRjb25zdCBzZWFyY2hUZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcclxuXHRcdHNlYXJjaFRleHR1cmUuaW1hZ2UgPSBzZWFyY2hJbWFnZTtcclxuXHRcdHNlYXJjaFRleHR1cmUubmFtZSA9IFwiU01BQS5TZWFyY2hcIjtcclxuXHRcdHNlYXJjaFRleHR1cmUubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcclxuXHRcdHNlYXJjaFRleHR1cmUubWluRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcclxuXHRcdHNlYXJjaFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblx0XHRzZWFyY2hUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdHNlYXJjaFRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLndlaWdodHNNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0Q29sb3JFZGdlcy50ZXh0dXJlO1xyXG5cdFx0dGhpcy53ZWlnaHRzTWF0ZXJpYWwudW5pZm9ybXMudEFyZWEudmFsdWUgPSBhcmVhVGV4dHVyZTtcclxuXHRcdHRoaXMud2VpZ2h0c01hdGVyaWFsLnVuaWZvcm1zLnRTZWFyY2gudmFsdWUgPSBzZWFyY2hUZXh0dXJlO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU01BQSBibGVuZCBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1NNQUFCbGVuZE1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYmxlbmRNYXRlcmlhbCA9IG5ldyBTTUFBQmxlbmRNYXRlcmlhbCgpO1xyXG5cclxuXHRcdHRoaXMuYmxlbmRNYXRlcmlhbC51bmlmb3Jtcy50V2VpZ2h0cy52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy50ZXh0dXJlO1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuYmxlbmRNYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBbnRpYWxpYXNlcyB0aGUgc2NlbmUuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHJlYWRCdWZmZXIgLSBUaGUgcmVhZCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gd3JpdGVCdWZmZXIgLSBUaGUgd3JpdGUgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyKSB7XHJcblxyXG5cdFx0Ly8gRGV0ZWN0IGNvbG9yIGVkZ2VzLlxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5jb2xvckVkZ2VzTWF0ZXJpYWw7XHJcblx0XHR0aGlzLmNvbG9yRWRnZXNNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUYXJnZXRDb2xvckVkZ2VzLCB0cnVlKTtcclxuXHJcblx0XHQvLyBDb21wdXRlIGVkZ2Ugd2VpZ2h0cy5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMud2VpZ2h0c01hdGVyaWFsO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlclRhcmdldFdlaWdodHMsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBBcHBseSB0aGUgYW50aWFsaWFzaW5nIGZpbHRlciB0byB0aGUgY29sb3JzLlxyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsID0gdGhpcy5ibGVuZE1hdGVyaWFsO1xyXG5cdFx0dGhpcy5ibGVuZE1hdGVyaWFsLnVuaWZvcm1zLnREaWZmdXNlLnZhbHVlID0gcmVhZEJ1ZmZlci50ZXh0dXJlO1xyXG5cclxuXHRcdHJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJUb1NjcmVlbiA/IG51bGwgOiB3cml0ZUJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGlzIHBhc3Mgd2l0aCB0aGUgcmVuZGVyZXIncyBzaXplLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0LlxyXG5cdCAqL1xyXG5cclxuXHRzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldENvbG9yRWRnZXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0V2VpZ2h0cy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdHRoaXMuY29sb3JFZGdlc01hdGVyaWFsLnVuaWZvcm1zLnRleGVsU2l6ZS52YWx1ZS5jb3B5KFxyXG5cdFx0XHR0aGlzLndlaWdodHNNYXRlcmlhbC51bmlmb3Jtcy50ZXhlbFNpemUudmFsdWUuY29weShcclxuXHRcdFx0XHR0aGlzLmJsZW5kTWF0ZXJpYWwudW5pZm9ybXMudGV4ZWxTaXplLnZhbHVlLnNldChcclxuXHRcdFx0XHRcdDEuMCAvIHdpZHRoLCAxLjAgLyBoZWlnaHRcclxuXHRcdCkpKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBBZGRpdGl2ZUJsZW5kaW5nIH0gZnJvbSBcInRocmVlXCI7XHJcbmltcG9ydCB7IENvcHlNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuaW1wb3J0IHsgUGFzcyB9IGZyb20gXCIuL1Bhc3MuanNcIjtcclxuXHJcbi8qKlxyXG4gKiBBIHBhc3MgdGhhdCByZW5kZXJzIGEgZ2l2ZW4gdGV4dHVyZS5cclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgVGV4dHVyZVBhc3MgZXh0ZW5kcyBQYXNzIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyB0ZXh0dXJlIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1RleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29wYWNpdHk9MS4wXSAtIFRoZSB0ZXh0dXJlIG9wYWNpdHkuXHJcblx0ICovXHJcblxyXG5cdGNvbnN0cnVjdG9yKHRleHR1cmUsIG9wYWNpdHkgPSAxLjApIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJUZXh0dXJlUGFzc1wiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBjb3B5IHNoYWRlciBtYXRlcmlhbCB1c2VkIGZvciByZW5kZXJpbmcgdG8gdGV4dHVyZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7Q29weU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29weU1hdGVyaWFsID0gbmV3IENvcHlNYXRlcmlhbCgpO1xyXG5cdFx0dGhpcy5jb3B5TWF0ZXJpYWwuYmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xyXG5cdFx0dGhpcy5jb3B5TWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcblx0XHR0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdHRoaXMucXVhZC5tYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSB0ZXh0dXJlLlxyXG5cdCAqXHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblxyXG5cdGdldCB0ZXh0dXJlKCkgeyByZXR1cm4gdGhpcy5jb3B5TWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge1RleHR1cmV9XHJcblx0ICovXHJcblxyXG5cdHNldCB0ZXh0dXJlKHgpIHsgdGhpcy5jb3B5TWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSB4OyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBvcGFjaXR5LlxyXG5cdCAqXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAxLjBcclxuXHQgKi9cclxuXHJcblx0Z2V0IG9wYWNpdHkoKSB7IHJldHVybiB0aGlzLmNvcHlNYXRlcmlhbC51bmlmb3Jtcy5vcGFjaXR5LnZhbHVlOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICovXHJcblxyXG5cdHNldCBvcGFjaXR5KHggPSAxLjApIHsgdGhpcy5jb3B5TWF0ZXJpYWwudW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IHg7IH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqL1xyXG5cclxuXHRyZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIpIHtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogcmVhZEJ1ZmZlcik7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuXHRMaW5lYXJGaWx0ZXIsXHJcblx0TGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLFxyXG5cdE1lc2hCYXNpY01hdGVyaWFsLFxyXG5cdFJHQkZvcm1hdCxcclxuXHRXZWJHTFJlbmRlclRhcmdldFxyXG59IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuaW1wb3J0IHtcclxuXHRBZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbCxcclxuXHRDb3B5TWF0ZXJpYWwsXHJcblx0THVtaW5vc2l0eU1hdGVyaWFsLFxyXG5cdFRvbmVNYXBwaW5nTWF0ZXJpYWxcclxufSBmcm9tIFwiLi4vbWF0ZXJpYWxzXCI7XHJcblxyXG5pbXBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5cclxuLyoqXHJcbiAqIFJvdW5kcyB0aGUgZ2l2ZW4gbnVtYmVyIHVwIHRvIHRoZSBuZXh0IHBvd2VyIG9mIHR3by5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbiAtIEEgbnVtYmVyLlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBuZXh0IHBvd2VyIG9mIHR3by5cclxuICovXHJcblxyXG5mdW5jdGlvbiBjZWlsMihuKSB7IHJldHVybiBNYXRoLnBvdygyLCBNYXRoLm1heCgwLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG4pKSkpOyB9XHJcblxyXG4vKipcclxuICogQSB0b25lIG1hcHBpbmcgcGFzcyB0aGF0IHN1cHBvcnRzIGFkYXB0aXZlIGx1bWlub3NpdHkuXHJcbiAqXHJcbiAqIElmIGFkYXB0aXZpdHkgaXMgZW5hYmxlZCwgdGhpcyBwYXNzIGdlbmVyYXRlcyBhIHRleHR1cmUgdGhhdCByZXByZXNlbnRzIHRoZVxyXG4gKiBsdW1pbm9zaXR5IG9mIHRoZSBjdXJyZW50IHNjZW5lIGFuZCBhZGp1c3RzIGl0IG92ZXIgdGltZSB0byBzaW11bGF0ZSB0aGVcclxuICogb3B0aWMgbmVydmUgcmVzcG9uZGluZyB0byB0aGUgYW1vdW50IG9mIGxpZ2h0IGl0IGlzIHJlY2VpdmluZy5cclxuICpcclxuICogUmVmZXJlbmNlOlxyXG4gKiAgR0RDMjAwNyAtIFdvbGZnYW5nIEVuZ2VsLCBQb3N0LVByb2Nlc3NpbmcgUGlwZWxpbmVcclxuICogIGh0dHA6Ly9wZXJzby51bml2LWx5b24xLmZyL2plYW4tY2xhdWRlLmllaGwvUHVibGljL2VkdWMvR0FNQS8yMDA3L2dkYzA3L1Bvc3QtUHJvY2Vzc2luZ19QaXBlbGluZS5wZGZcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgVG9uZU1hcHBpbmdQYXNzIGV4dGVuZHMgUGFzcyB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnN0cnVjdHMgYSBuZXcgdG9uZSBtYXBwaW5nIHBhc3MuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hZGFwdGl2ZT10cnVlXSAtIFdoZXRoZXIgdGhlIHRvbmUgbWFwcGluZyBzaG91bGQgdXNlIGFuIGFkYXB0aXZlIGx1bWluYW5jZSBtYXAuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MjU2XSAtIFRoZSByZW5kZXIgdGV4dHVyZSByZXNvbHV0aW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0aW5jdGlvbj0xLjBdIC0gQSBsdW1pbmFuY2UgZGlzdGluY3Rpb24gZmFjdG9yLlxyXG5cdCAqL1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHRzdXBlcigpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIG5hbWUgb2YgdGhpcyBwYXNzLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5uYW1lID0gXCJUb25lTWFwcGluZ1Bhc3NcIjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoaXMgcGFzcyByZW5kZXJzIHRvIHRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLm5lZWRzU3dhcCA9IHRydWU7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcmVuZGVyIHRhcmdldCBmb3IgdGhlIGN1cnJlbnQgbHVtaW5vc2l0eS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQHRvZG8gVXNlIFJFRCBmb3JtYXQgaW4gV2ViR0wgMi4wLlxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRMdW1pbm9zaXR5ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcclxuXHRcdFx0bWluRmlsdGVyOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsXHJcblx0XHRcdG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRmb3JtYXQ6IFJHQkZvcm1hdCxcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogZmFsc2UsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRMdW1pbm9zaXR5LnRleHR1cmUubmFtZSA9IFwiVG9uZU1hcHBpbmcuTHVtaW5vc2l0eVwiO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHJlbmRlciB0YXJnZXQgZm9yIGFkYXB0ZWQgbHVtaW5vc2l0eS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkID0gdGhpcy5yZW5kZXJUYXJnZXRMdW1pbm9zaXR5LmNsb25lKCk7XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmUubmFtZSA9IFwiVG9uZU1hcHBpbmcuQWRhcHRlZEx1bWlub3NpdHlcIjtcclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0QWRhcHRlZC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZW5kZXIgdGFyZ2V0IHRoYXQgaG9sZHMgYSBjb3B5IG9mIHRoZSBhZGFwdGVkIGxpbW9ub3NpdHkuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMgPSB0aGlzLnJlbmRlclRhcmdldEFkYXB0ZWQuY2xvbmUoKTtcclxuXHJcblx0XHR0aGlzLnJlbmRlclRhcmdldFByZXZpb3VzLnRleHR1cmUubmFtZSA9IFwiVG9uZU1hcHBpbmcuUHJldmlvdXNMdW1pbm9zaXR5XCI7XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDb3B5IHNoYWRlciBtYXRlcmlhbCB1c2VkIGZvciBzYXZpbmcgdGhlIGx1bWluYW5jZSBtYXAuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0NvcHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmNvcHlNYXRlcmlhbCA9IG5ldyBDb3B5TWF0ZXJpYWwoKTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEEgbHVtaW5vc2l0eSBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0x1bWlub3NpdHlNYXRlcmlhbH1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHJcblx0XHR0aGlzLmx1bWlub3NpdHlNYXRlcmlhbCA9IG5ldyBMdW1pbm9zaXR5TWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLmx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy5kaXN0aW5jdGlvbi52YWx1ZSA9IChvcHRpb25zLmRpc3RpbmN0aW9uICE9PSB1bmRlZmluZWQpID8gb3B0aW9ucy5kaXN0aW5jdGlvbiA6IDEuMDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEFuIGFkYXB0aXZlIGx1bWluYW5jZSBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge0FkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuYWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwgPSBuZXcgQWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHRvbmUgbWFwcGluZyBzaGFkZXIgbWF0ZXJpYWwuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1RvbmVNYXBwaW5nTWF0ZXJpYWx9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy50b25lTWFwcGluZ01hdGVyaWFsID0gbmV3IFRvbmVNYXBwaW5nTWF0ZXJpYWwoKTtcclxuXHJcblx0XHR0aGlzLmFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRhcmdldHMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IDI1NlxyXG5cdCAqL1xyXG5cclxuXHRnZXQgcmVzb2x1dGlvbigpIHsgcmV0dXJuIHRoaXMucmVuZGVyVGFyZ2V0THVtaW5vc2l0eS53aWR0aDsgfVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRhcmdldHMuIE11c3QgYmUgYSBwb3dlciBvZiB0d28gZm9yIG1pcG1hcHMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgcmVzb2x1dGlvbih4ID0gMjU2KSB7XHJcblxyXG5cdFx0eCA9IGNlaWwyKHgpO1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0THVtaW5vc2l0eS5zZXRTaXplKHgsIHgpO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cy5zZXRTaXplKHgsIHgpO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnNldFNpemUoeCwgeCk7XHJcblxyXG5cdFx0dGhpcy5hZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbC5kZWZpbmVzLk1JUF9MRVZFTF8xWDEgPSAoTWF0aC5yb3VuZChNYXRoLmxvZyh4KSkgLyBNYXRoLmxvZygyKSkudG9GaXhlZCgxKTtcclxuXHRcdHRoaXMuYWRhcHRpdmVMdW1pbm9zaXR5TWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhpcyBwYXNzIHVzZXMgYWRhcHRpdmUgbHVtaW5vc2l0eS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKi9cclxuXHJcblx0Z2V0IGFkYXB0aXZlKCkgeyByZXR1cm4gKHRoaXMudG9uZU1hcHBpbmdNYXRlcmlhbC5kZWZpbmVzLkFEQVBURURfTFVNSU5BTkNFICE9PSB1bmRlZmluZWQpOyB9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFdoZXRoZXIgdGhpcyBwYXNzIHNob3VsZCB1c2UgYWRhcHRpdmUgbHVtaW5vc2l0eS5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqL1xyXG5cclxuXHRzZXQgYWRhcHRpdmUoeCA9IHRydWUpIHtcclxuXHJcblx0XHRpZih4KSB7XHJcblxyXG5cdFx0XHR0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWwuZGVmaW5lcy5BREFQVEVEX0xVTUlOQU5DRSA9IFwiMVwiO1xyXG5cdFx0XHR0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWwudW5pZm9ybXMubHVtaW5hbmNlTWFwLnZhbHVlID0gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkLnRleHR1cmU7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGRlbGV0ZSB0aGlzLnRvbmVNYXBwaW5nTWF0ZXJpYWwuZGVmaW5lcy5BREFQVEVEX0xVTUlOQU5DRTtcclxuXHRcdFx0dGhpcy50b25lTWFwcGluZ01hdGVyaWFsLnVuaWZvcm1zLmx1bWluYW5jZU1hcC52YWx1ZSA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudG9uZU1hcHBpbmdNYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVuZGVycyB0aGUgZWZmZWN0LlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyVGFyZ2V0fSByZWFkQnVmZmVyIC0gVGhlIHJlYWQgYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJUYXJnZXR9IHdyaXRlQnVmZmVyIC0gVGhlIHdyaXRlIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgLSBUaGUgcmVuZGVyIGRlbHRhIHRpbWUuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIsIGRlbHRhKSB7XHJcblxyXG5cdFx0Y29uc3QgcXVhZCA9IHRoaXMucXVhZDtcclxuXHRcdGNvbnN0IHNjZW5lID0gdGhpcy5zY2VuZTtcclxuXHRcdGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG5cclxuXHRcdGNvbnN0IGFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsID0gdGhpcy5hZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbDtcclxuXHRcdGNvbnN0IGx1bWlub3NpdHlNYXRlcmlhbCA9IHRoaXMubHVtaW5vc2l0eU1hdGVyaWFsO1xyXG5cdFx0Y29uc3QgdG9uZU1hcHBpbmdNYXRlcmlhbCA9IHRoaXMudG9uZU1hcHBpbmdNYXRlcmlhbDtcclxuXHRcdGNvbnN0IGNvcHlNYXRlcmlhbCA9IHRoaXMuY29weU1hdGVyaWFsO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldFByZXZpb3VzID0gdGhpcy5yZW5kZXJUYXJnZXRQcmV2aW91cztcclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldEx1bWlub3NpdHkgPSB0aGlzLnJlbmRlclRhcmdldEx1bWlub3NpdHk7XHJcblx0XHRjb25zdCByZW5kZXJUYXJnZXRBZGFwdGVkID0gdGhpcy5yZW5kZXJUYXJnZXRBZGFwdGVkO1xyXG5cclxuXHRcdGlmKHRoaXMuYWRhcHRpdmUpIHtcclxuXHJcblx0XHRcdC8vIFJlbmRlciB0aGUgbHVtaW5hbmNlIG9mIHRoZSBjdXJyZW50IHNjZW5lIGludG8gYSByZW5kZXIgdGFyZ2V0IHdpdGggbWlwbWFwcGluZyBlbmFibGVkLlxyXG5cdFx0XHRxdWFkLm1hdGVyaWFsID0gbHVtaW5vc2l0eU1hdGVyaWFsO1xyXG5cdFx0XHRsdW1pbm9zaXR5TWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZWFkQnVmZmVyLnRleHR1cmU7XHJcblx0XHRcdHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXRMdW1pbm9zaXR5KTtcclxuXHJcblx0XHRcdC8vIFVzZSB0aGUgbmV3IGx1bWluYW5jZSB2YWx1ZXMsIHRoZSBwcmV2aW91cyBsdW1pbmFuY2UgYW5kIHRoZSBmcmFtZSBkZWx0YSB0byBhZGFwdCB0aGUgbHVtaW5hbmNlIG92ZXIgdGltZS5cclxuXHRcdFx0cXVhZC5tYXRlcmlhbCA9IGFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsO1xyXG5cdFx0XHRhZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy5kZWx0YS52YWx1ZSA9IGRlbHRhO1xyXG5cdFx0XHRhZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy50UHJldmlvdXNMdW0udmFsdWUgPSByZW5kZXJUYXJnZXRQcmV2aW91cy50ZXh0dXJlO1xyXG5cdFx0XHRhZGFwdGl2ZUx1bWlub3NpdHlNYXRlcmlhbC51bmlmb3Jtcy50Q3VycmVudEx1bS52YWx1ZSA9IHJlbmRlclRhcmdldEx1bWlub3NpdHkudGV4dHVyZTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldEFkYXB0ZWQpO1xyXG5cclxuXHRcdFx0Ly8gQ29weSB0aGUgbmV3IGFkYXB0ZWQgbHVtaW5hbmNlIHZhbHVlIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYnkgdGhlIG5leHQgZnJhbWUuXHJcblx0XHRcdHF1YWQubWF0ZXJpYWwgPSBjb3B5TWF0ZXJpYWw7XHJcblx0XHRcdGNvcHlNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlbmRlclRhcmdldEFkYXB0ZWQudGV4dHVyZTtcclxuXHRcdFx0cmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldFByZXZpb3VzKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQXBwbHkgdGhlIHRvbmUgbWFwcGluZyB0byB0aGUgY29sb3Vycy5cclxuXHRcdHF1YWQubWF0ZXJpYWwgPSB0b25lTWFwcGluZ01hdGVyaWFsO1xyXG5cdFx0dG9uZU1hcHBpbmdNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcclxuXHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVG9TY3JlZW4gPyBudWxsIDogd3JpdGVCdWZmZXIpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbmRlcnMgc29tZXRoaW5nIGludG8gdGhlIHByZXZpb3VzIGx1bWlub3NpdHkgdGV4dHVyZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXHJcblx0ICovXHJcblxyXG5cdGluaXRpYWxpc2UocmVuZGVyZXIpIHtcclxuXHJcblx0XHR0aGlzLnF1YWQubWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHg3ZmZmZmYgfSk7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyVGFyZ2V0UHJldmlvdXMpO1xyXG5cdFx0dGhpcy5xdWFkLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCIvKipcclxuICogQSBjb21waWxhdGlvbiBvZiB0aGUgcG9zdCBwcm9jZXNzaW5nIHBhc3Nlcy5cclxuICpcclxuICogQG1vZHVsZSBwb3N0cHJvY2Vzc2luZy9wYXNzZXNcclxuICovXHJcblxyXG5leHBvcnQgeyBCbG9vbVBhc3MgfSBmcm9tIFwiLi9CbG9vbVBhc3MuanNcIjtcclxuZXhwb3J0IHsgQmx1clBhc3MgfSBmcm9tIFwiLi9CbHVyUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBCb2tlaFBhc3MgfSBmcm9tIFwiLi9Cb2tlaFBhc3MuanNcIjtcclxuZXhwb3J0IHsgQm9rZWgyUGFzcyB9IGZyb20gXCIuL0Jva2VoMlBhc3MuanNcIjtcclxuZXhwb3J0IHsgQ2xlYXJNYXNrUGFzcyB9IGZyb20gXCIuL0NsZWFyTWFza1Bhc3MuanNcIjtcclxuZXhwb3J0IHsgQ2xlYXJQYXNzIH0gZnJvbSBcIi4vQ2xlYXJQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IERvdFNjcmVlblBhc3MgfSBmcm9tIFwiLi9Eb3RTY3JlZW5QYXNzLmpzXCI7XHJcbmV4cG9ydCB7IERlcHRoUGFzcyB9IGZyb20gXCIuL0RlcHRoUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBGaWxtUGFzcyB9IGZyb20gXCIuL0ZpbG1QYXNzLmpzXCI7XHJcbmV4cG9ydCB7IEdsaXRjaE1vZGUsIEdsaXRjaFBhc3MgfSBmcm9tIFwiLi9HbGl0Y2hQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IEdvZFJheXNQYXNzIH0gZnJvbSBcIi4vR29kUmF5c1Bhc3MuanNcIjtcclxuZXhwb3J0IHsgTWFza1Bhc3MgfSBmcm9tIFwiLi9NYXNrUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBQYXNzIH0gZnJvbSBcIi4vUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBQaXhlbGF0aW9uUGFzcyB9IGZyb20gXCIuL1BpeGVsYXRpb25QYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFJlbmRlclBhc3MgfSBmcm9tIFwiLi9SZW5kZXJQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFNhdmVQYXNzIH0gZnJvbSBcIi4vU2F2ZVBhc3MuanNcIjtcclxuZXhwb3J0IHsgU2hhZGVyUGFzcyB9IGZyb20gXCIuL1NoYWRlclBhc3MuanNcIjtcclxuZXhwb3J0IHsgU2hvY2tXYXZlUGFzcyB9IGZyb20gXCIuL1Nob2NrV2F2ZVBhc3MuanNcIjtcclxuZXhwb3J0IHsgU01BQVBhc3MgfSBmcm9tIFwiLi9TTUFBUGFzcy5qc1wiO1xyXG5leHBvcnQgeyBUZXh0dXJlUGFzcyB9IGZyb20gXCIuL1RleHR1cmVQYXNzLmpzXCI7XHJcbmV4cG9ydCB7IFRvbmVNYXBwaW5nUGFzcyB9IGZyb20gXCIuL1RvbmVNYXBwaW5nUGFzcy5qc1wiO1xyXG4iLCJpbXBvcnQge1xyXG5cdERlcHRoU3RlbmNpbEZvcm1hdCxcclxuXHREZXB0aFRleHR1cmUsXHJcblx0TGluZWFyRmlsdGVyLFxyXG5cdFJHQkFGb3JtYXQsXHJcblx0UkdCRm9ybWF0LFxyXG5cdFVuc2lnbmVkSW50MjQ4VHlwZSxcclxuXHRXZWJHTFJlbmRlclRhcmdldFxyXG59IGZyb20gXCJ0aHJlZVwiO1xyXG5cclxuaW1wb3J0IHsgQ2xlYXJNYXNrUGFzcywgTWFza1Bhc3MsIFNoYWRlclBhc3MgfSBmcm9tIFwiLi4vcGFzc2VzXCI7XHJcbmltcG9ydCB7IENvcHlNYXRlcmlhbCB9IGZyb20gXCIuLi9tYXRlcmlhbHNcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgRWZmZWN0Q29tcG9zZXIgbWF5IGJlIHVzZWQgaW4gcGxhY2Ugb2YgYSBub3JtYWwgV2ViR0xSZW5kZXJlci5cclxuICpcclxuICogVGhlIGF1dG8gY2xlYXIgYmVoYXZpb3VyIG9mIHRoZSBwcm92aWRlZCByZW5kZXJlciB3aWxsIGJlIGRpc2FibGVkIHRvIHByZXZlbnRcclxuICogdW5uZWNlc3NhcnkgY2xlYXIgb3BlcmF0aW9ucy5cclxuICpcclxuICogSXQgaXMgY29tbW9uIHByYWN0aWNlIHRvIHVzZSBhIHtAbGluayBSZW5kZXJQYXNzfSBhcyB0aGUgZmlyc3QgcGFzcyB0b1xyXG4gKiBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBzY3JlZW4gYW5kIHJlbmRlciB0aGUgc2NlbmUgdG8gYSB0ZXh0dXJlIGZvciBmdXJ0aGVyXHJcbiAqIHByb2Nlc3NpbmcuXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIEVmZmVjdENvbXBvc2VyIHtcclxuXHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0cyBhIG5ldyBlZmZlY3QgY29tcG9zZXIuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1dlYkdMUmVuZGVyZXJ9IFtyZW5kZXJlcl0gLSBUaGUgcmVuZGVyZXIgdGhhdCBzaG91bGQgYmUgdXNlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZXB0aEJ1ZmZlcj10cnVlXSAtIFdoZXRoZXIgdGhlIG1haW4gcmVuZGVyIHRhcmdldHMgc2hvdWxkIGhhdmUgYSBkZXB0aCBidWZmZXIuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdGVuY2lsQnVmZmVyPWZhbHNlXSAtIFdoZXRoZXIgdGhlIG1haW4gcmVuZGVyIHRhcmdldHMgc2hvdWxkIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcHRoVGV4dHVyZT1mYWxzZV0gLSBTZXQgdG8gdHJ1ZSBpZiBvbmUgb2YgeW91ciBwYXNzZXMgcmVsaWVzIG9uIGEgZGVwdGggdGV4dHVyZS5cclxuXHQgKi9cclxuXHJcblx0Y29uc3RydWN0b3IocmVuZGVyZXIgPSBudWxsLCBvcHRpb25zID0ge30pIHtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByZW5kZXJlci5cclxuXHRcdCAqXHJcblx0XHQgKiBZb3UgbWF5IHJlcGxhY2UgdGhlIHJlbmRlcmVyIGF0IGFueSB0aW1lIGJ5IHVzaW5nXHJcblx0XHQgKiB7QGxpbmsgRWZmZWN0Q29tcG9zZXIjcmVwbGFjZVJlbmRlcmVyfS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJlcn1cclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByZWFkIGJ1ZmZlci5cclxuXHRcdCAqXHJcblx0XHQgKiBSZWFkaW5nIGZyb20gYW5kIHdyaXRpbmcgdG8gdGhlIHNhbWUgcmVuZGVyIHRhcmdldCBzaG91bGQgYmUgYXZvaWRlZC5cclxuXHRcdCAqIFRoZXJlZm9yZSwgdHdvIHNlcGVyYXRlIHlldCBpZGVudGljYWwgYnVmZmVycyBhcmUgdXNlZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7V2ViR0xSZW5kZXJUYXJnZXR9XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblxyXG5cdFx0dGhpcy5yZWFkQnVmZmVyID0gbnVsbDtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB3cml0ZSBidWZmZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogQHR5cGUge1dlYkdMUmVuZGVyVGFyZ2V0fVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMud3JpdGVCdWZmZXIgPSBudWxsO1xyXG5cclxuXHRcdGlmKHRoaXMucmVuZGVyZXIgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XHJcblxyXG5cdFx0XHR0aGlzLnJlYWRCdWZmZXIgPSB0aGlzLmNyZWF0ZUJ1ZmZlcihcclxuXHRcdFx0XHQob3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkKSA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlLFxyXG5cdFx0XHRcdChvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiBmYWxzZSxcclxuXHRcdFx0XHQob3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCkgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IGZhbHNlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHR0aGlzLndyaXRlQnVmZmVyID0gdGhpcy5yZWFkQnVmZmVyLmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQSBjb3B5IHBhc3MgdXNlZCBmb3IgY29weWluZyBtYXNrZWQgc2NlbmVzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEB0eXBlIHtTaGFkZXJQYXNzfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMuY29weVBhc3MgPSBuZXcgU2hhZGVyUGFzcyhuZXcgQ29weU1hdGVyaWFsKCkpO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHBhc3Nlcy5cclxuXHRcdCAqXHJcblx0XHQgKiBAdHlwZSB7UGFzc1tdfVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cclxuXHRcdHRoaXMucGFzc2VzID0gW107XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIGRlcHRoIHRleHR1cmUgb2YgdGhlIHJlYWQgYW5kIHdyaXRlIGJ1ZmZlcnMuXHJcblx0ICpcclxuXHQgKiBAdHlwZSB7RGVwdGhUZXh0dXJlfVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKi9cclxuXHJcblx0Z2V0IGRlcHRoVGV4dHVyZSgpIHsgcmV0dXJuIHRoaXMucmVhZEJ1ZmZlci5kZXB0aFRleHR1cmU7IH1cclxuXHJcblx0LyoqXHJcblx0ICogVGhlIHJlYWQgYW5kIHdyaXRlIGJ1ZmZlcnMgc2hhcmUgYSBzaW5nbGUgZGVwdGggdGV4dHVyZS4gRGVwdGggd2lsbCBiZVxyXG5cdCAqIHdyaXR0ZW4gdG8gdGhpcyB0ZXh0dXJlIHdoZW4gc29tZXRoaW5nIGlzIHJlbmRlcmVkIGludG8gb25lIG9mIHRoZSBidWZmZXJzXHJcblx0ICogYW5kIHRoZSBpbnZvbHZlZCBtYXRlcmlhbHMgaGF2ZSBkZXB0aCB3cml0ZSBlbmFibGVkLlxyXG5cdCAqXHJcblx0ICogWW91IG1heSBlbmFibGUgdGhpcyBtZWNoYW5pc20gZHVyaW5nIHRoZSBpbnN0YW50aWF0aW9uIG9mIHRoZSBjb21wb3NlciBvclxyXG5cdCAqIGJ5IGFzc2lnbmluZyBhIERlcHRoVGV4dHVyZSBpbnN0YW5jZSBsYXRlciBvbi4gWW91IG1heSBhbHNvIGRpc2FibGUgaXQgYnlcclxuXHQgKiBhc3NpZ25pbmcgbnVsbC5cclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtEZXB0aFRleHR1cmV9XHJcblx0ICovXHJcblxyXG5cdHNldCBkZXB0aFRleHR1cmUoeCkge1xyXG5cclxuXHRcdHRoaXMucmVhZEJ1ZmZlci5kZXB0aFRleHR1cmUgPSB4O1xyXG5cdFx0dGhpcy53cml0ZUJ1ZmZlci5kZXB0aFRleHR1cmUgPSB4O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlcGxhY2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIG9uZS4gVGhlIERPTSBlbGVtZW50IG9mIHRoZVxyXG5cdCAqIGN1cnJlbnQgcmVuZGVyZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IG5vZGUgYW5kIHRoZVxyXG5cdCAqIERPTSBlbGVtZW50IG9mIHRoZSBuZXcgcmVuZGVyZXIgd2lsbCB0YWtlIGl0cyBwbGFjZS5cclxuXHQgKlxyXG5cdCAqIFRoZSBhdXRvIGNsZWFyIG1lY2hhbmlzbSBvZiB0aGUgcHJvdmlkZWQgcmVuZGVyZXIgd2lsbCBiZSBkaXNhYmxlZC5cclxuXHQgKlxyXG5cdCAqIFN3aXRjaGluZyBiZXR3ZWVuIHJlbmRlcmVycyBhbGxvd3MgeW91IHRvIGR5bmFtaWNhbGx5IGVuYWJsZSBvciBkaXNhYmxlXHJcblx0ICogYW50aWFsaWFzaW5nLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSBuZXcgcmVuZGVyZXIuXHJcblx0ICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gVGhlIG9sZCByZW5kZXJlci5cclxuXHQgKi9cclxuXHJcblx0cmVwbGFjZVJlbmRlcmVyKHJlbmRlcmVyKSB7XHJcblxyXG5cdFx0Y29uc3Qgb2xkUmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cclxuXHRcdGxldCBwYXJlbnQsIG9sZFNpemUsIG5ld1NpemU7XHJcblxyXG5cdFx0aWYob2xkUmVuZGVyZXIgIT09IG51bGwgJiYgb2xkUmVuZGVyZXIgIT09IHJlbmRlcmVyKSB7XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcblx0XHRcdHRoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XHJcblxyXG5cdFx0XHRwYXJlbnQgPSBvbGRSZW5kZXJlci5kb21FbGVtZW50LnBhcmVudE5vZGU7XHJcblx0XHRcdG9sZFNpemUgPSBvbGRSZW5kZXJlci5nZXRTaXplKCk7XHJcblx0XHRcdG5ld1NpemUgPSByZW5kZXJlci5nZXRTaXplKCk7XHJcblxyXG5cdFx0XHRpZihwYXJlbnQgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKG9sZFJlbmRlcmVyLmRvbUVsZW1lbnQpO1xyXG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKG9sZFNpemUud2lkdGggIT09IG5ld1NpemUud2lkdGggfHwgb2xkU2l6ZS5oZWlnaHQgIT09IG5ld1NpemUuaGVpZ2h0KSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2V0U2l6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2xkUmVuZGVyZXI7XHJcblxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlcyBhIG5ldyByZW5kZXIgdGFyZ2V0IGJ5IHJlcGxpY2F0aW5nIHRoZSByZW5kZXJlcidzIGNhbnZhcy5cclxuXHQgKlxyXG5cdCAqIFRoZSBjcmVhdGVkIHJlbmRlciB0YXJnZXQgdXNlcyBhIGxpbmVhciBmaWx0ZXIgZm9yIHRleGVsIG1pbmlmaWNhdGlvbiBhbmRcclxuXHQgKiBtYWduaWZpY2F0aW9uLiBJdHMgcmVuZGVyIHRleHR1cmUgZm9ybWF0IGRlcGVuZHMgb24gd2hldGhlciB0aGUgcmVuZGVyZXJcclxuXHQgKiB1c2VzIHRoZSBhbHBoYSBjaGFubmVsLiBNaXBtYXBzIGFyZSBkaXNhYmxlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVwdGhCdWZmZXIgLSBXaGV0aGVyIHRoZSByZW5kZXIgdGFyZ2V0IHNob3VsZCBoYXZlIGEgZGVwdGggYnVmZmVyLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RlbmNpbEJ1ZmZlciAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGhhdmUgYSBzdGVuY2lsIGJ1ZmZlci5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRlcHRoVGV4dHVyZSAtIFdoZXRoZXIgdGhlIHJlbmRlciB0YXJnZXQgc2hvdWxkIGhhdmUgYSBkZXB0aCB0ZXh0dXJlLlxyXG5cdCAqIEByZXR1cm4ge1dlYkdMUmVuZGVyVGFyZ2V0fSBBIG5ldyByZW5kZXIgdGFyZ2V0IHRoYXQgZXF1YWxzIHRoZSByZW5kZXJlcidzIGNhbnZhcy5cclxuXHQgKi9cclxuXHJcblx0Y3JlYXRlQnVmZmVyKGRlcHRoQnVmZmVyLCBzdGVuY2lsQnVmZmVyLCBkZXB0aFRleHR1cmUpIHtcclxuXHJcblx0XHRjb25zdCBzaXplID0gdGhpcy5yZW5kZXJlci5nZXRTaXplKCk7XHJcblx0XHRjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5yZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XHJcblx0XHRjb25zdCBhbHBoYSA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcygpLmFscGhhO1xyXG5cclxuXHRcdGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChzaXplLndpZHRoICogcGl4ZWxSYXRpbywgc2l6ZS5oZWlnaHQgKiBwaXhlbFJhdGlvLCB7XHJcblx0XHRcdG1pbkZpbHRlcjogTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtYWdGaWx0ZXI6IExpbmVhckZpbHRlcixcclxuXHRcdFx0Zm9ybWF0OiBhbHBoYSA/IFJHQkFGb3JtYXQgOiBSR0JGb3JtYXQsXHJcblx0XHRcdGRlcHRoQnVmZmVyOiBkZXB0aEJ1ZmZlcixcclxuXHRcdFx0c3RlbmNpbEJ1ZmZlcjogc3RlbmNpbEJ1ZmZlcixcclxuXHRcdFx0ZGVwdGhUZXh0dXJlOiBkZXB0aFRleHR1cmUgPyBuZXcgRGVwdGhUZXh0dXJlKCkgOiBudWxsXHJcblx0XHR9KTtcclxuXHJcblx0XHRpZihkZXB0aFRleHR1cmUgJiYgc3RlbmNpbEJ1ZmZlcikge1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XHJcblx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUudHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFwiRWZmZWN0Q29tcG9zZXIuQnVmZmVyXCI7XHJcblx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gcmVuZGVyVGFyZ2V0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBwYXNzLCBvcHRpb25hbGx5IGF0IGEgc3BlY2lmaWMgaW5kZXguXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1Bhc3N9IHBhc3MgLSBBIG5ldyBwYXNzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIC0gQW4gaW5kZXggYXQgd2hpY2ggdGhlIHBhc3Mgc2hvdWxkIGJlIGluc2VydGVkLlxyXG5cdCAqL1xyXG5cclxuXHRhZGRQYXNzKHBhc3MsIGluZGV4KSB7XHJcblxyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IHJlbmRlcmVyLmdldFNpemUoKTtcclxuXHRcdGNvbnN0IHBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XHJcblxyXG5cdFx0cGFzcy5zZXRTaXplKHNpemUud2lkdGggKiBwaXhlbFJhdGlvLCBzaXplLmhlaWdodCAqIHBpeGVsUmF0aW8pO1xyXG5cdFx0cGFzcy5pbml0aWFsaXNlKHJlbmRlcmVyLCByZW5kZXJlci5jb250ZXh0LmdldENvbnRleHRBdHRyaWJ1dGVzKCkuYWxwaGEpO1xyXG5cclxuXHRcdGlmKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdHRoaXMucGFzc2VzLnNwbGljZShpbmRleCwgMCwgcGFzcyk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMucGFzc2VzLnB1c2gocGFzcyk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgYSBwYXNzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtQYXNzfSBwYXNzIC0gVGhlIHBhc3MuXHJcblx0ICovXHJcblxyXG5cdHJlbW92ZVBhc3MocGFzcykge1xyXG5cclxuXHRcdHRoaXMucGFzc2VzLnNwbGljZSh0aGlzLnBhc3Nlcy5pbmRleE9mKHBhc3MpLCAxKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW5kZXJzIGFsbCBlbmFibGVkIHBhc3NlcyBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGFkZGVkLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIC0gVGhlIHRpbWUgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlIGN1cnJlbnQgb25lIGluIHNlY29uZHMuXHJcblx0ICovXHJcblxyXG5cdHJlbmRlcihkZWx0YSkge1xyXG5cclxuXHRcdGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xyXG5cdFx0Y29uc3QgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cdFx0Y29uc3QgY29weVBhc3MgPSB0aGlzLmNvcHlQYXNzO1xyXG5cclxuXHRcdGxldCByZWFkQnVmZmVyID0gdGhpcy5yZWFkQnVmZmVyO1xyXG5cdFx0bGV0IHdyaXRlQnVmZmVyID0gdGhpcy53cml0ZUJ1ZmZlcjtcclxuXHJcblx0XHRsZXQgbWFza0FjdGl2ZSA9IGZhbHNlO1xyXG5cdFx0bGV0IHBhc3MsIGNvbnRleHQsIGJ1ZmZlcjtcclxuXHRcdGxldCBpLCBsO1xyXG5cclxuXHRcdGZvcihpID0gMCwgbCA9IHBhc3Nlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuXHJcblx0XHRcdHBhc3MgPSBwYXNzZXNbaV07XHJcblxyXG5cdFx0XHRpZihwYXNzLmVuYWJsZWQpIHtcclxuXHJcblx0XHRcdFx0cGFzcy5yZW5kZXIocmVuZGVyZXIsIHJlYWRCdWZmZXIsIHdyaXRlQnVmZmVyLCBkZWx0YSwgbWFza0FjdGl2ZSk7XHJcblxyXG5cdFx0XHRcdGlmKHBhc3MubmVlZHNTd2FwKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYobWFza0FjdGl2ZSkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y29udGV4dCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRcdFx0XHRcdGNvbnRleHQuc3RlbmNpbEZ1bmMoY29udGV4dC5OT1RFUVVBTCwgMSwgMHhmZmZmZmZmZik7XHJcblx0XHRcdFx0XHRcdGNvcHlQYXNzLnJlbmRlcihyZW5kZXJlciwgcmVhZEJ1ZmZlciwgd3JpdGVCdWZmZXIpO1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnN0ZW5jaWxGdW5jKGNvbnRleHQuRVFVQUwsIDEsIDB4ZmZmZmZmZmYpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRidWZmZXIgPSByZWFkQnVmZmVyO1xyXG5cdFx0XHRcdFx0cmVhZEJ1ZmZlciA9IHdyaXRlQnVmZmVyO1xyXG5cdFx0XHRcdFx0d3JpdGVCdWZmZXIgPSBidWZmZXI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYocGFzcyBpbnN0YW5jZW9mIE1hc2tQYXNzKSB7XHJcblxyXG5cdFx0XHRcdFx0bWFza0FjdGl2ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZihwYXNzIGluc3RhbmNlb2YgQ2xlYXJNYXNrUGFzcykge1xyXG5cclxuXHRcdFx0XHRcdG1hc2tBY3RpdmUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBidWZmZXJzIGFuZCB0aGUgcmVuZGVyZXIncyBvdXRwdXQgY2FudmFzLlxyXG5cdCAqXHJcblx0ICogRXZlcnkgcGFzcyB3aWxsIGJlIGluZm9ybWVkIG9mIHRoZSBuZXcgc2l6ZS4gSXQncyB1cCB0byBlYWNoIHBhc3MgaG93IHRoYXRcclxuXHQgKiBpbmZvcm1hdGlvbiBpcyB1c2VkLlxyXG5cdCAqXHJcblx0ICogSWYgbm8gd2lkdGggb3IgaGVpZ2h0IGlzIHNwZWNpZmllZCwgdGhlIHJlbmRlciB0YXJnZXRzIGFuZCBwYXNzZXMgd2lsbCBiZVxyXG5cdCAqIHVwZGF0ZWQgd2l0aCB0aGUgY3VycmVudCBzaXplIG9mIHRoZSByZW5kZXJlci5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdIC0gVGhlIHdpZHRoLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0XSAtIFRoZSBoZWlnaHQuXHJcblx0ICovXHJcblxyXG5cdHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG5cclxuXHRcdGNvbnN0IHBhc3NlcyA9IHRoaXMucGFzc2VzO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMucmVuZGVyZXIuZ2V0U2l6ZSgpO1xyXG5cdFx0Y29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG5cclxuXHRcdGxldCBpLCBsO1xyXG5cclxuXHRcdGlmKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuXHJcblx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aDtcclxuXHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuXHJcblx0XHR3aWR0aCAqPSBwaXhlbFJhdGlvO1xyXG5cdFx0aGVpZ2h0ICo9IHBpeGVsUmF0aW87XHJcblxyXG5cdFx0dGhpcy5yZWFkQnVmZmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblx0XHR0aGlzLndyaXRlQnVmZmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0Zm9yKGkgPSAwLCBsID0gcGFzc2VzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xyXG5cclxuXHRcdFx0cGFzc2VzW2ldLnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0cyB0aGlzIGNvbXBvc2VyIGJ5IGRlbGV0aW5nIGFsbCBwYXNzZXMgYW5kIGNyZWF0aW5nIG5ldyBidWZmZXJzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldF0gLSBBIG5ldyByZW5kZXIgdGFyZ2V0LiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGUgc2V0dGluZ3Mgb2YgdGhlIHJlbmRlcmVyIHdpbGwgYmUgdXNlZC5cclxuXHQgKi9cclxuXHJcblx0cmVzZXQocmVuZGVyVGFyZ2V0KSB7XHJcblxyXG5cdFx0Y29uc3QgZGVwdGhCdWZmZXIgPSB0aGlzLnJlYWRCdWZmZXIuZGVwdGhCdWZmZXI7XHJcblx0XHRjb25zdCBzdGVuY2lsQnVmZmVyID0gdGhpcy5yZWFkQnVmZmVyLnN0ZW5jaWxCdWZmZXI7XHJcblx0XHRjb25zdCBkZXB0aFRleHR1cmUgPSAodGhpcy5yZWFkQnVmZmVyLmRlcHRoVGV4dHVyZSAhPT0gbnVsbCk7XHJcblxyXG5cdFx0dGhpcy5kaXNwb3NlKChyZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCkgP1xyXG5cdFx0XHR0aGlzLmNyZWF0ZUJ1ZmZlcihkZXB0aEJ1ZmZlciwgc3RlbmNpbEJ1ZmZlciwgZGVwdGhUZXh0dXJlKSA6XHJcblx0XHRcdHJlbmRlclRhcmdldFxyXG5cdFx0KTtcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEZXN0cm95cyBhbGwgcGFzc2VzIGFuZCByZW5kZXIgdGFyZ2V0cy5cclxuXHQgKlxyXG5cdCAqIFRoaXMgbWV0aG9kIGRlYWxsb2NhdGVzIGFsbCByZW5kZXIgdGFyZ2V0cywgdGV4dHVyZXMgYW5kIG1hdGVyaWFscyBjcmVhdGVkXHJcblx0ICogYnkgdGhlIHBhc3Nlcy4gSXQgYWxzbyBkZWxldGVzIHRoaXMgY29tcG9zZXIncyBmcmFtZSBidWZmZXJzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtXZWJHTFJlbmRlclRhcmdldH0gW3JlbmRlclRhcmdldF0gLSBBIG5ldyByZW5kZXIgdGFyZ2V0LiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGUgY29tcG9zZXIgd2lsbCBiZWNvbWUgaW5vcGVyYXRpdmUuXHJcblx0ICovXHJcblxyXG5cdGRpc3Bvc2UocmVuZGVyVGFyZ2V0KSB7XHJcblxyXG5cdFx0Y29uc3QgcGFzc2VzID0gdGhpcy5wYXNzZXM7XHJcblxyXG5cdFx0aWYodGhpcy5yZWFkQnVmZmVyICE9PSBudWxsICYmIHRoaXMud3JpdGVCdWZmZXIgIT09IG51bGwpIHtcclxuXHJcblx0XHRcdHRoaXMucmVhZEJ1ZmZlci5kaXNwb3NlKCk7XHJcblx0XHRcdHRoaXMud3JpdGVCdWZmZXIuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5yZWFkQnVmZmVyID0gbnVsbDtcclxuXHRcdFx0dGhpcy53cml0ZUJ1ZmZlciA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHdoaWxlKHBhc3Nlcy5sZW5ndGggPiAwKSB7XHJcblxyXG5cdFx0XHRwYXNzZXMucG9wKCkuZGlzcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZihyZW5kZXJUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuXHRcdFx0Ly8gUmVhbmltYXRlLlxyXG5cdFx0XHR0aGlzLnJlYWRCdWZmZXIgPSByZW5kZXJUYXJnZXQ7XHJcblx0XHRcdHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLnJlYWRCdWZmZXIuY2xvbmUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5jb3B5UGFzcy5kaXNwb3NlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59XHJcbiIsImltcG9ydCB7RWZmZWN0Q29tcG9zZXJ9IGZyb20gJ3Bvc3Rwcm9jZXNzaW5nL3NyYy9jb3JlL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7UmVuZGVyUGFzc30gZnJvbSAncG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9SZW5kZXJQYXNzJztcbmltcG9ydCB7U2hhZGVyUGFzc30gZnJvbSAncG9zdHByb2Nlc3Npbmcvc3JjL3Bhc3Nlcy9TaGFkZXJQYXNzJztcblxuaW1wb3J0IHtMb29wfSBmcm9tICcuLi8uLi9jb3JlL0xvb3AnO1xuXG5jb25zdCBwb2x5ZmlsbCA9IChvYmplY3QsIG1ldGhvZCwgc2hvd1dhcm4gPSB0cnVlKSA9PiB7XG4gIGlmIChvYmplY3RbbWV0aG9kXSkgcmV0dXJuO1xuICBpZiAoc2hvd1dhcm4pIGNvbnNvbGUud2FybihgQFBvc3RQcm9jZXNzb3JNb2R1bGU6IHBhc3MuJHttZXRob2R9KCkgd2FzIG5vdCBmb3VuZC5gLCBvYmplY3QpO1xuICBvYmplY3RbbWV0aG9kXSA9ICgpID0+IHt9O1xufTtcblxuLyoqXG4gKiBAY2xhc3MgUG9zdFByb2Nlc3Nvck1vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleGFtcGxlIDxjYXB0aW9uPiBDcmVhdGluZyBhIHJlbmRlcmluZyBtb2R1bGUgYW5kIHBhc3NpbmcgaXQgdG8gQXBwJ3MgbW9kdWxlczwvY2FwdGlvbj5cbiAqIG5ldyBBcHAoW1xuICogICBuZXcgRWxlbWVudE1vZHVsZSgpLFxuICogICBuZXcgU2NlbmVNb2R1bGUoKSxcbiAqICAgbmV3IERlZmluZU1vZHVsZSgnY2FtZXJhJywgbmV3IFdIUy5QZXJzcGVjdGl2ZUNhbWVyYSh7XG4gKiAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDYsIDE4KSxcbiAqICAgICBmYXI6IDEwMDAwXG4gKiAgIH0pKSxcbiAqICAgbmV3IFJlbmRlcmluZ01vZHVsZSgpLFxuICogICBuZXcgUG9zdFByb2Nlc3Nvck1vZHVsZSgpXG4gKiBdKTtcbiAqXG4gKiBjb25zdCBwcm9jZXNzb3IgPSBhcHAudXNlKCdwb3N0cHJvY2Vzc29yJyk7XG4gKlxuICogcHJvY2Vzc29yXG4gKiAgIC5yZW5kZXIoKVxuICogICAucGFzcyhuZXcgR2xpdGNoUGFzcygpKVxuICogICAucmVuZGVyVG9TY3JlZW4oKVxuICovXG5leHBvcnQgY2xhc3MgUG9zdFByb2Nlc3Nvck1vZHVsZSB7XG4gIGN1cnJlbnRQYXNzID0gbnVsbDtcblxuICBkZWZlciA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkZWJ1ZzogdHJ1ZVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IFBvc3RQcm9jZXNzb3JNb2R1bGUuZGVmYXVsdHMpIHtcbiAgICB0aGlzLmRlYnVnID0gcGFyYW1zLmRlYnVnO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ3Bvc3Rwcm9jZXNzb3InKTtcblxuICAgIHRoaXMuZWZmZWN0cyA9IG1hbmFnZXIudXNlKCdyZW5kZXJpbmcnKS5lZmZlY3RzO1xuICAgIHRoaXMucmVuZGVyZXIgPSBtYW5hZ2VyLmdldCgncmVuZGVyZXInKTtcbiAgICB0aGlzLnNjZW5lID0gbWFuYWdlci5nZXQoJ3NjZW5lJyk7XG4gICAgdGhpcy5jYW1lcmEgPSBtYW5hZ2VyLmdldCgnY2FtZXJhJyk7XG5cbiAgICB0aGlzLmNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHRoaXMucmVuZGVyZXIsIHRoaXMucGFyYW1zKTtcblxuICAgIG1hbmFnZXIudXNlKCdyZW5kZXJpbmcnKS5zdG9wKCk7XG5cbiAgICBjb25zdCBjb21wb3NlciA9IHRoaXMuY29tcG9zZXI7XG4gICAgdGhpcy5yZW5kZXJMb29wID0gbmV3IExvb3AoY2xvY2sgPT4gY29tcG9zZXIucmVuZGVyKGNsb2NrLmdldERlbHRhKCkpKS5zdGFydChtYW5hZ2VyLmhhbmRsZXIpO1xuXG4gICAgbWFuYWdlci51cGRhdGUoe1xuICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyID0+IHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5yZXBsYWNlUmVuZGVyZXIocmVuZGVyZXIpO1xuICAgICAgfSxcblxuICAgICAgc2NlbmU6IHNjZW5lID0+IHtcbiAgICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgfSxcblxuICAgICAgY2FtZXJhOiBjYW1lcmEgPT4ge1xuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVuZGVyXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIFJlbmRlclBhc3NcbiAgICogQHJldHVybiB7dGhpc31cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5Qb3N0UHJvY2Vzc29yTW9kdWxlXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgdGhpcy5kZWZlci50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3MgPSBuZXcgUmVuZGVyUGFzcyh0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYS5uYXRpdmUpO1xuXG4gICAgICAvLyBUT0RPOiBTdXBwb3J0IGZvciBlZmZlY3RzLlxuXG4gICAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3MocGFzcyk7XG4gICAgICB0aGlzLmN1cnJlbnRQYXNzID0gcGFzcztcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGFzc1xuICAgKiBAZGVzY3JpcHRpb24gQWRkcyB5b3VyIGN1c3RvbSBwYXNzXG4gICAqIEBwYXJhbSB7UGFzc30gcGFzcyBBIGN1c3RvbSBwYXNzXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUG9zdFByb2Nlc3Nvck1vZHVsZVxuICAgKi9cbiAgcGFzcyhwYXNzKSB7XG4gICAgdGhpcy5kZWZlci50aGVuKCgpID0+IHtcbiAgICAgIHBvbHlmaWxsKHBhc3MsICdzZXRTaXplJywgdGhpcy5kZWJ1Zyk7XG4gICAgICBwb2x5ZmlsbChwYXNzLCAnaW5pdGlhbGlzZScsIHRoaXMuZGVidWcpO1xuXG4gICAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3MocGFzcyk7XG4gICAgICB0aGlzLmN1cnJlbnRQYXNzID0gcGFzcztcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hhZGVyXG4gICAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgcGFzcyBtYWRlIGZyb20gc2hhZGVyIG1hdGVyaWFsXG4gICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1hdGVyaWFsIEEgU2hhZGVyTWF0ZXJpYWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHR1cmVJRCBOYW1lIG9mIHRoZSByZWFkQnVmZmVyIHVuaWZvcm1cbiAgICogQHJldHVybiB7dGhpc31cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5Qb3N0UHJvY2Vzc29yTW9kdWxlXG4gICAqL1xuICBzaGFkZXIobWF0ZXJpYWwsIHRleHR1cmVJRCA9ICdyZWFkQnVmZmVyJykge1xuICAgIHRoaXMuZGVmZXIudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIW1hdGVyaWFsLnVuaWZvcm1zW3RleHR1cmVJRF0pXG4gICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW3RleHR1cmVJRF0gPSB7dmFsdWU6IG51bGx9O1xuXG4gICAgICBjb25zdCBwYXNzID0gbmV3IFNoYWRlclBhc3MobWF0ZXJpYWwsIHRleHR1cmVJRCk7XG5cbiAgICAgIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhwYXNzKTtcbiAgICAgIHRoaXMuY3VycmVudFBhc3MgPSBwYXNzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBnZXRcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBwYXNzIGJ5IHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXNzXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUG9zdFByb2Nlc3Nvck1vZHVsZVxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZVxuICAgICAgPyB0aGlzLmNvbXBvc2VyLnBhc3Nlcy5maWx0ZXIocGFzcyA9PiBwYXNzLm5hbWUgPT09IG5hbWUpWzBdXG4gICAgICA6IHRoaXMuY3VycmVudFBhc3M7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW5kZXJUb1NjcmVlblxuICAgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgcmVuZGVyVG9TY3JlZW4gcHJvcGVydHkgb2YgY3VycmVudFBhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lPXRydWVdIFRoZSBuYW1lIG9mIHRoZSBwYXNzXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuUG9zdFByb2Nlc3Nvck1vZHVsZVxuICAgKi9cbiAgcmVuZGVyVG9TY3JlZW4oYm9vbCA9IHRydWUpIHtcbiAgICB0aGlzLmRlZmVyLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50UGFzcy5yZW5kZXJUb1NjcmVlbiA9IGJvb2w7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBAY2xhc3MgRXZlbnRzUGF0Y2hNb2R1bGVcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG9uZSBpcyB1c2VkIGluIHRoZSBjb3JlIHRvIGhhbmRsZSBldmVudHMgdXNlZCBieSBtb2R1bGVzLiBJZiB5b3Ugd2FudCB0byBtYWtlIGN1c3RvbSBldmVudHMgLSBwbGVhc2UgbWFrZSBhIHNpbWlsYXIgb25lLlxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudHNQYXRjaE1vZHVsZSB7XG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuZGVmaW5lKCdldmVudHMnKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmdldCgncmVuZGVyZXInKS5kb21FbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvbiBwYXRjaEV2ZW50c1xuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2RzIHBhdGNoZXMgdGhlIGxpc3Qgb2YgZXZlbnRzIG9uIHNwZWNpZmljIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9yaWdpbk9iamVjdCAtIFRoZSBvYmplY3QgdGhhdCBnaXZlcyBldmVudHMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZGVzdE9iamVjdD10aGlzXSAtIFRoZSBvYmplY3QgdGhhdCB0YWtlcyBldmVudHMuXG4gICAqIEBwYXJhbSB7QXJyYXlbU3RyaW5nc119IFtldmVudHM9W11dIC0gVGhlIGxpc3Qgb2YgZXZlbnRzIGJ5IG5hbWVzLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLkV2ZW50c1BhdGNoTW9kdWxlXG4gICAqL1xuICBwYXRjaEV2ZW50cyhvcmlnaW5PYmplY3QsIGRlc3RPYmplY3QgPSB0aGlzLCBldmVudHMgPSBbXSkge1xuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+XG4gICAgICBvcmlnaW5PYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZSA9PiBkZXN0T2JqZWN0LmVtaXQoZXZlbnQsIGUpKVxuICAgICk7XG4gIH1cblxuICBpbnRlZ3JhdGUoc2VsZikge1xuICAgIGNvbnN0IHtlbGVtZW50LCBwYXRjaEV2ZW50c30gPSBzZWxmO1xuXG4gICAgcGF0Y2hFdmVudHMoZWxlbWVudCwgdGhpcywgW1xuICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAnbW91c2V1cCcsXG4gICAgICAnY29udGV4dG1lbnUnLFxuICAgICAgJ21vdXNlZG93bicsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3doZWVsJyxcbiAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICd0b3VjaGVuZCcsXG4gICAgICAndG91Y2htb3ZlJyxcbiAgICAgICdrZXlkb3duJyxcbiAgICAgICdrZXl1cCcsXG4gICAgICAna2V5cHJlc3MnXG4gICAgXSk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFZlY3RvcjIsXG4gIFJheWNhc3RlcixcbiAgUGxhbmUsXG4gIFZlY3RvcjNcbn0gZnJvbSAndGhyZWUnO1xuXG5pbXBvcnQgRXZlbnRzIGZyb20gJ21pbml2ZW50cyc7XG5pbXBvcnQge0V2ZW50c1BhdGNoTW9kdWxlfSBmcm9tICcuL0V2ZW50c1BhdGNoTW9kdWxlJztcblxuLyoqXG4gKiBAY2xhc3MgVmlydHVhbE1vdXNlTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9hcHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2dsb2JhbE1vdmVtZW50PWZhbHNlXVxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcFxuICogQGV4dGVuZHMgRXZlbnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsTW91c2VNb2R1bGUgZXh0ZW5kcyBFdmVudHMge1xuICBtb3VzZSA9IG5ldyBWZWN0b3IyKCk7XG4gIHJheWNhc3RlciA9IG5ldyBSYXljYXN0ZXIoKTtcbiAgd29ybGQgPSBudWxsO1xuICBjYW52YXMgPSBudWxsO1xuICBwcm9qZWN0aW9uUGxhbmUgPSBuZXcgUGxhbmUobmV3IFZlY3RvcjMoMCwgMCwgMSksIDApO1xuXG4gIGNvbnN0cnVjdG9yKGdsb2JhbE1vdmVtZW50ID0gZmFsc2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2xvYmFsTW92ZW1lbnQgPSBnbG9iYWxNb3ZlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZShlLCBjdXN0b21YLCBjdXN0b21ZKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgY29uc3QgeCA9IGN1c3RvbVggfHwgZS5jbGllbnRYO1xuICAgIGNvbnN0IHkgPSBjdXN0b21ZIHx8IGUuY2xpZW50WTtcblxuICAgIHRoaXMubW91c2UueCA9ICgoeCAtIHJlY3QubGVmdCkgLyAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkpICogMiAtIDE7XG4gICAgdGhpcy5tb3VzZS55ID0gLSgoeSAtIHJlY3QudG9wKSAvIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSkgKiAyICsgMTtcblxuICAgIHRoaXMucHJvamVjdGlvblBsYW5lLm5vcm1hbC5jb3B5KHRoaXMuY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKCkpO1xuXG4gICAgdGhpcy5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSh0aGlzLm1vdXNlLCB0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5lbWl0KCdtb3ZlJyk7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLmRlZmluZSgnbW91c2UnKTtcbiAgICBtYW5hZ2VyLnJlcXVpcmUoJ2V2ZW50cycsICgpID0+IG5ldyBFdmVudHNQYXRjaE1vZHVsZSgpKTtcblxuICAgIHRoaXMuY2FudmFzID0gbWFuYWdlci5nZXQoJ3JlbmRlcmVyJykuZG9tRWxlbWVudDtcbiAgICB0aGlzLmNhbWVyYSA9IG1hbmFnZXIuZ2V0KCdjYW1lcmEnKS5uYXRpdmU7XG4gIH1cblxuICBpbnRlZ3JhdGUoc2VsZikge1xuICAgIFtcbiAgICAgICdjbGljaycsXG4gICAgICAnbW91c2Vkb3duJyxcbiAgICAgICdtb3VzZXVwJyxcbiAgICAgICdtb3VzZW1vdmUnXG4gICAgXS5mb3JFYWNoKGV2ID0+IHRoaXMub24oZXYsIGUgPT4gc2VsZi5lbWl0KGV2LCBlKSkpO1xuXG4gICAgc2VsZi5nbG9iYWxYID0gMDtcbiAgICBzZWxmLmdsb2JhbFkgPSAwO1xuXG4gICAgdGhpcy5vbignbW91c2Vtb3ZlJywgZSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHNlbGYuZ2xvYmFsWCArPSBlLm1vdmVtZW50WDtcbiAgICAgICAgc2VsZi5nbG9iYWxZICs9IGUubW92ZW1lbnRZO1xuXG4gICAgICAgIHNlbGYudXBkYXRlKGUsIHNlbGYuZ2xvYmFsWCwgc2VsZi5nbG9iYWxZKTtcbiAgICAgIH0gZWxzZSBzZWxmLnVwZGF0ZShlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRyYWNrXG4gICAqIEBkZXNjcmlwdGlvbiBTdGFydHMgdHJhY2tpbmcgZXZlbnRzIG9uIGEgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgQSBjb21wb25lbnQsIHRoYXQgc2hvdWxkIGJlIHRyYWNrZWQgYnkgdGhlIG1vdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVzdGVkIFdoZXRoZXIgY29tcG9uZW50J3MgY2hpbGRyZW4gc2hvdWxkIGJlIHRyYWNrZWQgb3Igbm90XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuVmlydHVhbE1vdXNlTW9kdWxlXG4gICAqL1xuICB0cmFjayhjb21wb25lbnQsIG5lc3RlZCA9IHRydWUpIHtcbiAgICBsZXQgaXNIb3ZlcmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLm9uKCdtb3ZlJywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaG92ZXJzKGNvbXBvbmVudCwgbmVzdGVkKSkge1xuICAgICAgICBpZiAoaXNIb3ZlcmVkKSBjb21wb25lbnQuZW1pdCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudC5lbWl0KCdtb3VzZW92ZXInKTtcbiAgICAgICAgICBpc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzSG92ZXJlZCkge1xuICAgICAgICBjb21wb25lbnQuZW1pdCgnbW91c2VvdXQnKTtcbiAgICAgICAgaXNIb3ZlcmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmIChpc0hvdmVyZWQpIGNvbXBvbmVudC5lbWl0KCdjbGljaycpO1xuICAgICAgZWxzZSBjb21wb25lbnQuZW1pdCgnb2ZmQ2xpY2snKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgIGlmIChpc0hvdmVyZWQpIGNvbXBvbmVudC5lbWl0KCdtb3VzZWRvd24nKTtcbiAgICB9KTtcblxuICAgIHRoaXMub24oJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICBpZiAoaXNIb3ZlcmVkKSBjb21wb25lbnQuZW1pdCgnbW91c2V1cCcpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW50ZXJzZWN0aW9uXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGFuIGludGVyc2VjdGlvbiBkYXRhXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBpbnRlcnNlY3RzIHdpdGggbW91c2UgcmF5IChvciBkb2Vzbid0KVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lc3RlZCBXaGV0aGVyIGNvbXBvbmVudCdzIGNoaWxkcmVuIHNob3VsZCBiZSB0cmFja2VkIG9yIG5vdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gaW50ZXJzZWN0aW9uIGRhdGEuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuVmlydHVhbE1vdXNlTW9kdWxlXG4gICAqL1xuICBpbnRlcnNlY3Rpb24oe25hdGl2ZX0sIG5lc3RlZCA9IHRydWUpIHtcbiAgICBpZiAobmF0aXZlLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgbmVzdGVkKSB7XG4gICAgICBjb25zdCBvYmplY3RzID0gW107XG4gICAgICBuYXRpdmUudHJhdmVyc2UoY2hpbGQgPT4gb2JqZWN0cy5wdXNoKGNoaWxkKSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKG9iamVjdHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3QobmF0aXZlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHByb2plY3RcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSB2ZWN0b3IgYmFzZWQgb24gbW91c2UgcmF5IGludGVyc2VjdGlvbiB3aXRoIHBsYW5lXG4gICAqIEBwYXJhbSB7VEhSRUUuUGxhbmV9IFtwbGFuZT10aGlzLnByb2plY3Rpb25QbGFuZV0gTWF0aCBwbGFuZSB0aGF0IGlzIHVzZWRcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBbdGFyZ2V0XSBPcHRpb25hbCB0YXJnZXRcbiAgICogQHJldHVybiB7VmVjdG9yM30gQW4gaW50ZXJzZWN0aW9uIHBvaW50LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZVxuICAgKi9cbiAgcHJvamVjdChwbGFuZSA9IHRoaXMucHJvamVjdGlvblBsYW5lLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5yYXljYXN0ZXIucmF5LmludGVyc2VjdFBsYW5lKHBsYW5lLCB0YXJnZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaG92ZXJzXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgYm9vbGVhbiBiYXNlZCBvbiBpbnRlcnNlY3Rpb24gZGF0YSAoV2hldGhlciBtb3VzZSBob3ZlcnMgdGhlIGNvbXBvbmVudClcbiAgICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGludGVyc2VjdHMgd2l0aCBtb3VzZSByYXkgKG9yIGRvZXNuJ3QpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVzdGVkIFdoZXRoZXIgY29tcG9uZW50J3MgY2hpbGRyZW4gc2hvdWxkIGJlIHRyYWNrZWQgb3Igbm90XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBob3ZlcmVkLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZVxuICAgKi9cbiAgaG92ZXJzKGNvbXBvbmVudCwgbmVzdGVkID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvbihjb21wb25lbnQsIG5lc3RlZCkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VzZSByYXlcbiAgICogQG1lbWJlciB7VEhSRUUuUmF5fSBtb2R1bGU6bW9kdWxlcy9hcHAuVmlydHVhbE1vdXNlTW9kdWxlI3JheVxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgcmF5KCkge1xuICAgIHJldHVybiB0aGlzLnJheWNhc3Rlci5yYXk7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgeCBbLTE7IDFdXG4gICAqIEBtZW1iZXIge051bWJlcn0gbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZSN4XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlLng7XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgeSBbLTE7IDFdXG4gICAqIEBtZW1iZXIge051bWJlcn0gbW9kdWxlOm1vZHVsZXMvYXBwLlZpcnR1YWxNb3VzZU1vZHVsZSN5XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlLnk7XG4gIH1cbn1cbiIsImltcG9ydCB7TG9vcH0gZnJvbSAnLi4vLi4vY29yZS9Mb29wJztcbmltcG9ydCB7RXZlbnRzUGF0Y2hNb2R1bGV9IGZyb20gJy4vRXZlbnRzUGF0Y2hNb2R1bGUnO1xuXG4vKipcbiAqIEBjbGFzcyBDb250cm9sc01vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleGFtcGxlIDxjYXB0aW9uPiBDcmVhdGluZyBhIHJlbmRlcmluZyBtb2R1bGUgYW5kIHBhc3NpbmcgaXQgdG8gQXBwJ3MgbW9kdWxlczwvY2FwdGlvbj5cbiAqIG5ldyBBcHAoW1xuICogICBuZXcgRWxlbWVudE1vZHVsZSgpLFxuICogICBuZXcgU2NlbmVNb2R1bGUoKSxcbiAqICAgbmV3IERlZmluZU1vZHVsZSgnY2FtZXJhJywgbmV3IFdIUy5QZXJzcGVjdGl2ZUNhbWVyYSh7XG4gKiAgICAgcG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDYsIDE4KSxcbiAqICAgICBmYXI6IDEwMDAwXG4gKiAgIH0pKSxcbiAqICAgbmV3IFJlbmRlcmluZ01vZHVsZSgpLFxuICogICBuZXcgQ29udHJvbHNNb2R1bGUuZnJvbShuZXcgVEhSRUUuVHJhY2tiYWxsQ29udHJvbHMoKSlcbiAqIF0pO1xuICovXG5leHBvcnQgY2xhc3MgQ29udHJvbHNNb2R1bGUge1xuICBzdGF0aWMgZnJvbShjb250cm9scykge1xuICAgIHJldHVybiBuZXcgQ29udHJvbHNNb2R1bGUoe2NvbnRyb2xzfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb250cm9sczogZmFsc2UsXG4gICAgICBmaXg6IGNvbnRyb2xzID0+IGNvbnRyb2xzLFxuXG4gICAgICB1cGRhdGUoYykge1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnVwZGF0ZShjLmdldERlbHRhKCkpO1xuICAgICAgfVxuICAgIH0sIHBhcmFtcyk7XG5cbiAgICB0aGlzLmNvbnRyb2xzID0gdGhpcy5wYXJhbXMuY29udHJvbHM7XG4gICAgdGhpcy51cGRhdGUgPSB0aGlzLnBhcmFtcy51cGRhdGU7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLmRlZmluZSgnY29udHJvbHMnKTtcbiAgICBtYW5hZ2VyLnJlcXVpcmUoJ2V2ZW50cycsICgpID0+IG5ldyBFdmVudHNQYXRjaE1vZHVsZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldENvbnRyb2xzXG4gICAqIEBkZXNjcmlwdGlvbiBTZXQgd29ya2luZyBjb250cm9sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udHJvbHMgV29ya2luZyB0aHJlZS5qcyBjb250cm9scyBvYmplY3QuXG4gICAqIEByZXR1cm4ge3RoaXN9XG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuQ29udHJvbHNNb2R1bGVcbiAgICovXG4gIHNldENvbnRyb2xzKGNvbnRyb2xzKSB7XG4gICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VXBkYXRlXG4gICAqIEBkZXNjcmlwdGlvbiBTZXQgY29udHJvbHMgdXBkYXRlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZSBVcGRhdGUgZnVuY3Rpb25cbiAgICogQHJldHVybiB7dGhpc31cbiAgICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL2FwcC5Db250cm9sc01vZHVsZVxuICAgKi9cbiAgc2V0VXBkYXRlKHVwZGF0ZSkge1xuICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBzZWxmLnVwZGF0ZUxvb3AgPSBuZXcgTG9vcChzZWxmLnVwZGF0ZS5iaW5kKHNlbGYpKTtcbiAgICBzZWxmLnVwZGF0ZUxvb3Auc3RhcnQodGhpcyk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEZvZ0V4cDIsXG4gIEZvZ1xufSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogQGNsYXNzIEZvZ01vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtcz17Y29sb3I6IDB4ZWZkMWI1LCBkZW5zaXR5OiAwLjAyMCwgbmVhcjogMTAsIGZhcjogMTAwMH1dIC0gVGhlIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlPWV4cDJdIC0gVGhlIHR5cGUgb2YgZm9nIC0gZXhwMiBvciBsaW5lYXJcbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkhvdyB0byBjcmVhdGUgYW5kIGFwcGx5IGEgRm9nTW9kdWxlPC9jYXB0aW9uPlxuICogY29uc3QgZm9nTW9kdWxlID0gbmV3IEZvZ01vZHVsZSh7XG4gKiAgICBjb2xvcjogMHhmZmZmZmYsXG4gKiAgICBkZW5zaXR5OiAwLjAzLFxuICogICAgbmVhcjogMjAsXG4gKiAgICBmYXI6IDIwMFxuICogIH0sICdleHAyJyk7XG4gKlxuICogbmV3IEFwcChbXG4gKiAgLi4uLFxuICogIGZvZ01vZHVsZVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBGb2dNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSwgdHlwZSkge1xuICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb2xvcjogMHhlZmQxYjUsXG4gICAgICBkZW5zaXR5OiAwLjAyMCxcbiAgICAgIG5lYXI6IDEwLFxuICAgICAgZmFyOiAxMDAwXG4gICAgfSwgcGFyYW1zKTtcbiAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ2V4cDInKSB0aGlzLmZvZyA9IG5ldyBGb2dFeHAyKHRoaXMucGFyYW1zLmNvbG9yLCB0aGlzLnBhcmFtcy5kZW5zaXR5KTtcbiAgICBlbHNlIGlmICh0eXBlID09PSAnbGluZWFyJykgdGhpcy5mb2cgPSBuZXcgRm9nKHRoaXMucGFyYW1zLmNvbG9yLCB0aGlzLnBhcmFtcy5uZWFyLCB0aGlzLnBhcmFtcy5mYXIpO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5zZXQoJ2ZvZycsIHRoaXMuZm9nKTtcbiAgICBtYW5hZ2VyLmdldCgnc2NlbmUnKS5mb2cgPSB0aGlzLmZvZztcbiAgfVxufVxuIiwiaW1wb3J0IHtjcmVhdGVTdG9yZX0gZnJvbSAncmVkdXgnO1xuXG5jb25zdCBpc0VxdWFsRGVmYXVsdCA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgZWxzZSBpZiAoYSAmJiBhLmVxdWFscyAmJiBhLmVxdWFscyhiKSkgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY2xhc3MgU3RhdGVNb2R1bGVcbiAqIEBkZXNjcmlwdGlvbiBgU3RhdGVNb2R1bGVgIGlzIHVzZWZ1bCBmb3IgYXBwcywgd2hlcmUgeW91IG5lZWQgc3RhdGUgbWFuaXB1bGF0aW9uLlxuICogVGhpcyBjYW4gYmU6IF90cmFuc2l0aW9ucyBiZXR3ZWVuIHNjcmVlbnMsIGdhbWVzLCBkZXZlbG9wbWVudCBtb21lbnRzXy5cbiAqIFlvdSBjYW4gY2hlY2sgW2Jhc2ljL3N0YXRlXShodHRwczovL3docy1kZXYuc3VyZ2Uuc2gvZXhhbXBsZXMvP2Jhc2ljL3N0YXRlKSBleGFtcGxlLlxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHBcbiAqIEBleGFtcGxlIDxjYXB0aW9uPiBDcmVhdGluZyBhIHN0YXRlIG1vZHVsZTwvY2FwdGlvbj5cbiAqIG5ldyBBcHAoW1xuICogICAvLyAuLi5cbiAqICAgbmV3IFN0YXRlTW9kdWxlKCkuZGVmYXVsdCh7XG4gKiAgICAgc3BoZXJlQ29sb3I6IDB4ZmYwMDAwXG4gKiAgIH0pXG4gKiBdKTtcbiAqL1xuZXhwb3J0IGNsYXNzIFN0YXRlTW9kdWxlIHtcbiAgc3RhdGljIGFjdGlvbkdlbmVyYXRlKGlzRXF1YWwpIHtcbiAgICByZXR1cm4gKHN0YXRlID0gW3t9LCAnJ10sIHtrZXksIGRhdGF9KSA9PiB7XG4gICAgICBpZiAoaXNFcXVhbChzdGF0ZVswXVtrZXldLCBkYXRhKSkgcmV0dXJuIHN0YXRlO1xuXG4gICAgICBzdGF0ZVswXVtrZXldID0gZGF0YTtcbiAgICAgIHN0YXRlWzFdID0ga2V5O1xuXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGVxdWFsQ2hlY2sgPSBpc0VxdWFsRGVmYXVsdCkge1xuICAgIHRoaXMuc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICAgIFN0YXRlTW9kdWxlLmFjdGlvbkdlbmVyYXRlKGVxdWFsQ2hlY2spXG4gICAgKTtcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IHt9O1xuICAgIHRoaXMuY3VycmVudENvbmZpZyA9ICdkZWZhdWx0JztcbiAgICB0aGlzLnByZXZDb25maWcgPSAnZGVmYXVsdCc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvbiBBZGQgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBDb25maWd1cmF0aW9uIHNldHVwXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuU3RhdGVNb2R1bGVcbiAgICogQGV4YW1wbGVcbiAgICogbmV3IFdIUy5TdGF0ZU1vZHVsZSgpLmRlZmF1bHQoe1xuICAgKiAgIHNwaGVyZUNvbG9yOiBVVElMUy4kY29sb3JzLm1lc2gsXG4gICAqICAgcGxhbmVDb2xvcjogMHg0NDdGOEJcbiAgICogfSlcbiAgICovXG4gIGRlZmF1bHQoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnKHtkZWZhdWx0OiBkYXRhfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRFcXVhbENoZWNrXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIGFuIGVxdWFsQ2hlY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBnZW5lcmF0ZSBlcXVhbCBjaGVja1xuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqL1xuICBzZXRFcXVhbENoZWNrKGZ1bmMpIHtcbiAgICB0aGlzLnN0b3JlLnJlcGxhY2VSZWR1Y2VyKFxuICAgICAgU3RhdGVNb2R1bGUuYWN0aW9uR2VuZXJhdGUoZnVuYylcbiAgICApO1xuICB9XG5cbiAgbWFuYWdlcihtYW5hZ2VyKSB7XG4gICAgbWFuYWdlci5kZWZpbmUoJ3N0YXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjb25maWdcbiAgICogQGRlc2NyaXB0aW9uIExvYWQgY29uZmlndXJhdGlvbnMgZnJvbSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdzIENvbmZpZ3VyYXRpb24gZGF0YVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPiBBZGRpbmcgYGdyZWVuYCBjb25maWd1cmF0aW9uPC9jYXB0aW9uPlxuICAgKiBzdGF0ZS5jb25maWcoe1xuICAgKiAgIGdyZWVuOiB7XG4gICAqICAgICBzcGhlcmVDb2xvcjogMHgwMGZmMDAsXG4gICAqICAgICBwbGFuZUNvbG9yOiAweDAwZmYwMFxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqL1xuICBjb25maWcoY29uZmlncykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZ3MpIHtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uW2tleV0gPSBrZXkgPT09ICdkZWZhdWx0J1xuICAgICAgICAgID8gY29uZmlnc1trZXldXG4gICAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24uZGVmYXVsdCwgY29uZmlnc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQGRlc2NyaXB0aW9uIExvYWQgdXBkYXRlcyBmcm9tIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXMgVXBkYXRlcyBkYXRhXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuU3RhdGVNb2R1bGVcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+IFVwZGF0ZSBjYWxsYmFjayBmb3IgYHNwaGVyZUNvbG9yYDwvY2FwdGlvbj5cbiAgICogc3RhdGUudXBkYXRlKHtcbiAgICogICBzcGhlcmVDb2xvcjogY29sb3IgPT4gc3BoZXJlLm1hdGVyaWFsLmNvbG9yLnNldEhleChjb2xvcilcbiAgICogfSk7XG4gICAqL1xuICB1cGRhdGUodXBkYXRlcyA9IHt9KSB7XG4gICAgdGhpcy5zdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgY29uc3QgW2RhdGEsIGNoYW5nZWRLZXldID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB1cGRhdGVzW2NoYW5nZWRLZXldO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGRhdGFbY2hhbmdlZEtleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9cbiAgICogQGRlc2NyaXB0aW9uIFN3aXRjaCB0byBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnTmFtZSBDb25maWd1cmF0aW9uIG5hbWUuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuU3RhdGVNb2R1bGVcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+IENoYW5nZXMgY29uZmlndXJhdGlvbiB0byBgZ3JlZW5gPC9jYXB0aW9uPlxuICAgKiBzdGF0ZS50bygnZ3JlZW4nKTtcbiAgICovXG4gIHRvKGNvbmZpZ05hbWUpIHtcbiAgICB0aGlzLnByZXZDb25maWcgPSB0aGlzLmN1cnJlbnRDb25maWc7XG4gICAgdGhpcy5jdXJyZW50Q29uZmlnID0gY29uZmlnTmFtZTtcblxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlndXJhdGlvbltjb25maWdOYW1lXVxuICAgICAgPyB0aGlzLmNvbmZpZ3VyYXRpb25bY29uZmlnTmFtZV1cbiAgICAgIDogdGhpcy5jb25maWd1cmF0aW9uLmRlZmF1bHQ7XG5cbiAgICB0aGlzLnNldChjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBkZXNjcmlwdGlvbiBTZXQgY3VycmVudCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBDb25maWd1cmF0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuU3RhdGVNb2R1bGVcbiAgICogQGV4YW1wbGVcbiAgICogc3RhdGUuc2V0KHtcbiAgICogICBzcGhlcmVDb2xvcjogMHgwMGZmMDBcbiAgICogfSk7XG4gICAqL1xuICBzZXQoZGF0YSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpXG4gICAgICBpZiAoa2V5KSB0aGlzLnN0b3JlLmRpc3BhdGNoKHt0eXBlOiAnQUREJywga2V5LCBkYXRhOiBkYXRhW2tleV19KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldFxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGRhdGEgb2YgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFBhcmFtZXRlciBuYW1lLlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqIEBleGFtcGxlXG4gICAqIHN0YXRlLmdldCgnc3BoZXJlQ29sb3InKTsgLy8gMHgwMGZmMDBcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpWzBdW2tleV07XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBwcmV2XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYHRydWVWYWxgIGlmIGBjb25maWdgIG1hdGNoIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24sIGluIG90aGVyIGNhc2UgLSByZXR1cm4gYGZhbHNlVmFsYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZyBDb25maWd1cmF0aW9uIG5hbWUuXG4gICAqIEBwYXJhbSB7QW55fSB0cnVlVmFsIFZhbHVlIHJldHVybmVkIGlmIGNvbmRpdGlvbiBpcyB0cnV0aHkuXG4gICAqIEBwYXJhbSB7QW55fSBmYWxzZVZhbCBWYWx1ZSByZXR1cm5lZCBpZiBjb25kaXRpb24gaXMgZmFsc3kuXG4gICAqIEBtZW1iZXJvZiBtb2R1bGU6bW9kdWxlcy9hcHAuU3RhdGVNb2R1bGVcbiAgICovXG4gIHByZXYoY29uZmlnLCB0cnVlVmFsLCBmYWxzZVZhbCkge1xuICAgIHJldHVybiB0aGlzLnByZXZDb25maWcgPT09IGNvbmZpZyA/IHRydWVWYWwgOiBmYWxzZVZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGN1cnJlbnRcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybiBgdHJ1ZVZhbGAgaWYgYGNvbmZpZ2AgbWF0Y2ggY3VycmVudCBjb25maWd1cmF0aW9uLCBpbiBvdGhlciBjYXNlIC0gcmV0dXJuIGBmYWxzZVZhbGAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcgQ29uZmlndXJhdGlvbiBuYW1lLlxuICAgKiBAcGFyYW0ge0FueX0gdHJ1ZVZhbCBWYWx1ZSByZXR1cm5lZCBpZiBjb25kaXRpb24gaXMgdHJ1dGh5LlxuICAgKiBAcGFyYW0ge0FueX0gZmFsc2VWYWwgVmFsdWUgcmV0dXJuZWQgaWYgY29uZGl0aW9uIGlzIGZhbHN5LlxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwLlN0YXRlTW9kdWxlXG4gICAqL1xuICBjdXJyZW50KGNvbmZpZywgdHJ1ZVZhbCwgZmFsc2VWYWwpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50Q29uZmlnID09PSBjb25maWcgPyB0cnVlVmFsIDogZmFsc2VWYWw7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIE1PVVNFLFxuICBRdWF0ZXJuaW9uLFxuICBTcGhlcmljYWwsXG4gIFZlY3RvcjIsXG4gIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICBPcnRob2dyYXBoaWNDYW1lcmEsXG4gIEV2ZW50RGlzcGF0Y2hlcixcbiAgVmVjdG9yM1xufSBmcm9tICd0aHJlZSc7XG5cbi8vIFRoaXMgc2V0IG9mIGNvbnRyb2xzIHBlcmZvcm1zIG9yYml0aW5nLCBkb2xseWluZyAoem9vbWluZyksIGFuZCBwYW5uaW5nLlxuLy8gVW5saWtlIFRyYWNrYmFsbENvbnRyb2xzLCBpdCBtYWludGFpbnMgdGhlIFwidXBcIiBkaXJlY3Rpb24gb2JqZWN0LnVwICgrWSBieSBkZWZhdWx0KS5cbi8vXG4vLyAgICBPcmJpdCAtIGxlZnQgbW91c2UgLyB0b3VjaDogb25lIGZpbmdlciBtb3ZlXG4vLyAgICBab29tIC0gbWlkZGxlIG1vdXNlLCBvciBtb3VzZXdoZWVsIC8gdG91Y2g6IHR3byBmaW5nZXIgc3ByZWFkIG9yIHNxdWlzaFxuLy8gICAgUGFuIC0gcmlnaHQgbW91c2UsIG9yIGFycm93IGtleXMgLyB0b3VjaDogdGhyZWUgZmludGVyIHN3aXBlXG5cbmV4cG9ydCBjbGFzcyBUaHJlZU9yYml0Q29udHJvbHMgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIGRvbUVsZW1lbnQsIGV2ZW50SGFuZGxlcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIHRoaXMuZG9tRWxlbWVudCA9IChkb21FbGVtZW50ID09PSB1bmRlZmluZWQpID8gZG9jdW1lbnQgOiBkb21FbGVtZW50O1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gZXZlbnRIYW5kbGVyO1xuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBjb250cm9sXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuICAgIHRoaXMudGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBkb2xseSBpbiBhbmQgb3V0ICggUGVyc3BlY3RpdmVDYW1lcmEgb25seSApXG4gICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XG4gICAgdGhpcy5tYXhEaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgLy8gSG93IGZhciB5b3UgY2FuIHpvb20gaW4gYW5kIG91dCAoIE9ydGhvZ3JhcGhpY0NhbWVyYSBvbmx5IClcbiAgICB0aGlzLm1pblpvb20gPSAwO1xuICAgIHRoaXMubWF4Wm9vbSA9IEluZmluaXR5O1xuXG4gICAgLy8gSG93IGZhciB5b3UgY2FuIG9yYml0IHZlcnRpY2FsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gUmFuZ2UgaXMgMCB0byBNYXRoLlBJIHJhZGlhbnMuXG4gICAgdGhpcy5taW5Qb2xhckFuZ2xlID0gMDsgLy8gcmFkaWFuc1xuICAgIHRoaXMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEk7IC8vIHJhZGlhbnNcblxuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gSWYgc2V0LCBtdXN0IGJlIGEgc3ViLWludGVydmFsIG9mIHRoZSBpbnRlcnZhbCBbIC0gTWF0aC5QSSwgTWF0aC5QSSBdLlxuICAgIHRoaXMubWluQXppbXV0aEFuZ2xlID0gLUluZmluaXR5OyAvLyByYWRpYW5zXG4gICAgdGhpcy5tYXhBemltdXRoQW5nbGUgPSBJbmZpbml0eTsgLy8gcmFkaWFuc1xuXG4gICAgLy8gU2V0IHRvIHRydWUgdG8gZW5hYmxlIGRhbXBpbmcgKGluZXJ0aWEpXG4gICAgLy8gSWYgZGFtcGluZyBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgICB0aGlzLmVuYWJsZURhbXBpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRhbXBpbmdGYWN0b3IgPSAwLjI1O1xuXG4gICAgLy8gVGhpcyBvcHRpb24gYWN0dWFsbHkgZW5hYmxlcyBkb2xseWluZyBpbiBhbmQgb3V0OyBsZWZ0IGFzIFwiem9vbVwiIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB6b29taW5nXG4gICAgdGhpcy5lbmFibGVab29tID0gdHJ1ZTtcbiAgICB0aGlzLnpvb21TcGVlZCA9IDEuMDtcblxuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHJvdGF0aW5nXG4gICAgdGhpcy5lbmFibGVSb3RhdGUgPSB0cnVlO1xuICAgIHRoaXMucm90YXRlU3BlZWQgPSAxLjA7XG5cbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgdGhpcy5lbmFibGVQYW4gPSB0cnVlO1xuICAgIHRoaXMua2V5UGFuU3BlZWQgPSA3LjA7IC8vIHBpeGVscyBtb3ZlZCBwZXIgYXJyb3cga2V5IHB1c2hcblxuICAgIC8vIFNldCB0byB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgcm90YXRlIGFyb3VuZCB0aGUgdGFyZ2V0XG4gICAgLy8gSWYgYXV0by1yb3RhdGUgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgdGhpcy5hdXRvUm90YXRlID0gZmFsc2U7XG4gICAgdGhpcy5hdXRvUm90YXRlU3BlZWQgPSAyLjA7IC8vIDMwIHNlY29uZHMgcGVyIHJvdW5kIHdoZW4gZnBzIGlzIDYwXG5cbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB1c2Ugb2YgdGhlIGtleXNcbiAgICB0aGlzLmVuYWJsZUtleXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGZvdXIgYXJyb3cga2V5c1xuICAgIHRoaXMua2V5cyA9IHtMRUZUOiAzNywgVVA6IDM4LCBSSUdIVDogMzksIEJPVFRPTTogNDB9O1xuXG4gICAgLy8gTW91c2UgYnV0dG9uc1xuICAgIHRoaXMubW91c2VCdXR0b25zID0ge09SQklUOiBNT1VTRS5MRUZULCBaT09NOiBNT1VTRS5NSURETEUsIFBBTjogTU9VU0UuUklHSFR9O1xuXG4gICAgLy8gZm9yIHJlc2V0XG4gICAgdGhpcy50YXJnZXQwID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcbiAgICB0aGlzLnBvc2l0aW9uMCA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gICAgdGhpcy56b29tMCA9IHRoaXMub2JqZWN0Lnpvb207XG5cbiAgICAvL1xuICAgIC8vIHB1YmxpYyBtZXRob2RzXG4gICAgLy9cblxuICAgIHRoaXMuZ2V0UG9sYXJBbmdsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBzcGhlcmljYWwucGhpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEF6aW11dGhhbEFuZ2xlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHNwaGVyaWNhbC50aGV0YTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgIHRoaXMudGFyZ2V0LmNvcHkodGhpcy50YXJnZXQwKTtcbiAgICAgIHRoaXMub2JqZWN0LnBvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbjApO1xuICAgICAgdGhpcy5vYmplY3Quem9vbSA9IHRoaXMuem9vbTA7XG5cbiAgICAgIHRoaXMub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9O1xuXG4gICAgLy8gdGhpcyBtZXRob2QgaXMgZXhwb3NlZCwgYnV0IHBlcmhhcHMgaXQgd291bGQgYmUgYmV0dGVyIGlmIHdlIGNhbiBtYWtlIGl0IHByaXZhdGUuLi5cbiAgICB0aGlzLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICAgIC8vIHNvIGNhbWVyYS51cCBpcyB0aGUgb3JiaXQgYXhpc1xuICAgICAgY29uc3QgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCkuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgbmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xuICAgICAgY29uc3QgcXVhdEludmVyc2UgPSBxdWF0LmNsb25lKCkuaW52ZXJzZSgpO1xuXG4gICAgICBjb25zdCBsYXN0UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgY29uc3QgbGFzdFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgICByZXR1cm4gKCgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm9iamVjdC5wb3NpdGlvbjtcblxuICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHRoaXMudGFyZ2V0KTtcblxuICAgICAgICAvLyByb3RhdGUgb2Zmc2V0IHRvIFwieS1heGlzLWlzLXVwXCIgc3BhY2VcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0KTtcblxuICAgICAgICAvLyBhbmdsZSBmcm9tIHotYXhpcyBhcm91bmQgeS1heGlzXG4gICAgICAgIHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyhvZmZzZXQpO1xuXG4gICAgICAgIGlmICh0aGlzLmF1dG9Sb3RhdGUgJiYgc3RhdGUgPT09IFNUQVRFLk5PTkUpXG4gICAgICAgICAgcm90YXRlTGVmdChnZXRBdXRvUm90YXRpb25BbmdsZSgpKTtcblxuICAgICAgICBzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG4gICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpO1xuXG4gICAgICAgIC8vIHJlc3RyaWN0IHRoZXRhIHRvIGJlIGJldHdlZW4gZGVzaXJlZCBsaW1pdHNcbiAgICAgICAgc3BoZXJpY2FsLnRoZXRhID0gTWF0aC5tYXgodGhpcy5taW5BemltdXRoQW5nbGUsIE1hdGgubWluKHRoaXMubWF4QXppbXV0aEFuZ2xlLCBzcGhlcmljYWwudGhldGEpKTtcblxuICAgICAgICAvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlbiBkZXNpcmVkIGxpbWl0c1xuICAgICAgICBzcGhlcmljYWwucGhpID0gTWF0aC5tYXgodGhpcy5taW5Qb2xhckFuZ2xlLCBNYXRoLm1pbih0aGlzLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkpKTtcblxuICAgICAgICBzcGhlcmljYWwubWFrZVNhZmUoKTtcblxuICAgICAgICBzcGhlcmljYWwucmFkaXVzICo9IHNjYWxlO1xuXG4gICAgICAgIC8vIHJlc3RyaWN0IHJhZGl1cyB0byBiZSBiZXR3ZWVuIGRlc2lyZWQgbGltaXRzXG4gICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBNYXRoLm1heCh0aGlzLm1pbkRpc3RhbmNlLCBNYXRoLm1pbih0aGlzLm1heERpc3RhbmNlLCBzcGhlcmljYWwucmFkaXVzKSk7XG5cbiAgICAgICAgLy8gbW92ZSB0YXJnZXQgdG8gcGFubmVkIGxvY2F0aW9uXG4gICAgICAgIHRoaXMudGFyZ2V0LmFkZChwYW5PZmZzZXQpO1xuXG4gICAgICAgIG9mZnNldC5zZXRGcm9tU3BoZXJpY2FsKHNwaGVyaWNhbCk7XG5cbiAgICAgICAgLy8gcm90YXRlIG9mZnNldCBiYWNrIHRvIFwiY2FtZXJhLXVwLXZlY3Rvci1pcy11cFwiIHNwYWNlXG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdEludmVyc2UpO1xuXG4gICAgICAgIHBvc2l0aW9uLmNvcHkodGhpcy50YXJnZXQpLmFkZChvZmZzZXQpO1xuXG4gICAgICAgIHRoaXMub2JqZWN0Lmxvb2tBdCh0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlRGFtcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhICo9ICgxIC0gdGhpcy5kYW1waW5nRmFjdG9yKTtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKj0gKDEgLSB0aGlzLmRhbXBpbmdGYWN0b3IpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5zZXQoMCwgMCwgMCk7XG5cbiAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICBwYW5PZmZzZXQuc2V0KDAsIDAsIDApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBjb25kaXRpb24gaXM6XG4gICAgICAgIC8vIG1pbihjYW1lcmEgZGlzcGxhY2VtZW50LCBjYW1lcmEgcm90YXRpb24gaW4gcmFkaWFucyleMiA+IEVQU1xuICAgICAgICAvLyB1c2luZyBzbWFsbC1hbmdsZSBhcHByb3hpbWF0aW9uIGNvcyh4LzIpID0gMSAtIHheMiAvIDhcblxuICAgICAgICBpZiAoem9vbUNoYW5nZWRcbiAgICAgICAgICB8fCBsYXN0UG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5vYmplY3QucG9zaXRpb24pID4gRVBTXG4gICAgICAgICAgfHwgOCAqICgxIC0gbGFzdFF1YXRlcm5pb24uZG90KHRoaXMub2JqZWN0LnF1YXRlcm5pb24pKSA+IEVQUykge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjaGFuZ2VFdmVudCk7XG5cbiAgICAgICAgICBsYXN0UG9zaXRpb24uY29weSh0aGlzLm9iamVjdC5wb3NpdGlvbik7XG4gICAgICAgICAgbGFzdFF1YXRlcm5pb24uY29weSh0aGlzLm9iamVjdC5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBvbkNvbnRleHRNZW51LCBmYWxzZSk7XG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCwgZmFsc2UpO1xuICAgICAgdGhpcy5kb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCBmYWxzZSk7XG5cbiAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApOyAvLyBzaG91bGQgdGhpcyBiZSBhZGRlZCBoZXJlP1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGludGVybmFsc1xuICAgIC8vXG5cbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IHt0eXBlOiAnY2hhbmdlJ307XG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IHt0eXBlOiAnc3RhcnQnfTtcbiAgICBjb25zdCBlbmRFdmVudCA9IHt0eXBlOiAnZW5kJ307XG5cbiAgICBjb25zdCBTVEFURSA9IHtOT05FOiAtMSwgUk9UQVRFOiAwLCBET0xMWTogMSwgUEFOOiAyLCBUT1VDSF9ST1RBVEU6IDMsIFRPVUNIX0RPTExZOiA0LCBUT1VDSF9QQU46IDV9O1xuXG4gICAgbGV0IHN0YXRlID0gU1RBVEUuTk9ORTtcblxuICAgIGNvbnN0IEVQUyA9IDAuMDAwMDAxO1xuXG4gICAgLy8gY3VycmVudCBwb3NpdGlvbiBpbiBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBzcGhlcmljYWwgPSBuZXcgU3BoZXJpY2FsKCk7XG4gICAgY29uc3Qgc3BoZXJpY2FsRGVsdGEgPSBuZXcgU3BoZXJpY2FsKCk7XG5cbiAgICBsZXQgc2NhbGUgPSAxO1xuICAgIGNvbnN0IHBhbk9mZnNldCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgbGV0IHpvb21DaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBjb25zdCByb3RhdGVTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgcm90YXRlRW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCByb3RhdGVEZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBjb25zdCBwYW5TdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuRW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBwYW5EZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBjb25zdCBkb2xseVN0YXJ0ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseUVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgZG9sbHlEZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBjb25zdCBnZXRBdXRvUm90YXRpb25BbmdsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAvIDYwIC8gNjAgKiB0aGlzLmF1dG9Sb3RhdGVTcGVlZDtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0Wm9vbVNjYWxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDAuOTUsIHRoaXMuem9vbVNwZWVkKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgcm90YXRlTGVmdCA9IGFuZ2xlID0+IHtcbiAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuICAgIH07XG5cbiAgICBjb25zdCByb3RhdGVVcCA9IGFuZ2xlID0+IHtcbiAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSAtPSBhbmdsZTtcbiAgICB9O1xuXG4gICAgY29uc3QgcGFuTGVmdCA9ICgoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIChkaXN0YW5jZSwgb2JqZWN0TWF0cml4KSA9PiB7XG4gICAgICAgIHYuc2V0RnJvbU1hdHJpeENvbHVtbihvYmplY3RNYXRyaXgsIDApOyAvLyBnZXQgWCBjb2x1bW4gb2Ygb2JqZWN0TWF0cml4XG4gICAgICAgIHYubXVsdGlwbHlTY2FsYXIoLWRpc3RhbmNlKTtcbiAgICAgICAgcGFuT2Zmc2V0LmFkZCh2KTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IHBhblVwID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgICByZXR1cm4gKGRpc3RhbmNlLCBvYmplY3RNYXRyaXgpID0+IHtcbiAgICAgICAgdi5zZXRGcm9tTWF0cml4Q29sdW1uKG9iamVjdE1hdHJpeCwgMSk7IC8vIGdldCBZIGNvbHVtbiBvZiBvYmplY3RNYXRyaXhcbiAgICAgICAgdi5tdWx0aXBseVNjYWxhcihkaXN0YW5jZSk7XG4gICAgICAgIHBhbk9mZnNldC5hZGQodik7XG4gICAgICB9O1xuICAgIH0pKCk7XG5cbiAgICAvLyBkZWx0YVggYW5kIGRlbHRhWSBhcmUgaW4gcGl4ZWxzOyByaWdodCBhbmQgZG93biBhcmUgcG9zaXRpdmVcbiAgICBjb25zdCBwYW4gPSAoKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgICAgcmV0dXJuIChkZWx0YVgsIGRlbHRhWSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5kb21FbGVtZW50ID09PSBkb2N1bWVudCA/IHRoaXMuZG9tRWxlbWVudC5ib2R5IDogdGhpcy5kb21FbGVtZW50O1xuXG4gICAgICAgIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICAgICAgLy8gcGVyc3BlY3RpdmVcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuICAgICAgICAgIG9mZnNldC5jb3B5KHBvc2l0aW9uKS5zdWIodGhpcy50YXJnZXQpO1xuICAgICAgICAgIGxldCB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcblxuICAgICAgICAgIC8vIGhhbGYgb2YgdGhlIGZvdiBpcyBjZW50ZXIgdG8gdG9wIG9mIHNjcmVlblxuICAgICAgICAgIHRhcmdldERpc3RhbmNlICo9IE1hdGgudGFuKCh0aGlzLm9iamVjdC5mb3YgLyAyKSAqIE1hdGguUEkgLyAxODAuMCk7XG5cbiAgICAgICAgICAvLyB3ZSBhY3R1YWxseSBkb24ndCB1c2Ugc2NyZWVuV2lkdGgsIHNpbmNlIHBlcnNwZWN0aXZlIGNhbWVyYSBpcyBmaXhlZCB0byBzY3JlZW4gaGVpZ2h0XG4gICAgICAgICAgcGFuTGVmdCgyICogZGVsdGFYICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgdGhpcy5vYmplY3QubWF0cml4KTtcbiAgICAgICAgICBwYW5VcCgyICogZGVsdGFZICogdGFyZ2V0RGlzdGFuY2UgLyBlbGVtZW50LmNsaWVudEhlaWdodCwgdGhpcy5vYmplY3QubWF0cml4KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgIC8vIG9ydGhvZ3JhcGhpY1xuICAgICAgICAgIHBhbkxlZnQoZGVsdGFYICogKHRoaXMub2JqZWN0LnJpZ2h0IC0gdGhpcy5vYmplY3QubGVmdCkgLyB0aGlzLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCwgdGhpcy5vYmplY3QubWF0cml4KTtcbiAgICAgICAgICBwYW5VcChkZWx0YVkgKiAodGhpcy5vYmplY3QudG9wIC0gdGhpcy5vYmplY3QuYm90dG9tKSAvIHRoaXMub2JqZWN0Lnpvb20gLyBlbGVtZW50LmNsaWVudEhlaWdodCwgdGhpcy5vYmplY3QubWF0cml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYW1lcmEgbmVpdGhlciBvcnRob2dyYXBoaWMgbm9yIHBlcnNwZWN0aXZlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBPcmJpdENvbnRyb2xzTW9kdWxlLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuJyk7XG4gICAgICAgICAgdGhpcy5lbmFibGVQYW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgY29uc3QgZG9sbHlJbiA9IGRvbGx5U2NhbGUgPT4ge1xuICAgICAgaWYgKHRoaXMub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEpXG4gICAgICAgIHNjYWxlIC89IGRvbGx5U2NhbGU7XG5cbiAgICAgIGVsc2UgaWYgKHRoaXMub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMub2JqZWN0Lnpvb20gPSBNYXRoLm1heCh0aGlzLm1pblpvb20sIE1hdGgubWluKHRoaXMubWF4Wm9vbSwgdGhpcy5vYmplY3Quem9vbSAqIGRvbGx5U2NhbGUpKTtcbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB6b29tQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE9yYml0Q29udHJvbHNNb2R1bGUuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyk7XG4gICAgICAgIHRoaXMuZW5hYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBkb2xseU91dCA9IGRvbGx5U2NhbGUgPT4ge1xuICAgICAgaWYgKHRoaXMub2JqZWN0IGluc3RhbmNlb2YgUGVyc3BlY3RpdmVDYW1lcmEpXG4gICAgICAgIHNjYWxlICo9IGRvbGx5U2NhbGU7XG5cbiAgICAgIGVsc2UgaWYgKHRoaXMub2JqZWN0IGluc3RhbmNlb2YgT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMub2JqZWN0Lnpvb20gPSBNYXRoLm1heCh0aGlzLm1pblpvb20sIE1hdGgubWluKHRoaXMubWF4Wm9vbSwgdGhpcy5vYmplY3Quem9vbSAvIGRvbGx5U2NhbGUpKTtcbiAgICAgICAgdGhpcy5vYmplY3QudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB6b29tQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE9yYml0Q29udHJvbHNNb2R1bGUuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIGRvbGx5L3pvb20gZGlzYWJsZWQuJyk7XG4gICAgICAgIHRoaXMuZW5hYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGV2ZW50IGNhbGxiYWNrcyAtIHVwZGF0ZSB0aGUgb2JqZWN0IHN0YXRlXG4gICAgLy9cblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRG93blJvdGF0ZSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUm90YXRlJyApO1xuXG4gICAgICByb3RhdGVTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRG93bkRvbGx5ID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVNb3VzZURvd25Eb2xseScgKTtcblxuICAgICAgZG9sbHlTdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlRG93blBhbiA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VEb3duUGFuJyApO1xuXG4gICAgICBwYW5TdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZVJvdGF0ZSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUm90YXRlJyApO1xuXG4gICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KTtcblxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZG9tRWxlbWVudCA9PT0gZG9jdW1lbnQgPyB0aGlzLmRvbUVsZW1lbnQuYm9keSA6IHRoaXMuZG9tRWxlbWVudDtcblxuICAgICAgLy8gcm90YXRpbmcgYWNyb3NzIHdob2xlIHNjcmVlbiBnb2VzIDM2MCBkZWdyZWVzIGFyb3VuZFxuICAgICAgcm90YXRlTGVmdCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnggLyBlbGVtZW50LmNsaWVudFdpZHRoICogdGhpcy5yb3RhdGVTcGVlZCk7XG5cbiAgICAgIC8vIHJvdGF0aW5nIHVwIGFuZCBkb3duIGFsb25nIHdob2xlIHNjcmVlbiBhdHRlbXB0cyB0byBnbyAzNjAsIGJ1dCBsaW1pdGVkIHRvIDE4MFxuICAgICAgcm90YXRlVXAoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQgKiB0aGlzLnJvdGF0ZVNwZWVkKTtcblxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpO1xuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmVEb2xseSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlRG9sbHknICk7XG5cbiAgICAgIGRvbGx5RW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcblxuICAgICAgZG9sbHlEZWx0YS5zdWJWZWN0b3JzKGRvbGx5RW5kLCBkb2xseVN0YXJ0KTtcblxuICAgICAgaWYgKGRvbGx5RGVsdGEueSA+IDApXG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpO1xuXG4gICAgICBlbHNlIGlmIChkb2xseURlbHRhLnkgPCAwKVxuICAgICAgICBkb2xseU91dChnZXRab29tU2NhbGUoKSk7XG5cbiAgICAgIGRvbGx5U3RhcnQuY29weShkb2xseUVuZCk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZVBhbiA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VNb3ZlUGFuJyApO1xuXG4gICAgICBwYW5FbmQuc2V0KGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuXG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpO1xuXG4gICAgICBwYW4ocGFuRGVsdGEueCwgcGFuRGVsdGEueSk7XG5cbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VVcCA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VVcCcgKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlTW91c2VXaGVlbCA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlTW91c2VXaGVlbCcgKTtcblxuICAgICAgaWYgKGV2ZW50LmRlbHRhWSA8IDApXG4gICAgICAgIGRvbGx5T3V0KGdldFpvb21TY2FsZSgpKTtcblxuICAgICAgZWxzZSBpZiAoZXZlbnQuZGVsdGFZID4gMClcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZUtleURvd24nICk7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIHRoaXMua2V5cy5VUDpcbiAgICAgICAgICBwYW4oMCwgdGhpcy5rZXlQYW5TcGVlZCk7XG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRoaXMua2V5cy5CT1RUT006XG4gICAgICAgICAgcGFuKDAsIC10aGlzLmtleVBhblNwZWVkKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy5rZXlzLkxFRlQ6XG4gICAgICAgICAgcGFuKHRoaXMua2V5UGFuU3BlZWQsIDApO1xuICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0aGlzLmtleXMuUklHSFQ6XG4gICAgICAgICAgcGFuKC10aGlzLmtleVBhblNwZWVkLCAwKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoU3RhcnRSb3RhdGUnICk7XG5cbiAgICAgIHJvdGF0ZVN0YXJ0LnNldChldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hTdGFydERvbGx5ID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVUb3VjaFN0YXJ0RG9sbHknICk7XG5cbiAgICAgIGNvbnN0IGR4ID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVg7XG4gICAgICBjb25zdCBkeSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZO1xuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgIGRvbGx5U3RhcnQuc2V0KDAsIGRpc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hTdGFydFBhbiA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hTdGFydFBhbicgKTtcblxuICAgICAgcGFuU3RhcnQuc2V0KGV2ZW50LnRvdWNoZXNbMF0ucGFnZVgsIGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVUb3VjaE1vdmVSb3RhdGUgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZVJvdGF0ZScgKTtcblxuICAgICAgcm90YXRlRW5kLnNldChldmVudC50b3VjaGVzWzBdLnBhZ2VYLCBldmVudC50b3VjaGVzWzBdLnBhZ2VZKTtcbiAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCk7XG5cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnQgPT09IGRvY3VtZW50ID8gdGhpcy5kb21FbGVtZW50LmJvZHkgOiB0aGlzLmRvbUVsZW1lbnQ7XG5cbiAgICAgIC8vIHJvdGF0aW5nIGFjcm9zcyB3aG9sZSBzY3JlZW4gZ29lcyAzNjAgZGVncmVlcyBhcm91bmRcbiAgICAgIHJvdGF0ZUxlZnQoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIHRoaXMucm90YXRlU3BlZWQpO1xuXG4gICAgICAvLyByb3RhdGluZyB1cCBhbmQgZG93biBhbG9uZyB3aG9sZSBzY3JlZW4gYXR0ZW1wdHMgdG8gZ28gMzYwLCBidXQgbGltaXRlZCB0byAxODBcbiAgICAgIHJvdGF0ZVVwKDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogdGhpcy5yb3RhdGVTcGVlZCk7XG5cbiAgICAgIHJvdGF0ZVN0YXJ0LmNvcHkocm90YXRlRW5kKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hNb3ZlRG9sbHkgPSBldmVudCA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2hhbmRsZVRvdWNoTW92ZURvbGx5JyApO1xuXG4gICAgICBjb25zdCBkeCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYO1xuICAgICAgY29uc3QgZHkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWTtcblxuICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICBkb2xseUVuZC5zZXQoMCwgZGlzdGFuY2UpO1xuXG4gICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoZG9sbHlFbmQsIGRvbGx5U3RhcnQpO1xuXG4gICAgICBpZiAoZG9sbHlEZWx0YS55ID4gMClcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuXG4gICAgICBlbHNlIGlmIChkb2xseURlbHRhLnkgPCAwKVxuICAgICAgICBkb2xseUluKGdldFpvb21TY2FsZSgpKTtcblxuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlVG91Y2hNb3ZlUGFuID0gZXZlbnQgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coICdoYW5kbGVUb3VjaE1vdmVQYW4nICk7XG5cbiAgICAgIHBhbkVuZC5zZXQoZXZlbnQudG91Y2hlc1swXS5wYWdlWCwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSk7XG5cbiAgICAgIHBhbkRlbHRhLnN1YlZlY3RvcnMocGFuRW5kLCBwYW5TdGFydCk7XG5cbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcblxuICAgICAgcGFuU3RhcnQuY29weShwYW5FbmQpO1xuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVUb3VjaEVuZCA9ICgpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnaGFuZGxlVG91Y2hFbmQnICk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gZXZlbnQgaGFuZGxlcnMgLSBGU006IGxpc3RlbiBmb3IgZXZlbnRzIGFuZCByZXNldCBzdGF0ZVxuICAgIC8vXG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IHRoaXMubW91c2VCdXR0b25zLk9SQklUKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpO1xuXG4gICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5idXR0b24gPT09IHRoaXMubW91c2VCdXR0b25zLlpPT00pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlWm9vbSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICBoYW5kbGVNb3VzZURvd25Eb2xseShldmVudCk7XG5cbiAgICAgICAgc3RhdGUgPSBTVEFURS5ET0xMWTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09PSB0aGlzLm1vdXNlQnV0dG9ucy5QQU4pIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGhhbmRsZU1vdXNlRG93blBhbihldmVudCk7XG5cbiAgICAgICAgc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlci5vbignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlKTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHN0YXRlID09PSBTVEFURS5ST1RBVEUpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUm90YXRlID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZShldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBTVEFURS5ET0xMWSkge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVab29tID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGhhbmRsZU1vdXNlTW92ZURvbGx5KGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFNUQVRFLlBBTikge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgaGFuZGxlTW91c2VNb3ZlUGFuKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgaGFuZGxlTW91c2VVcChldmVudCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG5cbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZVdoZWVsID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgfHwgdGhpcy5lbmFibGVab29tID09PSBmYWxzZSB8fCAoc3RhdGUgIT09IFNUQVRFLk5PTkUgJiYgc3RhdGUgIT09IFNUQVRFLlJPVEFURSkpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpOyAvLyBub3Qgc3VyZSB3aHkgdGhlc2UgYXJlIGhlcmUuLi5cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlbmRFdmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlIHx8IHRoaXMuZW5hYmxlS2V5cyA9PT0gZmFsc2UgfHwgdGhpcy5lbmFibGVQYW4gPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGhhbmRsZUtleURvd24oZXZlbnQpO1xuICAgIH07XG5cbiAgICBjb25zdCBvblRvdWNoU3RhcnQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoZXZlbnQpO1xuXG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6IC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVpvb20gPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoZXZlbnQpO1xuXG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ET0xMWTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG4gICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgICAgaGFuZGxlVG91Y2hTdGFydFBhbihldmVudCk7XG5cbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5OT05FKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uVG91Y2hNb3ZlID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTogLy8gb25lLWZpbmdlcmVkIHRvdWNoOiByb3RhdGVcblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLlRPVUNIX1JPVEFURSkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZShldmVudCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6IC8vIHR3by1maW5nZXJlZCB0b3VjaDogZG9sbHlcblxuICAgICAgICAgIGlmICh0aGlzLmVuYWJsZVpvb20gPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSBTVEFURS5UT1VDSF9ET0xMWSkgcmV0dXJuOyAvLyBpcyB0aGlzIG5lZWRlZD8uLi5cblxuICAgICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5KGV2ZW50KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzogLy8gdGhyZWUtZmluZ2VyZWQgdG91Y2g6IHBhblxuXG4gICAgICAgICAgaWYgKHRoaXMuZW5hYmxlUGFuID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuVE9VQ0hfUEFOKSByZXR1cm47IC8vIGlzIHRoaXMgbmVlZGVkPy4uLlxuXG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgb25Ub3VjaEVuZCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IGZhbHNlKSByZXR1cm47XG5cbiAgICAgIGhhbmRsZVRvdWNoRW5kKGV2ZW50KTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcblxuICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgLy9cblxuICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCdjb250ZXh0bWVudScsIG9uQ29udGV4dE1lbnUsIGZhbHNlKTtcblxuICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyLm9uKCd3aGVlbCcsIG9uTW91c2VXaGVlbCwgZmFsc2UpO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgICB0aGlzLmV2ZW50SGFuZGxlci5vbigndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gICAgdGhpcy5ldmVudEhhbmRsZXIub24oJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlci5vbigna2V5ZG93bicsIG9uS2V5RG93biwgZmFsc2UpO1xuXG4gICAgLy8gZm9yY2UgYW4gdXBkYXRlIGF0IHN0YXJ0XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG5cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5jZW50ZXIgaGFzIGJlZW4gcmVuYW1lZCB0byAudGFyZ2V0Jyk7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9XG5cbiAgZ2V0IG5vWm9vbSgpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub1pvb20gaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVab29tIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICF0aGlzLmVuYWJsZVpvb207XG4gIH1cblxuICBzZXQgbm9ab29tKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAubm9ab29tIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlWm9vbSBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZW5hYmxlWm9vbSA9ICF2YWx1ZTtcbiAgfVxuXG4gIGdldCBub1JvdGF0ZSgpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5lbmFibGVSb3RhdGU7XG4gIH1cblxuICBzZXQgbm9Sb3RhdGUodmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub1JvdGF0ZSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZVJvdGF0ZSBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZW5hYmxlUm90YXRlID0gIXZhbHVlO1xuICB9XG5cbiAgZ2V0IG5vUGFuKCkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICF0aGlzLmVuYWJsZVBhbjtcbiAgfVxuXG4gIHNldCBub1Bhbih2YWx1ZSkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLm5vUGFuIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlUGFuIGluc3RlYWQuJyk7XG4gICAgdGhpcy5lbmFibGVQYW4gPSAhdmFsdWU7XG4gIH1cblxuICBnZXQgbm9LZXlzKCkge1xuICAgIGNvbnNvbGUud2FybignT3JiaXRDb250cm9sczogLm5vS2V5cyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmVuYWJsZUtleXMgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gIXRoaXMuZW5hYmxlS2V5cztcbiAgfVxuXG4gIHNldCBub0tleXModmFsdWUpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5ub0tleXMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVLZXlzIGluc3RlYWQuJyk7XG4gICAgdGhpcy5lbmFibGVLZXlzID0gIXZhbHVlO1xuICB9XG5cbiAgZ2V0IHN0YXRpY01vdmluZygpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5zdGF0aWNNb3ZpbmcgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5lbmFibGVEYW1waW5nIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuICF0aGlzLmVuYWJsZURhbXBpbmc7XG4gIH1cblxuICBzZXQgc3RhdGljTW92aW5nKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAuc3RhdGljTW92aW5nIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuZW5hYmxlRGFtcGluZyBpbnN0ZWFkLicpO1xuICAgIHRoaXMuZW5hYmxlRGFtcGluZyA9ICF2YWx1ZTtcbiAgfVxuXG4gIGdldCBkeW5hbWljRGFtcGluZ0ZhY3RvcigpIHtcbiAgICBjb25zb2xlLndhcm4oJ09yYml0Q29udHJvbHM6IC5keW5hbWljRGFtcGluZ0ZhY3RvciBoYXMgYmVlbiByZW5hbWVkLiBVc2UgLmRhbXBpbmdGYWN0b3IgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy5kYW1waW5nRmFjdG9yO1xuICB9XG5cbiAgc2V0IGR5bmFtaWNEYW1waW5nRmFjdG9yKHZhbHVlKSB7XG4gICAgY29uc29sZS53YXJuKCdPcmJpdENvbnRyb2xzOiAuZHluYW1pY0RhbXBpbmdGYWN0b3IgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIC5kYW1waW5nRmFjdG9yIGluc3RlYWQuJyk7XG4gICAgdGhpcy5kYW1waW5nRmFjdG9yID0gdmFsdWU7XG4gIH1cbn1cbiIsImltcG9ydCB7VmVjdG9yM30gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHtDb250cm9sc01vZHVsZX0gZnJvbSAnLi4vQ29udHJvbHNNb2R1bGUnO1xuXG5pbXBvcnQge1RocmVlT3JiaXRDb250cm9sc30gZnJvbSAnLi9saWIvVGhyZWVPcmJpdENvbnRyb2xzJztcblxuLyoqXG4gKiBAY2xhc3MgT3JiaXRDb250cm9sc01vZHVsZVxuICogQGNhdGVnb3J5IG1vZHVsZXMvYXBwXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zLm9iamVjdD1jYW1lcmFdIE9iamVjdCB0byB3aGljaCBjb250cm9scyBhcmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7VEhSRUUuVmVjdG9yM30gW3BhcmFtcy50YXJnZXQ9bmV3IFZlY3RvcjMoKV0gQ29udHJvbHMgY2VudGVyIHZlY3Rvci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtcy5mb2xsb3c9ZmFsc2VdIEZvbGxvdyB0aGUgdGFyZ2V0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvYXBwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj4gQ3JlYXRpbmcgYSByZW5kZXJpbmcgbW9kdWxlIGFuZCBwYXNzaW5nIGl0IHRvIEFwcCdzIG1vZHVsZXM8L2NhcHRpb24+XG4gKiBuZXcgQXBwKFtcbiAqICAgbmV3IEVsZW1lbnRNb2R1bGUoKSxcbiAqICAgbmV3IFNjZW5lTW9kdWxlKCksXG4gKiAgIG5ldyBEZWZpbmVNb2R1bGUoJ2NhbWVyYScsIG5ldyBXSFMuUGVyc3BlY3RpdmVDYW1lcmEoe1xuICogICAgIHBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygwLCA2LCAxOCksXG4gKiAgICAgZmFyOiAxMDAwMFxuICogICB9KSksXG4gKiAgIG5ldyBSZW5kZXJpbmdNb2R1bGUoKSxcbiAqICAgbmV3IE9yYml0Q29udHJvbHNNb2R1bGUoKVxuICogXSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBPcmJpdENvbnRyb2xzTW9kdWxlIGV4dGVuZHMgQ29udHJvbHNNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmFtcyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZm9sbG93OiBmYWxzZSxcbiAgICAgIG9iamVjdDogbnVsbCxcbiAgICAgIHRhcmdldDogbmV3IFZlY3RvcjMoKVxuICAgIH0sIHBhcmFtcyk7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBzdXBlci5tYW5hZ2VyKG1hbmFnZXIpO1xuXG4gICAgY29uc3Qge29iamVjdDogb2JqLCBmb2xsb3csIHRhcmdldH0gPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBvYmplY3QgPSBvYmogPyBvYmoubmF0aXZlIDogbWFuYWdlci5nZXQoJ2NhbWVyYScpLm5hdGl2ZTtcblxuICAgIGNvbnN0IGNvbnRyb2xzID0gbmV3IFRocmVlT3JiaXRDb250cm9scyhcbiAgICAgIG9iamVjdCxcbiAgICAgIG1hbmFnZXIuZ2V0KCdlbGVtZW50JyksXG4gICAgICBtYW5hZ2VyLmhhbmRsZXJcbiAgICApO1xuXG4gICAgY29uc3QgdXBkYXRlUHJvY2Vzc29yID0gZm9sbG93ID8gYyA9PiB7XG4gICAgICBjb250cm9scy51cGRhdGUoYy5nZXREZWx0YSgpKTtcbiAgICAgIGNvbnRyb2xzLnRhcmdldC5jb3B5KHRhcmdldCk7XG4gICAgfSA6IGMgPT4ge1xuICAgICAgY29udHJvbHMudXBkYXRlKGMuZ2V0RGVsdGEoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0Q29udHJvbHMoY29udHJvbHMpO1xuICAgIHRoaXMuc2V0VXBkYXRlKHVwZGF0ZVByb2Nlc3Nvcik7XG5cbiAgICBtYW5hZ2VyLnVwZGF0ZSh7XG4gICAgICBjYW1lcmE6IGNhbWVyYSA9PiB7XG4gICAgICAgIGlmIChvYmopIHJldHVybjtcbiAgICAgICAgY29udHJvbHMub2JqZWN0ID0gY2FtZXJhLm5hdGl2ZTtcbiAgICAgIH0sXG4gICAgICBlbGVtZW50OiBlbGVtZW50ID0+IHtcbiAgICAgICAgY29udHJvbHMuZG9tRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb250cm9scy50YXJnZXQuY29weSh0YXJnZXQpO1xuICB9XG59XG4iLCIvKiogQG1vZHVsZSBtb2R1bGVzL2FwcC9jb250cm9scyAqL1xuZXhwb3J0ICogZnJvbSAnLi9PcmJpdENvbnRyb2xzTW9kdWxlJztcbiIsIi8qKiBAbW9kdWxlIG1vZHVsZXMvYXBwICovXG5leHBvcnQgKiBmcm9tICcuL0VsZW1lbnRNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9SZW5kZXJpbmdNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9TY2VuZU1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL1Jlc2l6ZU1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL1Bvc3RQcm9jZXNzb3JNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9WaXJ0dWFsTW91c2VNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9FdmVudHNQYXRjaE1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL0NvbnRyb2xzTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vRm9nTW9kdWxlJztcbmV4cG9ydCAqIGZyb20gJy4vU3RhdGVNb2R1bGUnO1xuXG4vLyBjb250cm9sc1xuZXhwb3J0ICogZnJvbSAnLi9jb250cm9scy9pbmRleCc7XG4iLCIvKipcbiAqIEBjbGFzcyBEeW5hbWljR2VvbWV0cnlNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL21lc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXthdHRyaWJ1dGVzOiBmYWxzZX1dIC0gcGFyYW1zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXRjaEV2ZW50cz10cnVlXVxuICogQG1lbWJlcm9mIG1vZHVsZTptb2R1bGVzL21lc2hcbiAqL1xuZXhwb3J0IGNsYXNzIER5bmFtaWNHZW9tZXRyeU1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgfSwgcGFyYW1zKTtcbiAgfVxuXG4gIGludGVncmF0ZShzZWxmKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc2VsZi5wYXJhbXM7XG5cbiAgICB0aGlzLmdfID0gZnVuY3Rpb24gKHBhcmFtcyA9IHt9KSB7XG4gICAgICBpZiAodGhpcy5idWlsZEdlb21ldHJ5KSB7XG4gICAgICAgIHRoaXMubmF0aXZlLmdlb21ldHJ5ID0gdGhpcy5idWlsZEdlb21ldHJ5KFxuICAgICAgICAgIHRoaXMudXBkYXRlUGFyYW1zKHtnZW9tZXRyeTogcGFyYW1zfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnBhcmFtcy5nZW9tZXRyeSkge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGBnXyR7a2V5fWAsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlLmdlb21ldHJ5LnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5uYXRpdmUuZ2VvbWV0cnkgPSB0aGlzLmJ1aWxkR2VvbWV0cnkodGhpcy51cGRhdGVQYXJhbXMoe2dlb21ldHJ5OiB7W2tleV06IHZhbHVlfX0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFJlcGVhdFdyYXBwaW5nLFxuICBVVk1hcHBpbmcsXG4gIE5lYXJlc3RGaWx0ZXIsXG4gIExpbmVhck1pcE1hcExpbmVhckZpbHRlcixcbiAgVGV4dHVyZUxvYWRlcixcbiAgVmVjdG9yMlxufSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IGxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCk7XG5cbi8qKlxuICogQGNsYXNzIFRleHR1cmVNb2R1bGVcbiAqIEBjYXRlZ29yeSBtb2R1bGVzL21lc2hcbiAqIEBkZXNjcmlwdGlvbiBBIFRleHR1cmVNb2R1bGUgY2FuIGJlIGFwcGxpZWQgdG8gYW55IE1lc2ggb3IgTW9kZWwuXG4gKiBAcGFyYW0ge0FycmF5fSBbdGV4dHVyZXNdIC0gYXJyYXkgb2YgdGV4dHVyZSBvYmplY3RzXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvbWVzaFxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRpbmcgYW4gaW5zdGFuY2UuIHVybCB0YWtlcyBhIHBhdGgsIG9yIGEgZGF0YSBvYmplY3QuPC9jYXB0aW9uPlxuICogdmFyIHdvb2RUZXh0dXJlID0gbmV3IFRleHR1cmVNb2R1bGUoe1xuICogICB1cmw6IGAke3Byb2Nlc3MuYXNzZXRzUGF0aH0vdGV4dHVyZXMvd29vZC5qcGdgXG4gKiB9KTtcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1vcmUgY29tcHJlaGVuc2l2ZSBleGFtcGxlLCB3b29kIHRleHR1cmUgYXBwbGllZCB0byBhIEJveC48L2NhcHRpb24+XG4gKiBuZXcgQm94KHtcbiAqICAgZ2VvbWV0cnk6IHtcbiAqICAgICB3aWR0aDogMixcbiAqICAgICBoZWlnaHQ6IDIsXG4gKiAgICAgZGVwdGg6IDJcbiAqICAgfSxcbiAqICAgbW9kdWxlczogW1xuICogICAgIG5ldyBUZXh0dXJlTW9kdWxlKHtcbiAqICAgICAgIHVybDogYHBhdGgvdG8vdGV4dHVyZS5qcGdgLFxuICogICAgICAgcmVwZWF0OiBuZXcgVEhSRUUuVmVjdG9yMigxLCAxKSAvLyBvcHRpb25hbFxuICogICAgIH0pXG4gKiAgIF0sXG4gKiAgIG1hdGVyaWFsOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICogICAgIGNvbG9yOiAweGZmZmZmZlxuICogICB9KSxcbiAqICAgcG9zaXRpb246IFs1MCwgNjAsIDcwXVxuICogfSkuYWRkVG8oYXBwKTtcbiAqL1xuZXhwb3J0IGNsYXNzIFRleHR1cmVNb2R1bGUge1xuICBzdGF0aWMgbG9hZCh1cmwpIHtcbiAgICByZXR1cm4gbmV3IFRleHR1cmVNb2R1bGUoe3VybH0pLnRleHR1cmVzWzBdWzFdO1xuICB9XG5cbiAgdGV4dHVyZXMgPSBbXTtcblxuICBjb25zdHJ1Y3RvciguLi50ZXh0dXJlcykge1xuICAgIHRleHR1cmVzLmZvckVhY2goKHtcbiAgICAgIHVybCxcbiAgICAgIHR5cGUgPSAnbWFwJyxcbiAgICAgIG9mZnNldCA9IG5ldyBWZWN0b3IyKDAsIDApLFxuICAgICAgcmVwZWF0ID0gbmV3IFZlY3RvcjIoMSwgMSksXG4gICAgICB3cmFwID0gUmVwZWF0V3JhcHBpbmcsXG4gICAgICBtYXBwaW5nID0gVVZNYXBwaW5nLFxuICAgICAgZml4ID0gdGV4ID0+IHRleFxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSBsb2FkZXIubG9hZCh1cmwpO1xuXG4gICAgICBpZiAod3JhcC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHR1cmUud3JhcFMgPSB3cmFwWzBdO1xuICAgICAgICB0ZXh0dXJlLndyYXBUID0gd3JhcFsxXTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0ZXh0dXJlLndyYXBTID0gdGV4dHVyZS53cmFwVCA9IHdyYXA7XG5cbiAgICAgIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cbiAgICAgIHRleHR1cmUub2Zmc2V0LmNvcHkob2Zmc2V0KTtcbiAgICAgIHRleHR1cmUucmVwZWF0LmNvcHkocmVwZWF0KTtcblxuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgICAgIHRoaXMudGV4dHVyZXMucHVzaChbdHlwZSwgZml4KHRleHR1cmUpXSk7XG4gICAgfSk7XG4gIH1cblxuICBicmlkZ2UgPSB7XG4gICAgbWF0ZXJpYWwobWF0ZXJpYWwsIHNlbGYpIHtcbiAgICAgIHNlbGYudGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgbWF0ZXJpYWxbdGV4dHVyZVswXV0gPSB0ZXh0dXJlWzFdO1xuICAgICAgfSk7XG5cbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEFuaW1hdGlvbk1peGVyLFxuICBBbmltYXRpb25DbGlwLFxuICBDbG9ja1xufSBmcm9tICd0aHJlZSc7XG5cbmltcG9ydCB7TG9vcH0gZnJvbSAnLi4vLi4vY29yZS9Mb29wJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0aW9uTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlcy9tZXNoXG4gKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbW9kdWxlIHRoYXQgd3JhcHMgdGhlIDxhIGhyZWY9J2h0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jbWFudWFsL2ludHJvZHVjdGlvbi9BbmltYXRpb24tc3lzdGVtJz50aHJlZS5qcyBhbmltYXRpb24gc3lzdGVtPC9hPlxuICogQHBhcmFtIHtBcHB9IGFwcCAtIHRoZSBhcHBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzRGVmZXJyZWQ9ZmFsc2VdIC0gc2V0IHRvIHRydWUgaWYgYW5pbWF0aW9uIHNob3VsZCBub3Qgc3RhcnQgYXV0b21hdGljYWxseVxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXM9e3NwZWVkOiAxfV0gLSB0aGUgcGFyYW1zXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvbWVzaFxuICogQGV4YW1wbGUgPGNhcHRpb24+Q3JlYXRlIGFuaW1hdGlvbiBtb2R1bGUgYW5kIHBsYXkgYSBnaXZlbiBjbGlwIG9mIGFuIGltcG9ydGVkIG1vZGVsPC9jYXB0aW9uPlxuICogY29uc3QgYW5pbWF0aW9uTW9kdWxlID0gbmV3IEFuaW1hdGlvbk1vZHVsZShhcHAsIGZhbHNlLCB7XG4gKiAgIHNwZWVkOiAxLjIgLy8gc3BlZWQgdXAgYW5pbWF0aW9uIGJ5IDIwJVxuICogfSk7XG4gKlxuICogbmV3IEltcG9ydGVyKHtcbiAqICAgcGFyc2VyKGdlb21ldHJ5LCBtYXRlcmlhbHMpIHtcbiAqICAgICAvLyBPdmVycmlkZSBwYXJzZSB0byBnZW5lcmF0ZSBhIHNraW5uZWRNZXNoLCBuZWVkZWQgZm9yIHNraW5uZWQgbW9kZWxzXG4gKiAgICAgcmV0dXJuIG5ldyBUSFJFRS5Ta2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWxzKTtcbiAqICAgfSxcbiAqXG4gKiAgIHVybDogYHBhdGgvdG8vbW9kZWwuanNvbmAsXG4gKiAgIHVzZUN1c3RvbU1hdGVyaWFsOiB0cnVlLFxuICpcbiAqICAgbWF0ZXJpYWw6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gKiAgICAgc2tpbm5pbmc6IHRydWVcbiAqICAgfSksXG4gKlxuICogICBtb2R1bGVzOiBbYW5pbWF0aW9uTW9kdWxlXVxuICogfSkuYWRkVG8oYXBwKS50aGVuKCgpID0+IHtcbiAqICAgLy8gYWRkaW5nIG1vZGVsIHRvIGFwcCByZXR1cm5zIGEgcHJvbWlzZSwgc28gcGlwZSB0aGUgZnVuY3Rpb24gdG8ga2ljayBvZmYgdGhlIGFuaW1hdGlvbiBjbGlwXG4gKiAgIGFuaW1hdGlvbk1vZHVsZS5wbGF5KCdjbGlwTmFtZScpO1xuICogfSk7XG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRpb25Nb2R1bGUge1xuICBjb25zdHJ1Y3RvcihhcHAsIGlzRGVmZXJyZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHNwZWVkOiAxXG4gICAgfSwgcGFyYW1zKTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IENsb2NrKCk7XG5cbiAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICB0aGlzLmlzRGVmZXJyZWQgPSBpc0RlZmVycmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGxheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIFBsYXlzIHRoZSBnaXZlbiBjbGlwIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsaXBOYW1lIC0gdGhlIGNsaXAgdG8gcGxheVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvbWVzaC5BbmltYXRpb25Nb2R1bGVcbiAgICovXG4gIHBsYXkoY2xpcE5hbWUpIHtcbiAgICBjb25zdCBjbGlwID0gQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKHRoaXMuY2xpcHMsIGNsaXBOYW1lKTtcbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oY2xpcCk7XG5cbiAgICBhY3Rpb24ucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlIHRoZSBtaXhlciAoYmVpbmcgY2FsbGVkIG9uIGZyYW1lIGFuaW1hdGlvbiBsb29wKVxuICAgKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXMvbWVzaC5BbmltYXRpb25Nb2R1bGVcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5taXhlcikgdGhpcy5taXhlci51cGRhdGUodGhpcy5jbG9jay5nZXREZWx0YSgpICogdGhpcy5wYXJhbXMuc3BlZWQpO1xuICB9XG5cbiAgaW50ZWdyYXRlKHNlbGYpIHtcbiAgICBzZWxmLmxvb3AgPSBuZXcgTG9vcCgoKSA9PiB7XG4gICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFzZWxmLmlzRGVmZXJyZWQpIHNlbGYubG9vcC5zdGFydChzZWxmLmFwcCk7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLmRlZmluZSgnYW5pbWF0aW9uJyk7XG4gIH1cblxuICBicmlkZ2UgPSB7XG4gICAgbWVzaChtZXNoLCBzZWxmKSB7XG4gICAgICBtZXNoLmdlb21ldHJ5LnNrZWxldG9uID0gbWVzaC5za2VsZXRvbjtcblxuICAgICAgc2VsZi5taXhlciA9IG5ldyBBbmltYXRpb25NaXhlcihtZXNoLmdlb21ldHJ5KTtcbiAgICAgIHNlbGYuY2xpcHMgPSBtZXNoLmdlb21ldHJ5LmFuaW1hdGlvbnM7XG5cbiAgICAgIHJldHVybiBtZXNoO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqIEBtb2R1bGUgbW9kdWxlcy9tZXNoICovXG5leHBvcnQgKiBmcm9tICcuL0R5bmFtaWNHZW9tZXRyeU1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL1RleHR1cmVNb2R1bGUnO1xuZXhwb3J0ICogZnJvbSAnLi9BbmltYXRpb25Nb2R1bGUnO1xuIiwiLyoqXG4gKiBAY2xhc3MgRGVmaW5lTW9kdWxlXG4gKiBAY2F0ZWdvcnkgbW9kdWxlc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAbWVtYmVyb2YgbW9kdWxlOm1vZHVsZXNcbiAqIEBleGFtcGxlIDxjYXB0aW9uPiBDcmVhdGluZyBhIERlZmluZU1vZHVsZSB3aXRoIFBlcnNwZWN0aXZlQ2FtZXJhIGFzIGNhbWVyYSBtb2R1bGUgYW5kIHBhc3NpbmcgaXQgdG8gQXBwJ3MgbW9kdWxlczwvY2FwdGlvbj5cbiAqIG5ldyBBcHAoW1xuICogICAvLyAuLi5cbiAqICAgbmV3IERlZmluZU1vZHVsZSgnY2FtZXJhJywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKiBdKTtcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmluZU1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBtYW5hZ2VyKG1hbmFnZXIpIHtcbiAgICBtYW5hZ2VyLnNldCh0aGlzLm5hbWUsIHRoaXMuZGF0YSk7XG4gIH1cbn1cbiIsIi8qKiBAbW9kdWxlIG1vZHVsZXMgKi9cblxuZXhwb3J0ICogZnJvbSAnLi9hcHAvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXNoL2luZGV4JztcblxuLy8gbW9kdWxlc1xuZXhwb3J0ICogZnJvbSAnLi9EZWZpbmVNb2R1bGUnO1xuIiwiaW1wb3J0IHtJbXBvcnRlcn0gZnJvbSAnLi9jb21wb25lbnRzL21lc2hlcy9JbXBvcnRlcic7XG5pbXBvcnQge1BlcnNwZWN0aXZlQ2FtZXJhfSBmcm9tICcuL2NvbXBvbmVudHMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbCBleHRlbmRzIEltcG9ydGVyIHtcbiAgY29uc3RydWN0b3IocGFyYW1zLCAuLi5hZGRpdGlvbmFsKSB7XG4gICAgY29uc29sZS53YXJuKCdNb2RlbCBpcyBkZXByZWNhdGVkLiBVc2UgSW1wb3J0ZXIgaW5zdGVhZC4nKTtcblxuICAgIGlmIChwYXJhbXMuZ2VvbWV0cnkpIHtcbiAgICAgIHBhcmFtcy51cmwgPSBwYXJhbXMuZ2VvbWV0cnkucGF0aDtcbiAgICAgIHBhcmFtcy5sb2FkZXIgPSBwYXJhbXMuZ2VvbWV0cnkubG9hZGVyO1xuICAgIH1cblxuICAgIHN1cGVyKHBhcmFtcywgLi4uYWRkaXRpb25hbCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENhbWVyYU1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc29sZS53YXJuKCdDYW1lcmFNb2R1bGUgaXMgZGVwcmVjYXRlZC4gVXNlIERlZmluZU1vZHVsZSBpbnN0ZWFkLicpO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKHBhcmFtcyk7XG4gIH1cblxuICBpbnRlZ3JhdGUoc2VsZikge1xuICAgIHRoaXMuYWRkKHNlbGYuY2FtZXJhKTtcbiAgfVxuXG4gIG1hbmFnZXIobWFuYWdlcikge1xuICAgIG1hbmFnZXIuc2V0KCdjYW1lcmEnLCB0aGlzLmNhbWVyYSk7XG4gIH1cbn1cbiIsIi8qKlxuICogTmFtZXNwYWNlIGNvbnRhaW5pbmcgYWxsIGNsYXNzZXMgZnJvbSBhbGwgbW9kdWxlcy4gVXNlZCBhcyBnbG9iYWwgaW4gVU1EIHBhdHRlcm4uXG4gKiBAbmFtZXNwYWNlIFdIU1xuICogQGV4YW1wbGUgPGNhcHRpb24+VGhlIHVzZSBvZiBXSFMgbmFtZXNwYWNlLjwvY2FwdGlvbj5cbiAqIG5ldyBXSFMuQXBwKCkgLy8gY29yZVxuICogbmV3IFdIUy5QZXJzcGVjdGl2ZUNhbWVyYSgpIC8vIGNvbXBvbmVudHNcbiAqIG5ldyBXSFMuUmVzaXplTW9kdWxlKCkgLy8gbW9kdWxlc1xuICogV0hTLmV4dGVuZCgpIC8vIHV0aWxzXG4gKi9cblxuXG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2xpZ2h0cy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvY2FtZXJhcy9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvbWVzaGVzL2luZGV4JztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvaW5kZXgnO1xuZXhwb3J0ICogZnJvbSAnLi9tb2R1bGVzL2luZGV4JztcblxuLy8gREVQUkVDQVRJT05cbmV4cG9ydCAqIGZyb20gJy4vZGVwcmVjYXRpb24nO1xuIl0sIm5hbWVzIjpbImV4dGVuZCIsIm9iamVjdCIsImV4dGVuc2lvbnMiLCJleHRlbnNpb24iLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicHJvcCIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsImluc3RydWN0IiwiYXJyYXkiLCJpbnN0QXJyYXkiLCJ0ZW1wT2JqZWN0IiwiaSIsIm1heCIsImxlbmd0aCIsImd1aWRlIiwidHJhbnNmb3JtRGF0YSIsImluc3RydWN0aW9ucyIsImtleSIsInRvQXJyYXkiLCJpbnN0cnVjdGlvbiIsInRlbXBBcnJheSIsIkNvbXBvc2l0aW9uRXJyb3IiLCJjbGFzc0luc3RhbmNlIiwibWVzc2FnZSIsImNvbXBvbmVudCIsInN0YWNrQXJyYXkiLCJzdGFjayIsInNwbGl0Iiwic3BsaWNlIiwiam9pbiIsImNvbnNvbGUiLCJlcnJvciIsIm5hbWUiLCJFcnJvciIsIkRlcGVuZGVuY3lFcnJvciIsImFjdGl2ZU1vZHVsZSIsImRlcGVuZGVuY3lNb2R1bGUiLCJNYW5hZ2VyRXJyb3IiLCJ3YXJuRGVwcyIsIlJFVklTSU9OIiwiZXJyIiwiTW9kdWxlU3lzdGVtIiwic291cmNlIiwibW9kdWxlcyIsImFwcGx5TW9kdWxlIiwiYXBwbHlCcmlkZ2UiLCJvbkNvcHkiLCJicmlkZ2VNYXAiLCJtb2R1bGUiLCJicmlkZ2UiLCJhcHBseSIsImNiIiwiZnVuYyIsIm1vZHVsZVNjb3BlIiwicHVzaCIsIm1hbmFnZXIiLCJhY3RpdmUiLCJpbnRlZ3JhdGUiLCJiaW5kIiwiZGlzcG9zZU1vZHVsZSIsImluZGV4T2YiLCJkaXNwb3NlIiwiRXZlbnRzIiwiU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsInN5bVRvU3RyaW5nVGFnIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJyb290IiwicG9ueWZpbGwiLCIkJG9ic2VydmFibGUiLCJNb2R1bGVNYW5hZ2VyIiwiaGFuZGxlciIsImN1cnJlbnRNb2R1bGUiLCJzdG9yZSIsImNyZWF0ZVN0b3JlIiwic3RhdGUiLCJhY3Rpb24iLCJkYXRhIiwiZGlzcGF0Y2giLCJnZXRTdGF0ZSIsIkJvb2xlYW4iLCJkZXBzTWFwIiwic3Vic2NyaWJlIiwiY2hhbmdlZEtleSIsImNhbGxiYWNrIiwid2FybiIsInNldCIsIm1vZHVsZUV4ZWN1dG9yIiwidXNlIiwiQ29tcG9uZW50IiwicGFyYW1zIiwiZGVmYXVsdHMiLCJfd2FpdCIsImNoaWxkcmVuIiwiaW50ZWdyYXRlTW9kdWxlcyIsInByb21pc2UiLCJQcm9taXNlIiwiYWxsIiwiaXNEZWZmZXJlZCIsIndhaXQiLCJ0aGVuIiwiY29weSIsImN1c3RvbWl6ZSIsIm5hdGl2ZSIsImNsb25lIiwicGFyZW50IiwicmVzb2x2ZSIsInJlamVjdCIsImRlZmVyIiwiYWRkUHJvbWlzZSIsIm9uQWRkIiwicmVzb2x2ZXIiLCJhZGQiLCJyZW1vdmUiLCJnZXQiLCJfbWFuYWdlciIsIl9uYXRpdmUiLCJtZXNoIiwiYXR0cmlidXRlcyIsIm1hcHBlcnMiLCJ0YXJnZXQiLCJtYXBwZXIiLCJrIiwibWFwIiwiYXR0cmlidXRlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwidmFsdWUiLCJtaXJyb3IiLCJNZXNoQ29tcG9uZW50IiwiZ2VvbSIsIk1lc2giLCJtYXRlcmlhbCIsImdlb21ldHJ5IiwiY3VzdG9tIiwiYnVpbGQiLCJ3cmFwIiwiYXBwbHlDb21tYW5kIiwicG9zaXRpb24iLCJyb3RhdGlvbiIsInNjYWxlIiwic2hhZG93IiwieCIsInkiLCJ6IiwiY2FzdFNoYWRvdyIsImNhc3QiLCJyZWNlaXZlU2hhZG93IiwicmVjZWl2ZSIsIm9uV3JhcCIsInF1YXRlcm5pb24iLCJkZXN0IiwiTGlnaHRDb21wb25lbnQiLCJsaWdodCIsIndyYXBTaGFkb3ciLCJtYXBTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJiaWFzIiwicmFkaXVzIiwic2hhZG93Q2FtZXJhIiwiY2FtZXJhIiwibmVhciIsImZhciIsImZvdiIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsIkNhbWVyYUNvbXBvbmVudCIsInN5c3RlbSIsIndpbmRvdyIsImdsb2JhbCIsIkFwcCIsImxvZyIsInZlcnNpb24iLCJlbmFibGVkIiwibG9vcHMiLCJyZXF1ZXN0QW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsInByb2Nlc3MiLCJsbCIsImUiLCJleGVjdXRlIiwiY2xvY2siLCJsb29wIiwiaW5kZXgiLCJMb29wIiwidXNlQ2xvY2siLCJDbG9jayIsIndvcmxkIiwiYWRkTG9vcCIsInN0YXJ0Iiwic3RvcCIsInJlbW92ZUxvb3AiLCJBbWJpZW50TGlnaHQiLCJBbWJpZW50TGlnaHROYXRpdmUiLCJjb2xvciIsImludGVuc2l0eSIsIkRpcmVjdGlvbmFsTGlnaHQiLCJEaXJlY3Rpb25hbExpZ2h0TmF0aXZlIiwiSGVtaXNwaGVyZUxpZ2h0IiwiSGVtaXNwaGVyZUxpZ2h0TmF0aXZlIiwic2t5Q29sb3IiLCJncm91bmRDb2xvciIsIlBvaW50TGlnaHQiLCJQb2ludExpZ2h0TmF0aXZlIiwiZGlzdGFuY2UiLCJkZWNheSIsIlNwb3RMaWdodCIsIlNwb3RMaWdodE5hdGl2ZSIsImFuZ2xlIiwiZXhwb25lbnQiLCJNYXRoIiwiUEkiLCJBcmVhTGlnaHQiLCJSZWN0QXJlYUxpZ2h0TmF0aXZlIiwiQ3ViZUNhbWVyYSIsIkN1YmVDYW1lcmFOYXRpdmUiLCJjdWJlUmVzb2x1dGlvbiIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIk9ydGhvZ3JhcGhpY0NhbWVyYU5hdGl2ZSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmFOYXRpdmUiLCJhc3BlY3QiLCJCb3giLCJidWlsZEdlb21ldHJ5IiwiYnVmZmVyIiwiQm94QnVmZmVyR2VvbWV0cnkiLCJCb3hHZW9tZXRyeSIsImRlcHRoIiwid2lkdGhTZWdtZW50cyIsImhlaWdodFNlZ21lbnRzIiwiZGVwdGhTZWdtZW50cyIsIkNpcmNsZSIsIkNpcmNsZUJ1ZmZlckdlb21ldHJ5IiwiQ2lyY2xlR2VvbWV0cnkiLCJzZWdtZW50cyIsInRoZXRhU3RhcnQiLCJ0aGV0YUxlbmd0aCIsIkNvbmUiLCJDb25lQnVmZmVyR2VvbWV0cnkiLCJDb25lR2VvbWV0cnkiLCJyYWRpdXNTZWdtZW50cyIsIm9wZW5FbmRlZCIsIkN5bGluZGVyIiwiQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSIsIkN5bGluZGVyR2VvbWV0cnkiLCJyYWRpdXNUb3AiLCJyYWRpdXNCb3R0b20iLCJEb2RlY2FoZWRyb24iLCJEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSIsIkRvZGVjYWhlZHJvbkdlb21ldHJ5IiwiZGV0YWlsIiwiRXh0cnVkZSIsIkV4dHJ1ZGVHZW9tZXRyeSIsInNoYXBlcyIsIm9wdGlvbnMiLCJCdWZmZXJHZW9tZXRyeSIsImZyb21HZW9tZXRyeSIsIkljb3NhaGVkcm9uIiwiSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJMYXRoZSIsIkxhdGhlQnVmZmVyR2VvbWV0cnkiLCJMYXRoZUdlb21ldHJ5IiwicG9pbnRzIiwiTGluZSIsIkxpbmVOYXRpdmUiLCJHZW9tZXRyeSIsInBwIiwiY3VydmUiLCJnZXRQb2ludHMiLCJ2ZXJ0cyIsIkZsb2F0MzJBcnJheSIsImkzIiwiYWRkQXR0cmlidXRlIiwiQnVmZmVyQXR0cmlidXRlIiwidmVydGljZXMiLCJJbXBvcnRlciIsImZpbHRlciIsInByb2Nlc3NGaWx0ZXIiLCJmb3JFYWNoIiwiZWwiLCJ0ZXh0dXJlUGF0aCIsImxvYWRlciIsInNldFRleHR1cmVQYXRoIiwibG9hZCIsInVybCIsIm9uTG9hZCIsInBhcnNlciIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwiSlNPTkxvYWRlciIsIm1hdCIsImJvbmVzIiwiU2tpbm5lZE1lc2giLCJPY3RhaGVkcm9uIiwiT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5IiwiT2N0YWhlZHJvbkdlb21ldHJ5IiwiUGFyYW1ldHJpYyIsIlBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSIsIlBhcmFtZXRyaWNHZW9tZXRyeSIsInNsaWNlcyIsInN0YWNrcyIsInUiLCJ2IiwiVmVjdG9yMyIsIlBsYW5lIiwiUGxhbmVCdWZmZXJHZW9tZXRyeSIsIlBsYW5lR2VvbWV0cnkiLCJ3U2VnbWVudHMiLCJoU2VnbWVudHMiLCJ2ZXJ0aWNlc09mQ3ViZSIsImluZGljZXNPZkZhY2VzIiwiUG9seWhlZHJvbiIsIlBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSIsIlBvbHloZWRyb25HZW9tZXRyeSIsIlJpbmciLCJSaW5nQnVmZmVyR2VvbWV0cnkiLCJSaW5nR2VvbWV0cnkiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwidGhldGFTZWdtZW50cyIsInBoaVNlZ21lbnRzIiwiU2hhcGUiLCJTaGFwZUJ1ZmZlckdlb21ldHJ5IiwiU2hhcGVHZW9tZXRyeSIsIlNwaGVyZSIsIlNwaGVyZUJ1ZmZlckdlb21ldHJ5IiwiU3BoZXJlR2VvbWV0cnkiLCJUZXRyYWhlZHJvbiIsIlRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkiLCJUZXRyYWhlZHJvbkdlb21ldHJ5IiwiVGV4dCIsInBhdGgiLCJmb250IiwiVGV4dEdlb21ldHJ5IiwidGV4dCIsImFzc2lnbiIsIkZvbnQiLCJGb250TG9hZGVyIiwiVG9ydXMiLCJUb3J1c0dlb21ldHJ5IiwidHViZSIsInJhZGlhbFNlZ21lbnRzIiwidHVidWxhclNlZ21lbnRzIiwiYXJjIiwiVG9ydXNrbm90IiwiR0NvbnN0cnVjdCIsIlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5IiwiVG9ydXNLbm90R2VvbWV0cnkiLCJwIiwicSIsIlR1YmUiLCJUdWJlQnVmZmVyR2VvbWV0cnkiLCJUdWJlR2VvbWV0cnkiLCJjbG9zZWQiLCJMaW5lQ3VydmUzIiwiR3JvdXAiLCJvYmplY3RzIiwib2JqIiwiYWRkVG8iLCJPYmplY3QzRCIsIkVsZW1lbnRNb2R1bGUiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImJvZHkiLCJjcmVhdGVFbGVtZW50IiwiZWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwic2VsZiIsImFwcGVuZENoaWxkIiwiUmVuZGVyaW5nTW9kdWxlIiwiYWRkaXRpb25hbCIsIlZlY3RvcjIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmdDb2xvciIsImJnT3BhY2l0eSIsInJlbmRlcmVyIiwicGl4ZWxSYXRpbyIsInJlc29sdXRpb24iLCJmaXgiLCJXZWJHTFJlbmRlcmVyIiwiZWZmZWN0cyIsInNldENsZWFyQ29sb3IiLCJzZXRQaXhlbFJhdGlvIiwic2V0U2l6ZSIsIk51bWJlciIsInRvRml4ZWQiLCJhcHBseUFkZGl0aW9uYWwiLCJzY2VuZSIsImF0dGFjaFRvQ2FudmFzIiwicmVuZGVyIiwiZWZmZWN0IiwiZWZmZWN0TG9vcCIsInJlbmRlckxvb3AiLCJzaXplIiwiZ2V0U2l6ZSIsImFwcCIsImNhbnZhcyIsImRvbUVsZW1lbnQiLCJkZWZpbmUiLCJpbnRlZ3JhdGVSZW5kZXJlciIsInVwZGF0ZSIsImZvcmNlQ29udGV4dExvc3MiLCJzaGFkb3dNYXAiLCJTY2VuZU1vZHVsZSIsIndpbGxTY2VuZUJlUmVwbGFjZWQiLCJTY2VuZSIsInNldFNjZW5lIiwiUmVzaXplTW9kdWxlIiwiY2FsbGJhY2tzIiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInJlbmRlcmluZyIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiZ2V0Q29udGFpbmVyIiwiZ2V0UmVzb2x1dGlvbiIsImF1dG8iLCJhZGRFdmVudExpc3RlbmVyIiwidHJpZ2dlciIsImFkZEF1dG9yZXNpemUiLCJmcmFnbWVudCIsInZlcnRleCIsIkFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsIiwiVW5pZm9ybSIsIlNoYWRlck1hdGVyaWFsIiwiQm9rZWhNYXRlcmlhbCIsImZvY3VzIiwiYXBlcnR1cmUiLCJtYXhCbHVyIiwiYWRvcHRDYW1lcmFTZXR0aW5ncyIsInVuaWZvcm1zIiwiY2FtZXJhTmVhciIsImNhbWVyYUZhciIsIkJva2VoMk1hdGVyaWFsIiwicmluZ3MiLCJzYW1wbGVzIiwic2hvd0ZvY3VzIiwibWFudWFsRG9GIiwidmlnbmV0dGUiLCJwZW50YWdvbiIsInNoYWRlckZvY3VzIiwibm9pc2UiLCJkZWZpbmVzIiwiU0hPV19GT0NVUyIsIk1BTlVBTF9ET0YiLCJWSUdORVRURSIsIlBFTlRBR09OIiwiU0hBREVSX0ZPQ1VTIiwiTk9JU0UiLCJ0ZXhlbFNpemUiLCJzZXRUZXhlbFNpemUiLCJoYWxmVGV4ZWxTaXplIiwibXVsdGlwbHlTY2FsYXIiLCJmb2NhbExlbmd0aCIsImdldEZvY2FsTGVuZ3RoIiwiQ29tYmluZU1hdGVyaWFsIiwic2NyZWVuTW9kZSIsIlNDUkVFTl9NT0RFIiwiQ29udm9sdXRpb25NYXRlcmlhbCIsImtlcm5lbFNpemUiLCJLZXJuZWxTaXplIiwiTEFSR0UiLCJrZXJuZWxQcmVzZXRzIiwiQ29weU1hdGVyaWFsIiwiRGVwdGhNYXRlcmlhbCIsIkRvdFNjcmVlbk1hdGVyaWFsIiwiYXZlcmFnZSIsIlZlY3RvcjQiLCJBVkVSQUdFIiwiRmlsbU1hdGVyaWFsIiwic2NhbmxpbmVzIiwiZ3JleXNjYWxlIiwic2VwaWEiLCJlc2tpbCIsIm5vaXNlSW50ZW5zaXR5Iiwic2NhbmxpbmVJbnRlbnNpdHkiLCJncmV5c2NhbGVJbnRlbnNpdHkiLCJzZXBpYUludGVuc2l0eSIsInZpZ25ldHRlT2Zmc2V0IiwidmlnbmV0dGVEYXJrbmVzcyIsIkdSRVlTQ0FMRSIsIlNFUElBIiwiRVNLSUwiLCJTQ0FOTElORVMiLCJHbGl0Y2hNYXRlcmlhbCIsIkdvZFJheXNNYXRlcmlhbCIsIkx1bWlub3NpdHlNYXRlcmlhbCIsInJhbmdlIiwiQ09MT1IiLCJSQU5HRSIsIlBpeGVsYXRpb25NYXRlcmlhbCIsImdyYW51bGFyaXR5IiwiZHgiLCJkeSIsIlNob2NrV2F2ZU1hdGVyaWFsIiwibWF4UmFkaXVzIiwid2F2ZVNpemUiLCJhbXBsaXR1ZGUiLCJTTUFBQmxlbmRNYXRlcmlhbCIsIlNNQUFDb2xvckVkZ2VzTWF0ZXJpYWwiLCJTTUFBV2VpZ2h0c01hdGVyaWFsIiwiYXJlYUltYWdlIiwic2VhcmNoSW1hZ2UiLCJUb25lTWFwcGluZ01hdGVyaWFsIiwiUGFzcyIsInF1YWQiLCJmcnVzdHVtQ3VsbGVkIiwibmVlZHNTd2FwIiwicmVuZGVyVG9TY3JlZW4iLCJyZWFkQnVmZmVyIiwid3JpdGVCdWZmZXIiLCJkZWx0YSIsIm1hc2tBY3RpdmUiLCJhbHBoYSIsImtleXMiLCJCbHVyUGFzcyIsInJlbmRlclRhcmdldFgiLCJXZWJHTFJlbmRlclRhcmdldCIsIkxpbmVhckZpbHRlciIsInRleHR1cmUiLCJnZW5lcmF0ZU1pcG1hcHMiLCJyZW5kZXJUYXJnZXRZIiwicmVzb2x1dGlvblNjYWxlIiwiY29udm9sdXRpb25NYXRlcmlhbCIsImtlcm5lbCIsImdldEtlcm5lbCIsImxhc3RSVCIsImRlc3RSVCIsImwiLCJ0RGlmZnVzZSIsImZvcm1hdCIsIlJHQkZvcm1hdCIsImZsb29yIiwiQmxvb21QYXNzIiwiYmx1clBhc3MiLCJyZW5kZXJUYXJnZXQiLCJjb21iaW5lTWF0ZXJpYWwiLCJsdW1pbm9zaXR5TWF0ZXJpYWwiLCJkaXN0aW5jdGlvbiIsInRleHR1cmUxIiwidGV4dHVyZTIiLCJpbml0aWFsaXNlIiwib3BhY2l0eTIiLCJCb2tlaFBhc3MiLCJib2tlaE1hdGVyaWFsIiwidERlcHRoIiwiZGVwdGhUZXh0dXJlIiwiQm9rZWgyUGFzcyIsIkNsZWFyTWFza1Bhc3MiLCJidWZmZXJzIiwic3RlbmNpbCIsInNldFRlc3QiLCJDb2xvciIsIkNsZWFyUGFzcyIsImNsZWFyQ29sb3IiLCJjbGVhckFscGhhIiwiZ2V0Q2xlYXJDb2xvciIsImdldENsZWFyQWxwaGEiLCJzZXRSZW5kZXJUYXJnZXQiLCJjbGVhciIsIkRvdFNjcmVlblBhc3MiLCJvZmZzZXRSZXBlYXQiLCJ3IiwiRGVwdGhQYXNzIiwiZGVwdGhNYXRlcmlhbCIsIkZpbG1QYXNzIiwic2NhbmxpbmVEZW5zaXR5IiwidGltZSIsInNjYW5saW5lQ291bnQiLCJyb3VuZCIsInJhbmRvbUludCIsImxvdyIsImhpZ2giLCJyYW5kb20iLCJyYW5kb21GbG9hdCIsIkdsaXRjaFBhc3MiLCJwZXJ0dXJiTWFwIiwiZ2VuZXJhdGVQZXJ0dXJiTWFwIiwiZHRTaXplIiwibW9kZSIsIkdsaXRjaE1vZGUiLCJTUE9SQURJQyIsImNvdW50ZXIiLCJicmVha1BvaW50IiwicGl4ZWxzIiwiZHQiLCJEYXRhVGV4dHVyZSIsIkZsb2F0VHlwZSIsIm5lZWRzVXBkYXRlIiwic2VlZCIsIkNPTlNUQU5UX1dJTEQiLCJhbW91bnQiLCJzZWVkWCIsInNlZWRZIiwiZGlzdG9ydGlvblgiLCJkaXN0b3J0aW9uWSIsIkNPTlNUQU5UX01JTEQiLCJ0UGVydHVyYiIsIlJlbmRlclBhc3MiLCJjbGVhclBhc3MiLCJvdmVycmlkZU1hdGVyaWFsIiwiY2xlYXJEZXB0aCIsImNsYW1wIiwibWluIiwiR29kUmF5c1Bhc3MiLCJsaWdodFNvdXJjZSIsImxpZ2h0U2NlbmUiLCJtYWluU2NlbmUiLCJtYWluQ2FtZXJhIiwicmVuZGVyUGFzc0xpZ2h0IiwicmVuZGVyUGFzc01hc2siLCJNZXNoQmFzaWNNYXRlcmlhbCIsInJlbmRlclRhcmdldE1hc2siLCJzY3JlZW5Qb3NpdGlvbiIsImdvZFJheXNNYXRlcmlhbCIsImxpZ2h0UG9zaXRpb24iLCJleHBvc3VyZSIsImRlbnNpdHkiLCJ3ZWlnaHQiLCJjbGFtcE1heCIsImJhY2tncm91bmQiLCJwcm9qZWN0IiwicGFyc2VJbnQiLCJOVU1fU0FNUExFU19JTlQiLCJOVU1fU0FNUExFU19GTE9BVCIsIk1hc2tQYXNzIiwiaW52ZXJzZSIsImNsZWFyU3RlbmNpbCIsImNvbnRleHQiLCJ3cml0ZVZhbHVlIiwiY2xlYXJWYWx1ZSIsInNldE1hc2siLCJzZXRMb2NrZWQiLCJzZXRPcCIsIlJFUExBQ0UiLCJzZXRGdW5jIiwiQUxXQVlTIiwic2V0Q2xlYXIiLCJFUVVBTCIsIktFRVAiLCJQaXhlbGF0aW9uUGFzcyIsInBpeGVsYXRpb25NYXRlcmlhbCIsInNldFJlc29sdXRpb24iLCJTYXZlUGFzcyIsInJlc2l6ZSIsIlNoYWRlclBhc3MiLCJ0ZXh0dXJlSUQiLCJIQUxGX1BJIiwiYWIiLCJTaG9ja1dhdmVQYXNzIiwiZXBpY2VudGVyIiwic3BlZWQiLCJzaG9ja1dhdmVNYXRlcmlhbCIsImNlbnRlciIsImNvcHlNYXRlcmlhbCIsImdldFdvcmxkRGlyZWN0aW9uIiwic3ViIiwiYW5nbGVUbyIsImNhbWVyYURpc3RhbmNlIiwiZGlzdGFuY2VUbyIsIlNNQUFQYXNzIiwiSW1hZ2UiLCJyZW5kZXJUYXJnZXRDb2xvckVkZ2VzIiwicmVuZGVyVGFyZ2V0V2VpZ2h0cyIsIlJHQkFGb3JtYXQiLCJjb2xvckVkZ2VzTWF0ZXJpYWwiLCJ3ZWlnaHRzTWF0ZXJpYWwiLCJzcmMiLCJhcmVhVGV4dHVyZSIsIlRleHR1cmUiLCJpbWFnZSIsIm1pbkZpbHRlciIsImZsaXBZIiwic2VhcmNoVGV4dHVyZSIsIm1hZ0ZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJ0QXJlYSIsInRTZWFyY2giLCJibGVuZE1hdGVyaWFsIiwidFdlaWdodHMiLCJUZXh0dXJlUGFzcyIsIm9wYWNpdHkiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJ0cmFuc3BhcmVudCIsImNlaWwyIiwibiIsInBvdyIsImNlaWwiLCJsb2cyIiwiVG9uZU1hcHBpbmdQYXNzIiwicmVuZGVyVGFyZ2V0THVtaW5vc2l0eSIsIkxpbmVhck1pcE1hcExpbmVhckZpbHRlciIsInJlbmRlclRhcmdldEFkYXB0ZWQiLCJyZW5kZXJUYXJnZXRQcmV2aW91cyIsImFkYXB0aXZlTHVtaW5vc2l0eU1hdGVyaWFsIiwidG9uZU1hcHBpbmdNYXRlcmlhbCIsImFkYXB0aXZlIiwidFByZXZpb3VzTHVtIiwidEN1cnJlbnRMdW0iLCJNSVBfTEVWRUxfMVgxIiwiQURBUFRFRF9MVU1JTkFOQ0UiLCJsdW1pbmFuY2VNYXAiLCJFZmZlY3RDb21wb3NlciIsImF1dG9DbGVhciIsImNyZWF0ZUJ1ZmZlciIsImRlcHRoQnVmZmVyIiwic3RlbmNpbEJ1ZmZlciIsImNvcHlQYXNzIiwicGFzc2VzIiwib2xkUmVuZGVyZXIiLCJvbGRTaXplIiwibmV3U2l6ZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImdldFBpeGVsUmF0aW8iLCJnZXRDb250ZXh0QXR0cmlidXRlcyIsIkRlcHRoVGV4dHVyZSIsIkRlcHRoU3RlbmNpbEZvcm1hdCIsInR5cGUiLCJVbnNpZ25lZEludDI0OFR5cGUiLCJwYXNzIiwic3RlbmNpbEZ1bmMiLCJOT1RFUVVBTCIsInBvcCIsInBvbHlmaWxsIiwibWV0aG9kIiwic2hvd1dhcm4iLCJQb3N0UHJvY2Vzc29yTW9kdWxlIiwiY3VycmVudFBhc3MiLCJkZWJ1ZyIsImNvbXBvc2VyIiwiZ2V0RGVsdGEiLCJyZXBsYWNlUmVuZGVyZXIiLCJhZGRQYXNzIiwiYm9vbCIsIkV2ZW50c1BhdGNoTW9kdWxlIiwib3JpZ2luT2JqZWN0IiwiZGVzdE9iamVjdCIsImV2ZW50cyIsImV2ZW50IiwiZW1pdCIsInBhdGNoRXZlbnRzIiwiVmlydHVhbE1vdXNlTW9kdWxlIiwiZ2xvYmFsTW92ZW1lbnQiLCJtb3VzZSIsInJheWNhc3RlciIsIlJheWNhc3RlciIsInByb2plY3Rpb25QbGFuZSIsImN1c3RvbVgiLCJjdXN0b21ZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwibm9ybWFsIiwic2V0RnJvbUNhbWVyYSIsInJlcXVpcmUiLCJvbiIsImV2IiwiZ2xvYmFsWCIsImdsb2JhbFkiLCJwb2ludGVyTG9ja0VsZW1lbnQiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJuZXN0ZWQiLCJpc0hvdmVyZWQiLCJob3ZlcnMiLCJ0cmF2ZXJzZSIsImNoaWxkIiwiaW50ZXJzZWN0T2JqZWN0cyIsImludGVyc2VjdE9iamVjdCIsInBsYW5lIiwicmF5IiwiaW50ZXJzZWN0UGxhbmUiLCJpbnRlcnNlY3Rpb24iLCJDb250cm9sc01vZHVsZSIsImNvbnRyb2xzIiwiYyIsInVwZGF0ZUxvb3AiLCJGb2dNb2R1bGUiLCJmb2ciLCJGb2dFeHAyIiwiRm9nIiwiaXNFcXVhbERlZmF1bHQiLCJhIiwiYiIsImVxdWFscyIsIlN0YXRlTW9kdWxlIiwiaXNFcXVhbCIsImVxdWFsQ2hlY2siLCJhY3Rpb25HZW5lcmF0ZSIsImNvbmZpZ3VyYXRpb24iLCJjdXJyZW50Q29uZmlnIiwicHJldkNvbmZpZyIsImNvbmZpZyIsImRlZmF1bHQiLCJyZXBsYWNlUmVkdWNlciIsImNvbmZpZ3MiLCJ1cGRhdGVzIiwiY29uZmlnTmFtZSIsInRydWVWYWwiLCJmYWxzZVZhbCIsIlRocmVlT3JiaXRDb250cm9scyIsImV2ZW50SGFuZGxlciIsIm1pbkRpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJJbmZpbml0eSIsIm1pblpvb20iLCJtYXhab29tIiwibWluUG9sYXJBbmdsZSIsIm1heFBvbGFyQW5nbGUiLCJtaW5BemltdXRoQW5nbGUiLCJtYXhBemltdXRoQW5nbGUiLCJlbmFibGVEYW1waW5nIiwiZGFtcGluZ0ZhY3RvciIsImVuYWJsZVpvb20iLCJ6b29tU3BlZWQiLCJlbmFibGVSb3RhdGUiLCJyb3RhdGVTcGVlZCIsImVuYWJsZVBhbiIsImtleVBhblNwZWVkIiwiYXV0b1JvdGF0ZSIsImF1dG9Sb3RhdGVTcGVlZCIsImVuYWJsZUtleXMiLCJMRUZUIiwiVVAiLCJSSUdIVCIsIkJPVFRPTSIsIm1vdXNlQnV0dG9ucyIsIk9SQklUIiwiTU9VU0UiLCJaT09NIiwiTUlERExFIiwiUEFOIiwidGFyZ2V0MCIsInBvc2l0aW9uMCIsInpvb20wIiwiem9vbSIsImdldFBvbGFyQW5nbGUiLCJzcGhlcmljYWwiLCJwaGkiLCJnZXRBemltdXRoYWxBbmdsZSIsInRoZXRhIiwicmVzZXQiLCJkaXNwYXRjaEV2ZW50IiwiY2hhbmdlRXZlbnQiLCJTVEFURSIsIk5PTkUiLCJvZmZzZXQiLCJxdWF0IiwiUXVhdGVybmlvbiIsInNldEZyb21Vbml0VmVjdG9ycyIsInVwIiwicXVhdEludmVyc2UiLCJsYXN0UG9zaXRpb24iLCJsYXN0UXVhdGVybmlvbiIsImFwcGx5UXVhdGVybmlvbiIsInNldEZyb21WZWN0b3IzIiwicm90YXRlTGVmdCIsImdldEF1dG9Sb3RhdGlvbkFuZ2xlIiwic3BoZXJpY2FsRGVsdGEiLCJtYWtlU2FmZSIsInBhbk9mZnNldCIsInNldEZyb21TcGhlcmljYWwiLCJsb29rQXQiLCJ6b29tQ2hhbmdlZCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiRVBTIiwiZG90IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uQ29udGV4dE1lbnUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VXaGVlbCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoTW92ZSIsIm9uTW91c2VNb3ZlIiwib25Nb3VzZVVwIiwib25LZXlEb3duIiwic3RhcnRFdmVudCIsImVuZEV2ZW50IiwiUk9UQVRFIiwiRE9MTFkiLCJUT1VDSF9ST1RBVEUiLCJUT1VDSF9ET0xMWSIsIlRPVUNIX1BBTiIsIlNwaGVyaWNhbCIsInJvdGF0ZVN0YXJ0Iiwicm90YXRlRW5kIiwicm90YXRlRGVsdGEiLCJwYW5TdGFydCIsInBhbkVuZCIsInBhbkRlbHRhIiwiZG9sbHlTdGFydCIsImRvbGx5RW5kIiwiZG9sbHlEZWx0YSIsImdldFpvb21TY2FsZSIsInJvdGF0ZVVwIiwicGFuTGVmdCIsIm9iamVjdE1hdHJpeCIsInNldEZyb21NYXRyaXhDb2x1bW4iLCJwYW5VcCIsInBhbiIsImRlbHRhWCIsImRlbHRhWSIsInRhcmdldERpc3RhbmNlIiwidGFuIiwiY2xpZW50SGVpZ2h0IiwibWF0cml4IiwiY2xpZW50V2lkdGgiLCJkb2xseUluIiwiZG9sbHlTY2FsZSIsImRvbGx5T3V0IiwiaGFuZGxlTW91c2VEb3duUm90YXRlIiwiaGFuZGxlTW91c2VEb3duRG9sbHkiLCJoYW5kbGVNb3VzZURvd25QYW4iLCJoYW5kbGVNb3VzZU1vdmVSb3RhdGUiLCJzdWJWZWN0b3JzIiwiaGFuZGxlTW91c2VNb3ZlRG9sbHkiLCJoYW5kbGVNb3VzZU1vdmVQYW4iLCJoYW5kbGVNb3VzZVVwIiwiaGFuZGxlTW91c2VXaGVlbCIsImhhbmRsZUtleURvd24iLCJrZXlDb2RlIiwiaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiaGFuZGxlVG91Y2hTdGFydERvbGx5Iiwic3FydCIsImhhbmRsZVRvdWNoU3RhcnRQYW4iLCJoYW5kbGVUb3VjaE1vdmVSb3RhdGUiLCJoYW5kbGVUb3VjaE1vdmVEb2xseSIsImhhbmRsZVRvdWNoTW92ZVBhbiIsImhhbmRsZVRvdWNoRW5kIiwicHJldmVudERlZmF1bHQiLCJidXR0b24iLCJzdG9wUHJvcGFnYXRpb24iLCJFdmVudERpc3BhdGNoZXIiLCJPcmJpdENvbnRyb2xzTW9kdWxlIiwiZm9sbG93IiwidXBkYXRlUHJvY2Vzc29yIiwic2V0Q29udHJvbHMiLCJzZXRVcGRhdGUiLCJEeW5hbWljR2VvbWV0cnlNb2R1bGUiLCJnXyIsInVwZGF0ZVBhcmFtcyIsInBhcmFtZXRlcnMiLCJUZXh0dXJlTG9hZGVyIiwiVGV4dHVyZU1vZHVsZSIsInRleHR1cmVzIiwicmVwZWF0IiwiUmVwZWF0V3JhcHBpbmciLCJtYXBwaW5nIiwiVVZNYXBwaW5nIiwidGV4Iiwid3JhcFMiLCJ3cmFwVCIsIkFuaW1hdGlvbk1vZHVsZSIsImlzRGVmZXJyZWQiLCJza2VsZXRvbiIsIm1peGVyIiwiQW5pbWF0aW9uTWl4ZXIiLCJjbGlwcyIsImFuaW1hdGlvbnMiLCJjbGlwTmFtZSIsImNsaXAiLCJBbmltYXRpb25DbGlwIiwiZmluZEJ5TmFtZSIsImNs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
