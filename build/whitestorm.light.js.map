{"version":3,"sources":["webpack:///whitestorm.light.js","webpack:///webpack/bootstrap 275062868896bd46ab55","webpack:///./src/index.js","webpack:///./src/cameras/index.js","webpack:///./src/cameras/CubeCamera.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/babel-runtime/helpers/createClass.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/core-js/library/fn/object/define-property.js","webpack:///./~/core-js/library/modules/es6.object.define-property.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/babel-runtime/helpers/possibleConstructorReturn.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/babel-runtime/core-js/symbol/iterator.js","webpack:///./~/core-js/library/fn/symbol/iterator.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/_add-to-unscopables.js","webpack:///./~/core-js/library/modules/_iter-step.js","webpack:///./~/core-js/library/modules/_wks-ext.js","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/core-js/library/fn/symbol/index.js","webpack:///./~/core-js/library/modules/es6.symbol.js","webpack:///./~/core-js/library/modules/_meta.js","webpack:///./~/core-js/library/modules/_wks-define.js","webpack:///./~/core-js/library/modules/_keyof.js","webpack:///./~/core-js/library/modules/_enum-keys.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_is-array.js","webpack:///./~/core-js/library/modules/_object-gopn-ext.js","webpack:///./~/core-js/library/modules/_object-gopn.js","webpack:///./~/core-js/library/modules/_object-gopd.js","webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.observable.js","webpack:///./~/babel-runtime/helpers/inherits.js","webpack:///./~/babel-runtime/core-js/object/set-prototype-of.js","webpack:///./~/core-js/library/fn/object/set-prototype-of.js","webpack:///./~/core-js/library/modules/es6.object.set-prototype-of.js","webpack:///./~/core-js/library/modules/_set-proto.js","webpack:///./~/babel-runtime/core-js/object/create.js","webpack:///./~/core-js/library/fn/object/create.js","webpack:///./~/core-js/library/modules/es6.object.create.js","webpack:///./~/babel-runtime/helpers/get.js","webpack:///./~/babel-runtime/core-js/object/get-prototype-of.js","webpack:///./~/core-js/library/fn/object/get-prototype-of.js","webpack:///./~/core-js/library/modules/es6.object.get-prototype-of.js","webpack:///./~/core-js/library/modules/_object-sap.js","webpack:///./~/babel-runtime/core-js/object/get-own-property-descriptor.js","webpack:///./~/core-js/library/fn/object/get-own-property-descriptor.js","webpack:///./~/core-js/library/modules/es6.object.get-own-property-descriptor.js","webpack:///./~/three/build/three.js","webpack:///./src/core/Camera.js","webpack:///./src/extensions/Loop.js","webpack:///./src/utils/defaults.js","webpack:///./src/core/Object.js","webpack:///./~/minivents/dist/minivents.commonjs.min.js","webpack:///./src/extras/api.js","webpack:///./src/physics/nophysi.js","webpack:///./src/utils/loaders.js","webpack:///./~/three-obj-loader/dist/index.js","webpack:///./src/cameras/OrtographicCamera.js","webpack:///./src/cameras/PerspectiveCamera.js","webpack:///./src/core/index.js","webpack:///./src/core/Light.js","webpack:///./src/core/Shape.js","webpack:///./src/core/World.js","webpack:///./~/stats.js/build/stats.min.js","webpack:///./src/extensions/index.js","webpack:///./src/extras/index.js","webpack:///./src/extras/controls/firstPersonControls.js","webpack:///./src/extras/controls/orbitControls.js","webpack:///./~/three-orbit-controls/index.js","webpack:///./src/extras/Curve.js","webpack:///./src/extras/Points.js","webpack:///./src/extras/Group.js","webpack:///./src/extras/Skybox.js","webpack:///./src/lights/index.js","webpack:///./src/lights/AmbientLight.js","webpack:///./src/lights/DirectionalLight.js","webpack:///./src/lights/HemisphereLight.js","webpack:///./src/lights/NormalLight.js","webpack:///./src/lights/PointLight.js","webpack:///./src/lights/SpotLight.js","webpack:///./src/meshes/index.js","webpack:///./src/meshes/Box.js","webpack:///./src/meshes/Cylinder.js","webpack:///./src/meshes/Dodecahedron.js","webpack:///./src/meshes/Extrude.js","webpack:///./src/meshes/Icosahedron.js","webpack:///./src/meshes/Lathe.js","webpack:///./src/meshes/Model.js","webpack:///./src/meshes/Morph.js","webpack:///./src/meshes/Octahedron.js","webpack:///./src/meshes/Parametric.js","webpack:///./src/meshes/Plane.js","webpack:///./src/meshes/Polyhedron.js","webpack:///./src/meshes/Ring.js","webpack:///./src/meshes/Shape2D.js","webpack:///./src/meshes/Sphere.js","webpack:///./src/meshes/Tetrahedron.js","webpack:///./src/meshes/Text.js","webpack:///./src/meshes/Torus.js","webpack:///./src/meshes/Torusknot.js","webpack:///./src/meshes/Tube.js"],"names":["WHS","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","defineProperty","value","_index","keys","forEach","enumerable","get","_index2","_index3","_index4","_index5","_index6","_three","THREE","_nophysi","Physijs","window","this","_CubeCamera","_OrtographicCamera","_PerspectiveCamera","_interopRequireDefault","default","CubeCamera","undefined","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","_possibleConstructorReturn2","_possibleConstructorReturn3","_inherits2","_inherits3","_get2","_get3","_Camera2","_Camera","params","arguments","length","_this","getPrototypeOf","build","_this2","Promse","resolve","setNative","camera","near","far","cubeResolution","Camera","instance","Constructor","TypeError","_defineProperty","_defineProperty2","defineProperties","target","props","i","descriptor","configurable","writable","protoProps","staticProps","$Object","it","desc","$export","S","F","f","core","ctx","hide","PROTOTYPE","type","name","source","own","out","IS_FORCED","IS_GLOBAL","G","IS_STATIC","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","expProto","C","a","b","apply","Function","virtual","R","U","Math","self","__g","version","__e","aFunction","fn","that","dP","createDesc","object","anObject","IE8_DOM_DEFINE","toPrimitive","O","Attributes","e","isObject","exec","document","is","createElement","val","toString","valueOf","bitmap","_typeof2","_typeof3","ReferenceError","_iterator","_iterator2","_symbol","_symbol2","_typeof","constructor","$at","String","iterated","_t","_i","point","index","done","toInteger","defined","TO_STRING","pos","s","l","charCodeAt","charAt","slice","ceil","floor","isNaN","LIBRARY","redefine","has","Iterators","$iterCreate","setToStringTag","ITERATOR","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","next","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","kind","proto","TAG","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","create","dPs","enumBugKeys","IE_PROTO","Empty","createDict","iframeDocument","iframe","gt","style","display","appendChild","src","contentWindow","open","write","close","Properties","result","getKeys","$keys","toIObject","arrayIndexOf","names","push","IObject","cof","propertyIsEnumerable","split","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","min","max","shared","uid","SHARED","store","px","random","concat","documentElement","def","tag","stat","Symbol","USE_SYMBOL","$exports","toObject","ObjectProto","TO_STRING_TAG","collections","Collection","Array","addToUnscopables","step","_k","Arguments","DESCRIPTORS","META","KEY","$fails","wks","wksExt","wksDefine","keyOf","enumKeys","isArray","_create","gOPNExt","$GOPD","$DP","gOPD","gOPN","$Symbol","$JSON","JSON","_stringify","stringify","HIDDEN","TO_PRIMITIVE","isEnum","SymbolRegistry","AllSymbols","OPSymbols","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","D","protoDesc","wrap","sym","isSymbol","iterator","$defineProperty","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","$set","set","symbols","for","keyFor","useSetter","useSimple","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","replacer","$replacer","args","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","w","fastKey","getWeak","onFreeze","meta","NEED","gOPS","pIE","getSymbols","arg","windowNames","getWindowNames","hiddenKeys","_setPrototypeOf","_setPrototypeOf2","_create2","subClass","superClass","__proto__","setPrototypeOf","check","test","buggy","_getPrototypeOf","_getPrototypeOf2","_getOwnPropertyDescriptor","_getOwnPropertyDescriptor2","property","receiver","parent","getter","$getPrototypeOf","fails","exp","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","REVISION","Number","EPSILON","pow","sign","x","match","assign","output","nextKey","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","Color","r","g","setRGB","copy","setHex","setStyle","setScalar","scalar","hex","setHSL","hue2rgb","q","t","h","euclideanModulo","clamp","handleAlpha","string","parseFloat","console","warn","color","components","parseInt","size","ColorKeywords","clone","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","getHSL","optionalTarget","hue","saturation","hsl","lightness","delta","getStyle","offsetHSL","add","addColors","color1","color2","addScalar","sub","multiply","multiplyScalar","lerp","alpha","equals","fromArray","array","offset","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","y","z","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","update","Euler","Error","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","v","lengthSq","multiplyQuaternions","premultiply","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","atan2","ratioA","ratioB","onChange","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","len","tDir","Vector2","width","height","setX","setY","setComponent","getComponent","addVectors","addScaledVector","subVectors","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","round","roundToZero","negate","lengthManhattan","PI","distanceTo","distanceToSquared","dx","dy","distanceToManhattan","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","center","setZ","multiplyVectors","applyEuler","error","applyQuaternion","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","project","matrix","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","acos","dz","setFromSpherical","sinPhiRadius","phi","radius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","end","line","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","scope","updateMatrixWorld","traverse","node","geometry","Geometry","vertices","BufferGeometry","attributes","position","stride","InterleavedBufferAttribute","data","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","j","applyToBuffer","buffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","detInv","transpose","tmp","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","lookAt","eye","up","n","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","scale","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","makePerspective","fov","aspect","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","intersectsSprite","sprite","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","uuid","rnd","join","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","log","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","minDistance","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","Date","now","stop","getElapsedTime","getDelta","newTime","EventDispatcher","addEventListener","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","splice","dispatchEvent","event","Layers","mask","channel","enable","toggle","disable","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","Mesh","Line","LOD","Points","threshold","Sprite","PointCloud","linePrecision","setFromCamera","PerspectiveCamera","OrthographicCamera","sort","intersectObjects","objects","Object3D","onRotationChange","rotation","onQuaternionChange","Object3DIdCount","DefaultUp","modelViewMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","remove","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","extractFromCache","cache","metadata","isRootObject","geometries","materials","textures","images","generator","material","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","count","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","positions","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","enabled","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","dispose","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationAction","_new","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","_lendControlInterpolant","times","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","AnimationClip","resetDuration","trim","optimize","track","json","jsonTracks","frameTime","fps","KeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","objectOrClipArray","clipArray","o","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_initMemoryManager","_accuIndex","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","useCount","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","pop","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","to","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","bind","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","context","createBufferSource","onended","onEnded","gain","createGain","connect","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","pause","currentTime","disconnect","getFilters","setFilters","getFilter","setFilter","filter","setPlaybackRate","getPlaybackRate","getLoop","getVolume","setVolume","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","AudioContext","webkitAudioContext","PositionalAudio","panner","createPanner","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","AudioListener","destination","removeFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","matrixWorldInverse","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","format","magFilter","minFilter","renderTarget","WebGLRenderTargetCube","updateCubeMap","renderer","scene","generateMipmaps","texture","activeCubeFace","render","setRenderTarget","zoom","view","updateProjectionMatrix","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","cx","cy","zoomW","zoomH","scaleW","scaleH","focus","filmGauge","filmOffset","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","map","AmbientLight","DirectionalLight","shadow","DirectionalLightShadow","light","HemisphereLight","skyColor","PointLight","power","SpotLight","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","load","url","onLoad","onProgress","onError","loader","XHRLoader","setResponseType","decodeAudioData","Cache","files","file","clear","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","repeat","anisotropy","fullPath","Handlers","setCrossOrigin","wrapS","wrapT","TextureLoader","MaterialLoader","blending","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","emissiveMap","mapEmissiveRepeat","mapEmissiveOffset","mapEmissiveWrap","mapEmissiveAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","metalnessMap","mapMetalnessRepeat","mapMetalnessOffset","mapMetalnessWrap","mapMetalnessAnisotropy","roughnessMap","mapRoughnessRepeat","mapRoughnessOffset","mapRoughnessWrap","mapRoughnessAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","side","opacity","transparent","setTextures","handlers","regex","cached","itemStart","setTimeout","itemEnd","request","XMLHttpRequest","overrideMimeType","response","status","itemError","responseType","withCredentials","send","setPath","setWithCredentials","FontLoader","text","substring","font","Font","ImageLoader","image","createElementNS","onload","URL","revokeObjectURL","blob","createObjectURL","JSONLoader","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","uniforms","vertexShader","fragmentShader","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","detail","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","flipY","getGeometry","getMaterial","Scene","SkinnedMesh","Group","levels","level","addLevel","isJPEG","search","CubeTextureLoader","urls","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","fog","lights","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshLambertMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","defines","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","clearCoat","clearCoatRoughness","MultiMaterial","PointsMaterial","ShaderMaterial","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","UniformsUtils","RawShaderMaterial","SpriteMaterial","ShadowMaterial","UniformsLib","ShaderChunk","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","unpackAlignment","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","requestAnimationFrame","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","distSq","faceIndex","nbVertices","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","background","overrideMaterial","autoUpdate","Fog","FogExp2","density","merged","uniforms_src","uniforms_dst","parameter_src","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","WebGLRenderer","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","state","clearColor","setDefaultGLState","init","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","_gl","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","isSphereViewable","isSpriteViewable","_frustum","numPlanes","_clipping","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","code","getProgramCode","programChange","shaderID","shader","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","uniform","lightsHash","ambient","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","CULL_FACE","setFlipSided","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","WebGLRenderTarget","_canvas","clientHeight","setupShadows","lightShadowsLength","shadows","setupLights","ll","shadowMap","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","allocTextureUnit","textureUnit","maxTextures","paramThreeToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","DEPTH_COMPONENT","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","domElement","autoClear","autoClearColor","autoClearDepth","autoClearStencil","localClippingEnabled","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","WebGLClipping","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLTextures","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","backgroundCamera","backgroundCamera2","backgroundPlaneMesh","PlaneBufferGeometry","backgroundBoxShader","backgroundBoxMesh","BoxBufferGeometry","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","getMaxAnisotropy","getPrecision","getPixelRatio","setPixelRatio","setSize","getSize","updateStyle","setViewport","setScissor","setScissorTest","boolean","getClearColor","setClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","buffers","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","beginShadows","endShadows","updateRenderTargetMipmap","setFaceCulling","cullFace","frontFaceDirection","setCullFace","setTexture2D","warned","slot","setTexture","setTextureCube","setTextureCubeDynamic","getCurrentRenderTarget","__webglFramebuffer","setupRenderTarget","framebuffer","isCube","renderTargetProperties","scissorTest","bindFramebuffer","FRAMEBUFFER","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","__webglTexture","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","depthBuffer","stencilBuffer","depthTexture","drawArraysInstancedANGLE","resetGlobalState","globalState","numGlobalPlanes","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","i4","renderingShadows","enableLocalClipping","fromCache","nGlobal","lGlobal","clippingState","drawElements","drawElementsInstancedANGLE","gl","getExtension","maxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","currentRenderTarget","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","renderSingleSided","renderReverseSided","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_maxShadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","pars","shadowMatrix","vpDimensions","clearAlpha","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texImage2D","WebGLColorBuffer","WebGLDepthBuffer","WebGLStencilBuffer","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentScissor","currentViewport","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","DEPTH_TEST","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","getCompressedTextureFormats","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","blendFunc","setMask","setTest","setFunc","setStencilTest","stencilTest","setStencilWrite","stencilWrite","setStencilFunc","stencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","setOp","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","activeTexture","webglSlot","TEXTURE0","webglType","webglTexture","boundTexture","compressedTexImage2D","setClear","locked","currentColorMask","currentColorClear","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","depthMask","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","STENCIL_TEST","stencilOp","clampToMaxSize","maxSize","makePowerOfTwo","HTMLImageElement","HTMLCanvasElement","textureNeedsPowerOfTwo","filterFallback","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","__image__webglTextureCube","deleteTexture","__webglInit","deleteFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__version","complete","uploadTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","isPowerOfTwoImage","glFormat","glType","setTextureParameters","mipmap","generateMipmap","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","internalFormat","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","setupFrameBufferTexture","attachment","textureTarget","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","isTargetPowerOfTwo","createFramebuffer","WebGL2RenderingContext","emptyTexture","emptyCubeTexture","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","uvOffset","uvScale","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","Face4","LineStrip","LinePieces","MeshFaceMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","getData","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","removeDupEndPts","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","resolution","EllipseCurve","SplineCurve","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","ShapePath","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","Path","currentPoint","fromPoints","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","firstPoint","lastPoint","subPaths","currentPath","isCCW","noHoles","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","twoPi","deltaAngle","samePoints","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","CubeGeometry","calculateVertexCount","calculateIndexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","nbCap","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","cosTheta","sinTheta","CylinderGeometry","ConeBufferGeometry","ConeGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","TorusBufferGeometry","TorusGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","T","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe","_Loop","_defaults","_Object","_WHSObject","_ret","_set","useTarget","Boolean","innerWidth","innerHeight","helper","rot","_type","defaults","debug","_len","tags","_key","Promise","reject","__params","getNative","emit","err","_helper","_scope","getScene","gEnd","Loop","clock","vec1","vec2","TVector3","TCurve","TCurvePath","setInterval","vector3","WHSObject","_minivents","_minivents2","_api","structurable","__whsobject","__releaseTime","getTime","__defaults","extend","native","_native","addTo","on","off","loadMaterial","_loaders","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","prop","opt","materialThree","useCustomMaterial","useVertexColors","SpriteCanvasMaterial","OBJLoader","_threeObjLoader","_threeObjLoader2","parseVertexIndex","parseNormalIndex","parseUVIndex","addVertex","addNormal","addUV","ua","ub","uc","ud","na","nb","nc","nd","ia","ib","ic","vertex_pattern","normal_pattern","uv_pattern","face_pattern1","face_pattern2","face_pattern3","face_pattern4","timeEnd","OrtographicCamera","_Light","_Shape","_World","exponent","shadowmap","cast","_light","_shadowmap","_this3","getElapsedtime","physicsDefaults","mass","softbody","helpers","physics","_physijs","__c_rot","_wait","promise","all","then","_params","getParams","_params_helpers","_params_pos","_params_rot","_params_scale","_params_helpers_faceNormals","_params_helpers_vertexNormals","_helpers","_parent","parentNative","World","sourceNative","tempGeometry","buildGeometry","updateParams","_initMaterial","_getNative","setAngularVelocity","_getNative2","setLinearVelocity","_getNative3","applyCentralImpulse","_getNative4","applyImpulse","_getNative5","applyTorque","_getNative6","applyCentralForce","_getNative7","applyForce","_getNative8","getAngularVelocity","_getNative9","getLinearVelocity","_getNative10","setAngularFactor","_getNative11","setLinearFactor","_getNative12","setDamping","_getNative13","setCcdMotionThreshold","_getNative14","setCcdSweptSphereRadius","_getNative15","_this4","getWorld","addLoop","removeLoop","__dirtyPosition","_this5","quat","__dirtyRotation","_this6","_stats","_stats2","autoresize","gravity","rWidth","rHeight","fixedTimeStep","body","initParams","_initDOM","_initScene","_initStats","_initCamera","_initRenderer","_initHelpers","loops","simulate","setScene","margin","padding","overflow","_dom","className","setCamera","getCamera","setRenderer","getRenderer","cascade","toFixed","reDraw","requestAnimFrame","begin","_process","controls","_updateControls","_composer","cameraNative","pass","stack","toScreen","_execLoops","webkitRequestAnimationFrame","mozRequestAnimationFrame","execute","import_three","moveChildren","obj3D","WHSobj","recieved","Stats","dom","cssText","Panel","addPanel","showPanel","usedJSHeapSize","jsHeapSizeLimit","devicePixelRatio","textBaseline","fillText","globalAlpha","_firstPersonControls","_orbitControls","_Curve","_Points","_Group","_Skybox","firstPersonControls","world","getObject","block","getElementById","speed","ypos","onMouseMove","movementX","mozMovementX","getMovementX","movementY","mozMovementY","getMovementY","yawObject","pitchObject","PI_2","onKeyDown","keyCode","moveForward","moveLeft","moveBackward","moveRight","canJump","player","runVelocity","onKeyUp","velocityFactor","otherObject","contactNormal","getDirection","targetVec","inputVelocity","element","pointerlockchange","pointerLockElement","mozPointerLockElement","webkitPointerLockElement","pointerlockerror","requestPointerLock","mozRequestPointerLock","webkitRequestPointerLock","requestFullscreen","mozRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","navigator","userAgent","fullscreenchange","fullscreenElement","mozFullscreenElement","mozFullScreenElement","orbitControls","ThreeOrbitControls","_threeOrbitControls","_threeOrbitControls2","OrbitConstraint","minZoom","maxZoom","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","phiDelta","thetaDelta","panOffset","zoomChanged","getPolarAngle","getAzimuthalAngle","rotateLeft","rotateUp","panLeft","panUp","pan","deltaX","deltaY","screenWidth","screenHeight","targetDistance","dollyIn","dollyScale","dollyOut","quatInverse","lastPosition","lastQuaternion","OrbitControls","constraint","clientWidth","getAutoRotationAngle","autoRotateSpeed","getZoomScale","zoomSpeed","onMouseDown","button","mouseButtons","ORBIT","enableRotate","STATE","ROTATE","rotateStart","clientX","clientY","ZOOM","enableZoom","DOLLY","dollyStart","PAN","enablePan","panStart","NONE","onMouseUp","startEvent","rotateEnd","rotateDelta","rotateSpeed","dollyEnd","dollyDelta","panEnd","panDelta","endEvent","onMouseWheel","stopPropagation","wheelDelta","enableKeys","UP","keyPanSpeed","BOTTOM","touchstart","touches","TOUCH_ROTATE","pageX","pageY","TOUCH_DOLLY","TOUCH_PAN","touchmove","touchend","contextmenu","autoRotate","target0","position0","zoom0","changeEvent","noZoom","noRotate","noPan","noKeys","staticMoving","dynamicDampingFactor","_material","param","_Shape2","Skybox","skyType","imgSuffix","skyGeometry","skyMat","directions","matArray","_AmbientLight","_DirectionalLight","_HemisphereLight","_NormalLight","_PointLight","_SpotLight","_Light2","NormalLight","_Box","_Cylinder","_Dodecahedron","_Extrude","_Icosahedron","_Lathe","_Model","_Morph","_Octahedron","_Parametric","_Plane","_Polyhedron","_Ring","_Shape2D","_Sphere","_Tetrahedron","_Text","_Torus","_Torusknot","_Tube","Box","SoftMesh","BoxMesh","GConstruct","proccessSoftbodyGeometry","Cylinder","radiusSegments","CylinderMesh","Dodecahedron","ConvexMesh","DodecahedronBufferGeometry","Extrude","_nophysi2","ConcaveMesh","ExtrudeBufferGeometry","Icosahedron","IcosahedronBufferGeometry","Icosahderon","Lathe","Model","pGeometry","data2","Morph","Octahedron","OctahedronBufferGeometry","Parametric","ParametricBufferGeometry","wSegments","hSegments","PlaneMesh","Polyhedron","verticesOfCube","indicesOfFaces","PolyhedronBufferGeometry","Ring","Shape2D","ShapeBufferGeometry","SphereMesh","Tetrahedron","TetrahedronBufferGeometry","Text","Torus","Torusknot","Tube","geometryOptions","CustomSinCurve","TubeBufferGeometry"],"mappings":"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","file":"whitestorm.light.js","sourcesContent":["var WHS =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _index = __webpack_require__(1);\n\t\n\tObject.keys(_index).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _index2 = __webpack_require__(105);\n\t\n\tObject.keys(_index2).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index2[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _index3 = __webpack_require__(110);\n\t\n\tObject.keys(_index3).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index3[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _index4 = __webpack_require__(111);\n\t\n\tObject.keys(_index4).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index4[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _index5 = __webpack_require__(119);\n\t\n\tObject.keys(_index5).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index5[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _index6 = __webpack_require__(126);\n\t\n\tObject.keys(_index6).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _index6[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tif (typeof window !== 'undefined') {\n\t  window.THREE = THREE;\n\t  window.Physijs = Physijs;\n\t} else if (typeof global !== 'undefined') {\n\t  global.THREE = THREE;\n\t  global.Physijs = Physijs;\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _CubeCamera = __webpack_require__(2);\n\t\n\tObject.keys(_CubeCamera).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _CubeCamera[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _OrtographicCamera = __webpack_require__(103);\n\t\n\tObject.keys(_OrtographicCamera).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _OrtographicCamera[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _PerspectiveCamera = __webpack_require__(104);\n\t\n\tObject.keys(_PerspectiveCamera).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _PerspectiveCamera[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.CubeCamera = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Camera2 = __webpack_require__(94);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar CubeCamera = function (_Camera) {\n\t  (0, _inherits3.default)(CubeCamera, _Camera);\n\t\n\t  function CubeCamera() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, CubeCamera);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(CubeCamera).call(this, params, 'cubecamera'));\n\t\n\t    _this.build(params);\n\t    (0, _get3.default)(Object.getPrototypeOf(CubeCamera.prototype), 'wrap', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(CubeCamera, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      return new Promse(function (resolve) {\n\t        _this2.setNative(new THREE.CubeCamera(params.camera.near, params.camera.far, params.camera.cubeResolution));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return CubeCamera;\n\t}(_Camera2.Camera);\n\t\n\texports.CubeCamera = CubeCamera;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _defineProperty = __webpack_require__(5);\n\t\n\tvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(6), __esModule: true };\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(7);\n\tvar $Object = __webpack_require__(10).Object;\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $Object.defineProperty(it, key, desc);\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(8);\r\n\t// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\r\n\t$export($export.S + $export.F * !__webpack_require__(18), 'Object', {defineProperty: __webpack_require__(14).f});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(9)\n\t  , core      = __webpack_require__(10)\n\t  , ctx       = __webpack_require__(11)\n\t  , hide      = __webpack_require__(13)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(12);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(14)\n\t  , createDesc = __webpack_require__(22);\n\tmodule.exports = __webpack_require__(18) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(15)\n\t  , IE8_DOM_DEFINE = __webpack_require__(17)\n\t  , toPrimitive    = __webpack_require__(21)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(18) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(16);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(18) && !__webpack_require__(19)(function(){\r\n\t  return Object.defineProperty(__webpack_require__(20)('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n\t});\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(19)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(16)\n\t  , document = __webpack_require__(9).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(16);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof2 = __webpack_require__(24);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\t\n\t  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _iterator = __webpack_require__(25);\n\t\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\t\n\tvar _symbol = __webpack_require__(61);\n\t\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\t\n\tvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(26), __esModule: true };\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(27);\n\t__webpack_require__(56);\n\tmodule.exports = __webpack_require__(60).f('iterator');\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(28)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(31)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(29)\n\t  , defined   = __webpack_require__(30);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(32)\n\t  , $export        = __webpack_require__(8)\n\t  , redefine       = __webpack_require__(33)\n\t  , hide           = __webpack_require__(13)\n\t  , has            = __webpack_require__(34)\n\t  , Iterators      = __webpack_require__(35)\n\t  , $iterCreate    = __webpack_require__(36)\n\t  , setToStringTag = __webpack_require__(52)\n\t  , getPrototypeOf = __webpack_require__(54)\n\t  , ITERATOR       = __webpack_require__(53)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(13);\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(37)\n\t  , descriptor     = __webpack_require__(22)\n\t  , setToStringTag = __webpack_require__(52)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(13)(IteratorPrototype, __webpack_require__(53)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n\tvar anObject    = __webpack_require__(15)\r\n\t  , dPs         = __webpack_require__(38)\r\n\t  , enumBugKeys = __webpack_require__(50)\r\n\t  , IE_PROTO    = __webpack_require__(47)('IE_PROTO')\r\n\t  , Empty       = function(){ /* empty */ }\r\n\t  , PROTOTYPE   = 'prototype';\r\n\t\r\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\n\tvar createDict = function(){\r\n\t  // Thrash, waste and sodomy: IE GC bug\r\n\t  var iframe = __webpack_require__(20)('iframe')\r\n\t    , i      = enumBugKeys.length\r\n\t    , gt     = '>'\r\n\t    , iframeDocument;\r\n\t  iframe.style.display = 'none';\r\n\t  __webpack_require__(51).appendChild(iframe);\r\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n\t  // createDict = iframe.contentWindow.Object;\r\n\t  // html.removeChild(iframe);\r\n\t  iframeDocument = iframe.contentWindow.document;\r\n\t  iframeDocument.open();\r\n\t  iframeDocument.write('<script>document.F=Object</script' + gt);\r\n\t  iframeDocument.close();\r\n\t  createDict = iframeDocument.F;\r\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n\t  return createDict();\r\n\t};\r\n\t\r\n\tmodule.exports = Object.create || function create(O, Properties){\r\n\t  var result;\r\n\t  if(O !== null){\r\n\t    Empty[PROTOTYPE] = anObject(O);\r\n\t    result = new Empty;\r\n\t    Empty[PROTOTYPE] = null;\r\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n\t    result[IE_PROTO] = O;\r\n\t  } else result = createDict();\r\n\t  return Properties === undefined ? result : dPs(result, Properties);\r\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(14)\r\n\t  , anObject = __webpack_require__(15)\r\n\t  , getKeys  = __webpack_require__(39);\r\n\t\r\n\tmodule.exports = __webpack_require__(18) ? Object.defineProperties : function defineProperties(O, Properties){\r\n\t  anObject(O);\r\n\t  var keys   = getKeys(Properties)\r\n\t    , length = keys.length\r\n\t    , i = 0\r\n\t    , P;\r\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\r\n\t  return O;\r\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\n\tvar $keys       = __webpack_require__(40)\r\n\t  , enumBugKeys = __webpack_require__(50);\r\n\t\r\n\tmodule.exports = Object.keys || function keys(O){\r\n\t  return $keys(O, enumBugKeys);\r\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(34)\r\n\t  , toIObject    = __webpack_require__(41)\r\n\t  , arrayIndexOf = __webpack_require__(44)(false)\r\n\t  , IE_PROTO     = __webpack_require__(47)('IE_PROTO');\r\n\t\r\n\tmodule.exports = function(object, names){\r\n\t  var O      = toIObject(object)\r\n\t    , i      = 0\r\n\t    , result = []\r\n\t    , key;\r\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\r\n\t  // Don't enum bug & hidden keys\r\n\t  while(names.length > i)if(has(O, key = names[i++])){\r\n\t    ~arrayIndexOf(result, key) || result.push(key);\r\n\t  }\r\n\t  return result;\r\n\t};\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(42)\n\t  , defined = __webpack_require__(30);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(43);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(41)\n\t  , toLength  = __webpack_require__(45)\n\t  , toIndex   = __webpack_require__(46);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(29)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(29)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(48)('keys')\r\n\t  , uid    = __webpack_require__(49);\r\n\tmodule.exports = function(key){\r\n\t  return shared[key] || (shared[key] = uid(key));\r\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(9)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\r\n\tmodule.exports = (\r\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n\t).split(',');\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(9).document && document.documentElement;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(14).f\n\t  , has = __webpack_require__(34)\n\t  , TAG = __webpack_require__(53)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(48)('wks')\n\t  , uid        = __webpack_require__(49)\n\t  , Symbol     = __webpack_require__(9).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\n\tvar has         = __webpack_require__(34)\r\n\t  , toObject    = __webpack_require__(55)\r\n\t  , IE_PROTO    = __webpack_require__(47)('IE_PROTO')\r\n\t  , ObjectProto = Object.prototype;\r\n\t\r\n\tmodule.exports = Object.getPrototypeOf || function(O){\r\n\t  O = toObject(O);\r\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\r\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\r\n\t    return O.constructor.prototype;\r\n\t  } return O instanceof Object ? ObjectProto : null;\r\n\t};\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(30);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(57);\n\tvar global        = __webpack_require__(9)\n\t  , hide          = __webpack_require__(13)\n\t  , Iterators     = __webpack_require__(35)\n\t  , TO_STRING_TAG = __webpack_require__(53)('toStringTag');\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype;\n\t  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t  Iterators[NAME] = Iterators.Array;\n\t}\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(58)\n\t  , step             = __webpack_require__(59)\n\t  , Iterators        = __webpack_require__(35)\n\t  , toIObject        = __webpack_require__(41);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(31)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(53);\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(62), __esModule: true };\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(63);\n\t__webpack_require__(74);\n\t__webpack_require__(75);\n\t__webpack_require__(76);\n\tmodule.exports = __webpack_require__(10).Symbol;\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(9)\n\t  , has            = __webpack_require__(34)\n\t  , DESCRIPTORS    = __webpack_require__(18)\n\t  , $export        = __webpack_require__(8)\n\t  , redefine       = __webpack_require__(33)\n\t  , META           = __webpack_require__(64).KEY\n\t  , $fails         = __webpack_require__(19)\n\t  , shared         = __webpack_require__(48)\n\t  , setToStringTag = __webpack_require__(52)\n\t  , uid            = __webpack_require__(49)\n\t  , wks            = __webpack_require__(53)\n\t  , wksExt         = __webpack_require__(60)\n\t  , wksDefine      = __webpack_require__(65)\n\t  , keyOf          = __webpack_require__(66)\n\t  , enumKeys       = __webpack_require__(67)\n\t  , isArray        = __webpack_require__(70)\n\t  , anObject       = __webpack_require__(15)\n\t  , toIObject      = __webpack_require__(41)\n\t  , toPrimitive    = __webpack_require__(21)\n\t  , createDesc     = __webpack_require__(22)\n\t  , _create        = __webpack_require__(37)\n\t  , gOPNExt        = __webpack_require__(71)\n\t  , $GOPD          = __webpack_require__(73)\n\t  , $DP            = __webpack_require__(14)\n\t  , $keys          = __webpack_require__(39)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(72).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(69).f  = $propertyIsEnumerable;\n\t  __webpack_require__(68).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(32)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(13)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(49)('meta')\n\t  , isObject = __webpack_require__(16)\n\t  , has      = __webpack_require__(34)\n\t  , setDesc  = __webpack_require__(14).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(19)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(9)\r\n\t  , core           = __webpack_require__(10)\r\n\t  , LIBRARY        = __webpack_require__(32)\r\n\t  , wksExt         = __webpack_require__(60)\r\n\t  , defineProperty = __webpack_require__(14).f;\r\n\tmodule.exports = function(name){\r\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\r\n\t};\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(39)\n\t  , toIObject = __webpack_require__(41);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(39)\n\t  , gOPS    = __webpack_require__(68)\n\t  , pIE     = __webpack_require__(69);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 68 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(43);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(41)\n\t  , gOPN      = __webpack_require__(72).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\n\tvar $keys      = __webpack_require__(40)\r\n\t  , hiddenKeys = __webpack_require__(50).concat('length', 'prototype');\r\n\t\r\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\r\n\t  return $keys(O, hiddenKeys);\r\n\t};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(69)\r\n\t  , createDesc     = __webpack_require__(22)\r\n\t  , toIObject      = __webpack_require__(41)\r\n\t  , toPrimitive    = __webpack_require__(21)\r\n\t  , has            = __webpack_require__(34)\r\n\t  , IE8_DOM_DEFINE = __webpack_require__(17)\r\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\r\n\t\r\n\texports.f = __webpack_require__(18) ? gOPD : function getOwnPropertyDescriptor(O, P){\r\n\t  O = toIObject(O);\r\n\t  P = toPrimitive(P, true);\r\n\t  if(IE8_DOM_DEFINE)try {\r\n\t    return gOPD(O, P);\r\n\t  } catch(e){ /* empty */ }\r\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\r\n\t};\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(65)('asyncIterator');\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(65)('observable');\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _setPrototypeOf = __webpack_require__(78);\n\t\n\tvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\t\n\tvar _create = __webpack_require__(82);\n\t\n\tvar _create2 = _interopRequireDefault(_create);\n\t\n\tvar _typeof2 = __webpack_require__(24);\n\t\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n\t  }\n\t\n\t  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(79), __esModule: true };\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(80);\n\tmodule.exports = __webpack_require__(10).Object.setPrototypeOf;\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(8);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(81).set});\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar isObject = __webpack_require__(16)\n\t  , anObject = __webpack_require__(15);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(11)(Function.call, __webpack_require__(73).f(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(83), __esModule: true };\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(84);\n\tvar $Object = __webpack_require__(10).Object;\n\tmodule.exports = function create(P, D){\n\t  return $Object.create(P, D);\n\t};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(8)\r\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n\t$export($export.S, 'Object', {create: __webpack_require__(37)});\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _getPrototypeOf = __webpack_require__(86);\n\t\n\tvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\t\n\tvar _getOwnPropertyDescriptor = __webpack_require__(90);\n\t\n\tvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function get(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = (0, _getPrototypeOf2.default)(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(87), __esModule: true };\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(88);\n\tmodule.exports = __webpack_require__(10).Object.getPrototypeOf;\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 Object.getPrototypeOf(O)\n\tvar toObject        = __webpack_require__(55)\n\t  , $getPrototypeOf = __webpack_require__(54);\n\t\n\t__webpack_require__(89)('getPrototypeOf', function(){\n\t  return function getPrototypeOf(it){\n\t    return $getPrototypeOf(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(8)\n\t  , core    = __webpack_require__(10)\n\t  , fails   = __webpack_require__(19);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(91), __esModule: true };\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(92);\n\tvar $Object = __webpack_require__(10).Object;\n\tmodule.exports = function getOwnPropertyDescriptor(it, key){\n\t  return $Object.getOwnPropertyDescriptor(it, key);\n\t};\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\tvar toIObject                 = __webpack_require__(41)\n\t  , $getOwnPropertyDescriptor = __webpack_require__(73).f;\n\t\n\t__webpack_require__(89)('getOwnPropertyDescriptor', function(){\n\t  return function getOwnPropertyDescriptor(it, key){\n\t    return $getOwnPropertyDescriptor(toIObject(it), key);\n\t  };\n\t});\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tvar THREE = { REVISION: '79' };\n\t\n\t//\n\t\n\tif ( true ) {\n\t\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t\n\t} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\t\n\t\tmodule.exports = THREE;\n\t\n\t}\n\t\n\t// Polyfills\n\t\n\tif ( Number.EPSILON === undefined ) {\n\t\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\n\t\n\t}\n\t\n\t//\n\t\n\tif ( Math.sign === undefined ) {\n\t\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\t\n\t\tMath.sign = function ( x ) {\n\t\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\t\n\t\t};\n\t\n\t}\n\t\n\tif ( Function.prototype.name === undefined ) {\n\t\n\t\t// Missing in IE9-11.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\t\n\t\tObject.defineProperty( Function.prototype, 'name', {\n\t\n\t\t\tget: function () {\n\t\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t}\n\t\n\tif ( Object.assign === undefined ) {\n\t\n\t\t// Missing in IE.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t\n\t\t( function () {\n\t\n\t\t\tObject.assign = function ( target ) {\n\t\n\t\t\t\t'use strict';\n\t\n\t\t\t\tif ( target === undefined || target === null ) {\n\t\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar output = Object( target );\n\t\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\t\n\t\t\t\t\tvar source = arguments[ index ];\n\t\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\n\t\n\t\t\t\t\t\tfor ( var nextKey in source ) {\n\t\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\t\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn output;\n\t\n\t\t\t};\n\t\n\t\t} )();\n\t\n\t}\n\t\n\t//\n\t\n\tObject.assign( THREE, {\n\t\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\t\n\t\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\t\n\t\t// GL STATE CONSTANTS\n\t\n\t\tCullFaceNone: 0,\n\t\tCullFaceBack: 1,\n\t\tCullFaceFront: 2,\n\t\tCullFaceFrontBack: 3,\n\t\n\t\tFrontFaceDirectionCW: 0,\n\t\tFrontFaceDirectionCCW: 1,\n\t\n\t\t// SHADOWING TYPES\n\t\n\t\tBasicShadowMap: 0,\n\t\tPCFShadowMap: 1,\n\t\tPCFSoftShadowMap: 2,\n\t\n\t\t// MATERIAL CONSTANTS\n\t\n\t\t// side\n\t\n\t\tFrontSide: 0,\n\t\tBackSide: 1,\n\t\tDoubleSide: 2,\n\t\n\t\t// shading\n\t\n\t\tFlatShading: 1,\n\t\tSmoothShading: 2,\n\t\n\t\t// colors\n\t\n\t\tNoColors: 0,\n\t\tFaceColors: 1,\n\t\tVertexColors: 2,\n\t\n\t\t// blending modes\n\t\n\t\tNoBlending: 0,\n\t\tNormalBlending: 1,\n\t\tAdditiveBlending: 2,\n\t\tSubtractiveBlending: 3,\n\t\tMultiplyBlending: 4,\n\t\tCustomBlending: 5,\n\t\n\t\t// custom blending equations\n\t\t// (numbers start from 100 not to clash with other\n\t\t// mappings to OpenGL constants defined in Texture.js)\n\t\n\t\tAddEquation: 100,\n\t\tSubtractEquation: 101,\n\t\tReverseSubtractEquation: 102,\n\t\tMinEquation: 103,\n\t\tMaxEquation: 104,\n\t\n\t\t// custom blending destination factors\n\t\n\t\tZeroFactor: 200,\n\t\tOneFactor: 201,\n\t\tSrcColorFactor: 202,\n\t\tOneMinusSrcColorFactor: 203,\n\t\tSrcAlphaFactor: 204,\n\t\tOneMinusSrcAlphaFactor: 205,\n\t\tDstAlphaFactor: 206,\n\t\tOneMinusDstAlphaFactor: 207,\n\t\n\t\t// custom blending source factors\n\t\n\t\t//ZeroFactor: 200,\n\t\t//OneFactor: 201,\n\t\t//SrcAlphaFactor: 204,\n\t\t//OneMinusSrcAlphaFactor: 205,\n\t\t//DstAlphaFactor: 206,\n\t\t//OneMinusDstAlphaFactor: 207,\n\t\tDstColorFactor: 208,\n\t\tOneMinusDstColorFactor: 209,\n\t\tSrcAlphaSaturateFactor: 210,\n\t\n\t\t// depth modes\n\t\n\t\tNeverDepth: 0,\n\t\tAlwaysDepth: 1,\n\t\tLessDepth: 2,\n\t\tLessEqualDepth: 3,\n\t\tEqualDepth: 4,\n\t\tGreaterEqualDepth: 5,\n\t\tGreaterDepth: 6,\n\t\tNotEqualDepth: 7,\n\t\n\t\n\t\t// TEXTURE CONSTANTS\n\t\n\t\tMultiplyOperation: 0,\n\t\tMixOperation: 1,\n\t\tAddOperation: 2,\n\t\n\t\t// Tone Mapping modes\n\t\n\t\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\t\tLinearToneMapping: 1, // only apply exposure.\n\t\tReinhardToneMapping: 2,\n\t\tUncharted2ToneMapping: 3, // John Hable\n\t\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\t\n\t\t// Mapping modes\n\t\n\t\tUVMapping: 300,\n\t\n\t\tCubeReflectionMapping: 301,\n\t\tCubeRefractionMapping: 302,\n\t\n\t\tEquirectangularReflectionMapping: 303,\n\t\tEquirectangularRefractionMapping: 304,\n\t\n\t\tSphericalReflectionMapping: 305,\n\t\tCubeUVReflectionMapping: 306,\n\t\tCubeUVRefractionMapping: 307,\n\t\n\t\t// Wrapping modes\n\t\n\t\tRepeatWrapping: 1000,\n\t\tClampToEdgeWrapping: 1001,\n\t\tMirroredRepeatWrapping: 1002,\n\t\n\t\t// Filters\n\t\n\t\tNearestFilter: 1003,\n\t\tNearestMipMapNearestFilter: 1004,\n\t\tNearestMipMapLinearFilter: 1005,\n\t\tLinearFilter: 1006,\n\t\tLinearMipMapNearestFilter: 1007,\n\t\tLinearMipMapLinearFilter: 1008,\n\t\n\t\t// Data types\n\t\n\t\tUnsignedByteType: 1009,\n\t\tByteType: 1010,\n\t\tShortType: 1011,\n\t\tUnsignedShortType: 1012,\n\t\tIntType: 1013,\n\t\tUnsignedIntType: 1014,\n\t\tFloatType: 1015,\n\t\tHalfFloatType: 1025,\n\t\n\t\t// Pixel types\n\t\n\t\t//UnsignedByteType: 1009,\n\t\tUnsignedShort4444Type: 1016,\n\t\tUnsignedShort5551Type: 1017,\n\t\tUnsignedShort565Type: 1018,\n\t\n\t\t// Pixel formats\n\t\n\t\tAlphaFormat: 1019,\n\t\tRGBFormat: 1020,\n\t\tRGBAFormat: 1021,\n\t\tLuminanceFormat: 1022,\n\t\tLuminanceAlphaFormat: 1023,\n\t\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\t\tRGBEFormat: THREE.RGBAFormat, //1024;\n\t\tDepthFormat: 1026,\n\t\n\t\t// DDS / ST3C Compressed texture formats\n\t\n\t\tRGB_S3TC_DXT1_Format: 2001,\n\t\tRGBA_S3TC_DXT1_Format: 2002,\n\t\tRGBA_S3TC_DXT3_Format: 2003,\n\t\tRGBA_S3TC_DXT5_Format: 2004,\n\t\n\t\t// PVRTC compressed texture formats\n\t\n\t\tRGB_PVRTC_4BPPV1_Format: 2100,\n\t\tRGB_PVRTC_2BPPV1_Format: 2101,\n\t\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\t\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\t\n\t\t// ETC compressed texture formats\n\t\n\t\tRGB_ETC1_Format: 2151,\n\t\n\t\t// Loop styles for AnimationAction\n\t\n\t\tLoopOnce: 2200,\n\t\tLoopRepeat: 2201,\n\t\tLoopPingPong: 2202,\n\t\n\t\t// Interpolation\n\t\n\t\tInterpolateDiscrete: 2300,\n\t\tInterpolateLinear: 2301,\n\t\tInterpolateSmooth: 2302,\n\t\n\t\t// Interpolant ending modes\n\t\n\t\tZeroCurvatureEnding: 2400,\n\t\tZeroSlopeEnding: 2401,\n\t\tWrapAroundEnding: 2402,\n\t\n\t\t// Triangle Draw modes\n\t\n\t\tTrianglesDrawMode: 0,\n\t\tTriangleStripDrawMode: 1,\n\t\tTriangleFanDrawMode: 2,\n\t\n\t\t// Texture Encodings\n\t\n\t\tLinearEncoding: 3000, // No encoding at all.\n\t\tsRGBEncoding: 3001,\n\t\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\t\n\t\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t\t// These encodings should not specified as output encodings except in rare situations.\n\t\tRGBEEncoding: 3002, // AKA Radiance.\n\t\tLogLuvEncoding: 3003,\n\t\tRGBM7Encoding: 3004,\n\t\tRGBM16Encoding: 3005,\n\t\tRGBDEncoding: 3006, // MaxRange is 256.\n\t\n\t\t// Depth packing strategies\n\t\n\t\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\t\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\t\n\t} );\n\t\n\t// File:src/math/Color.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Color = function ( r, g, b ) {\n\t\n\t\tif ( g === undefined && b === undefined ) {\n\t\n\t\t\t// r is THREE.Color, hex or string\n\t\t\treturn this.set( r );\n\t\n\t\t}\n\t\n\t\treturn this.setRGB( r, g, b );\n\t\n\t};\n\t\n\tTHREE.Color.prototype = {\n\t\n\t\tconstructor: THREE.Color,\n\t\n\t\tr: 1, g: 1, b: 1,\n\t\n\t\tset: function ( value ) {\n\t\n\t\t\tif ( value instanceof THREE.Color ) {\n\t\n\t\t\t\tthis.copy( value );\n\t\n\t\t\t} else if ( typeof value === 'number' ) {\n\t\n\t\t\t\tthis.setHex( value );\n\t\n\t\t\t} else if ( typeof value === 'string' ) {\n\t\n\t\t\t\tthis.setStyle( value );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\t\n\t\t},\n\t\n\t\tsetHex: function ( hex ) {\n\t\n\t\t\thex = Math.floor( hex );\n\t\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\t\tthis.b = ( hex & 255 ) / 255;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetRGB: function ( r, g, b ) {\n\t\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetHSL: function () {\n\t\n\t\t\tfunction hue2rgb( p, q, t ) {\n\t\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function setHSL( h, s, l ) {\n\t\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\t\n\t\t\t\tif ( s === 0 ) {\n\t\n\t\t\t\t\tthis.r = this.g = this.b = l;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\t\tvar q = ( 2 * l ) - p;\n\t\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetStyle: function ( style ) {\n\t\n\t\t\tfunction handleAlpha( string ) {\n\t\n\t\t\t\tif ( string === undefined ) return;\n\t\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar m;\n\t\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\t\n\t\t\t\t// rgb / hsl\n\t\n\t\t\t\tvar color;\n\t\t\t\tvar name = m[ 1 ];\n\t\t\t\tvar components = m[ 2 ];\n\t\n\t\t\t\tswitch ( name ) {\n\t\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\t\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\t\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\t\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\t\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\t\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\t\n\t\t\t\t// hex color\n\t\n\t\t\t\tvar hex = m[ 1 ];\n\t\t\t\tvar size = hex.length;\n\t\n\t\t\t\tif ( size === 3 ) {\n\t\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t} else if ( size === 6 ) {\n\t\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\t\n\t\t\t\t\treturn this;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( style && style.length > 0 ) {\n\t\n\t\t\t\t// color keywords\n\t\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\t\n\t\t\t\tif ( hex !== undefined ) {\n\t\n\t\t\t\t\t// red\n\t\t\t\t\tthis.setHex( hex );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// unknown color\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\n\t\n\t\t},\n\t\n\t\tcopy: function ( color ) {\n\t\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\t\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\t\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\t\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\t\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconvertGammaToLinear: function () {\n\t\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\tthis.r = r * r;\n\t\t\tthis.g = g * g;\n\t\t\tthis.b = b * b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconvertLinearToGamma: function () {\n\t\n\t\t\tthis.r = Math.sqrt( this.r );\n\t\t\tthis.g = Math.sqrt( this.g );\n\t\t\tthis.b = Math.sqrt( this.b );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetHex: function () {\n\t\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\t\n\t\t},\n\t\n\t\tgetHexString: function () {\n\t\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\t\n\t\t},\n\t\n\t\tgetHSL: function ( optionalTarget ) {\n\t\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\t\n\t\t\tvar r = this.r, g = this.g, b = this.b;\n\t\n\t\t\tvar max = Math.max( r, g, b );\n\t\t\tvar min = Math.min( r, g, b );\n\t\n\t\t\tvar hue, saturation;\n\t\t\tvar lightness = ( min + max ) / 2.0;\n\t\n\t\t\tif ( min === max ) {\n\t\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar delta = max - min;\n\t\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\t\n\t\t\t\tswitch ( max ) {\n\t\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\t\n\t\t\t\t}\n\t\n\t\t\t\thue /= 6;\n\t\n\t\t\t}\n\t\n\t\t\thsl.h = hue;\n\t\t\thsl.s = saturation;\n\t\t\thsl.l = lightness;\n\t\n\t\t\treturn hsl;\n\t\n\t\t},\n\t\n\t\tgetStyle: function () {\n\t\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\t\n\t\t},\n\t\n\t\toffsetHSL: function ( h, s, l ) {\n\t\n\t\t\tvar hsl = this.getHSL();\n\t\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\t\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( color ) {\n\t\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddColors: function ( color1, color2 ) {\n\t\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function( color ) {\n\t\n\t\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\t\tthis.b = Math.max( 0, this.b - color.b );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( color ) {\n\t\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerp: function ( color, alpha ) {\n\t\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( c ) {\n\t\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.r = array[ offset ];\n\t\t\tthis.g = array[ offset + 1 ];\n\t\t\tthis.b = array[ offset + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.r;\n\t\t\tarray[ offset + 1 ] = this.g;\n\t\t\tarray[ offset + 2 ] = this.b;\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\t\n\t// File:src/math/Quaternion.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Quaternion = function ( x, y, z, w ) {\n\t\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._w = ( w !== undefined ) ? w : 1;\n\t\n\t};\n\t\n\tTHREE.Quaternion.prototype = {\n\t\n\t\tconstructor: THREE.Quaternion,\n\t\n\t\tget x () {\n\t\n\t\t\treturn this._x;\n\t\n\t\t},\n\t\n\t\tset x ( value ) {\n\t\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget y () {\n\t\n\t\t\treturn this._y;\n\t\n\t\t},\n\t\n\t\tset y ( value ) {\n\t\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget z () {\n\t\n\t\t\treturn this._z;\n\t\n\t\t},\n\t\n\t\tset z ( value ) {\n\t\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget w () {\n\t\n\t\t\treturn this._w;\n\t\n\t\t},\n\t\n\t\tset w ( value ) {\n\t\n\t\t\tthis._w = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\t\n\t\t},\n\t\n\t\tcopy: function ( quaternion ) {\n\t\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromEuler: function ( euler, update ) {\n\t\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t}\n\t\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\t\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\n\t\n\t\t\tvar order = euler.order;\n\t\n\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\n\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\n\t\t\t}\n\t\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\n\t\t\t// assumes axis is normalized\n\t\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\t\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos( halfAngle );\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromRotationMatrix: function ( m ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar te = m.elements,\n\t\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\t\n\t\t\t\ttrace = m11 + m22 + m33,\n\t\t\t\ts;\n\t\n\t\t\tif ( trace > 0 ) {\n\t\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\t\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\n\t\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\t\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\n\t\n\t\t\t} else if ( m22 > m33 ) {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\t\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\t\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\t\n\t\t\t}\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromUnitVectors: function () {\n\t\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\t\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\n\t\t\tvar v1, r;\n\t\n\t\t\tvar EPS = 0.000001;\n\t\n\t\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\n\t\n\t\t\t\tif ( r < EPS ) {\n\t\n\t\t\t\t\tr = 0;\n\t\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\t\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._x = v1.x;\n\t\t\t\tthis._y = v1.y;\n\t\t\t\tthis._z = v1.z;\n\t\t\t\tthis._w = r;\n\t\n\t\t\t\treturn this.normalize();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tinverse: function () {\n\t\n\t\t\treturn this.conjugate().normalize();\n\t\n\t\t},\n\t\n\t\tconjugate: function () {\n\t\n\t\t\tthis._x *= - 1;\n\t\t\tthis._y *= - 1;\n\t\t\tthis._z *= - 1;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\tvar l = this.length();\n\t\n\t\t\tif ( l === 0 ) {\n\t\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tl = 1 / l;\n\t\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\t\n\t\t\t}\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( q, p ) {\n\t\n\t\t\tif ( p !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\t\treturn this.multiplyQuaternions( q, p );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.multiplyQuaternions( this, q );\n\t\n\t\t},\n\t\n\t\tpremultiply: function ( q ) {\n\t\n\t\t\treturn this.multiplyQuaternions( q, this );\n\t\n\t\t},\n\t\n\t\tmultiplyQuaternions: function ( a, b ) {\n\t\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\t\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tslerp: function ( qb, t ) {\n\t\n\t\t\tif ( t === 0 ) return this;\n\t\t\tif ( t === 1 ) return this.copy( qb );\n\t\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\t\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\t\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\t\n\t\t\tif ( cosHalfTheta < 0 ) {\n\t\n\t\t\t\tthis._w = - qb._w;\n\t\t\t\tthis._x = - qb._x;\n\t\t\t\tthis._y = - qb._y;\n\t\t\t\tthis._z = - qb._z;\n\t\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.copy( qb );\n\t\n\t\t\t}\n\t\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\n\t\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\t\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\t\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\t\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( quaternion ) {\n\t\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis._x = array[ offset ];\n\t\t\tthis._y = array[ offset + 1 ];\n\t\t\tthis._z = array[ offset + 2 ];\n\t\t\tthis._w = array[ offset + 3 ];\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._w;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tonChange: function ( callback ) {\n\t\n\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tonChangeCallback: function () {}\n\t\n\t};\n\t\n\tObject.assign( THREE.Quaternion, {\n\t\n\t\tslerp: function( qa, qb, qm, t ) {\n\t\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\n\t\n\t\t},\n\t\n\t\tslerpFlat: function(\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\t\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\t\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\t\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\t\n\t\t\t\tvar s = 1 - t,\n\t\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\t\tsqrSin = 1 - cos * cos;\n\t\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\n\t\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\t\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar tDir = t * dir;\n\t\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir;\n\t\n\t\t\t\t// Normalize in case we just did a lerp:\n\t\t\t\tif ( s === 1 - t ) {\n\t\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\t\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tdst[ dstOffset ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/Vector2.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.Vector2 = function ( x, y ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\n\t};\n\t\n\tTHREE.Vector2.prototype = {\n\t\n\t\tconstructor: THREE.Vector2,\n\t\n\t\tget width() {\n\t\n\t\t\treturn this.x;\n\t\n\t\t},\n\t\n\t\tset width( value ) {\n\t\n\t\t\tthis.x = value;\n\t\n\t\t},\n\t\n\t\tget height() {\n\t\n\t\t\treturn this.y;\n\t\n\t\t},\n\t\n\t\tset height( value ) {\n\t\n\t\t\tthis.y = value;\n\t\n\t\t},\n\t\n\t\t//\n\t\n\t\tset: function ( x, y ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( v ) {\n\t\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivide: function ( v ) {\n\t\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\t\tmax = new THREE.Vector2();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclampLength: function ( min, max ) {\n\t\n\t\t\tvar length = this.length();\n\t\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t},\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function() {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tangle: function () {\n\t\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\n\t\t\tvar angle = Math.atan2( this.y, this.x );\n\t\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\t\n\t\t\treturn angle;\n\t\n\t\t},\n\t\n\t\tdistanceTo: function ( v ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t},\n\t\n\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\n\t\t},\n\t\n\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateAround: function ( center, angle ) {\n\t\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\t\n\t\t\tvar x = this.x - center.x;\n\t\t\tvar y = this.y - center.y;\n\t\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Vector3.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Vector3 = function ( x, y, z ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\n\t};\n\t\n\tTHREE.Vector3.prototype = {\n\t\n\t\tconstructor: THREE.Vector3,\n\t\n\t\tset: function ( x, y, z ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( z ) {\n\t\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiply: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\t\treturn this.multiplyVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyEuler: function () {\n\t\n\t\t\tvar quaternion;\n\t\n\t\t\treturn function applyEuler( euler ) {\n\t\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyAxisAngle: function () {\n\t\n\t\t\tvar quaternion;\n\t\n\t\t\treturn function applyAxisAngle( axis, angle ) {\n\t\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyMatrix3: function ( m ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyProjection: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 projection matrix\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\t\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyQuaternion: function ( q ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\t\n\t\t\t// calculate quat * vector\n\t\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\n\t\n\t\t\t// calculate result * inverse quat\n\t\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tproject: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function project( camera ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tunproject: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function unproject( camera ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\t\treturn this.applyProjection( matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttransformDirection: function ( m ) {\n\t\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\t\n\t\t\treturn this.normalize();\n\t\n\t\t},\n\t\n\t\tdivide: function ( v ) {\n\t\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\t\tmax = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclampLength: function ( min, max ) {\n\t\n\t\t\tvar length = this.length();\n\t\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\t\n\t\t},\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function () {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tcross: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\t\treturn this.crossVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z;\n\t\n\t\t\tthis.x = y * v.z - z * v.y;\n\t\t\tthis.y = z * v.x - x * v.z;\n\t\t\tthis.z = x * v.y - y * v.x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcrossVectors: function ( a, b ) {\n\t\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\n\t\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tprojectOnVector: function ( vector ) {\n\t\n\t\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\t\n\t\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\t\n\t\t},\n\t\n\t\tprojectOnPlane: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function projectOnPlane( planeNormal ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\t\n\t\t\t\treturn this.sub( v1 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\treflect: function () {\n\t\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function reflect( normal ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tangleTo: function ( v ) {\n\t\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\t\n\t\t\t// clamp, to handle numerical problems\n\t\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\t\n\t\t},\n\t\n\t\tdistanceTo: function ( v ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\t\n\t\t},\n\t\n\t\tdistanceToSquared: function ( v ) {\n\t\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\t\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\n\t\t},\n\t\n\t\tdistanceToManhattan: function ( v ) {\n\t\n\t\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\t\n\t\t},\n\t\n\t\tsetFromSpherical: function( s ) {\n\t\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\t\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrixPosition: function ( m ) {\n\t\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\n\t\n\t\t},\n\t\n\t\tsetFromMatrixScale: function ( m ) {\n\t\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrixColumn: function ( m, index ) {\n\t\n\t\t\tif ( typeof m === 'number' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\t\tvar temp = m\n\t\t\t\tm = index;\n\t\t\t\tindex = temp;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.fromArray( m.elements, index * 4 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Vector4.js\n\t\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Vector4 = function ( x, y, z, w ) {\n\t\n\t\tthis.x = x || 0;\n\t\tthis.y = y || 0;\n\t\tthis.z = z || 0;\n\t\tthis.w = ( w !== undefined ) ? w : 1;\n\t\n\t};\n\t\n\tTHREE.Vector4.prototype = {\n\t\n\t\tconstructor: THREE.Vector4,\n\t\n\t\tset: function ( x, y, z, w ) {\n\t\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetScalar: function ( scalar ) {\n\t\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetX: function ( x ) {\n\t\n\t\t\tthis.x = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( y ) {\n\t\n\t\t\tthis.y = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( z ) {\n\t\n\t\t\tthis.z = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetW: function ( w ) {\n\t\n\t\t\tthis.w = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponent: function ( index, value ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: this.x = value; break;\n\t\t\t\tcase 1: this.y = value; break;\n\t\t\t\tcase 2: this.z = value; break;\n\t\t\t\tcase 3: this.w = value; break;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetComponent: function ( index ) {\n\t\n\t\t\tswitch ( index ) {\n\t\n\t\t\t\tcase 0: return this.x;\n\t\t\t\tcase 1: return this.y;\n\t\t\t\tcase 2: return this.z;\n\t\t\t\tcase 3: return this.w;\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\t\n\t\t},\n\t\n\t\tcopy: function ( v ) {\n\t\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\t\treturn this.addVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScalar: function ( s ) {\n\t\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddScaledVector: function ( v, s ) {\n\t\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsub: function ( v, w ) {\n\t\n\t\t\tif ( w !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\t\treturn this.subVectors( v, w );\n\t\n\t\t\t}\n\t\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubScalar: function ( s ) {\n\t\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsubVectors: function ( a, b ) {\n\t\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( scalar ) {\n\t\n\t\t\tif ( isFinite( scalar ) ) {\n\t\n\t\t\t\tthis.x *= scalar;\n\t\t\t\tthis.y *= scalar;\n\t\t\t\tthis.z *= scalar;\n\t\t\t\tthis.w *= scalar;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( m ) {\n\t\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\t\tvar e = m.elements;\n\t\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdivideScalar: function ( scalar ) {\n\t\n\t\t\treturn this.multiplyScalar( 1 / scalar );\n\t\n\t\t},\n\t\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\n\t\t\t// q is assumed to be normalized\n\t\n\t\t\tthis.w = 2 * Math.acos( q.w );\n\t\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\t\n\t\t\tif ( s < 0.0001 ) {\n\t\n\t\t\t\t this.x = 1;\n\t\t\t\t this.y = 0;\n\t\t\t\t this.z = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t this.x = q.x / s;\n\t\t\t\t this.y = q.y / s;\n\t\t\t\t this.z = q.z / s;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\t\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\t\n\t\t\t\tte = m.elements,\n\t\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\t\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\t\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\t\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\n\t\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// otherwise this singularity is angle = 180\n\t\n\t\t\t\tangle = Math.PI;\n\t\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\n\t\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\t\n\t\t\t\t\t// m11 is the largest diagonal term\n\t\n\t\t\t\t\tif ( xx < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( yy > zz ) {\n\t\n\t\t\t\t\t// m22 is the largest diagonal term\n\t\n\t\t\t\t\tif ( yy < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\n\t\t\t\t\tif ( zz < epsilon ) {\n\t\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.set( x, y, z, angle );\n\t\n\t\t\t\treturn this; // return 180 deg rotation\n\t\n\t\t\t}\n\t\n\t\t\t// as we have reached here there are no singularities so we can handle normally\n\t\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\t\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\t\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\t\n\t\t\tthis.x = ( m32 - m23 ) / s;\n\t\t\tthis.y = ( m13 - m31 ) / s;\n\t\t\tthis.z = ( m21 - m12 ) / s;\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmin: function ( v ) {\n\t\n\t\t\tthis.x = Math.min( this.x, v.x );\n\t\t\tthis.y = Math.min( this.y, v.y );\n\t\t\tthis.z = Math.min( this.z, v.z );\n\t\t\tthis.w = Math.min( this.w, v.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmax: function ( v ) {\n\t\n\t\t\tthis.x = Math.max( this.x, v.x );\n\t\t\tthis.y = Math.max( this.y, v.y );\n\t\t\tthis.z = Math.max( this.z, v.z );\n\t\t\tthis.w = Math.max( this.w, v.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclamp: function ( min, max ) {\n\t\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\t\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclampScalar: function () {\n\t\n\t\t\tvar min, max;\n\t\n\t\t\treturn function clampScalar( minVal, maxVal ) {\n\t\n\t\t\t\tif ( min === undefined ) {\n\t\n\t\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\t\tmax = new THREE.Vector4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\t\n\t\t\t\treturn this.clamp( min, max );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tfloor: function () {\n\t\n\t\t\tthis.x = Math.floor( this.x );\n\t\t\tthis.y = Math.floor( this.y );\n\t\t\tthis.z = Math.floor( this.z );\n\t\t\tthis.w = Math.floor( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tceil: function () {\n\t\n\t\t\tthis.x = Math.ceil( this.x );\n\t\t\tthis.y = Math.ceil( this.y );\n\t\t\tthis.z = Math.ceil( this.z );\n\t\t\tthis.w = Math.ceil( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tround: function () {\n\t\n\t\t\tthis.x = Math.round( this.x );\n\t\t\tthis.y = Math.round( this.y );\n\t\t\tthis.z = Math.round( this.z );\n\t\t\tthis.w = Math.round( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\troundToZero: function () {\n\t\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.x = - this.x;\n\t\t\tthis.y = - this.y;\n\t\t\tthis.z = - this.z;\n\t\t\tthis.w = - this.w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdot: function ( v ) {\n\t\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\n\t\t},\n\t\n\t\tlengthSq: function () {\n\t\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\n\t\t},\n\t\n\t\tlength: function () {\n\t\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\t\n\t\t},\n\t\n\t\tlengthManhattan: function () {\n\t\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\treturn this.divideScalar( this.length() );\n\t\n\t\t},\n\t\n\t\tsetLength: function ( length ) {\n\t\n\t\t\treturn this.multiplyScalar( length / this.length() );\n\t\n\t\t},\n\t\n\t\tlerp: function ( v, alpha ) {\n\t\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlerpVectors: function ( v1, v2, alpha ) {\n\t\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\t\n\t\t},\n\t\n\t\tequals: function ( v ) {\n\t\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.x = array[ offset ];\n\t\t\tthis.y = array[ offset + 1 ];\n\t\t\tthis.z = array[ offset + 2 ];\n\t\t\tthis.w = array[ offset + 3 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this.x;\n\t\t\tarray[ offset + 1 ] = this.y;\n\t\t\tarray[ offset + 2 ] = this.z;\n\t\t\tarray[ offset + 3 ] = this.w;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tfromAttribute: function ( attribute, index, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tindex = index * attribute.itemSize + offset;\n\t\n\t\t\tthis.x = attribute.array[ index ];\n\t\t\tthis.y = attribute.array[ index + 1 ];\n\t\t\tthis.z = attribute.array[ index + 2 ];\n\t\t\tthis.w = attribute.array[ index + 3 ];\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Euler.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Euler = function ( x, y, z, order ) {\n\t\n\t\tthis._x = x || 0;\n\t\tthis._y = y || 0;\n\t\tthis._z = z || 0;\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\n\t\n\t};\n\t\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\t\n\tTHREE.Euler.DefaultOrder = 'XYZ';\n\t\n\tTHREE.Euler.prototype = {\n\t\n\t\tconstructor: THREE.Euler,\n\t\n\t\tget x () {\n\t\n\t\t\treturn this._x;\n\t\n\t\t},\n\t\n\t\tset x ( value ) {\n\t\n\t\t\tthis._x = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget y () {\n\t\n\t\t\treturn this._y;\n\t\n\t\t},\n\t\n\t\tset y ( value ) {\n\t\n\t\t\tthis._y = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget z () {\n\t\n\t\t\treturn this._z;\n\t\n\t\t},\n\t\n\t\tset z ( value ) {\n\t\n\t\t\tthis._z = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tget order () {\n\t\n\t\t\treturn this._order;\n\t\n\t\t},\n\t\n\t\tset order ( value ) {\n\t\n\t\t\tthis._order = value;\n\t\t\tthis.onChangeCallback();\n\t\n\t\t},\n\t\n\t\tset: function ( x, y, z, order ) {\n\t\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\t\n\t\t},\n\t\n\t\tcopy: function ( euler ) {\n\t\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\n\t\n\t\t\tvar clamp = THREE.Math.clamp;\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tvar te = m.elements;\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\t\n\t\t\torder = order || this._order;\n\t\n\t\t\tif ( order === 'XYZ' ) {\n\t\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'YXZ' ) {\n\t\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'ZXY' ) {\n\t\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'ZYX' ) {\n\t\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'YZX' ) {\n\t\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( order === 'XZY' ) {\n\t\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\t\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\t\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\t\n\t\t\t}\n\t\n\t\t\tthis._order = order;\n\t\n\t\t\tif ( update !== false ) this.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromQuaternion: function () {\n\t\n\t\t\tvar matrix;\n\t\n\t\t\treturn function setFromQuaternion( q, order, update ) {\n\t\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\t\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\n\t\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetFromVector3: function ( v, order ) {\n\t\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\t\n\t\t},\n\t\n\t\treorder: function () {\n\t\n\t\t\t// WARNING: this discards revolution information -bhouston\n\t\n\t\t\tvar q = new THREE.Quaternion();\n\t\n\t\t\treturn function reorder( newOrder ) {\n\t\n\t\t\t\tq.setFromEuler( this );\n\t\t\t\t\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tequals: function ( euler ) {\n\t\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis._x = array[ 0 ];\n\t\t\tthis._y = array[ 1 ];\n\t\t\tthis._z = array[ 2 ];\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\t\n\t\t\tthis.onChangeCallback();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tarray[ offset ] = this._x;\n\t\t\tarray[ offset + 1 ] = this._y;\n\t\t\tarray[ offset + 2 ] = this._z;\n\t\t\tarray[ offset + 3 ] = this._order;\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\ttoVector3: function ( optionalResult ) {\n\t\n\t\t\tif ( optionalResult ) {\n\t\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tonChange: function ( callback ) {\n\t\n\t\t\tthis.onChangeCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tonChangeCallback: function () {}\n\t\n\t};\n\t\n\t// File:src/math/Line3.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Line3 = function ( start, end ) {\n\t\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Line3.prototype = {\n\t\n\t\tconstructor: THREE.Line3,\n\t\n\t\tset: function ( start, end ) {\n\t\n\t\t\tthis.start.copy( start );\n\t\t\tthis.end.copy( end );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( line ) {\n\t\n\t\t\tthis.start.copy( line.start );\n\t\t\tthis.end.copy( line.end );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tdelta: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.subVectors( this.end, this.start );\n\t\n\t\t},\n\t\n\t\tdistanceSq: function () {\n\t\n\t\t\treturn this.start.distanceToSquared( this.end );\n\t\n\t\t},\n\t\n\t\tdistance: function () {\n\t\n\t\t\treturn this.start.distanceTo( this.end );\n\t\n\t\t},\n\t\n\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t},\n\t\n\t\tclosestPointToPointParameter: function () {\n\t\n\t\t\tvar startP = new THREE.Vector3();\n\t\t\tvar startEnd = new THREE.Vector3();\n\t\n\t\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\t\n\t\t\t\tstartP.subVectors( point, this.start );\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\n\t\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\t\n\t\t\t\tvar t = startEnd_startP / startEnd2;\n\t\n\t\t\t\tif ( clampToLine ) {\n\t\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn t;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\t\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\tthis.start.applyMatrix4( matrix );\n\t\t\tthis.end.applyMatrix4( matrix );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( line ) {\n\t\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Box2.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Box2 = function ( min, max ) {\n\t\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\t\n\t};\n\t\n\tTHREE.Box2.prototype = {\n\t\n\t\tconstructor: THREE.Box2,\n\t\n\t\tset: function ( min, max ) {\n\t\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\tthis.makeEmpty();\n\t\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector2();\n\t\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( box ) {\n\t\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeEmpty: function () {\n\t\n\t\t\tthis.min.x = this.min.y = + Infinity;\n\t\t\tthis.max.x = this.max.y = - Infinity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tisEmpty: function () {\n\t\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.subVectors( this.max, this.min );\n\t\n\t\t},\n\t\n\t\texpandByPoint: function ( point ) {\n\t\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByVector: function ( vector ) {\n\t\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tcontainsBox: function ( box ) {\n\t\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t\t);\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector2();\n\t\n\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersect: function ( box ) {\n\t\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tunion: function ( box ) {\n\t\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( box ) {\n\t\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Box3.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Box3 = function ( min, max ) {\n\t\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\t\n\t};\n\t\n\tTHREE.Box3.prototype = {\n\t\n\t\tconstructor: THREE.Box3,\n\t\n\t\tset: function ( min, max ) {\n\t\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromArray: function ( array ) {\n\t\n\t\t\tvar minX = + Infinity;\n\t\t\tvar minY = + Infinity;\n\t\t\tvar minZ = + Infinity;\n\t\n\t\t\tvar maxX = - Infinity;\n\t\t\tvar maxY = - Infinity;\n\t\t\tvar maxZ = - Infinity;\n\t\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\tvar x = array[ i ];\n\t\t\t\tvar y = array[ i + 1 ];\n\t\t\t\tvar z = array[ i + 2 ];\n\t\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( z < minZ ) minZ = z;\n\t\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\t\t\t\tif ( z > maxZ ) maxZ = z;\n\t\n\t\t\t}\n\t\n\t\t\tthis.min.set( minX, minY, minZ );\n\t\t\tthis.max.set( maxX, maxY, maxZ );\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function ( points ) {\n\t\n\t\t\tthis.makeEmpty();\n\t\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.expandByPoint( points[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCenterAndSize: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromCenterAndSize( center, size ) {\n\t\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\t\tthis.max.copy( center ).add( halfSize );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetFromObject: function () {\n\t\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromObject( object ) {\n\t\n\t\t\t\tvar scope = this;\n\t\n\t\t\t\tobject.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.makeEmpty();\n\t\n\t\t\t\tobject.traverse( function ( node ) {\n\t\n\t\t\t\t\tvar geometry = node.geometry;\n\t\n\t\t\t\t\tif ( geometry !== undefined ) {\n\t\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\t\n\t\t\t\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\t\t\t\tvar array, offset, stride;\n\t\n\t\t\t\t\t\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\t\tstride = 3;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\t\n\t\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\t\n\t\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( box ) {\n\t\n\t\t\tthis.min.copy( box.min );\n\t\t\tthis.max.copy( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeEmpty: function () {\n\t\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tisEmpty: function () {\n\t\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\t\n\t\t},\n\t\n\t\tcenter: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\t\n\t\t},\n\t\n\t\tsize: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.subVectors( this.max, this.min );\n\t\n\t\t},\n\t\n\t\texpandByPoint: function ( point ) {\n\t\n\t\t\tthis.min.min( point );\n\t\t\tthis.max.max( point );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByVector: function ( vector ) {\n\t\n\t\t\tthis.min.sub( vector );\n\t\t\tthis.max.add( vector );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\texpandByScalar: function ( scalar ) {\n\t\n\t\t\tthis.min.addScalar( - scalar );\n\t\t\tthis.max.addScalar( scalar );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tcontainsBox: function ( box ) {\n\t\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tgetParameter: function ( point, optionalTarget ) {\n\t\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn result.set(\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t\t);\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\t\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tintersectsSphere: ( function () {\n\t\n\t\t\tvar closestPoint;\n\t\n\t\t\treturn function intersectsSphere( sphere ) {\n\t\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\t\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\t\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\n\t\t\tvar min, max;\n\t\n\t\t\tif ( plane.normal.x > 0 ) {\n\t\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\n\t\t\t}\n\t\n\t\t\tif ( plane.normal.y > 0 ) {\n\t\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\n\t\t\t}\n\t\n\t\t\tif ( plane.normal.z > 0 ) {\n\t\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\n\t\t\t}\n\t\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function distanceToPoint( point ) {\n\t\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\t\treturn clampedPoint.sub( point ).length();\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetBoundingSphere: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function getBoundingSphere( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\t\n\t\t\t\tresult.center = this.center();\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersect: function ( box ) {\n\t\n\t\t\tthis.min.max( box.min );\n\t\t\tthis.max.min( box.max );\n\t\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tunion: function ( box ) {\n\t\n\t\t\tthis.min.min( box.min );\n\t\t\tthis.max.max( box.max );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function () {\n\t\n\t\t\tvar points = [\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3(),\n\t\t\t\tnew THREE.Vector3()\n\t\t\t];\n\t\n\t\t\treturn function applyMatrix4( matrix ) {\n\t\n\t\t\t\t// transform of empty box is an empty box.\n\t\t\t\tif( this.isEmpty() ) return this;\n\t\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\t\n\t\t\t\tthis.setFromPoints( points );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.min.add( offset );\n\t\t\tthis.max.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( box ) {\n\t\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Matrix3.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\t\n\tTHREE.Matrix3 = function () {\n\t\n\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\t\n\t\t] );\n\t\n\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Matrix3.prototype = {\n\t\n\t\tconstructor: THREE.Matrix3,\n\t\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tidentity: function () {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0,\n\t\t\t\t0, 1, 0,\n\t\t\t\t0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().fromArray( this.elements );\n\t\n\t\t},\n\t\n\t\tcopy: function ( m ) {\n\t\n\t\t\tvar me = m.elements;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrix4: function( m ) {\n\t\n\t\t\tvar me = m.elements;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyToVector3Array: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyToBuffer: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\tv1.applyMatrix3( this );\n\t\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn buffer;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdeterminant: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\t\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\n\t\t},\n\t\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\t\n\t\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\t\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\t\n\t\t\t}\n\t\n\t\t\tvar me = matrix.elements,\n\t\t\t\tte = this.elements,\n\t\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\t\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\n\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\tif ( throwOnDegenerate || false ) {\n\t\n\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.identity();\n\t\t\t}\n\t\t\t\n\t\t\tvar detInv = 1 / det;\n\t\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\t\n\t\t\tte[ 3 ] = t12 * detInv;\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\t\n\t\t\tte[ 6 ] = t13 * detInv;\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranspose: function () {\n\t\n\t\t\tvar tmp, m = this.elements;\n\t\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\treturn this.toArray( array, offset );\n\t\n\t\t},\n\t\n\t\tgetNormalMatrix: function ( matrix4 ) {\n\t\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\t\n\t\t},\n\t\n\t\ttransposeIntoArray: function ( r ) {\n\t\n\t\t\tvar m = this.elements;\n\t\n\t\t\tr[ 0 ] = m[ 0 ];\n\t\t\tr[ 1 ] = m[ 3 ];\n\t\t\tr[ 2 ] = m[ 6 ];\n\t\t\tr[ 3 ] = m[ 1 ];\n\t\t\tr[ 4 ] = m[ 4 ];\n\t\t\tr[ 5 ] = m[ 7 ];\n\t\t\tr[ 6 ] = m[ 2 ];\n\t\t\tr[ 7 ] = m[ 5 ];\n\t\t\tr[ 8 ] = m[ 8 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis.elements.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Matrix4.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.Matrix4 = function () {\n\t\n\t\tthis.elements = new Float32Array( [\n\t\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\t\n\t\t] );\n\t\n\t\tif ( arguments.length > 0 ) {\n\t\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Matrix4.prototype = {\n\t\n\t\tconstructor: THREE.Matrix4,\n\t\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tidentity: function () {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\t\n\t\t},\n\t\n\t\tcopy: function ( m ) {\n\t\n\t\t\tthis.elements.set( m.elements );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyPosition: function ( m ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\t\n\t\t\tte[ 12 ] = me[ 12 ];\n\t\t\tte[ 13 ] = me[ 13 ];\n\t\t\tte[ 14 ] = me[ 14 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\t\n\t\t\tthis.set(\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t\t0,       0,       0,       1\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\textractRotation: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function extractRotation( m ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\n\t\t\t\tvar te = this.elements;\n\t\t\t\tvar me = m.elements;\n\t\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\t\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmakeRotationFromEuler: function ( euler ) {\n\t\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\t\n\t\t\t}\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\t\n\t\t\tif ( euler.order === 'XYZ' ) {\n\t\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - c * f;\n\t\t\t\tte[ 8 ] = d;\n\t\n\t\t\t\tte[ 1 ] = af + be * d;\n\t\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\t\tte[ 9 ] = - b * c;\n\t\n\t\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\t\tte[ 6 ] = be + af * d;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'YXZ' ) {\n\t\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\tte[ 0 ] = ce + df * b;\n\t\t\t\tte[ 4 ] = de * b - cf;\n\t\t\t\tte[ 8 ] = a * d;\n\t\n\t\t\t\tte[ 1 ] = a * f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b;\n\t\n\t\t\t\tte[ 2 ] = cf * b - de;\n\t\t\t\tte[ 6 ] = df + ce * b;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'ZXY' ) {\n\t\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\t\n\t\t\t\tte[ 0 ] = ce - df * b;\n\t\t\t\tte[ 4 ] = - a * f;\n\t\t\t\tte[ 8 ] = de + cf * b;\n\t\n\t\t\t\tte[ 1 ] = cf + de * b;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = df - ce * b;\n\t\n\t\t\t\tte[ 2 ] = - a * d;\n\t\t\t\tte[ 6 ] = b;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'ZYX' ) {\n\t\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = be * d - af;\n\t\t\t\tte[ 8 ] = ae * d + bf;\n\t\n\t\t\t\tte[ 1 ] = c * f;\n\t\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\t\tte[ 9 ] = af * d - be;\n\t\n\t\t\t\tte[ 2 ] = - d;\n\t\t\t\tte[ 6 ] = b * c;\n\t\t\t\tte[ 10 ] = a * c;\n\t\n\t\t\t} else if ( euler.order === 'YZX' ) {\n\t\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\t\tte[ 8 ] = bc * f + ad;\n\t\n\t\t\t\tte[ 1 ] = f;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = - b * e;\n\t\n\t\t\t\tte[ 2 ] = - d * e;\n\t\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\t\tte[ 10 ] = ac - bd * f;\n\t\n\t\t\t} else if ( euler.order === 'XZY' ) {\n\t\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\t\n\t\t\t\tte[ 0 ] = c * e;\n\t\t\t\tte[ 4 ] = - f;\n\t\t\t\tte[ 8 ] = d * e;\n\t\n\t\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\t\tte[ 5 ] = a * e;\n\t\t\t\tte[ 9 ] = ad * f - bc;\n\t\n\t\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\t\tte[ 6 ] = b * e;\n\t\t\t\tte[ 10 ] = bd * f + ac;\n\t\n\t\t\t}\n\t\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationFromQuaternion: function ( q ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\t\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\t\tte[ 4 ] = xy - wz;\n\t\t\tte[ 8 ] = xz + wy;\n\t\n\t\t\tte[ 1 ] = xy + wz;\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\t\tte[ 9 ] = yz - wx;\n\t\n\t\t\tte[ 2 ] = xz - wy;\n\t\t\tte[ 6 ] = yz + wx;\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\n\t\n\t\t\t// last column\n\t\t\tte[ 3 ] = 0;\n\t\t\tte[ 7 ] = 0;\n\t\t\tte[ 11 ] = 0;\n\t\n\t\t\t// bottom row\n\t\t\tte[ 12 ] = 0;\n\t\t\tte[ 13 ] = 0;\n\t\t\tte[ 14 ] = 0;\n\t\t\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar x, y, z;\n\t\n\t\t\treturn function lookAt( eye, target, up ) {\n\t\n\t\t\t\tif ( x === undefined ) {\n\t\n\t\t\t\t\tx = new THREE.Vector3();\n\t\t\t\t\ty = new THREE.Vector3();\n\t\t\t\t\tz = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tz.subVectors( eye, target ).normalize();\n\t\n\t\t\t\tif ( z.lengthSq() === 0 ) {\n\t\n\t\t\t\t\tz.z = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\tif ( x.lengthSq() === 0 ) {\n\t\n\t\t\t\t\tz.z += 0.0001;\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\ty.crossVectors( z, x );\n\t\n\t\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmultiply: function ( m, n ) {\n\t\n\t\t\tif ( n !== undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\t\treturn this.multiplyMatrices( m, n );\n\t\n\t\t\t}\n\t\n\t\t\treturn this.multiplyMatrices( this, m );\n\t\n\t\t},\n\t\n\t\tpremultiply: function ( m ) {\n\t\n\t\t\treturn this.multiplyMatrices( m, this );\n\t\n\t\t},\n\t\n\t\tmultiplyMatrices: function ( a, b ) {\n\t\n\t\t\tvar ae = a.elements;\n\t\t\tvar be = b.elements;\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\t\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\t\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyToArray: function ( a, b, r ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tthis.multiplyMatrices( a, b );\n\t\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmultiplyScalar: function ( s ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tapplyToVector3Array: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToVector3Array( array, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = array.length;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\t\n\t\t\t\t\tv1.fromArray( array, j );\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\t\tv1.toArray( array, j );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn array;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyToBuffer: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\t\n\t\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\t\tv1.z = buffer.getZ( j );\n\t\n\t\t\t\t\tv1.applyMatrix4( this );\n\t\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn buffer;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tdeterminant: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\t\n\t\t\t//TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\t\n\t\t\treturn (\n\t\t\t\tn41 * (\n\t\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t\t - n13 * n24 * n32\n\t\t\t\t\t - n14 * n22 * n33\n\t\t\t\t\t + n12 * n24 * n33\n\t\t\t\t\t + n13 * n22 * n34\n\t\t\t\t\t - n12 * n23 * n34\n\t\t\t\t) +\n\t\t\t\tn42 * (\n\t\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t\t - n11 * n24 * n33\n\t\t\t\t\t + n14 * n21 * n33\n\t\t\t\t\t - n13 * n21 * n34\n\t\t\t\t\t + n13 * n24 * n31\n\t\t\t\t\t - n14 * n23 * n31\n\t\t\t\t) +\n\t\t\t\tn43 * (\n\t\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t\t - n11 * n22 * n34\n\t\t\t\t\t - n14 * n21 * n32\n\t\t\t\t\t + n12 * n21 * n34\n\t\t\t\t\t + n14 * n22 * n31\n\t\t\t\t\t - n12 * n24 * n31\n\t\t\t\t) +\n\t\t\t\tn44 * (\n\t\t\t\t\t- n13 * n22 * n31\n\t\t\t\t\t - n11 * n23 * n32\n\t\t\t\t\t + n11 * n22 * n33\n\t\t\t\t\t + n13 * n21 * n32\n\t\t\t\t\t - n12 * n21 * n33\n\t\t\t\t\t + n12 * n23 * n31\n\t\t\t\t)\n\t\n\t\t\t);\n\t\n\t\t},\n\t\n\t\ttranspose: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar tmp;\n\t\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\t\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tflattenToArrayOffset: function ( array, offset ) {\n\t\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\t\"- just use .toArray instead.\" );\n\t\n\t\t\treturn this.toArray( array, offset );\n\t\n\t\t},\n\t\n\t\tgetPosition: function () {\n\t\n\t\t\tvar v1;\n\t\n\t\t\treturn function getPosition() {\n\t\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\t\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tsetPosition: function ( v ) {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tte[ 12 ] = v.x;\n\t\t\tte[ 13 ] = v.y;\n\t\t\tte[ 14 ] = v.z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\n\t\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tvar te = this.elements,\n\t\t\t\tme = m.elements,\n\t\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\t\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\n\t\t\tif ( det === 0 ) {\n\t\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\t\n\t\t\t\tif ( throwOnDegenerate || false ) {\n\t\n\t\t\t\t\tthrow new Error( msg );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( msg );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this.identity();\n\t\n\t\t\t}\n\t\t\t\n\t\t\tvar detInv = 1 / det;\n\t\n\t\t\tte[ 0 ] = t11 * detInv;\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\t\n\t\t\tte[ 4 ] = t12 * detInv;\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\t\n\t\t\tte[ 8 ] = t13 * detInv;\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\t\n\t\t\tte[ 12 ] = t14 * detInv;\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tscale: function ( v ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar x = v.x, y = v.y, z = v.z;\n\t\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetMaxScaleOnAxis: function () {\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\t\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\t\n\t\t},\n\t\n\t\tmakeTranslation: function ( x, y, z ) {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationX: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t1, 0,  0, 0,\n\t\t\t\t0, c, - s, 0,\n\t\t\t\t0, s,  c, 0,\n\t\t\t\t0, 0,  0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationY: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\t c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t- s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationZ: function ( theta ) {\n\t\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tc, - s, 0, 0,\n\t\t\t\ts,  c, 0, 0,\n\t\t\t\t0,  0, 1, 0,\n\t\t\t\t0,  0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakeRotationAxis: function ( axis, angle ) {\n\t\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\n\t\t\tvar c = Math.cos( angle );\n\t\t\tvar s = Math.sin( angle );\n\t\t\tvar t = 1 - c;\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\t\tvar tx = t * x, ty = t * y;\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\t return this;\n\t\n\t\t},\n\t\n\t\tmakeScale: function ( x, y, z ) {\n\t\n\t\t\tthis.set(\n\t\n\t\t\t\tx, 0, 0, 0,\n\t\t\t\t0, y, 0, 0,\n\t\t\t\t0, 0, z, 0,\n\t\t\t\t0, 0, 0, 1\n\t\n\t\t\t);\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcompose: function ( position, quaternion, scale ) {\n\t\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\t\tthis.scale( scale );\n\t\t\tthis.setPosition( position );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdecompose: function () {\n\t\n\t\t\tvar vector, matrix;\n\t\n\t\t\treturn function decompose( position, quaternion, scale ) {\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\t\tmatrix = new THREE.Matrix4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar te = this.elements;\n\t\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\t\n\t\t\t\t// if determine is negative, we need to invert one scale\n\t\t\t\tvar det = this.determinant();\n\t\t\t\tif ( det < 0 ) {\n\t\n\t\t\t\t\tsx = - sx;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tposition.x = te[ 12 ];\n\t\t\t\tposition.y = te[ 13 ];\n\t\t\t\tposition.z = te[ 14 ];\n\t\n\t\t\t\t// scale the rotation part\n\t\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\t\n\t\t\t\tvar invSX = 1 / sx;\n\t\t\t\tvar invSY = 1 / sy;\n\t\t\t\tvar invSZ = 1 / sz;\n\t\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\n\t\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\n\t\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\t\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\t\n\t\t\t\tscale.x = sx;\n\t\t\t\tscale.y = sy;\n\t\t\t\tscale.z = sz;\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar x = 2 * near / ( right - left );\n\t\t\tvar y = 2 * near / ( top - bottom );\n\t\n\t\t\tvar a = ( right + left ) / ( right - left );\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\t\tvar c = - ( far + near ) / ( far - near );\n\t\t\tvar d = - 2 * far * near / ( far - near );\n\t\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\n\t\n\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\tvar ymin = - ymax;\n\t\t\tvar xmin = ymin * aspect;\n\t\t\tvar xmax = ymax * aspect;\n\t\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\t\n\t\t},\n\t\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar w = 1.0 / ( right - left );\n\t\t\tvar h = 1.0 / ( top - bottom );\n\t\t\tvar p = 1.0 / ( far - near );\n\t\n\t\t\tvar x = ( right + left ) * w;\n\t\t\tvar y = ( top + bottom ) * h;\n\t\t\tvar z = ( far + near ) * p;\n\t\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( matrix ) {\n\t\n\t\t\tvar te = this.elements;\n\t\t\tvar me = matrix.elements;\n\t\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\t\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tfromArray: function ( array ) {\n\t\n\t\t\tthis.elements.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoArray: function ( array, offset ) {\n\t\n\t\t\tif ( array === undefined ) array = [];\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar te = this.elements;\n\t\n\t\t\tarray[ offset ] = te[ 0 ];\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\n\t\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\n\t\n\t\t\treturn array;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Ray.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Ray = function ( origin, direction ) {\n\t\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Ray.prototype = {\n\t\n\t\tconstructor: THREE.Ray,\n\t\n\t\tset: function ( origin, direction ) {\n\t\n\t\t\tthis.origin.copy( origin );\n\t\t\tthis.direction.copy( direction );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( ray ) {\n\t\n\t\t\tthis.origin.copy( ray.origin );\n\t\t\tthis.direction.copy( ray.direction );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tat: function ( t, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\t\n\t\t},\n\t\n\t\tlookAt: function ( v ) {\n\t\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trecast: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function recast( t ) {\n\t\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tresult.subVectors( point, this.origin );\n\t\t\tvar directionDistance = result.dot( this.direction );\n\t\n\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\treturn result.copy( this.origin );\n\t\n\t\t\t}\n\t\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\t\n\t\t},\n\t\n\t\tdistanceSqToPoint: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function distanceSqToPoint( point ) {\n\t\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\t\n\t\t\t\t// point behind the ray\n\t\n\t\t\t\tif ( directionDistance < 0 ) {\n\t\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\t\n\t\t\t\treturn v1.distanceToSquared( point );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tdistanceSqToSegment: function () {\n\t\n\t\t\tvar segCenter = new THREE.Vector3();\n\t\t\tvar segDir = new THREE.Vector3();\n\t\t\tvar diff = new THREE.Vector3();\n\t\n\t\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\t\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t\t// defined by v0 and v1\n\t\t\t\t// It can also set two optional targets :\n\t\t\t\t// - The closest point on the ray\n\t\t\t\t// - The closest point on the segment\n\t\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\t\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\t\tvar c = diff.lengthSq();\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\t\tvar s0, s1, sqrDist, extDet;\n\t\n\t\t\t\tif ( det > 0 ) {\n\t\n\t\t\t\t\t// The ray and segment are not parallel.\n\t\n\t\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\t\textDet = segExtent * det;\n\t\n\t\t\t\t\tif ( s0 >= 0 ) {\n\t\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\n\t\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t// region 1\n\t\n\t\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// region 5\n\t\n\t\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\n\t\n\t\t\t\t\t\t\t// region 4\n\t\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\n\t\n\t\t\t\t\t\t\t// region 3\n\t\n\t\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// region 2\n\t\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Ray and segment are parallel.\n\t\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( optionalPointOnRay ) {\n\t\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( optionalPointOnSegment ) {\n\t\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn sqrDist;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectSphere: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\t\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\t\tvar tca = v1.dot( this.direction );\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\t\n\t\t\t\tif ( d2 > radius2 ) return null;\n\t\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\t\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\t\tvar t0 = tca - thc;\n\t\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\t\tvar t1 = tca + thc;\n\t\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\t\n\t\t\t\t// test to see if t0 is behind the ray:\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\t\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\t\treturn this.at( t0, optionalTarget );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\t\n\t\t},\n\t\n\t\tdistanceToPlane: function ( plane ) {\n\t\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\t\n\t\t\t\t\treturn 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\t\n\t\t\t// Return if the ray never intersects the plane\n\t\n\t\t\treturn t >= 0 ? t :  null;\n\t\n\t\t},\n\t\n\t\tintersectPlane: function ( plane, optionalTarget ) {\n\t\n\t\t\tvar t = this.distanceToPlane( plane );\n\t\n\t\t\tif ( t === null ) {\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.at( t, optionalTarget );\n\t\n\t\t},\n\t\n\t\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// check if the ray lies on the plane first\n\t\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\t\n\t\t\tif ( distToPoint === 0 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\tvar denominator = plane.normal.dot( this.direction );\n\t\n\t\t\tif ( denominator * distToPoint < 0 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tintersectBox: function ( box, optionalTarget ) {\n\t\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\n\t\t\tvar invdirx = 1 / this.direction.x,\n\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\n\t\t\tvar origin = this.origin;\n\t\n\t\t\tif ( invdirx >= 0 ) {\n\t\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\t\n\t\t\t}\n\t\n\t\t\tif ( invdiry >= 0 ) {\n\t\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\t\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\t\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\t\n\t\t\tif ( invdirz >= 0 ) {\n\t\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\t\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\t\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\t\n\t\t\t//return point closest to the ray (positive side)\n\t\n\t\t\tif ( tmax < 0 ) return null;\n\t\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\t\n\t\t},\n\t\n\t\tintersectsBox: ( function () {\n\t\n\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tintersectTriangle: function () {\n\t\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\tvar diff = new THREE.Vector3();\n\t\t\tvar edge1 = new THREE.Vector3();\n\t\t\tvar edge2 = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\t\n\t\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\t\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\n\t\t\t\tedge1.subVectors( b, a );\n\t\t\t\tedge2.subVectors( c, a );\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\n\t\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\t\tvar sign;\n\t\n\t\t\t\tif ( DdN > 0 ) {\n\t\n\t\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\t\tsign = 1;\n\t\n\t\t\t\t} else if ( DdN < 0 ) {\n\t\n\t\t\t\t\tsign = - 1;\n\t\t\t\t\tDdN = - DdN;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdiff.subVectors( this.origin, a );\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\t\n\t\t\t\t// b1 < 0, no intersection\n\t\t\t\tif ( DdQxE2 < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\t\n\t\t\t\t// b2 < 0, no intersection\n\t\t\t\tif ( DdE1xQ < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// b1+b2 > 1, no intersection\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Line intersects triangle, check if ray does.\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\n\t\n\t\t\t\t// t < 0, no intersection\n\t\t\t\tif ( QdN < 0 ) {\n\t\n\t\t\t\t\treturn null;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Ray intersects triangle.\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tapplyMatrix4: function ( matrix4 ) {\n\t\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\t\tthis.origin.applyMatrix4( matrix4 );\n\t\t\tthis.direction.sub( this.origin );\n\t\t\tthis.direction.normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( ray ) {\n\t\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Sphere.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Sphere = function ( center, radius ) {\n\t\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\t\n\t};\n\t\n\tTHREE.Sphere.prototype = {\n\t\n\t\tconstructor: THREE.Sphere,\n\t\n\t\tset: function ( center, radius ) {\n\t\n\t\t\tthis.center.copy( center );\n\t\t\tthis.radius = radius;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPoints: function () {\n\t\n\t\t\tvar box = new THREE.Box3();\n\t\n\t\t\treturn function setFromPoints( points, optionalCenter ) {\n\t\n\t\t\t\tvar center = this.center;\n\t\n\t\t\t\tif ( optionalCenter !== undefined ) {\n\t\n\t\t\t\t\tcenter.copy( optionalCenter );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( sphere ) {\n\t\n\t\t\tthis.center.copy( sphere.center );\n\t\t\tthis.radius = sphere.radius;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tempty: function () {\n\t\n\t\t\treturn ( this.radius <= 0 );\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\t\n\t\t},\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\tvar radiusSum = this.radius + sphere.radius;\n\t\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\treturn box.intersectsSphere( this );\n\t\n\t\t},\n\t\n\t\tintersectsPlane: function ( plane ) {\n\t\n\t\t\t// We use the following equation to compute the signed distance from\n\t\t\t// the center of the sphere to the plane.\n\t\t\t//\n\t\t\t// distance = q * n - d\n\t\t\t//\n\t\t\t// If this distance is greater than the radius of the sphere,\n\t\t\t// then there is no intersection.\n\t\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\t\n\t\t},\n\t\n\t\tclampPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tresult.copy( point );\n\t\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\t\n\t\t\t\tresult.sub( this.center ).normalize();\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\tgetBoundingBox: function ( optionalTarget ) {\n\t\n\t\t\tvar box = optionalTarget || new THREE.Box3();\n\t\n\t\t\tbox.set( this.center, this.center );\n\t\t\tbox.expandByScalar( this.radius );\n\t\n\t\t\treturn box;\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function ( matrix ) {\n\t\n\t\t\tthis.center.applyMatrix4( matrix );\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.center.add( offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( sphere ) {\n\t\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Frustum.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\tthis.planes = [\n\t\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\t\n\t\t];\n\t\n\t};\n\t\n\tTHREE.Frustum.prototype = {\n\t\n\t\tconstructor: THREE.Frustum,\n\t\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tplanes[ 0 ].copy( p0 );\n\t\t\tplanes[ 1 ].copy( p1 );\n\t\t\tplanes[ 2 ].copy( p2 );\n\t\t\tplanes[ 3 ].copy( p3 );\n\t\t\tplanes[ 4 ].copy( p4 );\n\t\t\tplanes[ 5 ].copy( p5 );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( frustum ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromMatrix: function ( m ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\t\tvar me = m.elements;\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\t\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tintersectsObject: function () {\n\t\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function intersectsObject( object ) {\n\t\n\t\t\t\tvar geometry = object.geometry;\n\t\n\t\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSprite: function () {\n\t\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function intersectsSprite( sprite ) {\n\t\n\t\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\t\treturn this.intersectsSphere( sphere );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\t\tvar center = sphere.center;\n\t\t\tvar negRadius = - sphere.radius;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\t\n\t\t\t\tif ( distance < negRadius ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t},\n\t\n\t\tintersectsBox: function () {\n\t\n\t\t\tvar p1 = new THREE.Vector3(),\n\t\t\t\tp2 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectsBox( box ) {\n\t\n\t\t\t\tvar planes = this.planes;\n\t\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\n\t\t\t\t\tvar plane = planes[ i ];\n\t\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\t\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\n\t\t\t\t\t// if both outside plane, no intersection\n\t\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\n\t\t\t\t\t\treturn false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\tvar planes = this.planes;\n\t\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Plane.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Plane = function ( normal, constant ) {\n\t\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\t\n\t};\n\t\n\tTHREE.Plane.prototype = {\n\t\n\t\tconstructor: THREE.Plane,\n\t\n\t\tset: function ( normal, constant ) {\n\t\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = constant;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetComponents: function ( x, y, z, w ) {\n\t\n\t\t\tthis.normal.set( x, y, z );\n\t\t\tthis.constant = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\t\n\t\t\tthis.normal.copy( normal );\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromCoplanarPoints: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar v2 = new THREE.Vector3();\n\t\n\t\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\t\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\t\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\t\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( plane ) {\n\t\n\t\t\tthis.normal.copy( plane.normal );\n\t\t\tthis.constant = plane.constant;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\t\tthis.constant *= inverseNormalLength;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnegate: function () {\n\t\n\t\t\tthis.constant *= - 1;\n\t\t\tthis.normal.negate();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdistanceToPoint: function ( point ) {\n\t\n\t\t\treturn this.normal.dot( point ) + this.constant;\n\t\n\t\t},\n\t\n\t\tdistanceToSphere: function ( sphere ) {\n\t\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\t\n\t\t},\n\t\n\t\tprojectPoint: function ( point, optionalTarget ) {\n\t\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\t\n\t\t},\n\t\n\t\torthoPoint: function ( point, optionalTarget ) {\n\t\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\t\n\t\t},\n\t\n\t\tintersectLine: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function intersectLine( line, optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tvar direction = line.delta( v1 );\n\t\n\t\t\t\tvar denominator = this.normal.dot( direction );\n\t\n\t\t\t\tif ( denominator === 0 ) {\n\t\n\t\t\t\t\t// line is coplanar, return origin\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\t\n\t\t\t\t\t\treturn result.copy( line.start );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\t\n\t\t\t\tif ( t < 0 || t > 1 ) {\n\t\n\t\t\t\t\treturn undefined;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tintersectsLine: function ( line ) {\n\t\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\n\t\t\tvar startSign = this.distanceToPoint( line.start );\n\t\t\tvar endSign = this.distanceToPoint( line.end );\n\t\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\t\n\t\t},\n\t\n\t\tintersectsBox: function ( box ) {\n\t\n\t\t\treturn box.intersectsPlane( this );\n\t\n\t\t},\n\t\n\t\tintersectsSphere: function ( sphere ) {\n\t\n\t\t\treturn sphere.intersectsPlane( this );\n\t\n\t\t},\n\t\n\t\tcoplanarPoint: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\t\n\t\t},\n\t\n\t\tapplyMatrix4: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar m1 = new THREE.Matrix3();\n\t\n\t\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\t\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\t\n\t\t\t\t// transform normal based on theory here:\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function ( offset ) {\n\t\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tequals: function ( plane ) {\n\t\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Spherical.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\t\n\tTHREE.Spherical = function ( radius, phi, theta ) {\n\t\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\tTHREE.Spherical.prototype = {\n\t\n\t\tconstructor: THREE.Spherical,\n\t\n\t\tset: function ( radius, phi, theta ) {\n\t\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( other ) {\n\t\n\t\t\tthis.radius.copy( other.radius );\n\t\t\tthis.phi.copy( other.phi );\n\t\t\tthis.theta.copy( other.theta );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\tmakeSafe: function() {\n\t\n\t\t\tvar EPS = 0.000001;\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromVector3: function( vec3 ) {\n\t\n\t\t\tthis.radius = vec3.length();\n\t\n\t\t\tif ( this.radius === 0 ) {\n\t\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t};\n\t\n\t// File:src/math/Math.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Math = {\n\t\n\t\tDEG2RAD: Math.PI / 180,\n\t\tRAD2DEG: 180 / Math.PI,\n\t\n\t\tgenerateUUID: function () {\n\t\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\t\tvar uuid = new Array( 36 );\n\t\t\tvar rnd = 0, r;\n\t\n\t\t\treturn function generateUUID() {\n\t\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\t\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\t\n\t\t\t\t\t\tuuid[ i ] = '-';\n\t\n\t\t\t\t\t} else if ( i === 14 ) {\n\t\n\t\t\t\t\t\tuuid[ i ] = '4';\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn uuid.join( '' );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tclamp: function ( value, min, max ) {\n\t\n\t\t\treturn Math.max( min, Math.min( max, value ) );\n\t\n\t\t},\n\t\n\t\t// compute euclidian modulo of m % n\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\n\t\n\t\teuclideanModulo: function ( n, m ) {\n\t\n\t\t\treturn ( ( n % m ) + m ) % m;\n\t\n\t\t},\n\t\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\t\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\t\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\t\n\t\t},\n\t\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\n\t\n\t\tsmoothstep: function ( x, min, max ) {\n\t\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\treturn x * x * ( 3 - 2 * x );\n\t\n\t\t},\n\t\n\t\tsmootherstep: function ( x, min, max ) {\n\t\n\t\t\tif ( x <= min ) return 0;\n\t\t\tif ( x >= max ) return 1;\n\t\n\t\t\tx = ( x - min ) / ( max - min );\n\t\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\t\n\t\t},\n\t\n\t\trandom16: function () {\n\t\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\t\treturn Math.random();\n\t\n\t\t},\n\t\n\t\t// Random integer from <low, high> interval\n\t\n\t\trandInt: function ( low, high ) {\n\t\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\t\n\t\t},\n\t\n\t\t// Random float from <low, high> interval\n\t\n\t\trandFloat: function ( low, high ) {\n\t\n\t\t\treturn low + Math.random() * ( high - low );\n\t\n\t\t},\n\t\n\t\t// Random float from <-range/2, range/2> interval\n\t\n\t\trandFloatSpread: function ( range ) {\n\t\n\t\t\treturn range * ( 0.5 - Math.random() );\n\t\n\t\t},\n\t\n\t\tdegToRad: function ( degrees ) {\n\t\n\t\t\treturn degrees * THREE.Math.DEG2RAD;\n\t\n\t\t},\n\t\n\t\tradToDeg: function ( radians ) {\n\t\n\t\t\treturn radians * THREE.Math.RAD2DEG;\n\t\n\t\t},\n\t\n\t\tisPowerOfTwo: function ( value ) {\n\t\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\t\n\t\t},\n\t\n\t\tnearestPowerOfTwo: function ( value ) {\n\t\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\t\n\t\t},\n\t\n\t\tnextPowerOfTwo: function ( value ) {\n\t\n\t\t\tvalue --;\n\t\t\tvalue |= value >> 1;\n\t\t\tvalue |= value >> 2;\n\t\t\tvalue |= value >> 4;\n\t\t\tvalue |= value >> 8;\n\t\t\tvalue |= value >> 16;\n\t\t\tvalue ++;\n\t\n\t\t\treturn value;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Spline.js\n\t\n\t/**\n\t * Spline from Tween.js, slightly optimized (and trashed)\n\t * http://sole.github.com/tween.js/examples/05_spline.html\n\t *\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Spline = function ( points ) {\n\t\n\t\tthis.points = points;\n\t\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\t\tpoint, intPoint, weight, w2, w3,\n\t\tpa, pb, pc, pd;\n\t\n\t\tthis.initFromArray = function ( a ) {\n\t\n\t\t\tthis.points = [];\n\t\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\t\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getPoint = function ( k ) {\n\t\n\t\t\tpoint = ( this.points.length - 1 ) * k;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\t\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\t\tc[ 1 ] = intPoint;\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\t\n\t\t\tpa = this.points[ c[ 0 ] ];\n\t\t\tpb = this.points[ c[ 1 ] ];\n\t\t\tpc = this.points[ c[ 2 ] ];\n\t\t\tpd = this.points[ c[ 3 ] ];\n\t\n\t\t\tw2 = weight * weight;\n\t\t\tw3 = weight * w2;\n\t\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\t\n\t\t\treturn v3;\n\t\n\t\t};\n\t\n\t\tthis.getControlPointsArray = function () {\n\t\n\t\t\tvar i, p, l = this.points.length,\n\t\t\t\tcoords = [];\n\t\n\t\t\tfor ( i = 0; i < l; i ++ ) {\n\t\n\t\t\t\tp = this.points[ i ];\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\t\n\t\t\t}\n\t\n\t\t\treturn coords;\n\t\n\t\t};\n\t\n\t\t// approximate length by summing linear segments\n\t\n\t\tthis.getLength = function ( nSubDivisions ) {\n\t\n\t\t\tvar i, index, nSamples, position,\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\t\toldPosition = new THREE.Vector3(),\n\t\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\t\tchunkLengths = [],\n\t\t\t\ttotalLength = 0;\n\t\n\t\t\t// first point has 0 length\n\t\n\t\t\tchunkLengths[ 0 ] = 0;\n\t\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\t\n\t\t\tnSamples = this.points.length * nSubDivisions;\n\t\n\t\t\toldPosition.copy( this.points[ 0 ] );\n\t\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\t\n\t\t\t\tindex = i / nSamples;\n\t\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\ttmpVec.copy( position );\n\t\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\t\n\t\t\t\toldPosition.copy( position );\n\t\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\t\tintPoint = Math.floor( point );\n\t\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\n\t\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\t\toldIntPoint = intPoint;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// last point ends with total length\n\t\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\t\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\n\t\n\t\t};\n\t\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\t\n\t\t\tvar i, j,\n\t\t\t\tindex, indexCurrent, indexNext,\n\t\t\t\trealDistance,\n\t\t\t\tsampling, position,\n\t\t\t\tnewpoints = [],\n\t\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\t\tsl = this.getLength();\n\t\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\t\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\t\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\t\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\t\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\t\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\n\t\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\t\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\t\n\t\t\t\t\tposition = this.getPoint( index );\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\t\n\t\t\t}\n\t\n\t\t\tthis.points = newpoints;\n\t\n\t\t};\n\t\n\t\t// Catmull-Rom\n\t\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\t\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\t\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Triangle.js\n\t\n\t/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Triangle = function ( a, b, c ) {\n\t\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\t\n\t};\n\t\n\tTHREE.Triangle.normal = function () {\n\t\n\t\tvar v0 = new THREE.Vector3();\n\t\n\t\treturn function normal( a, b, c, optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tresult.subVectors( c, b );\n\t\t\tv0.subVectors( a, b );\n\t\t\tresult.cross( v0 );\n\t\n\t\t\tvar resultLengthSq = result.lengthSq();\n\t\t\tif ( resultLengthSq > 0 ) {\n\t\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn result.set( 0, 0, 0 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tTHREE.Triangle.barycoordFromPoint = function () {\n\t\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\n\t\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\t\n\t\t\tv0.subVectors( c, a );\n\t\t\tv1.subVectors( b, a );\n\t\t\tv2.subVectors( point, a );\n\t\n\t\t\tvar dot00 = v0.dot( v0 );\n\t\t\tvar dot01 = v0.dot( v1 );\n\t\t\tvar dot02 = v0.dot( v2 );\n\t\t\tvar dot11 = v1.dot( v1 );\n\t\t\tvar dot12 = v1.dot( v2 );\n\t\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t// collinear or singular triangle\n\t\t\tif ( denom === 0 ) {\n\t\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvar invDenom = 1 / denom;\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\t\n\t\t\t// barycentric coordinates must always sum to 1\n\t\t\treturn result.set( 1 - u - v, v, u );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Triangle.containsPoint = function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\n\t\treturn function containsPoint( point, a, b, c ) {\n\t\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\t\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Triangle.prototype = {\n\t\n\t\tconstructor: THREE.Triangle,\n\t\n\t\tset: function ( a, b, c ) {\n\t\n\t\t\tthis.a.copy( a );\n\t\t\tthis.b.copy( b );\n\t\t\tthis.c.copy( c );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\t\n\t\t\tthis.a.copy( points[ i0 ] );\n\t\t\tthis.b.copy( points[ i1 ] );\n\t\t\tthis.c.copy( points[ i2 ] );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( triangle ) {\n\t\n\t\t\tthis.a.copy( triangle.a );\n\t\t\tthis.b.copy( triangle.b );\n\t\t\tthis.c.copy( triangle.c );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tarea: function () {\n\t\n\t\t\tvar v0 = new THREE.Vector3();\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function area() {\n\t\n\t\t\t\tv0.subVectors( this.c, this.b );\n\t\t\t\tv1.subVectors( this.a, this.b );\n\t\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tmidpoint: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\t\n\t\t},\n\t\n\t\tnormal: function ( optionalTarget ) {\n\t\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\t\n\t\t},\n\t\n\t\tplane: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Plane();\n\t\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\n\t\t},\n\t\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\t\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\t\n\t\t},\n\t\n\t\tcontainsPoint: function ( point ) {\n\t\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\t\n\t\t},\n\t\n\t\tclosestPointToPoint: function () {\n\t\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\t\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\t\n\t\t\t\tif ( plane === undefined ) {\n\t\n\t\t\t\t\tplane = new THREE.Plane();\n\t\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\t\tclosestPoint = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\t\tvar minDistance = Infinity;\n\t\n\t\t\t\t// project the point onto the plane of the triangle\n\t\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\t\tplane.projectPoint( point, projectedPoint );\n\t\n\t\t\t\t// check if the projection lies within the triangle\n\t\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\t\n\t\t\t\t\t// if so, this is the closest point\n\t\n\t\t\t\t\tresult.copy( projectedPoint );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\t\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\t\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\t\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\t\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\t\n\t\t\t\t\t\tif( distance < minDistance ) {\n\t\n\t\t\t\t\t\t\tminDistance = distance;\n\t\n\t\t\t\t\t\t\tresult.copy( closestPoint );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tequals: function ( triangle ) {\n\t\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/math/Interpolant.js\n\t\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.Interpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\t\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\t\n\t};\n\t\n\tTHREE.Interpolant.prototype = {\n\t\n\t\tconstructor: THREE.Interpolant,\n\t\n\t\tevaluate: function( t ) {\n\t\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\ti1 = this._cachedIndex,\n\t\n\t\t\t\tt1 = pp[   i1   ],\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\tvalidate_interval: {\n\t\n\t\t\t\tseek: {\n\t\n\t\t\t\t\tvar right;\n\t\n\t\t\t\t\tlinear_scan: {\n\t//- See http://jsperf.com/comparison-to-undefined/3\n\t//- slower code:\n\t//-\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\t\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\t\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\t\n\t\t\t\t\t\t\t\t\t// after end\n\t\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\n\t\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t}\n\t\n\t//- slower code:\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\t\n\t\t\t\t\t\t\t// looping?\n\t\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\t\n\t\t\t\t\t\t\tif ( t < t1global ) {\n\t\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\t\tt0 = t1global;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// linear reverse scan\n\t\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\t\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\t// before start\n\t\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\t\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\n\t\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// the interval is valid\n\t\n\t\t\t\t\t\tbreak validate_interval;\n\t\n\t\t\t\t\t} // linear scan\n\t\n\t\t\t\t\t// binary search\n\t\n\t\t\t\t\twhile ( i1 < right ) {\n\t\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\t\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\n\t\n\t\t\t\t\t\t\tright = mid;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\ti1 = mid + 1;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\n\t\n\t\t\t\t\t// check boundary cases, again\n\t\n\t\t\t\t\tif ( t0 === undefined ) {\n\t\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( t1 === undefined ) {\n\t\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} // seek\n\t\n\t\t\t\tthis._cachedIndex = i1;\n\t\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\t\n\t\t\t} // validate_interval\n\t\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\n\t\n\t\t},\n\t\n\t\tsettings: null, // optional, subclass-specific settings structure\n\t\t// Note: The indirection allows central control of many interpolants.\n\t\n\t\t// --- Protected interface\n\t\n\t\tDefaultSettings_: {},\n\t\n\t\tgetSettings_: function() {\n\t\n\t\t\treturn this.settings || this.DefaultSettings_;\n\t\n\t\t},\n\t\n\t\tcopySampleValue_: function( index ) {\n\t\n\t\t\t// copies a sample value to the result buffer\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = index * stride;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// Template methods for derived classes:\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tthrow new Error( \"call to abstract method\" );\n\t\t\t// implementations shall return this.resultBuffer\n\t\n\t\t},\n\t\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\t// empty\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Interpolant.prototype, {\n\t\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\t\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/CubicInterpolant.js\n\t\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.CubicInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t\tthis._weightPrev = -0;\n\t\tthis._offsetPrev = -0;\n\t\tthis._weightNext = -0;\n\t\tthis._offsetNext = -0;\n\t\n\t};\n\t\n\tTHREE.CubicInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.CubicInterpolant,\n\t\n\t\tDefaultSettings_: {\n\t\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t\n\t\t},\n\t\n\t\tintervalChanged_: function( i1, t0, t1 ) {\n\t\n\t\t\tvar pp = this.parameterPositions,\n\t\t\t\tiPrev = i1 - 2,\n\t\t\t\tiNext = i1 + 1,\n\t\n\t\t\t\ttPrev = pp[ iPrev ],\n\t\t\t\ttNext = pp[ iNext ];\n\t\n\t\t\tif ( tPrev === undefined ) {\n\t\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\n\t\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.WrapAroundEnding:\n\t\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( tNext === undefined ) {\n\t\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\t\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\n\t\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.WrapAroundEnding:\n\t\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\n\t\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\t\tstride = this.valueSize;\n\t\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\t\n\t\t},\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\t\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tpp = p * p,\n\t\t\t\tppp = pp * p;\n\t\n\t\t\t// evaluate polynomials\n\t\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\t\n\t\t\t// combine data linearly\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\t\tsN * values[ oN + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/DiscreteInterpolant.js\n\t\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.DiscreteInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.DiscreteInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.DiscreteInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\treturn this.copySampleValue_( i1 - 1 );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/LinearInterpolant.js\n\t\n\t/**\n\t * @author tschw\n\t */\n\t\n\tTHREE.LinearInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.LinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.LinearInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toffset1 = i1 * stride,\n\t\t\t\toffset0 = offset1 - stride,\n\t\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\t\tweight0 = 1 - weight1;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tresult[ i ] =\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\t\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.QuaternionLinearInterpolant = function(\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\t\n\t\tTHREE.Interpolant.call(\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\t\n\t};\n\t\n\tTHREE.QuaternionLinearInterpolant.prototype =\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\t\n\t\tconstructor: THREE.QuaternionLinearInterpolant,\n\t\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\n\t\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toffset = i1 * stride,\n\t\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\t\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\t\n\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/Clock.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Clock = function ( autoStart ) {\n\t\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\t\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\t\n\t\tthis.running = false;\n\t\n\t};\n\t\n\tTHREE.Clock.prototype = {\n\t\n\t\tconstructor: THREE.Clock,\n\t\n\t\tstart: function () {\n\t\n\t\t\tthis.startTime = ( performance || Date ).now();\n\t\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.running = true;\n\t\n\t\t},\n\t\n\t\tstop: function () {\n\t\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\n\t\t},\n\t\n\t\tgetElapsedTime: function () {\n\t\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\t\n\t\t},\n\t\n\t\tgetDelta: function () {\n\t\n\t\t\tvar diff = 0;\n\t\n\t\t\tif ( this.autoStart && ! this.running ) {\n\t\n\t\t\t\tthis.start();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.running ) {\n\t\n\t\t\t\tvar newTime = ( performance || Date ).now();\n\t\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\t\n\t\t\t\tthis.elapsedTime += diff;\n\t\n\t\t\t}\n\t\n\t\t\treturn diff;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/EventDispatcher.js\n\t\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\t\n\tTHREE.EventDispatcher = function () {};\n\t\n\tObject.assign( THREE.EventDispatcher.prototype, {\n\t\n\t\taddEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\n\t\n\t\t\tvar listeners = this._listeners;\n\t\n\t\t\tif ( listeners[ type ] === undefined ) {\n\t\n\t\t\t\tlisteners[ type ] = [];\n\t\n\t\t\t}\n\t\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\t\n\t\t\t\tlisteners[ type ].push( listener );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\thasEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return false;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t},\n\t\n\t\tremoveEventListener: function ( type, listener ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ type ];\n\t\n\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\tvar index = listenerArray.indexOf( listener );\n\t\n\t\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\t\tlistenerArray.splice( index, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tdispatchEvent: function ( event ) {\n\t\n\t\t\tif ( this._listeners === undefined ) return;\n\t\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\t\n\t\t\tif ( listenerArray !== undefined ) {\n\t\n\t\t\t\tevent.target = this;\n\t\n\t\t\t\tvar array = [], i = 0;\n\t\t\t\tvar length = listenerArray.length;\n\t\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\n\t\n\t\t\t\t\tarray[ i ].call( this, event );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/Layers.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Layers = function () {\n\t\n\t\tthis.mask = 1;\n\t\n\t};\n\t\n\tTHREE.Layers.prototype = {\n\t\n\t\tconstructor: THREE.Layers,\n\t\n\t\tset: function ( channel ) {\n\t\n\t\t\tthis.mask = 1 << channel;\n\t\n\t\t},\n\t\n\t\tenable: function ( channel ) {\n\t\n\t\t\tthis.mask |= 1 << channel;\n\t\n\t\t},\n\t\n\t\ttoggle: function ( channel ) {\n\t\n\t\t\tthis.mask ^= 1 << channel;\n\t\n\t\t},\n\t\n\t\tdisable: function ( channel ) {\n\t\n\t\t\tthis.mask &= ~ ( 1 << channel );\n\t\n\t\t},\n\t\n\t\ttest: function ( layers ) {\n\t\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/Raycaster.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\t\n\t( function ( THREE ) {\n\t\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\t\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\tthis.near = near || 0;\n\t\t\tthis.far = far || Infinity;\n\t\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: { threshold: 1 },\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\n\t\t\tObject.defineProperties( this.params, {\n\t\t\t\tPointCloud: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\t\treturn this.Points;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\n\t\t};\n\t\n\t\tfunction ascSort( a, b ) {\n\t\n\t\t\treturn a.distance - b.distance;\n\t\n\t\t}\n\t\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tobject.raycast( raycaster, intersects );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tvar children = object.children;\n\t\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tTHREE.Raycaster.prototype = {\n\t\n\t\t\tconstructor: THREE.Raycaster,\n\t\n\t\t\tlinePrecision: 1,\n\t\n\t\t\tset: function ( origin, direction ) {\n\t\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\n\t\t\t\tthis.ray.set( origin, direction );\n\t\n\t\t\t},\n\t\n\t\t\tsetFromCamera: function ( coords, camera ) {\n\t\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tintersectObject: function ( object, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tintersectObject( object, this, intersects, recursive );\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t},\n\t\n\t\t\tintersectObjects: function ( objects, recursive ) {\n\t\n\t\t\t\tvar intersects = [];\n\t\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\t\treturn intersects;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.sort( ascSort );\n\t\n\t\t\t\treturn intersects;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t}( THREE ) );\n\t\n\t// File:src/core/Object3D.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\t\n\tTHREE.Object3D = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\t\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\n\t\n\t\tvar position = new THREE.Vector3();\n\t\tvar rotation = new THREE.Euler();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\t\n\t\tfunction onRotationChange() {\n\t\n\t\t\tquaternion.setFromEuler( rotation, false );\n\t\n\t\t}\n\t\n\t\tfunction onQuaternionChange() {\n\t\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\t\n\t\t}\n\t\n\t\trotation.onChange( onRotationChange );\n\t\tquaternion.onChange( onQuaternionChange );\n\t\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new THREE.Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new THREE.Matrix3()\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.matrix = new THREE.Matrix4();\n\t\tthis.matrixWorld = new THREE.Matrix4();\n\t\n\t\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\tthis.layers = new THREE.Layers();\n\t\tthis.visible = true;\n\t\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\t\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\t\n\t\tthis.userData = {};\n\t\n\t};\n\t\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\n\tTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\t\n\tObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\t\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\n\t\t},\n\t\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\t\n\t\t\t// assumes axis is normalized\n\t\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\t\n\t\t},\n\t\n\t\tsetRotationFromEuler: function ( euler ) {\n\t\n\t\t\tthis.quaternion.setFromEuler( euler, true );\n\t\n\t\t},\n\t\n\t\tsetRotationFromMatrix: function ( m ) {\n\t\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\n\t\n\t\t},\n\t\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\n\t\t\t// assumes q is normalized\n\t\n\t\t\tthis.quaternion.copy( q );\n\t\n\t\t},\n\t\n\t\trotateOnAxis: function () {\n\t\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\n\t\t\tvar q1 = new THREE.Quaternion();\n\t\n\t\t\treturn function rotateOnAxis( axis, angle ) {\n\t\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\n\t\n\t\t\t\tthis.quaternion.multiply( q1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateX: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateOnAxis: function () {\n\t\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\n\t\t\treturn function translateOnAxis( axis, distance ) {\n\t\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\t\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateX: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\t\n\t\t\treturn function translateX( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateY: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\t\n\t\t\treturn function translateY( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslateZ: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\t\n\t\t\treturn function translateZ( distance ) {\n\t\n\t\t\t\treturn this.translateOnAxis( v1, distance );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlocalToWorld: function ( vector ) {\n\t\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\n\t\n\t\t},\n\t\n\t\tworldToLocal: function () {\n\t\n\t\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\t\treturn function worldToLocal( vector ) {\n\t\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\t\n\t\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\n\t\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tadd: function ( object ) {\n\t\n\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\tthis.add( arguments[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tif ( object === this ) {\n\t\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tif ( object instanceof THREE.Object3D ) {\n\t\n\t\t\t\tif ( object.parent !== null ) {\n\t\n\t\t\t\t\tobject.parent.remove( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.parent = this;\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\n\t\n\t\t\t\tthis.children.push( object );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tremove: function ( object ) {\n\t\n\t\t\tif ( arguments.length > 1 ) {\n\t\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\t\n\t\t\t\t\tthis.remove( arguments[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar index = this.children.indexOf( object );\n\t\n\t\t\tif ( index !== - 1 ) {\n\t\n\t\t\t\tobject.parent = null;\n\t\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\t\n\t\t\t\tthis.children.splice( index, 1 );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetObjectById: function ( id ) {\n\t\n\t\t\treturn this.getObjectByProperty( 'id', id );\n\t\n\t\t},\n\t\n\t\tgetObjectByName: function ( name ) {\n\t\n\t\t\treturn this.getObjectByProperty( 'name', name );\n\t\n\t\t},\n\t\n\t\tgetObjectByProperty: function ( name, value ) {\n\t\n\t\t\tif ( this[ name ] === value ) return this;\n\t\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\n\t\n\t\t\t\tif ( object !== undefined ) {\n\t\n\t\t\t\t\treturn object;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn undefined;\n\t\n\t\t},\n\t\n\t\tgetWorldPosition: function ( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t},\n\t\n\t\tgetWorldQuaternion: function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\n\t\t\treturn function getWorldQuaternion( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldRotation: function () {\n\t\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldRotation( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldScale: function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldScale( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\t\n\t\t\t\treturn result;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tgetWorldDirection: function () {\n\t\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\traycast: function () {},\n\t\n\t\ttraverse: function ( callback ) {\n\t\n\t\t\tcallback( this );\n\t\n\t\t\tvar children = this.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tchildren[ i ].traverse( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttraverseVisible: function ( callback ) {\n\t\n\t\t\tif ( this.visible === false ) return;\n\t\n\t\t\tcallback( this );\n\t\n\t\t\tvar children = this.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tchildren[ i ].traverseVisible( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttraverseAncestors: function ( callback ) {\n\t\n\t\t\tvar parent = this.parent;\n\t\n\t\t\tif ( parent !== null ) {\n\t\n\t\t\t\tcallback( parent );\n\t\n\t\t\t\tparent.traverseAncestors( callback );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdateMatrix: function () {\n\t\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\t\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: function ( force ) {\n\t\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\t\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\t\n\t\t\t\tif ( this.parent === null ) {\n\t\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\n\t\t\t\tforce = true;\n\t\n\t\t\t}\n\t\n\t\t\t// update children\n\t\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\t// meta is '' when called from JSON.stringify\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\t\n\t\t\tvar output = {};\n\t\n\t\t\t// meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// standard Object3D serialization\n\t\n\t\t\tvar object = {};\n\t\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\t\n\t\t\tif ( this.name !== '' ) object.name = this.name;\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\t\tif ( this.visible === false ) object.visible = false;\n\t\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\n\t\t\t//\n\t\n\t\t\tif ( this.geometry !== undefined ) {\n\t\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.geometry = this.geometry.uuid;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.material !== undefined ) {\n\t\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.material = this.material.uuid;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( this.children.length > 0 ) {\n\t\n\t\t\t\tobject.children = [];\n\t\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\t\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( isRootObject ) {\n\t\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\t\tif ( images.length > 0 ) output.images = images;\n\t\n\t\t\t}\n\t\n\t\t\toutput.object = object;\n\t\n\t\t\treturn output;\n\t\n\t\t\t// extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\t\t\tfunction extractFromCache ( cache ) {\n\t\n\t\t\t\tvar values = [];\n\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function ( recursive ) {\n\t\n\t\t\treturn new this.constructor().copy( this, recursive );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source, recursive ) {\n\t\n\t\t\tif ( recursive === undefined ) recursive = true;\n\t\n\t\t\tthis.name = source.name;\n\t\n\t\t\tthis.up.copy( source.up );\n\t\n\t\t\tthis.position.copy( source.position );\n\t\t\tthis.quaternion.copy( source.quaternion );\n\t\t\tthis.scale.copy( source.scale );\n\t\n\t\t\tthis.matrix.copy( source.matrix );\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\n\t\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\n\t\t\tthis.visible = source.visible;\n\t\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\t\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\t\n\t\t\tif ( recursive === true ) {\n\t\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\t\n\t\t\t\t\tvar child = source.children[ i ];\n\t\t\t\t\tthis.add( child.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.Object3DIdCount = 0;\n\t\n\t// File:src/core/Face3.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\t\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\t\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\t\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\t\n\t};\n\t\n\tTHREE.Face3.prototype = {\n\t\n\t\tconstructor: THREE.Face3,\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.a = source.a;\n\t\t\tthis.b = source.b;\n\t\t\tthis.c = source.c;\n\t\n\t\t\tthis.normal.copy( source.normal );\n\t\t\tthis.color.copy( source.color );\n\t\n\t\t\tthis.materialIndex = source.materialIndex;\n\t\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/BufferAttribute.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\tthis.version = 0;\n\t\tthis.normalized = normalized === true;\n\t\n\t};\n\t\n\tTHREE.BufferAttribute.prototype = {\n\t\n\t\tconstructor: THREE.BufferAttribute,\n\t\n\t\tget count() {\n\t\n\t\t\treturn this.array.length / this.itemSize;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tsetDynamic: function ( value ) {\n\t\n\t\t\tthis.dynamic = value;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.itemSize = source.itemSize;\n\t\n\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\t\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\t\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyArray: function ( array ) {\n\t\n\t\t\tthis.array.set( array );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyColorsArray: function ( colors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar color = colors[ i ];\n\t\n\t\t\t\tif ( color === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\t\tcolor = new THREE.Color();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = color.r;\n\t\t\t\tarray[ offset ++ ] = color.g;\n\t\t\t\tarray[ offset ++ ] = color.b;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyIndicesArray: function ( indices ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar index = indices[ i ];\n\t\n\t\t\t\tarray[ offset ++ ] = index.a;\n\t\t\t\tarray[ offset ++ ] = index.b;\n\t\t\t\tarray[ offset ++ ] = index.c;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector2sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector2();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector3sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector3();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyVector4sArray: function ( vectors ) {\n\t\n\t\t\tvar array = this.array, offset = 0;\n\t\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar vector = vectors[ i ];\n\t\n\t\t\t\tif ( vector === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\t\tvector = new THREE.Vector4();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\t\tarray[ offset ++ ] = vector.w;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tset: function ( value, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.array.set( value, offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetX: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize ];\n\t\n\t\t},\n\t\n\t\tsetX: function ( index, x ) {\n\t\n\t\t\tthis.array[ index * this.itemSize ] = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetY: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\n\t\n\t\t},\n\t\n\t\tsetY: function ( index, y ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetZ: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\n\t\n\t\t},\n\t\n\t\tsetZ: function ( index, z ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetW: function ( index ) {\n\t\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\n\t\n\t\t},\n\t\n\t\tsetW: function ( index, w ) {\n\t\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\tindex *= this.itemSize;\n\t\n\t\t\tthis.array[ index + 0 ] = x;\n\t\t\tthis.array[ index + 1 ] = y;\n\t\t\tthis.array[ index + 2 ] = z;\n\t\t\tthis.array[ index + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Int8Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint8Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Int16Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint16Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Int32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Uint32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Float32Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\t\n\t};\n\t\n\tTHREE.Float64Attribute = function ( array, itemSize ) {\n\t\n\t\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\t\n\t};\n\t\n\t\n\t// Deprecated\n\t\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\t\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\t\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\t\n\t};\n\t\n\t// File:src/core/InstancedBufferAttribute.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\t\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\n\t\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t};\n\t\n\tTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\n\tTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\t\n\tTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\t\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/InterleavedBuffer.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InterleavedBuffer = function ( array, stride ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\n\t\tthis.dynamic = false;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\n\t\tthis.version = 0;\n\t\n\t};\n\t\n\tTHREE.InterleavedBuffer.prototype = {\n\t\n\t\tconstructor: THREE.InterleavedBuffer,\n\t\n\t\tget length () {\n\t\n\t\t\treturn this.array.length;\n\t\n\t\t},\n\t\n\t\tget count () {\n\t\n\t\t\treturn this.array.length / this.stride;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tsetDynamic: function ( value ) {\n\t\n\t\t\tthis.dynamic = value;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.array = new source.array.constructor( source.array );\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.dynamic = source.dynamic;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcopyAt: function ( index1, attribute, index2 ) {\n\t\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\t\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\t\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tset: function ( value, offset ) {\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tthis.array.set( value, offset );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/InstancedInterleavedBuffer.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\t\n\t\tTHREE.InterleavedBuffer.call( this, array, stride );\n\t\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\n\t};\n\t\n\tTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\n\tTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\t\n\tTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\t\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/InterleavedBufferAttribute.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset, normalized ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\t\n\t\tthis.normalized = normalized === true;\n\t\n\t};\n\t\n\t\n\tTHREE.InterleavedBufferAttribute.prototype = {\n\t\n\t\tconstructor: THREE.InterleavedBufferAttribute,\n\t\n\t\tget length() {\n\t\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\n\t\t},\n\t\n\t\tget count() {\n\t\n\t\t\treturn this.data.count;\n\t\n\t\t},\n\t\n\t\tget array() {\n\t\n\t\t\treturn this.data.array;\n\t\n\t\t},\n\t\n\t\tsetX: function ( index, x ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetY: function ( index, y ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetZ: function ( index, z ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetW: function ( index, w ) {\n\t\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetX: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\t\n\t\t},\n\t\n\t\tgetY: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\t\n\t\t},\n\t\n\t\tgetZ: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\t\n\t\t},\n\t\n\t\tgetW: function ( index ) {\n\t\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\t\n\t\t},\n\t\n\t\tsetXY: function ( index, x, y ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZ: function ( index, x, y, z ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetXYZW: function ( index, x, y, z, w ) {\n\t\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\n\t\t\tthis.data.array[ index + 0 ] = x;\n\t\t\tthis.data.array[ index + 1 ] = y;\n\t\t\tthis.data.array[ index + 2 ] = z;\n\t\t\tthis.data.array[ index + 3 ] = w;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/core/Geometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\tTHREE.Geometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Geometry';\n\t\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\n\t\tthis.lineDistances = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\t// update flags\n\t\n\t\tthis.elementsNeedUpdate = false;\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.lineDistancesNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertex.applyMatrix4( matrix );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ i ];\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t}\n\t\n\t\t\tthis.verticesNeedUpdate = true;\n\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateX: function () {\n\t\n\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function () {\n\t\n\t\t\t// translate geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tscale: function () {\n\t\n\t\t\t// scale geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar obj;\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\t\n\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tfromBufferGeometry: function ( geometry ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\t\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\t\n\t\t\tvar tempNormals = [];\n\t\t\tvar tempUVs = [];\n\t\t\tvar tempUVs2 = [];\n\t\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\t\n\t\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\t\n\t\t\t\tif ( normals !== undefined ) {\n\t\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( colors !== undefined ) {\n\t\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\n\t\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\t\n\t\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\t\n\t\t\t\tscope.faces.push( face );\n\t\n\t\t\t\tif ( uvs !== undefined ) {\n\t\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( uvs2 !== undefined ) {\n\t\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( indices !== undefined ) {\n\t\n\t\t\t\tvar groups = geometry.groups;\n\t\n\t\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\t\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\t\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\t\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\t\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.computeFaceNormals();\n\t\n\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcenter: function () {\n\t\n\t\t\tthis.computeBoundingBox();\n\t\n\t\t\tvar offset = this.boundingBox.center().negate();\n\t\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\treturn offset;\n\t\n\t\t},\n\t\n\t\tnormalize: function () {\n\t\n\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\tvar center = this.boundingSphere.center;\n\t\t\tvar radius = this.boundingSphere.radius;\n\t\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tmatrix.set(\n\t\t\t\ts, 0, 0, - s * center.x,\n\t\t\t\t0, s, 0, - s * center.y,\n\t\t\t\t0, 0, s, - s * center.z,\n\t\t\t\t0, 0, 0, 1\n\t\t\t);\n\t\n\t\t\tthis.applyMatrix( matrix );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\t\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ f ];\n\t\n\t\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\t\tvar vC = this.vertices[ face.c ];\n\t\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\tcb.normalize();\n\t\n\t\t\t\tface.normal.copy( cb );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\n\t\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\t\n\t\t\tvar v, vl, f, fl, face, vertices;\n\t\n\t\t\tvertices = new Array( this.vertices.length );\n\t\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\n\t\n\t\t\t}\n\t\n\t\t\tif ( areaWeighted ) {\n\t\n\t\t\t\t// vertex normals weighted by triangle areas\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\t\n\t\t\t\tvar vA, vB, vC;\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\t\tvC = this.vertices[ face.c ];\n\t\n\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\t\tvertices[ face.c ].add( cb );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\t\n\t\t\t\tvertices[ v ].normalize();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.faces.length > 0 ) {\n\t\n\t\t\t\tthis.normalsNeedUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeMorphNormals: function () {\n\t\n\t\t\tvar i, il, f, fl, face;\n\t\n\t\t\t// save original normals\n\t\t\t// - create temp variables on first access\n\t\t\t//   otherwise just copy (for faster repeated calls)\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\n\t\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\t\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\t\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\n\t\n\t\t\tvar tmpGeo = new THREE.Geometry();\n\t\t\ttmpGeo.faces = this.faces;\n\t\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\t// create on first access\n\t\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\n\t\n\t\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\t\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\t\n\t\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\t\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\n\t\n\t\t\t\t// set vertices to morph target\n\t\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\t\n\t\t\t\t// compute morph normals\n\t\n\t\t\t\ttmpGeo.computeFaceNormals();\n\t\t\t\ttmpGeo.computeVertexNormals();\n\t\n\t\t\t\t// store morph normals\n\t\n\t\t\t\tvar faceNormal, vertexNormals;\n\t\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\t\n\t\t\t\t\tfaceNormal.copy( face.normal );\n\t\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// restore original normals\n\t\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\tface = this.faces[ f ];\n\t\n\t\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeTangents: function () {\n\t\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\t\n\t\t},\n\t\n\t\tcomputeLineDistances: function () {\n\t\n\t\t\tvar d = 0;\n\t\t\tvar vertices = this.vertices;\n\t\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tif ( i > 0 ) {\n\t\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.lineDistances[ i ] = d;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeBoundingBox: function () {\n\t\n\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\tthis.boundingBox = new THREE.Box3();\n\t\n\t\t\t}\n\t\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\n\t\n\t\t},\n\t\n\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\t\n\t\t\t}\n\t\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\t\n\t\t},\n\t\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\t\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar normalMatrix,\n\t\t\tvertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\t\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\t\n\t\t\tif ( matrix !== undefined ) {\n\t\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t}\n\t\n\t\t\t// vertices\n\t\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar vertex = vertices2[ i ];\n\t\n\t\t\t\tvar vertexCopy = vertex.clone();\n\t\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\t\n\t\t\t\tvertices1.push( vertexCopy );\n\t\n\t\t\t}\n\t\n\t\t\t// faces\n\t\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\t\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\t\tfaceCopy.normal.copy( face.normal );\n\t\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\t\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\n\t\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaceCopy.color.copy( face.color );\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\t\n\t\t\t\tfaces1.push( faceCopy );\n\t\n\t\t\t}\n\t\n\t\t\t// uvs\n\t\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\t\n\t\t\t\tif ( uv === undefined ) {\n\t\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuvs1.push( uvCopy );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmergeMesh: function ( mesh ) {\n\t\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\t\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\n\t\n\t\t},\n\t\n\t\t/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\t\n\t\tmergeVertices: function () {\n\t\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\t\tvar unique = [], changes = [];\n\t\n\t\t\tvar v, key;\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\t\tvar i, il, face;\n\t\t\tvar indices, j, jl;\n\t\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tv = this.vertices[ i ];\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\t\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\n\t\n\t\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// if faces are completely degenerate after merging vertices, we\n\t\t\t// have to remove them from the geometry.\n\t\t\tvar faceIndicesToRemove = [];\n\t\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tface = this.faces[ i ];\n\t\n\t\t\t\tface.a = changes[ face.a ];\n\t\t\t\tface.b = changes[ face.b ];\n\t\t\t\tface.c = changes[ face.c ];\n\t\n\t\t\t\tindices = [ face.a, face.b, face.c ];\n\t\n\t\t\t\tvar dupIndex = - 1;\n\t\n\t\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t\t// we have to remove the face as nothing can be saved\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\t\n\t\t\t\t\t\tdupIndex = n;\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\n\t\n\t\t\t\tthis.faces.splice( idx, 1 );\n\t\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Use unique set of vertices\n\t\n\t\t\tvar diff = this.vertices.length - unique.length;\n\t\t\tthis.vertices = unique;\n\t\t\treturn diff;\n\t\n\t\t},\n\t\n\t\tsortFacesByMaterialIndex: function () {\n\t\n\t\t\tvar faces = this.faces;\n\t\t\tvar length = faces.length;\n\t\n\t\t\t// tag faces\n\t\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\tfaces[ i ]._id = i;\n\t\n\t\t\t}\n\t\n\t\t\t// sort faces\n\t\n\t\t\tfunction materialIndexSort( a, b ) {\n\t\n\t\t\t\treturn a.materialIndex - b.materialIndex;\n\t\n\t\t\t}\n\t\n\t\t\tfaces.sort( materialIndexSort );\n\t\n\t\t\t// sort uvs\n\t\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\t\n\t\t\tvar newUvs1, newUvs2;\n\t\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\t\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\t\n\t\t\t\tvar id = faces[ i ]._id;\n\t\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\t\n\t\t\t}\n\t\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\t\n\t\t},\n\t\n\t\ttoJSON: function () {\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Geometry',\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard Geometry serialization\n\t\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t\tvar vertices = [];\n\t\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\t\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = [];\n\t\t\tvar normals = [];\n\t\t\tvar normalsHash = {};\n\t\t\tvar colors = [];\n\t\t\tvar colorsHash = {};\n\t\t\tvar uvs = [];\n\t\t\tvar uvsHash = {};\n\t\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = this.faces[ i ];\n\t\n\t\t\t\tvar hasMaterial = true;\n\t\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\t\n\t\t\t\tvar faceType = 0;\n\t\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\t\n\t\t\t\tfaces.push( faceType );\n\t\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\t\tfaces.push( face.materialIndex );\n\t\n\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t\t);\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction setBit( value, position, enabled ) {\n\t\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\t\n\t\t\t}\n\t\n\t\t\tfunction getNormalIndex( normal ) {\n\t\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\t\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\n\t\t\t\treturn normalsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getColorIndex( color ) {\n\t\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\t\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\t\tcolors.push( color.getHex() );\n\t\n\t\t\t\treturn colorsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getUvIndex( uv ) {\n\t\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\t\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\t\n\t\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\t\n\t\t\t\treturn uvsHash[ hash ];\n\t\n\t\t\t}\n\t\n\t\t\tdata.data = {};\n\t\n\t\t\tdata.data.vertices = vertices;\n\t\t\tdata.data.normals = normals;\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\t\tdata.data.faces = faces;\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\t/*\n\t\t\t// Handle primitives\n\t\n\t\t\tvar parameters = this.parameters;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\t\n\t\t\treturn new THREE.Geometry().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.vertices = [];\n\t\t\tthis.faces = [];\n\t\t\tthis.faceVertexUvs = [ [] ];\n\t\n\t\t\tvar vertices = source.vertices;\n\t\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar faces = source.faces;\n\t\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\t\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\t\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\t\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\t\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\tvar uv = uvs[ k ];\n\t\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.GeometryIdCount = 0;\n\t\n\t// File:src/core/DirectGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.DirectGeometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'DirectGeometry';\n\t\n\t\tthis.indices = [];\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\t\n\t\tthis.groups = [];\n\t\n\t\tthis.morphTargets = {};\n\t\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\n\t\t// this.lineDistances = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\t// update flags\n\t\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\t\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function () {\n\t\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\t\n\t\t},\n\t\n\t\tcomputeGroups: function ( geometry ) {\n\t\n\t\t\tvar group;\n\t\t\tvar groups = [];\n\t\t\tvar materialIndex;\n\t\n\t\t\tvar faces = geometry.faces;\n\t\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t// materials\n\t\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\n\t\n\t\t\t\t\tmaterialIndex = face.materialIndex;\n\t\n\t\t\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgroup = {\n\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( group !== undefined ) {\n\t\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\tgroups.push( group );\n\t\n\t\t\t}\n\t\n\t\t\tthis.groups = groups;\n\t\n\t\t},\n\t\n\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\t\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\t\n\t\t\t// morphs\n\t\n\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\tvar morphTargetsLength = morphTargets.length;\n\t\n\t\t\tvar morphTargetsPosition;\n\t\n\t\t\tif ( morphTargetsLength > 0 ) {\n\t\n\t\t\t\tmorphTargetsPosition = [];\n\t\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\t\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\t\n\t\t\t}\n\t\n\t\t\tvar morphNormals = geometry.morphNormals;\n\t\t\tvar morphNormalsLength = morphNormals.length;\n\t\n\t\t\tvar morphTargetsNormal;\n\t\n\t\t\tif ( morphNormalsLength > 0 ) {\n\t\n\t\t\t\tmorphTargetsNormal = [];\n\t\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\t\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\t\n\t\t\t}\n\t\n\t\t\t// skins\n\t\n\t\t\tvar skinIndices = geometry.skinIndices;\n\t\t\tvar skinWeights = geometry.skinWeights;\n\t\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\t\n\t\t\t//\n\t\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\t\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\t\n\t\t\t\tif ( vertexNormals.length === 3 ) {\n\t\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar vertexColors = face.vertexColors;\n\t\n\t\t\t\tif ( vertexColors.length === 3 ) {\n\t\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar color = face.color;\n\t\n\t\t\t\t\tthis.colors.push( color, color, color );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexUv === true ) {\n\t\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\t\n\t\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\n\t\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\t\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\n\t\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\t\n\t\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// morphs\n\t\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\t\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\t\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\t\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// skins\n\t\n\t\t\t\tif ( hasSkinIndices ) {\n\t\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( hasSkinWeights ) {\n\t\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.computeGroups( geometry );\n\t\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/core/BufferGeometry.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferGeometry = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\t\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\n\t\tthis.morphAttributes = {};\n\t\n\t\tthis.groups = [];\n\t\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\t\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\t\n\t};\n\t\n\tObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tgetIndex: function () {\n\t\n\t\t\treturn this.index;\n\t\n\t\t},\n\t\n\t\tsetIndex: function ( index ) {\n\t\n\t\t\tthis.index = index;\n\t\n\t\t},\n\t\n\t\taddAttribute: function ( name, attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\t\n\t\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\t\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( name === 'index' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\t\tthis.setIndex( attribute );\n\t\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.attributes[ name ] = attribute;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetAttribute: function ( name ) {\n\t\n\t\t\treturn this.attributes[ name ];\n\t\n\t\t},\n\t\n\t\tremoveAttribute: function ( name ) {\n\t\n\t\t\tdelete this.attributes[ name ];\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddGroup: function ( start, count, materialIndex ) {\n\t\n\t\t\tthis.groups.push( {\n\t\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\t\n\t\t\t} );\n\t\n\t\t},\n\t\n\t\tclearGroups: function () {\n\t\n\t\t\tthis.groups = [];\n\t\n\t\t},\n\t\n\t\tsetDrawRange: function ( start, count ) {\n\t\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\t\n\t\t},\n\t\n\t\tapplyMatrix: function ( matrix ) {\n\t\n\t\t\tvar position = this.attributes.position;\n\t\n\t\t\tif ( position !== undefined ) {\n\t\n\t\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\t\tposition.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tvar normal = this.attributes.normal;\n\t\n\t\t\tif ( normal !== undefined ) {\n\t\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\t\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\t\tnormal.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingBox !== null ) {\n\t\n\t\t\t\tthis.computeBoundingBox();\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.computeBoundingSphere();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\trotateX: function () {\n\t\n\t\t\t// rotate geometry around world x-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateX( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationX( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateY: function () {\n\t\n\t\t\t// rotate geometry around world y-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateY( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationY( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\trotateZ: function () {\n\t\n\t\t\t// rotate geometry around world z-axis\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function rotateZ( angle ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeRotationZ( angle );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttranslate: function () {\n\t\n\t\t\t// translate geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function translate( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeTranslation( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tscale: function () {\n\t\n\t\t\t// scale geometry\n\t\n\t\t\tvar m1;\n\t\n\t\t\treturn function scale( x, y, z ) {\n\t\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\t\n\t\t\t\tm1.makeScale( x, y, z );\n\t\n\t\t\t\tthis.applyMatrix( m1 );\n\t\n\t\t\t\treturn this;\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tlookAt: function () {\n\t\n\t\t\tvar obj;\n\t\n\t\t\treturn function lookAt( vector ) {\n\t\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\t\n\t\t\t\tobj.lookAt( vector );\n\t\n\t\t\t\tobj.updateMatrix();\n\t\n\t\t\t\tthis.applyMatrix( obj.matrix );\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tcenter: function () {\n\t\n\t\t\tthis.computeBoundingBox();\n\t\n\t\t\tvar offset = this.boundingBox.center().negate();\n\t\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\n\t\n\t\t\treturn offset;\n\t\n\t\t},\n\t\n\t\tsetFromObject: function ( object ) {\n\t\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\t\n\t\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\t\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\t\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\t\n\t\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\t\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tthis.fromGeometry( geometry );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdateFromObject: function ( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tvar direct = geometry.__directGeometry;\n\t\n\t\t\t\tif ( direct === undefined || geometry.elementsNeedUpdate === true ) {\n\t\n\t\t\t\t\treturn this.fromGeometry( geometry );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate || geometry.elementsNeedUpdate;\n\t\n\t\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t\tgeometry = direct;\n\t\n\t\t\t}\n\t\n\t\t\tvar attribute;\n\t\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\n\t\n\t\t\t\tattribute = this.attributes.position;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.verticesNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\n\t\n\t\t\t\tattribute = this.attributes.normal;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.normalsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\n\t\n\t\t\t\tattribute = this.attributes.color;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.colorsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvsNeedUpdate ) {\n\t\n\t\t\t\tattribute = this.attributes.uv;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.uvsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\t\n\t\t\t\tattribute = this.attributes.lineDistance;\n\t\n\t\t\t\tif ( attribute !== undefined ) {\n\t\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\t\tattribute.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.groupsNeedUpdate ) {\n\t\n\t\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t\tgeometry.groupsNeedUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tfromGeometry: function ( geometry ) {\n\t\n\t\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\t\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\t\n\t\t},\n\t\n\t\tfromDirectGeometry: function ( geometry ) {\n\t\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\t\n\t\t\tif ( geometry.normals.length > 0 ) {\n\t\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.colors.length > 0 ) {\n\t\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\t\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.uvs2.length > 0 ) {\n\t\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.indices.length > 0 ) {\n\t\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\t\n\t\t\t}\n\t\n\t\t\t// groups\n\t\n\t\t\tthis.groups = geometry.groups;\n\t\n\t\t\t// morphs\n\t\n\t\t\tfor ( var name in geometry.morphTargets ) {\n\t\n\t\t\t\tvar array = [];\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\t\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\n\t\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\t\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.morphAttributes[ name ] = array;\n\t\n\t\t\t}\n\t\n\t\t\t// skinning\n\t\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\n\t\n\t\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\n\t\n\t\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\t\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcomputeBoundingBox: function () {\n\t\n\t\t\tif ( this.boundingBox === null ) {\n\t\n\t\t\t\tthis.boundingBox = new THREE.Box3();\n\t\n\t\t\t}\n\t\n\t\t\tvar positions = this.attributes.position.array;\n\t\n\t\t\tif ( positions !== undefined ) {\n\t\n\t\t\t\tthis.boundingBox.setFromArray( positions );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.boundingBox.makeEmpty();\n\t\n\t\t\t}\n\t\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\t\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tcomputeBoundingSphere: function () {\n\t\n\t\t\tvar box = new THREE.Box3();\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\treturn function computeBoundingSphere() {\n\t\n\t\t\t\tif ( this.boundingSphere === null ) {\n\t\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = this.attributes.position;\n\t\n\t\t\t\tif ( positions ) {\n\t\n\t\t\t\t\tvar array = positions.array;\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\t\n\t\t\t\t\tbox.setFromArray( array );\n\t\t\t\t\tbox.center( center );\n\t\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\t\n\t\t\t\t\tvar maxRadiusSq = 0;\n\t\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\t\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\tcomputeFaceNormals: function () {\n\t\n\t\t\t// backwards compatibility\n\t\n\t\t},\n\t\n\t\tcomputeVertexNormals: function () {\n\t\n\t\t\tvar index = this.index;\n\t\t\tvar attributes = this.attributes;\n\t\t\tvar groups = this.groups;\n\t\n\t\t\tif ( attributes.position ) {\n\t\n\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\tif ( attributes.normal === undefined ) {\n\t\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// reset existing normals to zero\n\t\n\t\t\t\t\tvar array = attributes.normal.array;\n\t\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tarray[ i ] = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar normals = attributes.normal.array;\n\t\n\t\t\t\tvar vA, vB, vC,\n\t\n\t\t\t\tpA = new THREE.Vector3(),\n\t\t\t\tpB = new THREE.Vector3(),\n\t\t\t\tpC = new THREE.Vector3(),\n\t\n\t\t\t\tcb = new THREE.Vector3(),\n\t\t\t\tab = new THREE.Vector3();\n\t\n\t\t\t\t// indexed elements\n\t\n\t\t\t\tif ( index ) {\n\t\n\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\t\n\t\t\t\t\t\tvar group = groups[ j ];\n\t\n\t\t\t\t\t\tvar start = group.start;\n\t\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\t\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\n\t\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\t\n\t\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\t\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\t\n\t\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\t\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\t\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.normalizeNormals();\n\t\n\t\t\t\tattributes.normal.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmerge: function ( geometry, offset ) {\n\t\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\t\n\t\t\t\tvar attribute1 = attributes[ key ];\n\t\t\t\tvar attributeArray1 = attribute1.array;\n\t\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\t\tvar attributeArray2 = attribute2.array;\n\t\n\t\t\t\tvar attributeSize = attribute2.itemSize;\n\t\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\t\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tnormalizeNormals: function () {\n\t\n\t\t\tvar normals = this.attributes.normal.array;\n\t\n\t\t\tvar x, y, z, n;\n\t\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\t\n\t\t\t\tx = normals[ i ];\n\t\t\t\ty = normals[ i + 1 ];\n\t\t\t\tz = normals[ i + 2 ];\n\t\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\t\n\t\t\t\tnormals[ i ] *= n;\n\t\t\t\tnormals[ i + 1 ] *= n;\n\t\t\t\tnormals[ i + 2 ] *= n;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoNonIndexed: function () {\n\t\n\t\t\tif ( this.index === null ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\t\treturn this;\n\t\n\t\t\t}\n\t\n\t\t\tvar geometry2 = new THREE.BufferGeometry();\n\t\n\t\t\tvar indices = this.index.array;\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\t\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\t\n\t\t\t\tvar index = 0, index2 = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\t\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\t\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry2;\n\t\n\t\t},\n\t\n\t\ttoJSON: function () {\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard BufferGeometry serialization\n\t\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.parameters !== undefined ) {\n\t\n\t\t\t\tvar parameters = this.parameters;\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn data;\n\t\n\t\t\t}\n\t\n\t\t\tdata.data = { attributes: {} };\n\t\n\t\t\tvar index = this.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\n\t\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: array\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = this.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ key ];\n\t\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\t\n\t\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: attribute.normalized\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = this.groups;\n\t\n\t\t\tif ( groups.length > 0 ) {\n\t\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar boundingSphere = this.boundingSphere;\n\t\n\t\t\tif ( boundingSphere !== null ) {\n\t\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\t/*\n\t\t\t// Handle primitives\n\t\n\t\t\tvar parameters = this.parameters;\n\t\n\t\t\tif ( parameters !== undefined ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in parameters ) {\n\t\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\t\n\t\t\t}\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\t\n\t\t\treturn new THREE.BufferGeometry().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tvar index = source.index;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = source.attributes;\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ name ];\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = source.groups;\n\t\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar group = groups[ i ];\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.BufferGeometry.MaxIndex = 65535;\n\t\n\t// File:src/core/InstancedBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.InstancedBufferGeometry = function () {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.maxInstancedCount = undefined;\n\t\n\t};\n\t\n\tTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\t\n\tTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\t\n\t\tthis.groups.push( {\n\t\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tinstances: instances\n\t\n\t\t} );\n\t\n\t};\n\t\n\tTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\t\n\t\tvar index = source.index;\n\t\n\t\tif ( index !== null ) {\n\t\n\t\t\tthis.setIndex( index.clone() );\n\t\n\t\t}\n\t\n\t\tvar attributes = source.attributes;\n\t\n\t\tfor ( var name in attributes ) {\n\t\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\t\n\t\t}\n\t\n\t\tvar groups = source.groups;\n\t\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.instances );\n\t\n\t\t}\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/core/Uniform.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Uniform = function ( value ) {\n\t\n\t\tif ( typeof value === 'string' ) {\n\t\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\t\tvalue = arguments[ 1 ];\n\t\n\t\t}\n\t\n\t\tthis.value = value;\n\t\n\t\tthis.dynamic = false;\n\t\n\t};\n\t\n\tTHREE.Uniform.prototype = {\n\t\n\t\tconstructor: THREE.Uniform,\n\t\n\t\tonUpdate: function ( callback ) {\n\t\n\t\t\tthis.dynamic = true;\n\t\t\tthis.onUpdateCallback = callback;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/AnimationAction.js\n\t\n\t/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\t\n\tTHREE.AnimationAction = function() {\n\t\n\t\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\t\"Use mixer.clipAction for construction.\" );\n\t\n\t};\n\t\n\tTHREE.AnimationAction._new =\n\t\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\t\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot || null;\n\t\n\t\tvar tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\t\n\t\tvar interpolantSettings = {\n\t\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t\t};\n\t\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\t\n\t\t}\n\t\n\t\tthis._interpolantSettings = interpolantSettings;\n\t\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\n\t\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\t\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\t\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\t\n\t\tthis.loop = THREE.LoopRepeat;\n\t\tthis._loopCount = -1;\n\t\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\t\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\t\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\t\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\t\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\t\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\t\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\t\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\t\n\t};\n\t\n\tTHREE.AnimationAction._new.prototype = {\n\t\n\t\tconstructor: THREE.AnimationAction._new,\n\t\n\t\t// State & Scheduling\n\t\n\t\tplay: function() {\n\t\n\t\t\tthis._mixer._activateAction( this );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstop: function() {\n\t\n\t\t\tthis._mixer._deactivateAction( this );\n\t\n\t\t\treturn this.reset();\n\t\n\t\t},\n\t\n\t\treset: function() {\n\t\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\t\n\t\t\tthis.time = 0;\t\t\t// restart clip\n\t\t\tthis._loopCount = -1;\t// forget previous loops\n\t\t\tthis._startTime = null;\t// forget scheduling\n\t\n\t\t\treturn this.stopFading().stopWarping();\n\t\n\t\t},\n\t\n\t\tisRunning: function() {\n\t\n\t\t\tvar start = this._startTime;\n\t\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\t\n\t\t},\n\t\n\t\t// return true when play has been called\n\t\tisScheduled: function() {\n\t\n\t\t\treturn this._mixer._isActiveAction( this );\n\t\n\t\t},\n\t\n\t\tstartAt: function( time ) {\n\t\n\t\t\tthis._startTime = time;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetLoop: function( mode, repetitions ) {\n\t\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Weight\n\t\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\t\tsetEffectiveWeight: function( weight ) {\n\t\n\t\t\tthis.weight = weight;\n\t\n\t\t\t// note: same logic as when updated at runtime\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\n\t\t\treturn this.stopFading();\n\t\n\t\t},\n\t\n\t\t// return the weight considering fading and .enabled\n\t\tgetEffectiveWeight: function() {\n\t\n\t\t\treturn this._effectiveWeight;\n\t\n\t\t},\n\t\n\t\tfadeIn: function( duration ) {\n\t\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\n\t\n\t\t},\n\t\n\t\tfadeOut: function( duration ) {\n\t\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\n\t\n\t\t},\n\t\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\t\n\t\t\tvar mixer = this._mixer;\n\t\n\t\t\tfadeOutAction.fadeOut( duration );\n\t\t\tthis.fadeIn( duration );\n\t\n\t\t\tif( warp ) {\n\t\n\t\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\t\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\t\n\t\t},\n\t\n\t\tstopFading: function() {\n\t\n\t\t\tvar weightInterpolant = this._weightInterpolant;\n\t\n\t\t\tif ( weightInterpolant !== null ) {\n\t\n\t\t\t\tthis._weightInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Time Scale Control\n\t\n\t\t// set the weight stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\t\tsetEffectiveTimeScale: function( timeScale ) {\n\t\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\t// return the time scale considering warping and .paused\n\t\tgetEffectiveTimeScale: function() {\n\t\n\t\t\treturn this._effectiveTimeScale;\n\t\n\t\t},\n\t\n\t\tsetDuration: function( duration ) {\n\t\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\tsyncWith: function( action ) {\n\t\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\t\n\t\t\treturn this.stopWarping();\n\t\n\t\t},\n\t\n\t\thalt: function( duration ) {\n\t\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\t\n\t\t},\n\t\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\n\t\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\n\t\n\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\ttimes[ 0 ] = now;\n\t\t\ttimes[ 1 ] = now + duration;\n\t\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstopWarping: function() {\n\t\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\t\n\t\t\tif ( timeScaleInterpolant !== null ) {\n\t\n\t\t\t\tthis._timeScaleInterpolant = null;\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// Object Accessors\n\t\n\t\tgetMixer: function() {\n\t\n\t\t\treturn this._mixer;\n\t\n\t\t},\n\t\n\t\tgetClip: function() {\n\t\n\t\t\treturn this._clip;\n\t\n\t\t},\n\t\n\t\tgetRoot: function() {\n\t\n\t\t\treturn this._localRoot || this._mixer._root;\n\t\n\t\t},\n\t\n\t\t// Interna\n\t\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t\t// called by the mixer\n\t\n\t\t\tvar startTime = this._startTime;\n\t\n\t\t\tif ( startTime !== null ) {\n\t\n\t\t\t\t// check for scheduled start of action\n\t\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\t\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// start\n\t\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\n\t\t\t}\n\t\n\t\t\t// apply time scale and advance time\n\t\n\t\t\tdeltaTime *= this._updateTimeScale( time );\n\t\t\tvar clipTime = this._updateTime( deltaTime );\n\t\n\t\t\t// note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\t\n\t\t\tvar weight = this._updateWeight( time );\n\t\n\t\t\tif ( weight > 0 ) {\n\t\n\t\t\t\tvar interpolants = this._interpolants;\n\t\t\t\tvar propertyMixers = this._propertyBindings;\n\t\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\t\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_updateWeight: function( time ) {\n\t\n\t\t\tvar weight = 0;\n\t\n\t\t\tif ( this.enabled ) {\n\t\n\t\t\t\tweight = this.weight;\n\t\t\t\tvar interpolant = this._weightInterpolant;\n\t\n\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\tweight *= interpolantValue;\n\t\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\tthis.stopFading();\n\t\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\n\t\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\t\n\t\t},\n\t\n\t\t_updateTimeScale: function( time ) {\n\t\n\t\t\tvar timeScale = 0;\n\t\n\t\t\tif ( ! this.paused ) {\n\t\n\t\t\t\ttimeScale = this.timeScale;\n\t\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\n\t\n\t\t\t\tif ( interpolant !== null ) {\n\t\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\t\n\t\t\t\t\ttimeScale *= interpolantValue;\n\t\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\t\n\t\t\t\t\t\tthis.stopWarping();\n\t\n\t\t\t\t\t\tif ( timeScale === 0 ) {\n\t\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\t\n\t\t},\n\t\n\t\t_updateTime: function( deltaTime ) {\n\t\n\t\t\tvar time = this.time + deltaTime;\n\t\n\t\t\tif ( deltaTime === 0 ) return time;\n\t\n\t\t\tvar duration = this._clip.duration,\n\t\n\t\t\t\tloop = this.loop,\n\t\t\t\tloopCount = this._loopCount;\n\t\n\t\t\tif ( loop === THREE.LoopOnce ) {\n\t\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\t\n\t\t\t\t\tthis.loopCount = 0;\n\t\t\t\t\tthis._setEndings( true, true, false );\n\t\n\t\t\t\t}\n\t\n\t\t\t\thandle_stop: {\n\t\n\t\t\t\t\tif ( time >= duration ) {\n\t\n\t\t\t\t\t\ttime = duration;\n\t\n\t\t\t\t\t} else if ( time < 0 ) {\n\t\n\t\t\t\t\t\ttime = 0;\n\t\n\t\t\t\t\t} else break handle_stop;\n\t\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t} );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else { // repetitive Repeat or PingPong\n\t\n\t\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\t\n\t\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t\t// just started\n\t\n\t\t\t\t\tif ( deltaTime >= 0 ) {\n\t\n\t\t\t\t\t\tloopCount = 0;\n\t\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\t\n\t\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t\t// wrap around\n\t\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\t\ttime -= duration * loopDelta;\n\t\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\n\t\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\n\t\n\t\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\t\telse this.enabled = false;\n\t\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\t\n\t\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t\t// entering the last round\n\t\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\t\n\t\t\t\t\tthis.time = time;\n\t\t\t\t\treturn duration - time;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.time = time;\n\t\t\treturn time;\n\t\n\t\t},\n\t\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\n\t\n\t\t\tvar settings = this._interpolantSettings;\n\t\n\t\t\tif ( pingPong ) {\n\t\n\t\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\n\t\t\t\tif ( atStart ) {\n\t\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( atEnd ) {\n\t\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\t\n\t\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\t\tinterpolant = this._weightInterpolant;\n\t\n\t\t\tif ( interpolant === null ) {\n\t\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\t\tthis._weightInterpolant = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = interpolant.parameterPositions,\n\t\t\t\tvalues = interpolant.sampleValues;\n\t\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/animation/AnimationClip.js\n\t\n\t/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\t\n\tTHREE.AnimationClip = function ( name, duration, tracks ) {\n\t\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\t\n\t\t\tthis.resetDuration();\n\t\n\t\t}\n\t\n\t\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t\t// but leaving these here during development as this ensures a lot of testing of these functions\n\t\tthis.trim();\n\t\tthis.optimize();\n\t\n\t};\n\t\n\tTHREE.AnimationClip.prototype = {\n\t\n\t\tconstructor: THREE.AnimationClip,\n\t\n\t\tresetDuration: function() {\n\t\n\t\t\tvar tracks = this.tracks,\n\t\t\t\tduration = 0;\n\t\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar track = this.tracks[ i ];\n\t\n\t\t\t\tduration = Math.max(\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\t\n\t\t\t}\n\t\n\t\t\tthis.duration = duration;\n\t\n\t\t},\n\t\n\t\ttrim: function() {\n\t\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\toptimize: function() {\n\t\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\t\n\t\t\t\tthis.tracks[ i ].optimize();\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// Static methods:\n\t\n\tObject.assign( THREE.AnimationClip, {\n\t\n\t\tparse: function( json ) {\n\t\n\t\t\tvar tracks = [],\n\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\t\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\t\n\t\t},\n\t\n\t\n\t\ttoJSON: function( clip ) {\n\t\n\t\t\tvar tracks = [],\n\t\t\t\tclipTracks = clip.tracks;\n\t\n\t\t\tvar json = {\n\t\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks\n\t\n\t\t\t};\n\t\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\t\n\t\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn json;\n\t\n\t\t},\n\t\n\t\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\t\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\t\tvar tracks = [];\n\t\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\t\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\t\n\t\t\t\ttimes.push(\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\t\ti,\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\t\n\t\t\t\tvalues.push( 0, 1, 0 );\n\t\n\t\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\t\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\t\n\t\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\t\tvalues.push( values[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttracks.push(\n\t\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\t\ttimes, values\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t\t}\n\t\n\t\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\t\n\t\t},\n\t\n\t\tfindByName: function( objectOrClipArray, name ) {\n\t\n\t\t\tvar clipArray = objectOrClipArray;\n\t\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\t\n\t\t\t\tvar o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\t\n\t\t\t\tif ( clipArray[ i ].name === name ) {\n\t\n\t\t\t\t\treturn clipArray[ i ];\n\t\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\t\n\t\t\tvar animationToMorphTargets = {};\n\t\n\t\t\t// tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\t\n\t\t\t// sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\n\t\n\t\t\t\tif ( parts && parts.length > 1 ) {\n\t\n\t\t\t\t\tvar name = parts[ 1 ];\n\t\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\t\tif ( ! animationMorphTargets ) {\n\t\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar clips = [];\n\t\n\t\t\tfor ( var name in animationToMorphTargets ) {\n\t\n\t\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn clips;\n\t\n\t\t},\n\t\n\t\t// parse the animation.hierarchy format\n\t\tparseAnimation: function( animation, bones, nodeName ) {\n\t\n\t\t\tif ( ! animation ) {\n\t\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar addNonemptyTrack = function(\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\t\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif ( animationKeys.length !== 0 ) {\n\t\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\t\n\t\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\t\tif ( times.length !== 0 ) {\n\t\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tvar tracks = [];\n\t\n\t\t\tvar clipName = animation.name || 'default';\n\t\t\t// automatic length determination in AnimationClip.\n\t\t\tvar duration = animation.length || -1;\n\t\t\tvar fps = animation.fps || 30;\n\t\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\n\t\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\t\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\t\n\t\t\t\t// skip empty tracks\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\t\n\t\t\t\t// process morph targets in a way exactly compatible\n\t\t\t\t// with AnimationHandler.init( animation )\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\n\t\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tvar morphTargetNames = {};\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\t\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\t\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\t\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\t\n\t\t\t\t\t\tvar times = [];\n\t\t\t\t\t\tvar values = [];\n\t\n\t\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\t\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\t\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\t\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\t\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\t\n\t\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( tracks.length === 0 ) {\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t}\n\t\n\t\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\t\n\t\t\treturn clip;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/animation/AnimationMixer.js\n\t\n\t/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.AnimationMixer = function( root ) {\n\t\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\n\t\tthis.time = 0;\n\t\n\t\tthis.timeScale = 1.0;\n\t\n\t};\n\t\n\tObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\t// return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\t\tclipAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\t\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\t\tprototypeAction = null;\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\tvar existingAction =\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( existingAction !== undefined ) {\n\t\n\t\t\t\t\treturn existingAction;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\t\n\t\t\t\t// also, take the clip from the prototype action\n\t\t\t\tif ( clipObject === null )\n\t\t\t\t\tclipObject = prototypeAction._clip;\n\t\n\t\t\t}\n\t\n\t\t\t// clip must be known when specified via string\n\t\t\tif ( clipObject === null ) return null;\n\t\n\t\t\t// allocate all resources required to run it\n\t\t\tvar newAction = new THREE.\n\t\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\t\n\t\t\tthis._bindAction( newAction, prototypeAction );\n\t\n\t\t\t// and make the action known to the memory manager\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\t\n\t\t\treturn newAction;\n\t\n\t\t},\n\t\n\t\t// get an existing action\n\t\texistingAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar root = optionalRoot || this._root,\n\t\t\t\trootUuid = root.uuid,\n\t\n\t\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\t\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\t// deactivates all previously scheduled actions\n\t\tstopAllAction: function() {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\tactions[ i ].reset();\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].useCount = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// advance the time and update apply the animation\n\t\tupdate: function( deltaTime ) {\n\t\n\t\t\tdeltaTime *= this.timeScale;\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tnActions = this._nActiveActions,\n\t\n\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\n\t\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\n\t\n\t\t\t// run active actions\n\t\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\t\n\t\t\t\tvar action = actions[ i ];\n\t\n\t\t\t\tif ( action.enabled ) {\n\t\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// update scene graph\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tnBindings = this._nActiveBindings;\n\t\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].apply( accuIndex );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// return this mixer's root target object\n\t\tgetRoot: function() {\n\t\n\t\t\treturn this._root;\n\t\n\t\t},\n\t\n\t\t// free all resources specific to a particular clip\n\t\tuncacheClip: function( clip ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip !== undefined ) {\n\t\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\t\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\t\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar action = actionsToRemove[ i ];\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\t\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\t\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\t\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// free all resources specific to a particular root target object\n\t\tuncacheRoot: function( root ) {\n\t\n\t\t\tvar rootUuid = root.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip;\n\t\n\t\t\tfor ( var clipUuid in actionsByClip ) {\n\t\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\n\t\n\t\t\t\tif ( action !== undefined ) {\n\t\n\t\t\t\t\tthis._deactivateAction( action );\n\t\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\tif ( bindingByName !== undefined ) {\n\t\n\t\t\t\tfor ( var trackName in bindingByName ) {\n\t\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// remove a targeted clip from the cache\n\t\tuncacheAction: function( clip, optionalRoot ) {\n\t\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\n\t\n\t\t\tif ( action !== null ) {\n\t\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\tTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\t\n\t// Implementation details:\n\t\n\tObject.assign( THREE.AnimationMixer.prototype, {\n\t\n\t\t_bindAction: function( action, prototypeAction ) {\n\t\n\t\t\tvar root = action._localRoot || this._root,\n\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\tnTracks = tracks.length,\n\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\trootUuid = root.uuid,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\t\n\t\t\tif ( bindingsByName === undefined ) {\n\t\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\t\n\t\t\t\tvar track = tracks[ i ],\n\t\t\t\t\ttrackName = track.name,\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\n\t\n\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbinding = bindings[ i ];\n\t\n\t\t\t\t\tif ( binding !== undefined ) {\n\t\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\t\n\t\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\t\n\t\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\t\n\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\t\n\t\t\t\t\tbindings[ i ] = binding;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_activateAction: function( action ) {\n\t\n\t\t\tif ( ! this._isActiveAction( action ) ) {\n\t\n\t\t\t\tif ( action._cacheIndex === null ) {\n\t\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\t\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\t\n\t\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\t\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t// increment reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\t\n\t\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\t\tbinding.saveOriginalState();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._lendAction( action );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_deactivateAction: function( action ) {\n\t\n\t\t\tif ( this._isActiveAction( action ) ) {\n\t\n\t\t\t\tvar bindings = action._propertyBindings;\n\t\n\t\t\t\t// decrement reference counts / sort out state\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\n\t\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\t\tthis._takeBackBinding( binding );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis._takeBackAction( action );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// Memory manager\n\t\n\t\t_initMemoryManager: function() {\n\t\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\t\tthis._nActiveActions = 0;\n\t\n\t\t\tthis._actionsByClip = {};\n\t\t\t// inside:\n\t\t\t// {\n\t\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t\t// }\n\t\n\t\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\t\tthis._nActiveBindings = 0;\n\t\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\t\n\t\n\t\t\tthis._controlInterpolants = []; // same game as above\n\t\t\tthis._nActiveControlInterpolants = 0;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tthis.stats = {\n\t\n\t\t\t\tactions: {\n\t\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t},\n\t\n\t\t// Memory management for _Action objects\n\t\n\t\t_isActiveAction: function( action ) {\n\t\n\t\t\tvar index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\t\n\t\t},\n\t\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\t\n\t\t\tif ( actionsForClip === undefined ) {\n\t\n\t\t\t\tactionsForClip = {\n\t\n\t\t\t\t\tknownActions: [ action ],\n\t\t\t\t\tactionByRoot: {}\n\t\n\t\t\t\t};\n\t\n\t\t\t\taction._byClipCacheIndex = 0;\n\t\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\n\t\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push( action );\n\t\n\t\t\t}\n\t\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push( action );\n\t\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\t\n\t\t},\n\t\n\t\t_removeInactiveAction: function( action ) {\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\t\tcacheIndex = action._cacheIndex;\n\t\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\tactions.pop();\n\t\n\t\t\taction._cacheIndex = null;\n\t\n\t\n\t\t\tvar clipUuid = action._clip.uuid,\n\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\n\t\t\t\tlastKnownAction =\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\t\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\t\n\t\t\taction._byClipCacheIndex = null;\n\t\n\t\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\t\n\t\t\tdelete actionByRoot[ rootUuid ];\n\t\n\t\t\tif ( knownActionsForClip.length === 0 ) {\n\t\n\t\t\t\tdelete actionsByClip[ clipUuid ];\n\t\n\t\t\t}\n\t\n\t\t\tthis._removeInactiveBindingsForAction( action );\n\t\n\t\t},\n\t\n\t\t_removeInactiveBindingsForAction: function( action ) {\n\t\n\t\t\tvar bindings = action._propertyBindings;\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar binding = bindings[ i ];\n\t\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\n\t\n\t\t\t\t\tthis._removeInactiveBinding( binding );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_lendAction: function( action ) {\n\t\n\t\t\t// [ active actions |  inactive actions  ]\n\t\t\t// [  active actions >| inactive actions ]\n\t\t\t//                 s        a\n\t\t\t//                  <-swap->\n\t\t\t//                 a        s\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\n\t\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\t\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[ lastActiveIndex ] = action;\n\t\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\n\t\n\t\t},\n\t\n\t\t_takeBackAction: function( action ) {\n\t\n\t\t\t// [  active actions  | inactive actions ]\n\t\t\t// [ active actions |< inactive actions  ]\n\t\t\t//        a        s\n\t\t\t//         <-swap->\n\t\t\t//        s        a\n\t\n\t\t\tvar actions = this._actions,\n\t\t\t\tprevIndex = action._cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\t\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\t\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[ firstInactiveIndex ] = action;\n\t\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[ prevIndex ] = lastActiveAction;\n\t\n\t\t},\n\t\n\t\t// Memory management for PropertyMixer objects\n\t\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\t\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\tbindings = this._bindings;\n\t\n\t\t\tif ( bindingByName === undefined ) {\n\t\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\t\n\t\t\t}\n\t\n\t\t\tbindingByName[ trackName ] = binding;\n\t\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push( binding );\n\t\n\t\t},\n\t\n\t\t_removeInactiveBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tpropBinding = binding.binding,\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\ttrackName = propBinding.path,\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\t\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\t\n\t\t\tdelete bindingByName[ trackName ];\n\t\n\t\t\tremove_empty_map: {\n\t\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\t\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_lendBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\t\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\t\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[ lastActiveIndex ] = binding;\n\t\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\t\n\t\t},\n\t\n\t\t_takeBackBinding: function( binding ) {\n\t\n\t\t\tvar bindings = this._bindings,\n\t\t\t\tprevIndex = binding._cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\t\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\t\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[ firstInactiveIndex ] = binding;\n\t\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\n\t\n\t\t},\n\t\n\t\n\t\t// Memory management of Interpolants for weight and time scale\n\t\n\t\t_lendControlInterpolant: function() {\n\t\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\t\n\t\t\tif ( interpolant === undefined ) {\n\t\n\t\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\t\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\t\n\t\t\t}\n\t\n\t\t\treturn interpolant;\n\t\n\t\t},\n\t\n\t\t_takeBackControlInterpolant: function( interpolant ) {\n\t\n\t\t\tvar interpolants = this._controlInterpolants,\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\t\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\t\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\t\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\t\n\t\t},\n\t\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\t\n\t} );\n\t\n\t// File:src/animation/AnimationObjectGroup.js\n\t\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\t\n\tTHREE.AnimationObjectGroup = function( var_args ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\t\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t\t// note: read by PropertyBinding.Composite\n\t\n\t\tvar indices = {};\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\t\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\t\n\t\t}\n\t\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\t\n\t\tvar scope = this;\n\t\n\t\tthis.stats = {\n\t\n\t\t\tobjects: {\n\t\t\t\tget total() { return scope._objects.length; },\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t\t},\n\t\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.AnimationObjectGroup.prototype = {\n\t\n\t\tconstructor: THREE.AnimationObjectGroup,\n\t\n\t\tadd: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tpaths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index === undefined ) {\n\t\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\n\t\t\t\t\tindex = nObjects ++;\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\t\tobjects.push( object );\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( index < nCachedObjects ) {\n\t\n\t\t\t\t\tvar knownObject = objects[ index ];\n\t\n\t\t\t\t\t// move existing object to the ACTIVE region\n\t\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\t\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\n\t\t\t\t\t\tif ( binding === undefined ) {\n\t\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\t\n\t\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\n\t\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\t\n\t\t\t\t} // else the object is already where we want it to be\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\tremove: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\t\n\t\t\t\t\t// move existing object into the CACHED region\n\t\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\t\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\n\t\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\n\t\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\t\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\t// remove & forget\n\t\tuncache: function( var_args ) {\n\t\n\t\t\tvar objects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tnBindings = bindings.length;\n\t\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = arguments[ i ],\n\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\n\t\n\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\n\t\n\t\t\t\t\tif ( index < nCachedObjects ) {\n\t\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\t\n\t\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\t\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\t\tobjects.pop();\n\t\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\n\t\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\t\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\t\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} // cached or active\n\t\n\t\t\t\t} // if object is known\n\t\n\t\t\t} // for arguments\n\t\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\n\t\t},\n\t\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\n\t\n\t\tsubscribe_: function( path, parsedPath ) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\t\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ],\n\t\t\t\tbindings = this._bindings;\n\t\n\t\t\tif ( index !== undefined ) return bindings[ index ];\n\t\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tobjects = this._objects,\n\t\t\t\tnObjects = objects.length,\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\tbindingsForPath = new Array( nObjects );\n\t\n\t\t\tindex = bindings.length;\n\t\n\t\t\tindicesByPath[ path ] = index;\n\t\n\t\t\tpaths.push( path );\n\t\t\tparsedPaths.push( parsedPath );\n\t\t\tbindings.push( bindingsForPath );\n\t\n\t\t\tfor ( var i = nCachedObjects,\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar object = objects[ i ];\n\t\n\t\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\t\n\t\t\t}\n\t\n\t\t\treturn bindingsForPath;\n\t\n\t\t},\n\t\n\t\tunsubscribe_: function( path ) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\t\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\tindex = indicesByPath[ path ];\n\t\n\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\tvar paths = this._paths,\n\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\t\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\t\n\t\t\t\tbindings[ index ] = lastBindings;\n\t\t\t\tbindings.pop();\n\t\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\t\tparsedPaths.pop();\n\t\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\t\tpaths.pop();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/animation/AnimationUtils.js\n\t\n\t/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\t\n\tTHREE.AnimationUtils = {\n\t\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function( array, from, to ) {\n\t\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\t\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn array.slice( from, to );\n\t\n\t\t},\n\t\n\t\t// converts an array to a specific type\n\t\tconvertArray: function( array, type, forceClone ) {\n\t\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\n\t\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\t\n\t\t\t\treturn new type( array ); // create typed array\n\t\n\t\t\t}\n\t\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\n\t\n\t\t},\n\t\n\t\tisTypedArray: function( object ) {\n\t\n\t\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t\t! ( object instanceof DataView );\n\t\n\t\t},\n\t\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function( times ) {\n\t\n\t\t\tfunction compareTime( i, j ) {\n\t\n\t\t\t\treturn times[ i ] - times[ j ];\n\t\n\t\t\t}\n\t\n\t\t\tvar n = times.length;\n\t\t\tvar result = new Array( n );\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\t\n\t\t\tresult.sort( compareTime );\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function( values, stride, order ) {\n\t\n\t\t\tvar nValues = values.length;\n\t\t\tvar result = new values.constructor( nValues );\n\t\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\t\n\t\t\t\tvar srcOffset = order[ i ] * stride;\n\t\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t},\n\t\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\t\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\n\t\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\t\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t}\n\t\n\t\t\tif ( key === undefined ) return; // no data\n\t\n\t\t\tvar value = key[ valuePropertyName ];\n\t\t\tif ( value === undefined ) return; // no data\n\t\n\t\t\tif ( Array.isArray( value ) ) {\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t\t// ...assume THREE.Math-ish\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalue.toArray( values, values.length );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\t\n\t\t\t\tdo {\n\t\n\t\t\t\t\tvalue = key[ valuePropertyName ];\n\t\n\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\t\tvalues.push( value );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\n\t\n\t\t\t\t} while ( key !== undefined );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/KeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\t\n\t\tif( times === undefined || times.length === 0 ) {\n\t\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\n\t\n\t\t}\n\t\n\t\tthis.name = name;\n\t\n\t\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\t\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\t\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\t\n\t\tthis.validate();\n\t\tthis.optimize();\n\t\n\t};\n\t\n\tTHREE.KeyframeTrack.prototype = {\n\t\n\t\tconstructor: THREE.KeyframeTrack,\n\t\n\t\tTimeBufferType: Float32Array,\n\t\tValueBufferType: Float32Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\n\t\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\n\t\n\t\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\treturn new THREE.LinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\n\t\n\t\t\treturn new THREE.CubicInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tsetInterpolation: function( interpolation ) {\n\t\n\t\t\tvar factoryMethod;\n\t\n\t\t\tswitch ( interpolation ) {\n\t\n\t\t\t\tcase THREE.InterpolateDiscrete:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.InterpolateLinear:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.InterpolateSmooth:\n\t\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\n\t\t\tif ( factoryMethod === undefined ) {\n\t\n\t\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\t\n\t\t\t\tif ( this.createInterpolant === undefined ) {\n\t\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\t\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tconsole.warn( message );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.createInterpolant = factoryMethod;\n\t\n\t\t},\n\t\n\t\tgetInterpolation: function() {\n\t\n\t\t\tswitch ( this.createInterpolant ) {\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\n\t\t\t\t\treturn THREE.InterpolateDiscrete;\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\n\t\t\t\t\treturn THREE.InterpolateLinear;\n\t\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\n\t\t\t\t\treturn THREE.InterpolateSmooth;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetValueSize: function() {\n\t\n\t\t\treturn this.values.length / this.times.length;\n\t\n\t\t},\n\t\n\t\t// move all keyframes either forwards or backwards in time\n\t\tshift: function( timeOffset ) {\n\t\n\t\t\tif( timeOffset !== 0.0 ) {\n\t\n\t\t\t\tvar times = this.times;\n\t\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttimes[ i ] += timeOffset;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\t\tscale: function( timeScale ) {\n\t\n\t\t\tif( timeScale !== 1.0 ) {\n\t\n\t\t\t\tvar times = this.times;\n\t\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\ttimes[ i ] *= timeScale;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\t\ttrim: function( startTime, endTime ) {\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tnKeys = times.length,\n\t\t\t\tfrom = 0,\n\t\t\t\tto = nKeys - 1;\n\t\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\t\n\t\t\t++ to; // inclusive -> exclusive bound\n\t\n\t\t\tif( from !== 0 || to !== nKeys ) {\n\t\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\t\n\t\t\t\tvar stride = this.getValueSize();\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\t\tvalidate: function() {\n\t\n\t\t\tvar valid = true;\n\t\n\t\t\tvar valueSize = this.getValueSize();\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\t\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\t\tvalid = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\n\t\t\t\tnKeys = times.length;\n\t\n\t\t\tif( nKeys === 0 ) {\n\t\n\t\t\t\tconsole.error( \"track is empty\", this );\n\t\t\t\tvalid = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar prevTime = null;\n\t\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\t\n\t\t\t\tvar currTime = times[ i ];\n\t\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\t\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\t\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprevTime = currTime;\n\t\n\t\t\t}\n\t\n\t\t\tif ( values !== undefined ) {\n\t\n\t\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\t\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tvar value = values[ i ];\n\t\n\t\t\t\t\t\tif ( isNaN( value ) ) {\n\t\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn valid;\n\t\n\t\t},\n\t\n\t\t// removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\t\toptimize: function() {\n\t\n\t\t\tvar times = this.times,\n\t\t\t\tvalues = this.values,\n\t\t\t\tstride = this.getValueSize(),\n\t\n\t\t\t\twriteIndex = 1;\n\t\n\t\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\t\n\t\t\t\tvar keep = false;\n\t\n\t\t\t\tvar time = times[ i ];\n\t\t\t\tvar timeNext = times[ i + 1 ];\n\t\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\n\t\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\t\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\t\tvar offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\t\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\tvar value = values[ offset + j ];\n\t\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\t\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// in-place compaction\n\t\n\t\t\t\tif ( keep ) {\n\t\n\t\t\t\t\tif ( i !== writeIndex ) {\n\t\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\t\n\t\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\t\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\t\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t++ writeIndex;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( writeIndex !== times.length ) {\n\t\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// Static methods:\n\t\n\tObject.assign( THREE.KeyframeTrack, {\n\t\n\t\t// Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\t\n\t\tparse: function( json ) {\n\t\n\t\t\tif( json.type === undefined ) {\n\t\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\t\n\t\t\t}\n\t\n\t\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\t\n\t\t\tif ( json.times === undefined ) {\n\t\n\t\t\t\tvar times = [], values = [];\n\t\n\t\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\t\n\t\t\t\tjson.times = times;\n\t\t\t\tjson.values = values;\n\t\n\t\t\t}\n\t\n\t\t\t// derived classes can define a static parse method\n\t\t\tif ( trackType.parse !== undefined ) {\n\t\n\t\t\t\treturn trackType.parse( json );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\t\treturn new trackType(\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function( track ) {\n\t\n\t\t\tvar trackType = track.constructor;\n\t\n\t\t\tvar json;\n\t\n\t\t\t// derived classes can define a static toJSON method\n\t\t\tif ( trackType.toJSON !== undefined ) {\n\t\n\t\t\t\tjson = trackType.toJSON( track );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\t\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\t\n\t\t\t\t};\n\t\n\t\t\t\tvar interpolation = track.getInterpolation();\n\t\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\t\n\t\t\t\t\tjson.interpolation = interpolation;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\t\n\t\t\treturn json;\n\t\n\t\t},\n\t\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\n\t\n\t\t\tswitch( typeName.toLowerCase() ) {\n\t\n\t\t\t\tcase \"scalar\":\n\t\t\t\tcase \"double\":\n\t\t\t\tcase \"float\":\n\t\t\t\tcase \"number\":\n\t\t\t\tcase \"integer\":\n\t\n\t\t\t\t\treturn THREE.NumberKeyframeTrack;\n\t\n\t\t\t\tcase \"vector\":\n\t\t\t\tcase \"vector2\":\n\t\t\t\tcase \"vector3\":\n\t\t\t\tcase \"vector4\":\n\t\n\t\t\t\t\treturn THREE.VectorKeyframeTrack;\n\t\n\t\t\t\tcase \"color\":\n\t\n\t\t\t\t\treturn THREE.ColorKeyframeTrack;\n\t\n\t\t\t\tcase \"quaternion\":\n\t\n\t\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\t\n\t\t\t\tcase \"bool\":\n\t\t\t\tcase \"boolean\":\n\t\n\t\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\t\n\t\t\t\tcase \"string\":\n\t\n\t\t\t\t\treturn THREE.StringKeyframeTrack;\n\t\n\t\t\t}\n\t\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/animation/PropertyBinding.js\n\t\n\t/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\t\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath ||\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\t\n\t\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\t\n\t\tthis.rootNode = rootNode;\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.prototype = {\n\t\n\t\tconstructor: THREE.PropertyBinding,\n\t\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\n\t\n\t\t\tthis.bind();\n\t\t\tthis.getValue( targetArray, offset );\n\t\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t\t// prototype version of these methods with one that represents\n\t\t\t// the bound state. When the property is not found, the methods\n\t\t\t// become no-ops.\n\t\n\t\t},\n\t\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\t\n\t\t\tthis.bind();\n\t\t\tthis.setValue( sourceArray, offset );\n\t\n\t\t},\n\t\n\t\t// create getter / setter pair for a property in the scene graph\n\t\tbind: function() {\n\t\n\t\t\tvar targetObject = this.node,\n\t\t\t\tparsedPath = this.parsedPath,\n\t\n\t\t\t\tobjectName = parsedPath.objectName,\n\t\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\t\n\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\t\n\t\t\t\tthis.node = targetObject;\n\t\n\t\t\t}\n\t\n\t\t\t// set fail state so we can just 'return' on error\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable;\n\t\n\t \t\t// ensure there is a value node\n\t\t\tif ( ! targetObject ) {\n\t\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( objectName ) {\n\t\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\n\t\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\t\tswitch ( objectName ) {\n\t\n\t\t\t\t\tcase 'materials':\n\t\n\t\t\t\t\t\tif ( ! targetObject.material ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'bones':\n\t\n\t\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\t\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\t\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\t\n\t\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\t\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\t\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tif ( objectIndex !== undefined ) {\n\t\n\t\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// resolve property\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\n\t\n\t\t\tif ( nodeProperty === undefined ) {\n\t\n\t\t\t\tvar nodeName = parsedPath.nodeName;\n\t\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\t// determine versioning scheme\n\t\t\tvar versioning = this.Versioning.None;\n\t\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\t\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\t\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t\tthis.targetObject = targetObject;\n\t\n\t\t\t}\n\t\n\t\t\t// determine how the property gets bound\n\t\t\tvar bindingType = this.BindingType.Direct;\n\t\n\t\t\tif ( propertyIndex !== undefined ) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif ( ! targetObject.geometry ) {\n\t\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\t\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\t\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\t\n\t\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\n\t\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.propertyName = propertyName;\n\t\n\t\t\t}\n\t\n\t\t\t// select getter / setter\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\t\n\t\t},\n\t\n\t\tunbind: function() {\n\t\n\t\t\tthis.node = null;\n\t\n\t\t\t// back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\t\n\t\t// these are used to \"bind\" a nonexistent property\n\t\t_getValue_unavailable: function() {},\n\t\t_setValue_unavailable: function() {},\n\t\n\t\t// initial state of these methods that calls 'bind'\n\t\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\t\n\t\tBindingType: {\n\t\t\tDirect: 0,\n\t\t\tEntireArray: 1,\n\t\t\tArrayElement: 2,\n\t\t\tHasFromToArray: 3\n\t\t},\n\t\n\t\tVersioning: {\n\t\t\tNone: 0,\n\t\t\tNeedsUpdate: 1,\n\t\t\tMatrixWorldNeedsUpdate: 2\n\t\t},\n\t\n\t\tGetterByBindingType: [\n\t\n\t\t\tfunction getValue_direct( buffer, offset ) {\n\t\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_array( buffer, offset ) {\n\t\n\t\t\t\tvar source = this.resolvedProperty;\n\t\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\t\n\t\t\t},\n\t\n\t\t\tfunction getValue_toArray( buffer, offset ) {\n\t\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\t\n\t\t\t}\n\t\n\t\t],\n\t\n\t\tSetterByBindingTypeAndVersioning: [\n\t\n\t\t\t[\n\t\t\t\t// Direct\n\t\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// EntireArray\n\t\n\t\t\t\tfunction setValue_array( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tvar dest = this.resolvedProperty;\n\t\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// ArrayElement\n\t\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t], [\n\t\n\t\t\t\t// HasToFromArray\n\t\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\t\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t]\n\t\n\t\t]\n\t\n\t} );\n\t\n\tTHREE.PropertyBinding.Composite =\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\t\n\t\tvar parsedPath = optionalParsedPath ||\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\t\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.Composite.prototype = {\n\t\n\t\tconstructor: THREE.PropertyBinding.Composite,\n\t\n\t\tgetValue: function( array, offset ) {\n\t\n\t\t\tthis.bind(); // bind all binding\n\t\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\n\t\n\t\t\t// and only call .getValue on the first\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\t\n\t\t},\n\t\n\t\tsetValue: function( array, offset ) {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].setValue( array, offset );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tbind: function() {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].bind();\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tunbind: function() {\n\t\n\t\t\tvar bindings = this._bindings;\n\t\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\t\n\t\t\t\tbindings[ i ].unbind();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\t\n\t\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\t\n\t\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\t\n\t\t} else {\n\t\n\t\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\t\n\t\t// matches strings in the form of:\n\t\t//    nodeName.property\n\t\t//    nodeName.property[accessor]\n\t\t//    nodeName.material.property[accessor]\n\t\t//    uuid.property[accessor]\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t\t//    parentName/nodeName.property\n\t\t//    parentName/parentName/nodeName.property[index]\n\t\t//\t  .bone[Armature.DEF_cog].position\n\t\t// created and tested via https://regex101.com/#javascript\n\t\n\t\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\t\tvar matches = re.exec( trackName );\n\t\n\t\tif ( ! matches ) {\n\t\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\t\n\t\t}\n\t\n\t\tif ( matches.index === re.lastIndex ) {\n\t\n\t\t\tre.lastIndex++;\n\t\n\t\t}\n\t\n\t\tvar results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\t\tobjectName: matches[ 5 ],\n\t\t\tobjectIndex: matches[ 7 ],\n\t\t\tpropertyName: matches[ 9 ],\n\t\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t\t};\n\t\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\t\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\t\n\t\t}\n\t\n\t\treturn results;\n\t\n\t};\n\t\n\tTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\t\n\t\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\t\n\t\t\treturn root;\n\t\n\t\t}\n\t\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\t\n\t\t\tvar searchSkeleton = function( skeleton ) {\n\t\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\t\n\t\t\t\t\tvar bone = skeleton.bones[ i ];\n\t\n\t\t\t\t\tif ( bone.name === nodeName ) {\n\t\n\t\t\t\t\t\treturn bone;\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t};\n\t\n\t\t\tvar bone = searchSkeleton( root.skeleton );\n\t\n\t\t\tif ( bone ) {\n\t\n\t\t\t\treturn bone;\n\t\n\t\t\t}\n\t\t}\n\t\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\t\n\t\t\tvar searchNodeSubtree = function( children ) {\n\t\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\t\n\t\t\t\t\tvar childNode = children[ i ];\n\t\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\t\n\t\t\t\t\t\treturn childNode;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\t\n\t\t\t\t\tif ( result ) return result;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn null;\n\t\n\t\t\t};\n\t\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\t\n\t\t\tif ( subTreeNode ) {\n\t\n\t\t\t\treturn subTreeNode;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\treturn null;\n\t\n\t};\n\t\n\t// File:src/animation/PropertyMixer.js\n\t\n\t/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\t\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\t\n\t\tvar bufferType = Float64Array,\n\t\t\tmixFunction;\n\t\n\t\tswitch ( typeName ) {\n\t\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\t\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\t\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\t\n\t\t}\n\t\n\t\tthis.buffer = new bufferType( valueSize * 4 );\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\n\t\tthis._mixBufferRegion = mixFunction;\n\t\n\t\tthis.cumulativeWeight = 0;\n\t\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\t\n\t};\n\t\n\tTHREE.PropertyMixer.prototype = {\n\t\n\t\tconstructor: THREE.PropertyMixer,\n\t\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\n\t\taccumulate: function( accuIndex, weight ) {\n\t\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\t\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\n\t\n\t\t\tif ( currentWeight === 0 ) {\n\t\n\t\t\t\t// accuN := incoming * weight\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentWeight = weight;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// accuN := accuN + incoming * weight\n\t\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tvar mix = weight / currentWeight;\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\t\n\t\t\t}\n\t\n\t\t\tthis.cumulativeWeight = currentWeight;\n\t\n\t\t},\n\t\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\n\t\tapply: function( accuIndex ) {\n\t\n\t\t\tvar stride = this.valueSize,\n\t\t\t\tbuffer = this.buffer,\n\t\t\t\toffset = accuIndex * stride + stride,\n\t\n\t\t\t\tweight = this.cumulativeWeight,\n\t\n\t\t\t\tbinding = this.binding;\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t\tif ( weight < 1 ) {\n\t\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\n\t\t\t\tvar originalValueOffset = stride * 3;\n\t\n\t\t\t\tthis._mixBufferRegion(\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\t\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\t\n\t\t\t\t\t// value has changed -> update scene graph\n\t\n\t\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// remember the state of the bound property and copy it to both accus\n\t\tsaveOriginalState: function() {\n\t\n\t\t\tvar binding = this.binding;\n\t\n\t\t\tvar buffer = this.buffer,\n\t\t\t\tstride = this.valueSize,\n\t\n\t\t\t\toriginalValueOffset = stride * 3;\n\t\n\t\t\tbinding.getValue( buffer, originalValueOffset );\n\t\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\t\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\t\n\t\t\t}\n\t\n\t\t\tthis.cumulativeWeight = 0;\n\t\n\t\t},\n\t\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\n\t\trestoreOriginalState: function() {\n\t\n\t\t\tvar originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\t\n\t\t},\n\t\n\t\n\t\t// mix functions\n\t\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tif ( t >= 0.5 ) {\n\t\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\t\n\t\t},\n\t\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\t\n\t\t\tvar s = 1 - t;\n\t\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\t\n\t\t\t\tvar j = dstOffset + i;\n\t\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/animation/tracks/BooleanKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values );\n\t\n\t};\n\t\n\tTHREE.BooleanKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.BooleanKeyframeTrack,\n\t\n\t\tValueTypeName: 'bool',\n\t\tValueBufferType: Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\t\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t\t// Note: Actually this track could have a optimized / compressed\n\t\t// representation of a single value and a custom interpolant that\n\t\t// computes \"firstValue ^ isOdd( index )\".\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/ColorKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.ColorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.ColorKeyframeTrack,\n\t\n\t\tValueTypeName: 'color'\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t\n\t\t// Note: Very basic implementation and nothing special yet.\n\t\t// However, this is the place for color space parameterization.\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/NumberKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.NumberKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.NumberKeyframeTrack,\n\t\n\t\tValueTypeName: 'number',\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.QuaternionKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.QuaternionKeyframeTrack,\n\t\n\t\tValueTypeName: 'quaternion',\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\n\t\n\t\tInterpolantFactoryMethodLinear: function( result ) {\n\t\n\t\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\t\n\t\t},\n\t\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/StringKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.StringKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.StringKeyframeTrack,\n\t\n\t\tValueTypeName: 'string',\n\t\tValueBufferType: Array,\n\t\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\t\n\t\tInterpolantFactoryMethodLinear: undefined,\n\t\n\t\tInterpolantFactoryMethodSmooth: undefined\n\t\n\t} );\n\t\n\t// File:src/animation/tracks/VectorKeyframeTrack.js\n\t\n\t/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\t\n\tTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\t\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\t\n\t};\n\t\n\tTHREE.VectorKeyframeTrack.prototype =\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\t\n\t\tconstructor: THREE.VectorKeyframeTrack,\n\t\n\t\tValueTypeName: 'vector'\n\t\n\t\t// ValueBufferType is inherited\n\t\n\t\t// DefaultInterpolation is inherited\n\t\n\t} );\n\t\n\t// File:src/audio/Audio.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\t\n\tTHREE.Audio = function ( listener ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Audio';\n\t\n\t\tthis.context = listener.context;\n\t\tthis.source = this.context.createBufferSource();\n\t\tthis.source.onended = this.onEnded.bind( this );\n\t\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\t\n\t\tthis.autoplay = false;\n\t\n\t\tthis.startTime = 0;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.sourceType = 'empty';\n\t\n\t\tthis.filters = [];\n\t\n\t};\n\t\n\tTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Audio,\n\t\n\t\tgetOutput: function () {\n\t\n\t\t\treturn this.gain;\n\t\n\t\t},\n\t\n\t\tsetNodeSource: function ( audioNode ) {\n\t\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetBuffer: function ( audioBuffer ) {\n\t\n\t\t\tthis.source.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\t\n\t\t\tif ( this.autoplay ) this.play();\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tplay: function () {\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar source = this.context.createBufferSource();\n\t\n\t\t\tsource.buffer = this.source.buffer;\n\t\t\tsource.loop = this.source.loop;\n\t\t\tsource.onended = this.source.onended;\n\t\t\tsource.start( 0, this.startTime );\n\t\t\tsource.playbackRate.value = this.playbackRate;\n\t\n\t\t\tthis.isPlaying = true;\n\t\n\t\t\tthis.source = source;\n\t\n\t\t\treturn this.connect();\n\t\n\t\t},\n\t\n\t\tpause: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = this.context.currentTime;\n\t\t\tthis.isPlaying = false;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tstop: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.stop();\n\t\t\tthis.startTime = 0;\n\t\t\tthis.isPlaying = false;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tconnect: function () {\n\t\n\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\n\t\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.source.connect( this.getOutput() );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdisconnect: function () {\n\t\n\t\t\tif ( this.filters.length > 0 ) {\n\t\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\t\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.source.disconnect( this.getOutput() );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetFilters: function () {\n\t\n\t\t\treturn this.filters;\n\t\n\t\t},\n\t\n\t\tsetFilters: function ( value ) {\n\t\n\t\t\tif ( ! value ) value = [];\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value;\n\t\t\t\tthis.connect();\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.filters = value;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetFilter: function () {\n\t\n\t\t\treturn this.getFilters()[ 0 ];\n\t\n\t\t},\n\t\n\t\tsetFilter: function ( filter ) {\n\t\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\t\n\t\t},\n\t\n\t\tsetPlaybackRate: function ( value ) {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.playbackRate = value;\n\t\n\t\t\tif ( this.isPlaying === true ) {\n\t\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tgetPlaybackRate: function () {\n\t\n\t\t\treturn this.playbackRate;\n\t\n\t\t},\n\t\n\t\tonEnded: function () {\n\t\n\t\t\tthis.isPlaying = false;\n\t\n\t\t},\n\t\n\t\tgetLoop: function () {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn false;\n\t\n\t\t\t}\n\t\n\t\t\treturn this.source.loop;\n\t\n\t\t},\n\t\n\t\tsetLoop: function ( value ) {\n\t\n\t\t\tif ( this.hasPlaybackControl === false ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tthis.source.loop = value;\n\t\n\t\t},\n\t\n\t\tgetVolume: function () {\n\t\n\t\t\treturn this.gain.gain.value;\n\t\n\t\t},\n\t\n\t\n\t\tsetVolume: function ( value ) {\n\t\n\t\t\tthis.gain.gain.value = value;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/audio/AudioAnalyser.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\t\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\t\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\t\n\t\taudio.getOutput().connect( this.analyser );\n\t\n\t};\n\t\n\tObject.assign( THREE.AudioAnalyser.prototype, {\n\t\n\t\tgetFrequencyData: function () {\n\t\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\n\t\n\t\t\treturn this.data;\n\t\n\t\t},\n\t\n\t\tgetAverageFrequency: function () {\n\t\n\t\t\tvar value = 0, data = this.getFrequencyData();\n\t\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\t\n\t\t\t\tvalue += data[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn value / data.length;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/audio/AudioContext.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tObject.defineProperty( THREE, 'AudioContext', {\n\t\n\t\tget: ( function () {\n\t\n\t\t\tvar context;\n\t\n\t\t\treturn function get() {\n\t\n\t\t\t\tif ( context === undefined ) {\n\t\n\t\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn context;\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/audio/PositionalAudio.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.PositionalAudio = function ( listener ) {\n\t\n\t\tTHREE.Audio.call( this, listener );\n\t\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.connect( this.gain );\n\t\n\t};\n\t\n\tTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\t\n\t\tconstructor: THREE.PositionalAudio,\n\t\n\t\tgetOutput: function () {\n\t\n\t\t\treturn this.panner;\n\t\n\t\t},\n\t\n\t\tgetRefDistance: function () {\n\t\n\t\t\treturn this.panner.refDistance;\n\t\n\t\t},\n\t\n\t\tsetRefDistance: function ( value ) {\n\t\n\t\t\tthis.panner.refDistance = value;\n\t\n\t\t},\n\t\n\t\tgetRolloffFactor: function () {\n\t\n\t\t\treturn this.panner.rolloffFactor;\n\t\n\t\t},\n\t\n\t\tsetRolloffFactor: function ( value ) {\n\t\n\t\t\tthis.panner.rolloffFactor = value;\n\t\n\t\t},\n\t\n\t\tgetDistanceModel: function () {\n\t\n\t\t\treturn this.panner.distanceModel;\n\t\n\t\t},\n\t\n\t\tsetDistanceModel: function ( value ) {\n\t\n\t\t\tthis.panner.distanceModel = value;\n\t\n\t\t},\n\t\n\t\tgetMaxDistance: function () {\n\t\n\t\t\treturn this.panner.maxDistance;\n\t\n\t\t},\n\t\n\t\tsetMaxDistance: function ( value ) {\n\t\n\t\t\tthis.panner.maxDistance = value;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t\n\t} );\n\t\n\t// File:src/audio/AudioListener.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AudioListener = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'AudioListener';\n\t\n\t\tthis.context = THREE.AudioContext;\n\t\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\t\n\t\tthis.filter = null;\n\t\n\t};\n\t\n\tTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.AudioListener,\n\t\n\t\tgetInput: function () {\n\t\n\t\t\treturn this.gain;\n\t\n\t\t},\n\t\n\t\tremoveFilter: function ( ) {\n\t\n\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\t\tthis.gain.connect( this.context.destination );\n\t\t\t\tthis.filter = null;\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetFilter: function () {\n\t\n\t\t\treturn this.filter;\n\t\n\t\t},\n\t\n\t\tsetFilter: function ( value ) {\n\t\n\t\t\tif ( this.filter !== null ) {\n\t\n\t\t\t\tthis.gain.disconnect( this.filter );\n\t\t\t\tthis.filter.disconnect( this.context.destination );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.gain.disconnect( this.context.destination );\n\t\n\t\t\t}\n\t\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect( this.filter );\n\t\t\tthis.filter.connect( this.context.destination );\n\t\n\t\t},\n\t\n\t\tgetMasterVolume: function () {\n\t\n\t\t\treturn this.gain.gain.value;\n\t\n\t\t},\n\t\n\t\tsetMasterVolume: function ( value ) {\n\t\n\t\t\tthis.gain.gain.value = value;\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: ( function () {\n\t\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar scale = new THREE.Vector3();\n\t\n\t\t\tvar orientation = new THREE.Vector3();\n\t\n\t\t\treturn function updateMatrixWorld( force ) {\n\t\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\t\n\t\t\t\tvar listener = this.context.listener;\n\t\t\t\tvar up = this.up;\n\t\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\t\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/cameras/Camera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.Camera = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Camera';\n\t\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\n\t\tthis.projectionMatrix = new THREE.Matrix4();\n\t\n\t};\n\t\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\n\t\n\tTHREE.Camera.prototype.getWorldDirection = function () {\n\t\n\t\tvar quaternion = new THREE.Quaternion();\n\t\n\t\treturn function getWorldDirection( optionalTarget ) {\n\t\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\n\t\t\tthis.getWorldQuaternion( quaternion );\n\t\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Camera.prototype.lookAt = function () {\n\t\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\n\t\n\t\tvar m1 = new THREE.Matrix4();\n\t\n\t\treturn function lookAt( vector ) {\n\t\n\t\t\tm1.lookAt( this.position, vector, this.up );\n\t\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\t\n\t\t};\n\t\n\t}();\n\t\n\tTHREE.Camera.prototype.clone = function () {\n\t\n\t\treturn new this.constructor().copy( this );\n\t\n\t};\n\t\n\tTHREE.Camera.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/cameras/CubeCamera.js\n\t\n\t/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'CubeCamera';\n\t\n\t\tvar fov = 90, aspect = 1;\n\t\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\t\tthis.add( cameraPX );\n\t\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\t\tthis.add( cameraNX );\n\t\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.up.set( 0, 0, 1 );\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\t\tthis.add( cameraPY );\n\t\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\t\tthis.add( cameraNY );\n\t\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\t\tthis.add( cameraPZ );\n\t\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\t\tthis.add( cameraNZ );\n\t\n\t\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\t\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\t\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\n\t\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\t\n\t\t\tvar renderTarget = this.renderTarget;\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\n\t\t\trenderTarget.activeCubeFace = 0;\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 1;\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 2;\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 3;\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\n\t\n\t\t\trenderTarget.activeCubeFace = 4;\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\n\t\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\n\t\t\trenderTarget.activeCubeFace = 5;\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\n\t\n\t\t\trenderer.setRenderTarget( null );\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\t\n\t// File:src/cameras/OrthographicCamera.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\t\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\t\n\t\tTHREE.Camera.call( this );\n\t\n\t\tthis.type = 'OrthographicCamera';\n\t\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\t\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\t\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\n\t\n\t\tthis.updateProjectionMatrix();\n\t\n\t};\n\t\n\tTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\t\n\t\tconstructor: THREE.OrthographicCamera,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\n\t\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tclearViewOffset: function() {\n\t\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\t\tvar cx = ( this.right + this.left ) / 2;\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\n\t\n\t\t\tvar left = cx - dx;\n\t\t\tvar right = cx + dx;\n\t\t\tvar top = cy + dy;\n\t\t\tvar bottom = cy - dy;\n\t\n\t\t\tif ( this.view !== null ) {\n\t\n\t\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\t\n\t\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\t\n\t\t\t}\n\t\n\t\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/cameras/PerspectiveCamera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\t\n\tTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\t\n\t\tTHREE.Camera.call( this );\n\t\n\t\tthis.type = 'PerspectiveCamera';\n\t\n\t\tthis.fov = fov !== undefined ? fov : 50;\n\t\tthis.zoom = 1;\n\t\n\t\tthis.near = near !== undefined ? near : 0.1;\n\t\tthis.far = far !== undefined ? far : 2000;\n\t\tthis.focus = 10;\n\t\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\n\t\tthis.view = null;\n\t\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\t\n\t\tthis.updateProjectionMatrix();\n\t\n\t};\n\t\n\tTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\t\n\t\tconstructor: THREE.PerspectiveCamera,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\n\t\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\t\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\t\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\t\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\t\tsetFocalLength: function ( focalLength ) {\n\t\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\n\t\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\t\tgetFocalLength: function () {\n\t\n\t\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\t\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\n\t\t},\n\t\n\t\tgetEffectiveFOV: function () {\n\t\n\t\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\t\n\t\t},\n\t\n\t\tgetFilmWidth: function () {\n\t\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\t\n\t\t},\n\t\n\t\tgetFilmHeight: function () {\n\t\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\t\n\t\t},\n\t\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\t\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\t\n\t\t\tthis.view = {\n\t\t\t\tfullWidth: fullWidth,\n\t\t\t\tfullHeight: fullHeight,\n\t\t\t\toffsetX: x,\n\t\t\t\toffsetY: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tclearViewOffset: function() {\n\t\n\t\t\tthis.view = null;\n\t\t\tthis.updateProjectionMatrix();\n\t\n\t\t},\n\t\n\t\tupdateProjectionMatrix: function () {\n\t\n\t\t\tvar near = this.near,\n\t\t\t\ttop = near * Math.tan(\n\t\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\t\theight = 2 * top,\n\t\t\t\twidth = this.aspect * height,\n\t\t\t\tleft = - 0.5 * width,\n\t\t\t\tview = this.view;\n\t\n\t\t\tif ( view !== null ) {\n\t\n\t\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\t\tfullHeight = view.fullHeight;\n\t\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\t\n\t\t\t}\n\t\n\t\t\tvar skew = this.filmOffset;\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\t\n\t\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\t\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\t\n\t\t\tdata.object.aspect = this.aspect;\n\t\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\t\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/cameras/StereoCamera.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.StereoCamera = function () {\n\t\n\t\tthis.type = 'StereoCamera';\n\t\n\t\tthis.aspect = 1;\n\t\n\t\tthis.cameraL = new THREE.PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\n\t\tthis.cameraR = new THREE.PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.StereoCamera.prototype, {\n\t\n\t\tupdate: ( function () {\n\t\n\t\t\tvar focus, fov, aspect, near, far;\n\t\n\t\t\tvar eyeRight = new THREE.Matrix4();\n\t\t\tvar eyeLeft = new THREE.Matrix4();\n\t\n\t\t\treturn function update( camera ) {\n\t\n\t\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\t\n\t\t\t\tif ( needsUpdate ) {\n\t\n\t\t\t\t\tfocus = camera.focus;\n\t\t\t\t\tfov = camera.fov;\n\t\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\t\tnear = camera.near;\n\t\t\t\t\tfar = camera.far;\n\t\n\t\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\t\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\t\tvar xmin, xmax;\n\t\n\t\t\t\t\t// translate xOffset\n\t\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\t\n\t\t\t\t\t// for left eye\n\t\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\t\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t\t// for right eye\n\t\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\t\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\t\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t} );\n\t\n\t// File:src/lights/Light.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Light = function ( color, intensity ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Light';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\n\t\n\t\tthis.receiveShadow = undefined;\n\t\n\t};\n\t\n\tTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Light,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.color.copy( source.color );\n\t\t\tthis.intensity = source.intensity;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\t\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\t\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/LightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LightShadow = function ( camera ) {\n\t\n\t\tthis.camera = camera;\n\t\n\t\tthis.bias = 0;\n\t\tthis.radius = 1;\n\t\n\t\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\t\n\t\tthis.map = null;\n\t\tthis.matrix = new THREE.Matrix4();\n\t\n\t};\n\t\n\tObject.assign( THREE.LightShadow.prototype, {\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.camera = source.camera.clone();\n\t\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\t\n\t\t\tthis.mapSize.copy( source.mapSize );\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/AmbientLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AmbientLight = function ( color, intensity ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'AmbientLight';\n\t\n\t\tthis.castShadow = undefined;\n\t\n\t};\n\t\n\tTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.AmbientLight\n\t\n\t} );\n\t\n\t// File:src/lights/DirectionalLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.DirectionalLight = function ( color, intensity ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'DirectionalLight';\n\t\n\t\tthis.position.copy( THREE.Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.target = new THREE.Object3D();\n\t\n\t\tthis.shadow = new THREE.DirectionalLightShadow();\n\t\n\t};\n\t\n\tTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.DirectionalLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.target = source.target.clone();\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/DirectionalLightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.DirectionalLightShadow = function ( light ) {\n\t\n\t\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\t\n\t\tconstructor: THREE.DirectionalLightShadow\n\t\n\t} );\n\t\n\t// File:src/lights/HemisphereLight.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\t\n\t\tTHREE.Light.call( this, skyColor, intensity );\n\t\n\t\tthis.type = 'HemisphereLight';\n\t\n\t\tthis.castShadow = undefined;\n\t\n\t\tthis.position.copy( THREE.Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.groundColor = new THREE.Color( groundColor );\n\t\n\t};\n\t\n\tTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.HemisphereLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.groundColor.copy( source.groundColor );\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/PointLight.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\t\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'PointLight';\n\t\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * 4 * Math.PI;\n\t\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.PointLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/SpotLight.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\t\n\t\tTHREE.Light.call( this, color, intensity );\n\t\n\t\tthis.type = 'SpotLight';\n\t\n\t\tthis.position.copy( THREE.Object3D.DefaultUp );\n\t\tthis.updateMatrix();\n\t\n\t\tthis.target = new THREE.Object3D();\n\t\n\t\tObject.defineProperty( this, 'power', {\n\t\t\tget: function () {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\treturn this.intensity * Math.PI;\n\t\t\t},\n\t\t\tset: function ( power ) {\n\t\t\t\t// intensity = power per solid angle.\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\t\tthis.intensity = power / Math.PI;\n\t\t\t}\n\t\t} );\n\t\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\t\n\t\tthis.shadow = new THREE.SpotLightShadow();\n\t\n\t};\n\t\n\tTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\t\n\t\tconstructor: THREE.SpotLight,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\n\t\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\t\n\t\t\tthis.target = source.target.clone();\n\t\n\t\t\tthis.shadow = source.shadow.clone();\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/lights/SpotLightShadow.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.SpotLightShadow = function () {\n\t\n\t\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\t\n\t};\n\t\n\tTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\t\n\t\tconstructor: THREE.SpotLightShadow,\n\t\n\t\tupdate: function ( light ) {\n\t\n\t\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tvar far = light.distance || 500;\n\t\n\t\t\tvar camera = this.camera;\n\t\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\t\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/AudioLoader.js\n\t\n\t/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\t\n\tTHREE.AudioLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.AudioLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\tvar context = THREE.AudioContext;\n\t\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\t\n\t\t\t\t\tonLoad( audioBuffer );\n\t\n\t\t\t\t} );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/Cache.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Cache = {\n\t\n\t\tenabled: false,\n\t\n\t\tfiles: {},\n\t\n\t\tadd: function ( key, file ) {\n\t\n\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\t\n\t\t\tthis.files[ key ] = file;\n\t\n\t\t},\n\t\n\t\tget: function ( key ) {\n\t\n\t\t\tif ( this.enabled === false ) return;\n\t\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\t\n\t\t\treturn this.files[ key ];\n\t\n\t\t},\n\t\n\t\tremove: function ( key ) {\n\t\n\t\t\tdelete this.files[ key ];\n\t\n\t\t},\n\t\n\t\tclear: function () {\n\t\n\t\t\tthis.files = {};\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/loaders/Loader.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Loader = function () {\n\t\n\t\tthis.onLoadStart = function () {};\n\t\tthis.onLoadProgress = function () {};\n\t\tthis.onLoadComplete = function () {};\n\t\n\t};\n\t\n\tTHREE.Loader.prototype = {\n\t\n\t\tconstructor: THREE.Loader,\n\t\n\t\tcrossOrigin: undefined,\n\t\n\t\textractUrlBase: function ( url ) {\n\t\n\t\t\tvar parts = url.split( '/' );\n\t\n\t\t\tif ( parts.length === 1 ) return './';\n\t\n\t\t\tparts.pop();\n\t\n\t\t\treturn parts.join( '/' ) + '/';\n\t\n\t\t},\n\t\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\t\n\t\t\tvar array = [];\n\t\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\t\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\t\n\t\t\t}\n\t\n\t\t\treturn array;\n\t\n\t\t},\n\t\n\t\tcreateMaterial: ( function () {\n\t\n\t\t\tvar color, textureLoader, materialLoader;\n\t\n\t\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\t\n\t\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\t\n\t\t\t\t// convert from old material format\n\t\n\t\t\t\tvar textures = {};\n\t\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\t\n\t\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\t\n\t\t\t\t\tvar texture;\n\t\n\t\t\t\t\tif ( loader !== null ) {\n\t\n\t\t\t\t\t\ttexture = loader.load( fullPath );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( repeat !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\t\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( offset !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( wrap !== undefined ) {\n\t\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\t\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( anisotropy !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\t\n\t\t\t\t\ttextures[ uuid ] = texture;\n\t\n\t\t\t\t\treturn uuid;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t\t};\n\t\n\t\t\t\tfor ( var name in m ) {\n\t\n\t\t\t\t\tvar value = m[ name ];\n\t\n\t\t\t\t\tswitch ( name ) {\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\t\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\t\n\t\t\t\tmaterialLoader.setTextures( textures );\n\t\n\t\t\t\treturn materialLoader.parse( json );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t};\n\t\n\tTHREE.Loader.Handlers = {\n\t\n\t\thandlers: [],\n\t\n\t\tadd: function ( regex, loader ) {\n\t\n\t\t\tthis.handlers.push( regex, loader );\n\t\n\t\t},\n\t\n\t\tget: function ( file ) {\n\t\n\t\t\tvar handlers = this.handlers;\n\t\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\t\n\t\t\t\tvar regex = handlers[ i ];\n\t\t\t\tvar loader  = handlers[ i + 1 ];\n\t\n\t\t\t\tif ( regex.test( file ) ) {\n\t\n\t\t\t\t\treturn loader;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/loaders/XHRLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.XHRLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.XHRLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar cached = THREE.Cache.get( url );\n\t\n\t\t\tif ( cached !== undefined ) {\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\tsetTimeout( function () {\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( cached );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t}, 0 );\n\t\n\t\t\t\treturn cached;\n\t\n\t\t\t}\n\t\n\t\t\tvar request = new XMLHttpRequest();\n\t\t\trequest.overrideMimeType( 'text/plain' );\n\t\t\trequest.open( 'GET', url, true );\n\t\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\t\n\t\t\t\tvar response = event.target.response;\n\t\n\t\t\t\tTHREE.Cache.add( url, response );\n\t\n\t\t\t\tif ( this.status === 200 ) {\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} else if ( this.status === 0 ) {\n\t\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\n\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( response );\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t\t}\n\t\n\t\t\t}, false );\n\t\n\t\t\tif ( onProgress !== undefined ) {\n\t\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\t\n\t\t\t\t\tonProgress( event );\n\t\n\t\t\t\t}, false );\n\t\n\t\t\t}\n\t\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\t\n\t\t\t\tif ( onError ) onError( event );\n\t\n\t\t\t\tscope.manager.itemError( url );\n\t\n\t\t\t}, false );\n\t\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\t\n\t\t\trequest.send( null );\n\t\n\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\treturn request;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetResponseType: function ( value ) {\n\t\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetWithCredentials: function ( value ) {\n\t\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/FontLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.FontLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.FontLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tvar json;\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tjson = JSON.parse( text );\n\t\n\t\t\t\t} catch ( e ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar font = scope.parse( json );\n\t\n\t\t\t\tif ( onLoad ) onLoad( font );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\treturn new THREE.Font( json );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/ImageLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ImageLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.ImageLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\t\timage.onload = function () {\n\t\n\t\t\t\tURL.revokeObjectURL( image.src );\n\t\n\t\t\t\tif ( onLoad ) onLoad( image );\n\t\n\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t};\n\t\n\t\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\t\n\t\t\t\timage.src = url;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar loader = new THREE.XHRLoader();\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'blob' );\n\t\t\t\tloader.load( url, function ( blob ) {\n\t\n\t\t\t\t\timage.src = URL.createObjectURL( blob );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\treturn image;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/JSONLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.JSONLoader = function ( manager ) {\n\t\n\t\tif ( typeof manager === 'boolean' ) {\n\t\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\t\n\t\t}\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\tthis.withCredentials = false;\n\t\n\t};\n\t\n\tObject.assign( THREE.JSONLoader.prototype, {\n\t\n\t\tload: function( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\t\n\t\t\t\tif ( metadata !== undefined ) {\n\t\n\t\t\t\t\tvar type = metadata.type;\n\t\n\t\t\t\t\tif ( type !== undefined ) {\n\t\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\t\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\tthis.texturePath = value;\n\t\n\t\t},\n\t\n\t\tparse: function ( json, texturePath ) {\n\t\n\t\t\tvar geometry = new THREE.Geometry(),\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\t\n\t\t\tparseModel( scale );\n\t\n\t\t\tparseSkin();\n\t\t\tparseMorphing( scale );\n\t\t\tparseAnimations();\n\t\n\t\t\tgeometry.computeFaceNormals();\n\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\tfunction parseModel( scale ) {\n\t\n\t\t\t\tfunction isBitSet( value, position ) {\n\t\n\t\t\t\t\treturn value & ( 1 << position );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar i, j, fi,\n\t\n\t\t\t\toffset, zLength,\n\t\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\t\n\t\t\t\ttype,\n\t\t\t\tisQuad,\n\t\t\t\thasMaterial,\n\t\t\t\thasFaceVertexUv,\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\thasFaceColor, hasFaceVertexColor,\n\t\n\t\t\tvertex, face, faceA, faceB, hex, normal,\n\t\n\t\t\t\tuvLayer, uv, u, v,\n\t\n\t\t\t\tfaces = json.faces,\n\t\t\t\tvertices = json.vertices,\n\t\t\t\tnormals = json.normals,\n\t\t\t\tcolors = json.colors,\n\t\n\t\t\t\tnUvLayers = 0;\n\t\n\t\t\t\tif ( json.uvs !== undefined ) {\n\t\n\t\t\t\t\t// disregard empty arrays\n\t\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\t\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\t\n\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\tvertex = new THREE.Vector3();\n\t\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\t\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\t\n\t\t\t\t}\n\t\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\t\n\t\t\t\twhile ( offset < zLength ) {\n\t\n\t\t\t\t\ttype = faces[ offset ++ ];\n\t\n\t\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\t\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\t\n\t\t\t\t\tif ( isQuad ) {\n\t\n\t\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\t\n\t\t\t\t\t\toffset += 4;\n\t\n\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\t\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\t\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\t\n\t\t\t\t\t\tif ( hasMaterial ) {\n\t\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\t\n\t\t\t\t\t\tfi = geometry.faces.length;\n\t\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\t\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\t\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\t\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\t\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\t\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\t\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\t\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\t\n\t\t\t\t\t\t}\n\t\n\t\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\t\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\t\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tgeometry.faces.push( face );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseSkin() {\n\t\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\t\n\t\t\t\tif ( json.skinWeights ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.skinIndices ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\t\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\t\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.bones = json.bones;\n\t\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\t\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseMorphing( scale ) {\n\t\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\t\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\t\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\t\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\t\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\t\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\t\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction parseAnimations() {\n\t\n\t\t\t\tvar outputAnimations = [];\n\t\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\t\n\t\t\t\tif ( json.animation !== undefined ) {\n\t\n\t\t\t\t\tanimations.push( json.animation );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( json.animations !== undefined ) {\n\t\n\t\t\t\t\tif ( json.animations.length ) {\n\t\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tanimations.push( json.animations );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\t\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\t\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\t\n\t\t\t\treturn { geometry: geometry };\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\t\n\t\t\t\treturn { geometry: geometry, materials: materials };\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/LoadingManager.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\t\n\t\tvar scope = this;\n\t\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\t\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\t\n\t\tthis.itemStart = function ( url ) {\n\t\n\t\t\titemsTotal ++;\n\t\n\t\t\tif ( isLoading === false ) {\n\t\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\t\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tisLoading = true;\n\t\n\t\t};\n\t\n\t\tthis.itemEnd = function ( url ) {\n\t\n\t\t\titemsLoaded ++;\n\t\n\t\t\tif ( scope.onProgress !== undefined ) {\n\t\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\t\n\t\t\t}\n\t\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\t\n\t\t\t\tisLoading = false;\n\t\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\t\n\t\t\t\t\tscope.onLoad();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.itemError = function ( url ) {\n\t\n\t\t\tif ( scope.onError !== undefined ) {\n\t\n\t\t\t\tscope.onError( url );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\t\n\t// File:src/loaders/BufferGeometryLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BufferGeometryLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.BufferGeometryLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\t\tvar index = json.data.index;\n\t\n\t\t\tvar TYPED_ARRAYS = {\n\t\t\t\t'Int8Array': Int8Array,\n\t\t\t\t'Uint8Array': Uint8Array,\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t\t'Int16Array': Int16Array,\n\t\t\t\t'Uint16Array': Uint16Array,\n\t\t\t\t'Int32Array': Int32Array,\n\t\t\t\t'Uint32Array': Uint32Array,\n\t\t\t\t'Float32Array': Float32Array,\n\t\t\t\t'Float64Array': Float64Array\n\t\t\t};\n\t\n\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = json.data.attributes;\n\t\n\t\t\tfor ( var key in attributes ) {\n\t\n\t\t\t\tvar attribute = attributes[ key ];\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\t\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\t\n\t\t\t}\n\t\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\t\n\t\t\tif ( groups !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar group = groups[ i ];\n\t\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar boundingSphere = json.data.boundingSphere;\n\t\n\t\t\tif ( boundingSphere !== undefined ) {\n\t\n\t\t\t\tvar center = new THREE.Vector3();\n\t\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\n\t\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/MaterialLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.MaterialLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.textures = {};\n\t\n\t};\n\t\n\tObject.assign( THREE.MaterialLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTextures: function ( value ) {\n\t\n\t\t\tthis.textures = value;\n\t\n\t\t},\n\t\n\t\tgetTexture: function ( name ) {\n\t\n\t\t\tvar textures = this.textures;\n\t\n\t\t\tif ( textures[ name ] === undefined ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\t\n\t\t\t}\n\t\n\t\t\treturn textures[ name ];\n\t\n\t\t},\n\t\n\t\tparse: function ( json ) {\n\t\n\t\t\tvar material = new THREE[ json.type ];\n\t\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\n\t\t\t// for PointsMaterial\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\t\n\t\t\t// maps\n\t\n\t\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\t\n\t\t\tif ( json.alphaMap !== undefined ) {\n\t\n\t\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\t\tmaterial.transparent = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\t\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\t\tif ( json.normalScale !== undefined ) {\n\t\n\t\t\t\tvar normalScale = json.normalScale;\n\t\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\t\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\t\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\t\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\t\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\t\n\t\t\tif ( json.envMap !== undefined ) {\n\t\n\t\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\t\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\t\n\t\t\t// MultiMaterial\n\t\n\t\t\tif ( json.materials !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn material;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/ObjectLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ObjectLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.texturePath = '';\n\t\n\t};\n\t\n\tObject.assign( THREE.ObjectLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tif ( this.texturePath === '' ) {\n\t\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\t\tloader.load( url, function ( text ) {\n\t\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t},\n\t\n\t\tsetTexturePath: function ( value ) {\n\t\n\t\t\tthis.texturePath = value;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\n\t\t},\n\t\n\t\tparse: function ( json, onLoad ) {\n\t\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\n\t\t\tvar images = this.parseImages( json.images, function () {\n\t\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t} );\n\t\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\n\t\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\n\t\n\t\t\tif ( json.animations ) {\n\t\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\t\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\t\n\t\t\t}\n\t\n\t\t\treturn object;\n\t\n\t\t},\n\t\n\t\tparseGeometries: function ( json ) {\n\t\n\t\t\tvar geometries = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t\t);\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'BufferGeometry':\n\t\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase 'Geometry':\n\t\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\t\n\t\t\t\t\t\t\tcontinue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn geometries;\n\t\n\t\t},\n\t\n\t\tparseMaterials: function ( json, textures ) {\n\t\n\t\t\tvar materials = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\t\tloader.setTextures( textures );\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn materials;\n\t\n\t\t},\n\t\n\t\tparseAnimations: function ( json ) {\n\t\n\t\t\tvar animations = [];\n\t\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\t\n\t\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\t\n\t\t\t\tanimations.push( clip );\n\t\n\t\t\t}\n\t\n\t\t\treturn animations;\n\t\n\t\t},\n\t\n\t\tparseImages: function ( json, onLoad ) {\n\t\n\t\t\tvar scope = this;\n\t\t\tvar images = {};\n\t\n\t\t\tfunction loadImage( url ) {\n\t\n\t\t\t\tscope.manager.itemStart( url );\n\t\n\t\t\t\treturn loader.load( url, function () {\n\t\n\t\t\t\t\tscope.manager.itemEnd( url );\n\t\n\t\t\t\t} );\n\t\n\t\t\t}\n\t\n\t\t\tif ( json !== undefined && json.length > 0 ) {\n\t\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\t\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar image = json[ i ];\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\t\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn images;\n\t\n\t\t},\n\t\n\t\tparseTextures: function ( json, images ) {\n\t\n\t\t\tfunction parseConstant( value ) {\n\t\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\n\t\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\t\n\t\t\t\treturn THREE[ value ];\n\t\n\t\t\t}\n\t\n\t\t\tvar textures = {};\n\t\n\t\t\tif ( json !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar data = json[ i ];\n\t\n\t\t\t\t\tif ( data.image === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\ttexture.uuid = data.uuid;\n\t\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\t\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\t\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\t\tif ( data.wrap !== undefined ) {\n\t\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\t\n\t\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\t\n\t\t\t\t\ttextures[ data.uuid ] = texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn textures;\n\t\n\t\t},\n\t\n\t\tparseObject: function () {\n\t\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\n\t\t\treturn function parseObject( data, geometries, materials ) {\n\t\n\t\t\t\tvar object;\n\t\n\t\t\t\tfunction getGeometry( name ) {\n\t\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn geometries[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction getMaterial( name ) {\n\t\n\t\t\t\t\tif ( name === undefined ) return undefined;\n\t\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn materials[ name ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( data.type ) {\n\t\n\t\t\t\t\tcase 'Scene':\n\t\n\t\t\t\t\t\tobject = new THREE.Scene();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PerspectiveCamera':\n\t\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\t\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'OrthographicCamera':\n\t\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'AmbientLight':\n\t\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'DirectionalLight':\n\t\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointLight':\n\t\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'SpotLight':\n\t\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'HemisphereLight':\n\t\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Mesh':\n\t\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\t\tvar material = getMaterial( data.material );\n\t\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\t\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'LOD':\n\t\n\t\t\t\t\t\tobject = new THREE.LOD();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Line':\n\t\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'PointCloud':\n\t\t\t\t\tcase 'Points':\n\t\n\t\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Sprite':\n\t\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 'Group':\n\t\n\t\t\t\t\t\tobject = new THREE.Group();\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tobject = new THREE.Object3D();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tobject.uuid = data.uuid;\n\t\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\t\tif ( data.matrix !== undefined ) {\n\t\n\t\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\t\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\n\t\t\t\tif ( data.children !== undefined ) {\n\t\n\t\t\t\t\tfor ( var child in data.children ) {\n\t\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( data.type === 'LOD' ) {\n\t\n\t\t\t\t\tvar levels = data.levels;\n\t\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\t\n\t\t\t\t\t\tif ( child !== undefined ) {\n\t\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn object;\n\t\n\t\t\t};\n\t\n\t\t}()\n\t\n\t} );\n\t\n\t// File:src/loaders/TextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.TextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.TextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar texture = new THREE.Texture();\n\t\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( image ) {\n\t\n\t\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\t\n\t\t\t\ttexture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n\t\t\t\ttexture.image = image;\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\tif ( onLoad !== undefined ) {\n\t\n\t\t\t\t\tonLoad( texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/CubeTextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CubeTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t};\n\t\n\tObject.assign( THREE.CubeTextureLoader.prototype, {\n\t\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar texture = new THREE.CubeTexture();\n\t\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\t\tloader.setPath( this.path );\n\t\n\t\t\tvar loaded = 0;\n\t\n\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\n\t\n\t\t\t\t\ttexture.images[ i ] = image;\n\t\n\t\t\t\t\tloaded ++;\n\t\n\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, undefined, onError );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\t\n\t\t\t\tloadTexture( i );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetCrossOrigin: function ( value ) {\n\t\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/BinaryTextureLoader.js\n\t\n\t/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\t\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.BinaryTextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar texture = new THREE.DataTexture();\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\tvar texData = scope._parser( buffer );\n\t\n\t\t\t\tif ( ! texData ) return;\n\t\n\t\t\t\tif ( undefined !== texData.image ) {\n\t\n\t\t\t\t\ttexture.image = texData.image;\n\t\n\t\t\t\t} else if ( undefined !== texData.data ) {\n\t\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\t\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\t\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\t\n\t\t\t\tif ( undefined !== texData.format ) {\n\t\n\t\t\t\t\ttexture.format = texData.format;\n\t\n\t\t\t\t}\n\t\t\t\tif ( undefined !== texData.type ) {\n\t\n\t\t\t\t\ttexture.type = texData.type;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\n\t\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\n\t\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\t\n\t\t\t}, onProgress, onError );\n\t\n\t\n\t\t\treturn texture;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/loaders/CompressedTextureLoader.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\t\n\tTHREE.CompressedTextureLoader = function ( manager ) {\n\t\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\n\t\t// override in sub classes\n\t\tthis._parser = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.CompressedTextureLoader.prototype, {\n\t\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar images = [];\n\t\n\t\t\tvar texture = new THREE.CompressedTexture();\n\t\t\ttexture.image = images;\n\t\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\n\t\t\tfunction loadTexture( i ) {\n\t\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\n\t\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\timages[ i ] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\t\n\t\t\t\t\tloaded += 1;\n\t\n\t\t\t\t\tif ( loaded === 6 ) {\n\t\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\tif ( Array.isArray( url ) ) {\n\t\n\t\t\t\tvar loaded = 0;\n\t\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\t\n\t\t\t\t\tloadTexture( i );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\n\t\t\t\tloader.load( url, function ( buffer ) {\n\t\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\t\n\t\t\t\t\tif ( texDatas.isCubemap ) {\n\t\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\t\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\t\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\t\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\t\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\t\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\t\n\t\t\t\t}, onProgress, onError );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tsetPath: function ( value ) {\n\t\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/materials/Material.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Material = function () {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\t\n\t\tthis.fog = true;\n\t\tthis.lights = true;\n\t\n\t\tthis.blending = THREE.NormalBlending;\n\t\tthis.side = THREE.FrontSide;\n\t\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\t\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\t\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = THREE.AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\t\n\t\tthis.depthFunc = THREE.LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\t\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipShadows = false;\n\t\n\t\tthis.colorWrite = true;\n\t\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\t\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\t\n\t\tthis.alphaTest = 0;\n\t\tthis.premultipliedAlpha = false;\n\t\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\t\n\t\tthis.visible = true;\n\t\n\t\tthis._needsUpdate = true;\n\t\n\t};\n\t\n\tTHREE.Material.prototype = {\n\t\n\t\tconstructor: THREE.Material,\n\t\n\t\tget needsUpdate() {\n\t\n\t\t\treturn this._needsUpdate;\n\t\n\t\t},\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.update();\n\t\t\tthis._needsUpdate = value;\n\t\n\t\t},\n\t\n\t\tsetValues: function ( values ) {\n\t\n\t\t\tif ( values === undefined ) return;\n\t\n\t\t\tfor ( var key in values ) {\n\t\n\t\t\t\tvar newValue = values[ key ];\n\t\n\t\t\t\tif ( newValue === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar currentValue = this[ key ];\n\t\n\t\t\t\tif ( currentValue === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\n\t\n\t\t\t\t\tcurrentValue.set( newValue );\n\t\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\t\n\t\t\t\t\tcurrentValue.copy( newValue );\n\t\n\t\t\t\t} else if ( key === 'overdraw' ) {\n\t\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number( newValue );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis[ key ] = newValue;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar isRoot = meta === undefined;\n\t\n\t\t\tif ( isRoot ) {\n\t\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tvar data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\t// standard Material serialization\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\n\t\t\tif ( this.name !== '' ) data.name = this.name;\n\t\n\t\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\t\n\t\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\t\n\t\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\n\t\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\n\t\t\t}\n\t\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\n\t\t\t}\n\t\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\n\t\t\t}\n\t\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\t\n\t\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\n\t\t\tif ( this.envMap instanceof THREE.Texture ) {\n\t\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\t\n\t\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\t\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\n\t\t\t// TODO: Copied from Object3D.toJSON\n\t\n\t\t\tfunction extractFromCache ( cache ) {\n\t\n\t\t\t\tvar values = [];\n\t\n\t\t\t\tfor ( var key in cache ) {\n\t\n\t\t\t\t\tvar data = cache[ key ];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push( data );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn values;\n\t\n\t\t\t}\n\t\n\t\t\tif ( isRoot ) {\n\t\n\t\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\t\tvar images = extractFromCache( meta.images );\n\t\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\t\tif ( images.length > 0 ) data.images = images;\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.name = source.name;\n\t\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.lights = source.lights;\n\t\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.shading = source.shading;\n\t\t\tthis.vertexColors = source.vertexColors;\n\t\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\t\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\t\n\t\t\tthis.colorWrite = source.colorWrite;\n\t\n\t\t\tthis.precision = source.precision;\n\t\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\n\t\t\tthis.overdraw = source.overdraw;\n\t\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\n\t\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\t\tdstPlanes = null;\n\t\n\t\t\tif ( srcPlanes !== null ) {\n\t\n\t\t\t\tvar n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array( n );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\t\n\t\t\t}\n\t\n\t\t\tthis.clippingPlanes = dstPlanes;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdate: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'update' } );\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\t\n\tTHREE.MaterialIdCount = 0;\n\t\n\t// File:src/materials/LineBasicMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\t\n\tTHREE.LineBasicMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'LineBasicMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\t\n\tTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/LineDashedMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\t\n\tTHREE.LineDashedMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'LineDashedMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.linewidth = 1;\n\t\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\t\n\tTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.linewidth = source.linewidth;\n\t\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshBasicMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshBasicMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\t\n\tTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshDepthMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshDepthMaterial';\n\t\n\t\tthis.depthPacking = THREE.BasicDepthPacking;\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\t\n\tTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.depthPacking = source.depthPacking;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshLambertMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshLambertMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\t\n\tTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshNormalMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this, parameters );\n\t\n\t\tthis.type = 'MeshNormalMaterial';\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\tthis.morphTargets = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\t\n\tTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshPhongMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'MeshPhongMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\tthis.specular = new THREE.Color( 0x111111 );\n\t\tthis.shininess = 30;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\t\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.specularMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.combine = THREE.MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\t\n\tTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.specularMap = source.specularMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshStandardMaterial.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.MeshStandardMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\tthis.type = 'MeshStandardMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 0.5;\n\t\tthis.metalness = 0.5;\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\t\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\t\n\t\tthis.emissive = new THREE.Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\t\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\t\n\t\tthis.normalMap = null;\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\t\n\t\tthis.roughnessMap = null;\n\t\n\t\tthis.metalnessMap = null;\n\t\n\t\tthis.alphaMap = null;\n\t\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\t\n\t\tthis.refractionRatio = 0.98;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\t\n\t\tthis.skinning = false;\n\t\tthis.morphTargets = false;\n\t\tthis.morphNormals = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\t\n\tTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.defines = { 'STANDARD': '' };\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\t\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalScale.copy( source.normalScale );\n\t\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\t\n\t\tthis.roughnessMap = source.roughnessMap;\n\t\n\t\tthis.metalnessMap = source.metalnessMap;\n\t\n\t\tthis.alphaMap = source.alphaMap;\n\t\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\n\t\tthis.refractionRatio = source.refractionRatio;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\n\t\tthis.skinning = source.skinning;\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MeshPhysicalMaterial.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\t\n\tTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\t\n\t\tTHREE.MeshStandardMaterial.call( this );\n\t\n\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\tthis.type = 'MeshPhysicalMaterial';\n\t\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\t\n\t\tthis.clearCoat = 0.0;\n\t\tthis.clearCoatRoughness = 0.0;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\n\tTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\t\n\tTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\t\n\t\tthis.defines = { 'PHYSICAL': '' };\n\t\n\t\tthis.reflectivity = source.reflectivity;\n\t\n\t\tthis.clearCoat = source.clearCoat;\n\t\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/MultiMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.MultiMaterial = function ( materials ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.type = 'MultiMaterial';\n\t\n\t\tthis.materials = materials instanceof Array ? materials : [];\n\t\n\t\tthis.visible = true;\n\t\n\t};\n\t\n\tTHREE.MultiMaterial.prototype = {\n\t\n\t\tconstructor: THREE.MultiMaterial,\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.2,\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\ttype: this.type,\n\t\t\t\tmaterials: []\n\t\t\t};\n\t\n\t\t\tvar materials = this.materials;\n\t\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\t\tdelete material.metadata;\n\t\n\t\t\t\toutput.materials.push( material );\n\t\n\t\t\t}\n\t\n\t\t\toutput.visible = this.visible;\n\t\n\t\t\treturn output;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\tvar material = new this.constructor();\n\t\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\t\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\t\n\t\t\t}\n\t\n\t\t\tmaterial.visible = this.visible;\n\t\n\t\t\treturn material;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/materials/PointsMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\t\n\tTHREE.PointsMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'PointsMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\n\t\tthis.map = null;\n\t\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\t\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\t\n\tTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\n\t\tthis.map = source.map;\n\t\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/ShaderMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\t\n\tTHREE.ShaderMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'ShaderMaterial';\n\t\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\t\n\t\tthis.linewidth = 1;\n\t\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\t\n\t\tthis.skinning = false; // set to use skinning attribute streams\n\t\tthis.morphTargets = false; // set to use morph targets\n\t\tthis.morphNormals = false; // set to use morph normals\n\t\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\t\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv2': [ 0, 0 ]\n\t\t};\n\t\n\t\tthis.index0AttributeName = undefined;\n\t\n\t\tif ( parameters !== undefined ) {\n\t\n\t\t\tif ( parameters.attributes !== undefined ) {\n\t\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\t\n\t\t\t}\n\t\n\t\t\tthis.setValues( parameters );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\t\n\tTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\t\n\t\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\t\n\t\tthis.defines = source.defines;\n\t\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\t\n\t\tthis.skinning = source.skinning;\n\t\n\t\tthis.morphTargets = source.morphTargets;\n\t\tthis.morphNormals = source.morphNormals;\n\t\n\t\tthis.extensions = source.extensions;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\tTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\t\n\t\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\t\n\t\tdata.uniforms = this.uniforms;\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\t\n\t\treturn data;\n\t\n\t};\n\t\n\t// File:src/materials/RawShaderMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.RawShaderMaterial = function ( parameters ) {\n\t\n\t\tTHREE.ShaderMaterial.call( this, parameters );\n\t\n\t\tthis.type = 'RawShaderMaterial';\n\t\n\t};\n\t\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\t\n\t// File:src/materials/SpriteMaterial.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\t\n\tTHREE.SpriteMaterial = function ( parameters ) {\n\t\n\t\tTHREE.Material.call( this );\n\t\n\t\tthis.type = 'SpriteMaterial';\n\t\n\t\tthis.color = new THREE.Color( 0xffffff );\n\t\tthis.map = null;\n\t\n\t\tthis.rotation = 0;\n\t\n\t\tthis.fog = false;\n\t\tthis.lights = false;\n\t\n\t\tthis.setValues( parameters );\n\t\n\t};\n\t\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\t\n\tTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\t\n\t\tTHREE.Material.prototype.copy.call( this, source );\n\t\n\t\tthis.color.copy( source.color );\n\t\tthis.map = source.map;\n\t\n\t\tthis.rotation = source.rotation;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/materials/ShadowMaterial.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.ShadowMaterial = function () {\n\t\n\t\tTHREE.ShaderMaterial.call( this, {\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t\t{\n\t\t\t\t\topacity: { value: 1.0 }\n\t\t\t\t}\n\t\t\t] ),\n\t\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t\t} );\n\t\n\t\tthis.lights = true;\n\t\tthis.transparent = true;\n\t\n\t\tObject.defineProperties( this, {\n\t\t\topacity: {\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t\t},\n\t\t\t\tset: function ( value ) {\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t\n\t};\n\t\n\tTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\n\tTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\t\n\t// File:src/textures/Texture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\t\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.name = '';\n\t\tthis.sourceFile = '';\n\t\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\t\tthis.mipmaps = [];\n\t\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\t\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\t\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\t\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\t\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\t\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\n\t\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\n\t\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\t\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\t\n\t};\n\t\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\t\n\tTHREE.Texture.prototype = {\n\t\n\t\tconstructor: THREE.Texture,\n\t\n\t\tset needsUpdate( value ) {\n\t\n\t\t\tif ( value === true ) this.version ++;\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\t\n\t\t\tthis.mapping = source.mapping;\n\t\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\t\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\t\n\t\t\tthis.anisotropy = source.anisotropy;\n\t\n\t\t\tthis.format = source.format;\n\t\t\tthis.type = source.type;\n\t\n\t\t\tthis.offset.copy( source.offset );\n\t\t\tthis.repeat.copy( source.repeat );\n\t\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\t\n\t\t\t\treturn meta.textures[ this.uuid ];\n\t\n\t\t\t}\n\t\n\t\t\tfunction getDataURL( image ) {\n\t\n\t\t\t\tvar canvas;\n\t\n\t\t\t\tif ( image.toDataURL !== undefined ) {\n\t\n\t\t\t\t\tcanvas = image;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\tcanvas.height = image.height;\n\t\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\t\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.4,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\t\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\t\n\t\t\t\tmapping: this.mapping,\n\t\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\n\t\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\t\n\t\t\t\tflipY: this.flipY\n\t\t\t};\n\t\n\t\t\tif ( this.image !== undefined ) {\n\t\n\t\t\t\t// TODO: Move to THREE.Image\n\t\n\t\t\t\tvar image = this.image;\n\t\n\t\t\t\tif ( image.uuid === undefined ) {\n\t\n\t\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\t\n\t\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\toutput.image = image.uuid;\n\t\n\t\t\t}\n\t\n\t\t\tmeta.textures[ this.uuid ] = output;\n\t\n\t\t\treturn output;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t},\n\t\n\t\ttransformUv: function ( uv ) {\n\t\n\t\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\t\n\t\t\tuv.multiply( this.repeat );\n\t\t\tuv.add( this.offset );\n\t\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\t\n\t\t\t\tswitch ( this.wrapS ) {\n\t\n\t\t\t\t\tcase THREE.RepeatWrapping:\n\t\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\t\n\t\t\t\tswitch ( this.wrapT ) {\n\t\n\t\t\t\t\tcase THREE.RepeatWrapping:\n\t\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\t\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\t\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\t\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.flipY ) {\n\t\n\t\t\t\tuv.y = 1 - uv.y;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\t\n\tTHREE.TextureIdCount = 0;\n\t\n\t// File:src/textures/DepthTexture.js\n\t\n\t/**\n\t * @author Matt DesLauriers / @mattdesl\n\t */\n\t\n\tTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\t\n\t  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\t\n\t  this.image = { width: width, height: height };\n\t\n\t  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\t\n\t  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\t  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\t\n\t  this.flipY = false;\n\t  this.generateMipmaps  = false;\n\t\n\t};\n\t\n\tTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\t\n\t// File:src/textures/CanvasTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\tthis.needsUpdate = true;\n\t\n\t};\n\t\n\tTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\t\n\t// File:src/textures/CubeTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\t\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\t\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.flipY = false;\n\t\n\t};\n\t\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\t\n\tObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\t\n\t\tget: function () {\n\t\n\t\t\treturn this.image;\n\t\n\t\t},\n\t\n\t\tset: function ( value ) {\n\t\n\t\t\tthis.image = value;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/textures/CompressedTexture.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\t\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\t\n\t\tthis.flipY = false;\n\t\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\t\n\t\tthis.generateMipmaps = false;\n\t\n\t};\n\t\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\t\n\t// File:src/textures/DataTexture.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\t\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\t\n\t\tthis.image = { data: data, width: width, height: height };\n\t\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\t\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps  = false;\n\t\n\t};\n\t\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\t\n\t// File:src/textures/VideoTexture.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\t\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\t\n\t\tthis.generateMipmaps = false;\n\t\n\t\tvar scope = this;\n\t\n\t\tfunction update() {\n\t\n\t\t\trequestAnimationFrame( update );\n\t\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\t\n\t\t\t\tscope.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tupdate();\n\t\n\t};\n\t\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\t\n\t// File:src/objects/Group.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Group = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Group';\n\t\n\t};\n\t\n\tTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Group\n\t\n\t} );\n\t\n\t// File:src/objects/Points.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Points = function ( geometry, material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Points';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t};\n\t\n\tTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Points,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar object = this;\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\t\tvar position = new THREE.Vector3();\n\t\n\t\t\t\tfunction testPoint( point, index ) {\n\t\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\t\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\t\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\t\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\t\n\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tobject: object\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\t\n\t\t\t\t\t\t\ttestPoint( position, a );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\t\n\t\t\t\t\t\t\ttestPoint( position, i );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Line.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Line = function ( geometry, material, mode ) {\n\t\n\t\tif ( mode === 1 ) {\n\t\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\t\treturn new THREE.LineSegments( geometry, material );\n\t\n\t\t}\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Line';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t};\n\t\n\tTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Line,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar precision = raycaster.linePrecision;\n\t\t\t\tvar precisionSq = precision * precision;\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\tvar vStart = new THREE.Vector3();\n\t\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\t\tvar interRay = new THREE.Vector3();\n\t\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\t\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\t\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\t\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\t\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar nbVertices = vertices.length;\n\t\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\t\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\t\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\t\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\t\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\t\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\t\n\t\t\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\n\t\t\t\t\t\t} );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LineSegments.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LineSegments = function ( geometry, material ) {\n\t\n\t\tTHREE.Line.call( this, geometry, material );\n\t\n\t\tthis.type = 'LineSegments';\n\t\n\t};\n\t\n\tTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\t\n\t\tconstructor: THREE.LineSegments\n\t\n\t} );\n\t\n\t// File:src/objects/Mesh.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\t\n\tTHREE.Mesh = function ( geometry, material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Mesh';\n\t\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\t\n\t\tthis.drawMode = THREE.TrianglesDrawMode;\n\t\n\t\tthis.updateMorphTargets();\n\t\n\t};\n\t\n\tTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Mesh,\n\t\n\t\tsetDrawMode: function ( value ) {\n\t\n\t\t\tthis.drawMode = value;\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.drawMode = source.drawMode;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tupdateMorphTargets: function () {\n\t\n\t\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\t\n\t\t\t\tthis.morphTargetBase = - 1;\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\t\n\t\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\t\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tgetMorphTargetIndexByName: function ( name ) {\n\t\n\t\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\t\n\t\t\t\treturn this.morphTargetDictionary[ name ];\n\t\n\t\t\t}\n\t\n\t\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\t\n\t\t\treturn 0;\n\t\n\t\t},\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\t\tvar ray = new THREE.Ray();\n\t\t\tvar sphere = new THREE.Sphere();\n\t\n\t\t\tvar vA = new THREE.Vector3();\n\t\t\tvar vB = new THREE.Vector3();\n\t\t\tvar vC = new THREE.Vector3();\n\t\n\t\t\tvar tempA = new THREE.Vector3();\n\t\t\tvar tempB = new THREE.Vector3();\n\t\t\tvar tempC = new THREE.Vector3();\n\t\n\t\t\tvar uvA = new THREE.Vector2();\n\t\t\tvar uvB = new THREE.Vector2();\n\t\t\tvar uvC = new THREE.Vector2();\n\t\n\t\t\tvar barycoord = new THREE.Vector3();\n\t\n\t\t\tvar intersectionPoint = new THREE.Vector3();\n\t\t\tvar intersectionPointWorld = new THREE.Vector3();\n\t\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\t\n\t\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\t\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\n\t\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\n\t\n\t\t\t\treturn uv1.clone();\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\t\n\t\t\t\tvar intersect;\n\t\t\t\tvar material = object.material;\n\t\n\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( intersect === null ) return null;\n\t\n\t\t\t\tintersectionPointWorld.copy( point );\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\t\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\t\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\t\tobject: object\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\t\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\t\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\t\n\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\t\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\t\tintersection.faceIndex = a;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn intersection;\n\t\n\t\t\t}\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\n\t\t\t\tif ( material === undefined ) return;\n\t\n\t\t\t\t// Checking boundingSphere distance to ray\n\t\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\n\t\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\t\n\t\t\t\t//\n\t\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\t\n\t\t\t\t// Check boundingBox before continuing\n\t\n\t\t\t\tif ( geometry.boundingBox !== null ) {\n\t\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar uvs, intersection;\n\t\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\tvar a, b, c;\n\t\t\t\t\tvar index = geometry.index;\n\t\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\t\tvar positions = attributes.position.array;\n\t\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\n\t\n\t\t\t\t\t\tuvs = attributes.uv.array;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t\tvar indices = index.array;\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\n\t\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\t\tc = a + 2;\n\t\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\t\n\t\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\t\n\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\t\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\t\n\t\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\t\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\t\n\t\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\t\tfvC = vertices[ face.c ];\n\t\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\t\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\t\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\t\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\t\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\t\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\t\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\t\tvC.add( fvC );\n\t\n\t\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\t\tfvC = vC;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\t\n\t\t\t\t\t\tif ( intersection ) {\n\t\n\t\t\t\t\t\t\tif ( uvs ) {\n\t\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\t\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Bone.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.Bone = function ( skin ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Bone';\n\t\n\t\tthis.skin = skin;\n\t\n\t};\n\t\n\tTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Bone,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.skin = source.skin;\n\t\n\t\t\treturn this;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Skeleton.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\t\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\t\n\t\tthis.identityMatrix = new THREE.Matrix4();\n\t\n\t\t// copy the bone array\n\t\n\t\tbones = bones || [];\n\t\n\t\tthis.bones = bones.slice( 0 );\n\t\n\t\t// create a bone texture or an array of floats\n\t\n\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\n\t\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\t\tsize = Math.max( size, 4 );\n\t\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\t\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\n\t\t} else {\n\t\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\t\n\t\t}\n\t\n\t\t// use the supplied bone inverses or calculate the inverses\n\t\n\t\tif ( boneInverses === undefined ) {\n\t\n\t\t\tthis.calculateInverses();\n\t\n\t\t} else {\n\t\n\t\t\tif ( this.bones.length === boneInverses.length ) {\n\t\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\t\n\t\t\t\tthis.boneInverses = [];\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tObject.assign( THREE.Skeleton.prototype, {\n\t\n\t\tcalculateInverses: function () {\n\t\n\t\t\tthis.boneInverses = [];\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\n\t\t\t\tif ( this.bones[ b ] ) {\n\t\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.boneInverses.push( inverse );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tpose: function () {\n\t\n\t\t\tvar bone;\n\t\n\t\t\t// recover the bind-time world matrices\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// compute the local matrices, positions, rotations and scales\n\t\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\tbone = this.bones[ b ];\n\t\n\t\t\t\tif ( bone ) {\n\t\n\t\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdate: ( function () {\n\t\n\t\t\tvar offsetMatrix = new THREE.Matrix4();\n\t\n\t\t\treturn function update() {\n\t\n\t\t\t\t// flatten bone matrices to array\n\t\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\t\n\t\t\t\t\t// compute the offset between the current and the original transform\n\t\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\t\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.useVertexTexture ) {\n\t\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/SkinnedMesh.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.type = 'SkinnedMesh';\n\t\n\t\tthis.bindMode = \"attached\";\n\t\tthis.bindMatrix = new THREE.Matrix4();\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\n\t\n\t\t// init bones\n\t\n\t\t// TODO: remove bone creation as there is no reason (other than\n\t\t// convenience) for THREE.SkinnedMesh to do this.\n\t\n\t\tvar bones = [];\n\t\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\t\n\t\t\tvar bone, gbone;\n\t\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\tbone = new THREE.Bone( this );\n\t\t\t\tbones.push( bone );\n\t\n\t\t\t\tbone.name = gbone.name;\n\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\t\n\t\t\t\tgbone = this.geometry.bones[ b ];\n\t\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\t\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthis.add( bones[ b ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.normalizeSkinWeights();\n\t\n\t\tthis.updateMatrixWorld( true );\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\t\n\t};\n\t\n\t\n\tTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\t\n\t\tconstructor: THREE.SkinnedMesh,\n\t\n\t\tbind: function( skeleton, bindMatrix ) {\n\t\n\t\t\tthis.skeleton = skeleton;\n\t\n\t\t\tif ( bindMatrix === undefined ) {\n\t\n\t\t\t\tthis.updateMatrixWorld( true );\n\t\n\t\t\t\tthis.skeleton.calculateInverses();\n\t\n\t\t\t\tbindMatrix = this.matrixWorld;\n\t\n\t\t\t}\n\t\n\t\t\tthis.bindMatrix.copy( bindMatrix );\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\t\n\t\t},\n\t\n\t\tpose: function () {\n\t\n\t\t\tthis.skeleton.pose();\n\t\n\t\t},\n\t\n\t\tnormalizeSkinWeights: function () {\n\t\n\t\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\t\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\t\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\t\n\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\tsw.multiplyScalar( scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tvar vec = new THREE.Vector4();\n\t\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\t\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\t\n\t\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\t\tvec.w = skinWeight.getW( i );\n\t\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\t\n\t\t\t\t\tif ( scale !== Infinity ) {\n\t\n\t\t\t\t\t\tvec.multiplyScalar( scale );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tupdateMatrixWorld: function( force ) {\n\t\n\t\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\t\n\t\t\tif ( this.bindMode === \"attached\" ) {\n\t\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\t\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\n\t\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tclone: function() {\n\t\n\t\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LOD.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.LOD = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'LOD';\n\t\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t}\n\t\t} );\n\t\n\t};\n\t\n\t\n\tTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.LOD,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\t\n\t\t\tvar levels = source.levels;\n\t\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\taddLevel: function ( object, distance ) {\n\t\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\n\t\t\tdistance = Math.abs( distance );\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\t\n\t\t\t\tif ( distance < levels[ l ].distance ) {\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\t\n\t\t\tthis.add( object );\n\t\n\t\t},\n\t\n\t\tgetObjectForDistance: function ( distance ) {\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tif ( distance < levels[ i ].distance ) {\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn levels[ i - 1 ].object;\n\t\n\t\t},\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar matrixPosition = new THREE.Vector3();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\t\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tupdate: function () {\n\t\n\t\t\tvar v1 = new THREE.Vector3();\n\t\t\tvar v2 = new THREE.Vector3();\n\t\n\t\t\treturn function update( camera ) {\n\t\n\t\t\t\tvar levels = this.levels;\n\t\n\t\t\t\tif ( levels.length > 1 ) {\n\t\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\n\t\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\n\t\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\t\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\n\t\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}(),\n\t\n\t\ttoJSON: function ( meta ) {\n\t\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\t\n\t\t\tdata.object.levels = [];\n\t\n\t\t\tvar levels = this.levels;\n\t\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar level = levels[ i ];\n\t\n\t\t\t\tdata.object.levels.push( {\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t} );\n\t\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/Sprite.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Sprite = function ( material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Sprite';\n\t\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\t\n\t};\n\t\n\tTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.Sprite,\n\t\n\t\traycast: ( function () {\n\t\n\t\t\tvar matrixPosition = new THREE.Vector3();\n\t\n\t\t\treturn function raycast( raycaster, intersects ) {\n\t\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\t\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\t\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\n\t\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tintersects.push( {\n\t\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\t\tpoint: this.position,\n\t\t\t\t\tface: null,\n\t\t\t\t\tobject: this\n\t\n\t\t\t\t} );\n\t\n\t\t\t};\n\t\n\t\t}() ),\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor( this.material ).copy( this );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/objects/LensFlare.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.lensFlares = [];\n\t\n\t\tthis.positionScreen = new THREE.Vector3();\n\t\tthis.customUpdateCallback = undefined;\n\t\n\t\tif ( texture !== undefined ) {\n\t\n\t\t\tthis.add( texture, size, distance, blending, color );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\t\n\t\tconstructor: THREE.LensFlare,\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\t\n\t\t\tthis.positionScreen.copy( source.positionScreen );\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\t\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\t\n\t\t\tif ( size === undefined ) size = - 1;\n\t\t\tif ( distance === undefined ) distance = 0;\n\t\t\tif ( opacity === undefined ) opacity = 1;\n\t\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\t\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\t\n\t\t\tthis.lensFlares.push( {\n\t\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\t\tscale: 1, \t\t// scale\n\t\t\t\trotation: 0, \t\t// rotation\n\t\t\t\topacity: opacity,\t// opacity\n\t\t\t\tcolor: color,\t\t// color\n\t\t\t\tblending: blending\t// blending\n\t\t\t} );\n\t\n\t\t},\n\t\n\t\t/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\t\n\t\tupdateLensFlares: function () {\n\t\n\t\t\tvar f, fl = this.lensFlares.length;\n\t\t\tvar flare;\n\t\t\tvar vecX = - this.positionScreen.x * 2;\n\t\t\tvar vecY = - this.positionScreen.y * 2;\n\t\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\n\t\n\t\t\t\tflare = this.lensFlares[ f ];\n\t\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\t\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/scenes/Scene.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Scene = function () {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.type = 'Scene';\n\t\n\t\tthis.background = null;\n\t\tthis.fog = null;\n\t\tthis.overrideMaterial = null;\n\t\n\t\tthis.autoUpdate = true; // checked by the renderer\n\t\n\t};\n\t\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\n\t\n\tTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\t\n\t\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\t\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\t\n\t\tthis.autoUpdate = source.autoUpdate;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t// File:src/scenes/Fog.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.Fog = function ( color, near, far ) {\n\t\n\t\tthis.name = '';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\n\t\tthis.near = ( near !== undefined ) ? near : 1;\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\n\t\n\t};\n\t\n\tTHREE.Fog.prototype.clone = function () {\n\t\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\t\n\t};\n\t\n\t// File:src/scenes/FogExp2.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.FogExp2 = function ( color, density ) {\n\t\n\t\tthis.name = '';\n\t\n\t\tthis.color = new THREE.Color( color );\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\t\n\t};\n\t\n\tTHREE.FogExp2.prototype.clone = function () {\n\t\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/ShaderChunk.js\n\t\n\tTHREE.ShaderChunk = {};\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\t\n\tTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\n\t\n\tTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\t#ifndef STANDARD\\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\t#else\\n\t\tfloat clearCoatDHR = 0.0;\\n\t#endif\\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\t#ifndef STANDARD\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\tfloat dotNL = dotNV;\\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\t#else\\n\t\tfloat clearCoatDHR = 0.0;\\n\t#endif\\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\t\n\tTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\t\n\tTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\t\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\t\n\tTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\t\n\t// File:src/renderers/shaders/UniformsUtils.js\n\t\n\t/**\n\t * Uniform Utilities\n\t */\n\t\n\tTHREE.UniformsUtils = {\n\t\n\t\tmerge: function ( uniforms ) {\n\t\n\t\t\tvar merged = {};\n\t\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\t\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\t\n\t\t\t\tfor ( var p in tmp ) {\n\t\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn merged;\n\t\n\t\t},\n\t\n\t\tclone: function ( uniforms_src ) {\n\t\n\t\t\tvar uniforms_dst = {};\n\t\n\t\t\tfor ( var u in uniforms_src ) {\n\t\n\t\t\t\tuniforms_dst[ u ] = {};\n\t\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\t\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\t\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\t\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn uniforms_dst;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/UniformsLib.js\n\t\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\t\n\tTHREE.UniformsLib = {\n\t\n\t\tcommon: {\n\t\n\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\"opacity\": { value: 1.0 },\n\t\n\t\t\t\"map\": { value: null },\n\t\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\t\n\t\t\t\"specularMap\": { value: null },\n\t\t\t\"alphaMap\": { value: null },\n\t\n\t\t\t\"envMap\": { value: null },\n\t\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\t\"reflectivity\": { value: 1.0 },\n\t\t\t\"refractionRatio\": { value: 0.98 }\n\t\n\t\t},\n\t\n\t\taomap: {\n\t\n\t\t\t\"aoMap\": { value: null },\n\t\t\t\"aoMapIntensity\": { value: 1 }\n\t\n\t\t},\n\t\n\t\tlightmap: {\n\t\n\t\t\t\"lightMap\": { value: null },\n\t\t\t\"lightMapIntensity\": { value: 1 }\n\t\n\t\t},\n\t\n\t\temissivemap: {\n\t\n\t\t\t\"emissiveMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tbumpmap: {\n\t\n\t\t\t\"bumpMap\": { value: null },\n\t\t\t\"bumpScale\": { value: 1 }\n\t\n\t\t},\n\t\n\t\tnormalmap: {\n\t\n\t\t\t\"normalMap\": { value: null },\n\t\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\t\n\t\t},\n\t\n\t\tdisplacementmap: {\n\t\n\t\t\t\"displacementMap\": { value: null },\n\t\t\t\"displacementScale\": { value: 1 },\n\t\t\t\"displacementBias\": { value: 0 }\n\t\n\t\t},\n\t\n\t\troughnessmap: {\n\t\n\t\t\t\"roughnessMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tmetalnessmap: {\n\t\n\t\t\t\"metalnessMap\": { value: null }\n\t\n\t\t},\n\t\n\t\tfog: {\n\t\n\t\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\t\"fogNear\": { value: 1 },\n\t\t\t\"fogFar\": { value: 2000 },\n\t\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\t\n\t\t},\n\t\n\t\tlights: {\n\t\n\t\t\t\"ambientLightColor\": { value: [] },\n\t\n\t\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"color\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"directionalShadowMap\": { value: [] },\n\t\t\t\"directionalShadowMatrix\": { value: [] },\n\t\n\t\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\t\"color\": {},\n\t\t\t\t\"position\": {},\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"distance\": {},\n\t\t\t\t\"coneCos\": {},\n\t\t\t\t\"penumbraCos\": {},\n\t\t\t\t\"decay\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"spotShadowMap\": { value: [] },\n\t\t\t\"spotShadowMatrix\": { value: [] },\n\t\n\t\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\t\"color\": {},\n\t\t\t\t\"position\": {},\n\t\t\t\t\"decay\": {},\n\t\t\t\t\"distance\": {},\n\t\n\t\t\t\t\"shadow\": {},\n\t\t\t\t\"shadowBias\": {},\n\t\t\t\t\"shadowRadius\": {},\n\t\t\t\t\"shadowMapSize\": {}\n\t\t\t} },\n\t\n\t\t\t\"pointShadowMap\": { value: [] },\n\t\t\t\"pointShadowMatrix\": { value: [] },\n\t\n\t\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\t\"direction\": {},\n\t\t\t\t\"skyColor\": {},\n\t\t\t\t\"groundColor\": {}\n\t\t\t} }\n\t\n\t\t},\n\t\n\t\tpoints: {\n\t\n\t\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\t\"opacity\": { value: 1.0 },\n\t\t\t\"size\": { value: 1.0 },\n\t\t\t\"scale\": { value: 1.0 },\n\t\t\t\"map\": { value: null },\n\t\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\tgl_FragColor.a *= opacity;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\t\n\tTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\t\n\t// File:src/renderers/shaders/ShaderLib.js\n\t\n\t/**\n\t * Webgl Shader Library for three.js\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\t\n\t\n\tTHREE.ShaderLib = {\n\t\n\t\t'basic': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\t\n\t\t},\n\t\n\t\t'lambert': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\t\n\t\t},\n\t\n\t\t'phong': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\t\n\t\t},\n\t\n\t\t'standard': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\t\n\t\t},\n\t\n\t\t'points': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\t\n\t\t},\n\t\n\t\t'dashed': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\n\t\t\t\t{\n\t\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t\t}\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\t\n\t\t},\n\t\n\t\t'depth': {\n\t\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\t\n\t\t\t] ),\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\t\n\t\t},\n\t\n\t\t'normal': {\n\t\n\t\t\tuniforms: {\n\t\n\t\t\t\t\"opacity\" : { value: 1.0 }\n\t\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\t\n\t\t},\n\t\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\n\t\t'cube': {\n\t\n\t\t\tuniforms: {\n\t\t\t\t\"tCube\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 },\n\t\t\t\t\"opacity\": { value: 1.0 }\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\t\n\t\t},\n\t\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\n\t\t'equirect': {\n\t\n\t\t\tuniforms: {\n\t\t\t\t\"tEquirect\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 }\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\t\n\t\t},\n\t\n\t\t'distanceRGBA': {\n\t\n\t\t\tuniforms: {\n\t\n\t\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\t\n\t\t\t},\n\t\n\t\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ShaderLib[ 'physical' ] = {\n\t\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\n\t\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\t\n\t\t\t{\n\t\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t\t}\n\t\n\t\t] ),\n\t\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\t\n\t};\n\t\n\t// File:src/renderers/WebGLRenderer.js\n\t\n\t/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\t\n\tTHREE.WebGLRenderer = function ( parameters ) {\n\t\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\t\n\t\tparameters = parameters || {};\n\t\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\t\n\t\tvar lights = [];\n\t\n\t\tvar opaqueObjects = [];\n\t\tvar opaqueObjectsLastIndex = - 1;\n\t\tvar transparentObjects = [];\n\t\tvar transparentObjectsLastIndex = - 1;\n\t\n\t\tvar morphInfluences = new Float32Array( 8 );\n\t\n\t\tvar sprites = [];\n\t\tvar lensFlares = [];\n\t\n\t\t// public properties\n\t\n\t\tthis.domElement = _canvas;\n\t\tthis.context = null;\n\t\n\t\t// clearing\n\t\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\t\n\t\t// scene graph\n\t\n\t\tthis.sortObjects = true;\n\t\n\t\t// user-defined clipping\n\t\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\t\n\t\t// physically based shading\n\t\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\t\tthis.gammaInput = false;\n\t\tthis.gammaOutput = false;\n\t\n\t\t// physical lights\n\t\n\t\tthis.physicallyCorrectLights = false;\n\t\n\t\t// tone mapping\n\t\n\t\tthis.toneMapping = THREE.LinearToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\t\tthis.toneMappingWhitePoint = 1.0;\n\t\n\t\t// morphs\n\t\n\t\tthis.maxMorphTargets = 8;\n\t\tthis.maxMorphNormals = 4;\n\t\n\t\t// internal properties\n\t\n\t\tvar _this = this,\n\t\n\t\t// internal state cache\n\t\n\t\t_currentProgram = null,\n\t\t_currentRenderTarget = null,\n\t\t_currentFramebuffer = null,\n\t\t_currentMaterialId = - 1,\n\t\t_currentGeometryProgram = '',\n\t\t_currentCamera = null,\n\t\n\t\t_currentScissor = new THREE.Vector4(),\n\t\t_currentScissorTest = null,\n\t\n\t\t_currentViewport = new THREE.Vector4(),\n\t\n\t\t//\n\t\n\t\t_usedTextureUnits = 0,\n\t\n\t\t//\n\t\n\t\t_clearColor = new THREE.Color( 0x000000 ),\n\t\t_clearAlpha = 0,\n\t\n\t\t_width = _canvas.width,\n\t\t_height = _canvas.height,\n\t\n\t\t_pixelRatio = 1,\n\t\n\t\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t\t_scissorTest = false,\n\t\n\t\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\t\n\t\t// frustum\n\t\n\t\t_frustum = new THREE.Frustum(),\n\t\n\t\t// clipping\n\t\n\t\t_clipping = new THREE.WebGLClipping(),\n\t\t_clippingEnabled = false,\n\t\t_localClippingEnabled = false,\n\t\n\t\t_sphere = new THREE.Sphere(),\n\t\n\t\t// camera matrices cache\n\t\n\t\t_projScreenMatrix = new THREE.Matrix4(),\n\t\n\t\t_vector3 = new THREE.Vector3(),\n\t\n\t\t// light arrays cache\n\t\n\t\t_lights = {\n\t\n\t\t\thash: '',\n\t\n\t\t\tambient: [ 0, 0, 0 ],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\tpoint: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: [],\n\t\n\t\t\tshadows: []\n\t\n\t\t},\n\t\n\t\t// info\n\t\n\t\t_infoRender = {\n\t\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\t\n\t\t};\n\t\n\t\tthis.info = {\n\t\n\t\t\trender: _infoRender,\n\t\t\tmemory: {\n\t\n\t\t\t\tgeometries: 0,\n\t\t\t\ttextures: 0\n\t\n\t\t\t},\n\t\t\tprograms: null\n\t\n\t\t};\n\t\n\t\n\t\t// initialize\n\t\n\t\tvar _gl;\n\t\n\t\ttry {\n\t\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\t\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\t\n\t\t\tif ( _gl === null ) {\n\t\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\t\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tthrow 'Error creating WebGL context.';\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\t\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\t\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t} catch ( error ) {\n\t\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\t\n\t\t}\n\t\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\n\t\n\t\textensions.get( 'WEBGL_depth_texture' );\n\t\textensions.get( 'OES_texture_float' );\n\t\textensions.get( 'OES_texture_float_linear' );\n\t\textensions.get( 'OES_texture_half_float' );\n\t\textensions.get( 'OES_texture_half_float_linear' );\n\t\textensions.get( 'OES_standard_derivatives' );\n\t\textensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\t\n\t\t}\n\t\n\t\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\t\n\t\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\t\tvar properties = new THREE.WebGLProperties();\n\t\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\t\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\t\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\t\tvar lightCache = new THREE.WebGLLights();\n\t\n\t\tthis.info.programs = programCache.programs;\n\t\n\t\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\t\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\t\n\t\t//\n\t\n\t\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\t\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\t\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t\t);\n\t\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\t\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\t\tnew THREE.ShaderMaterial( {\n\t\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\t\tside: THREE.BackSide,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tfog: false\n\t\t\t} )\n\t\t);\n\t\n\t\t//\n\t\n\t\tfunction getTargetPixelRatio() {\n\t\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\n\t\t}\n\t\n\t\tfunction glClearColor( r, g, b, a ) {\n\t\n\t\t\tif ( _premultipliedAlpha === true ) {\n\t\n\t\t\t\tr *= a; g *= a; b *= a;\n\t\n\t\t\t}\n\t\n\t\t\tstate.clearColor( r, g, b, a );\n\t\n\t\t}\n\t\n\t\tfunction setDefaultGLState() {\n\t\n\t\t\tstate.init();\n\t\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t}\n\t\n\t\tfunction resetGLState() {\n\t\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\t\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\n\t\t\tstate.reset();\n\t\n\t\t}\n\t\n\t\tsetDefaultGLState();\n\t\n\t\tthis.context = _gl;\n\t\tthis.capabilities = capabilities;\n\t\tthis.extensions = extensions;\n\t\tthis.properties = properties;\n\t\tthis.state = state;\n\t\n\t\t// shadow map\n\t\n\t\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects, capabilities );\n\t\n\t\tthis.shadowMap = shadowMap;\n\t\n\t\n\t\t// Plugins\n\t\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\t\n\t\t// API\n\t\n\t\tthis.getContext = function () {\n\t\n\t\t\treturn _gl;\n\t\n\t\t};\n\t\n\t\tthis.getContextAttributes = function () {\n\t\n\t\t\treturn _gl.getContextAttributes();\n\t\n\t\t};\n\t\n\t\tthis.forceContextLoss = function () {\n\t\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\t\n\t\t};\n\t\n\t\tthis.getMaxAnisotropy = function () {\n\t\n\t\t\treturn capabilities.getMaxAnisotropy();\n\t\n\t\t};\n\t\n\t\tthis.getPrecision = function () {\n\t\n\t\t\treturn capabilities.precision;\n\t\n\t\t};\n\t\n\t\tthis.getPixelRatio = function () {\n\t\n\t\t\treturn _pixelRatio;\n\t\n\t\t};\n\t\n\t\tthis.setPixelRatio = function ( value ) {\n\t\n\t\t\tif ( value === undefined ) return;\n\t\n\t\t\t_pixelRatio = value;\n\t\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\t\n\t\t};\n\t\n\t\tthis.getSize = function () {\n\t\n\t\t\treturn {\n\t\t\t\twidth: _width,\n\t\t\t\theight: _height\n\t\t\t};\n\t\n\t\t};\n\t\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\t\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\n\t\t\t_canvas.width = width * _pixelRatio;\n\t\t\t_canvas.height = height * _pixelRatio;\n\t\n\t\t\tif ( updateStyle !== false ) {\n\t\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\n\t\t\t}\n\t\n\t\t\tthis.setViewport( 0, 0, width, height );\n\t\n\t\t};\n\t\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\t\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\t\n\t\t};\n\t\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\t\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\t\n\t\t};\n\t\n\t\tthis.setScissorTest = function ( boolean ) {\n\t\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\t\n\t\t};\n\t\n\t\t// Clearing\n\t\n\t\tthis.getClearColor = function () {\n\t\n\t\t\treturn _clearColor;\n\t\n\t\t};\n\t\n\t\tthis.setClearColor = function ( color, alpha ) {\n\t\n\t\t\t_clearColor.set( color );\n\t\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t};\n\t\n\t\tthis.getClearAlpha = function () {\n\t\n\t\t\treturn _clearAlpha;\n\t\n\t\t};\n\t\n\t\tthis.setClearAlpha = function ( alpha ) {\n\t\n\t\t\t_clearAlpha = alpha;\n\t\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t};\n\t\n\t\tthis.clear = function ( color, depth, stencil ) {\n\t\n\t\t\tvar bits = 0;\n\t\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\t\n\t\t\t_gl.clear( bits );\n\t\n\t\t};\n\t\n\t\tthis.clearColor = function () {\n\t\n\t\t\tthis.clear( true, false, false );\n\t\n\t\t};\n\t\n\t\tthis.clearDepth = function () {\n\t\n\t\t\tthis.clear( false, true, false );\n\t\n\t\t};\n\t\n\t\tthis.clearStencil = function () {\n\t\n\t\t\tthis.clear( false, false, true );\n\t\n\t\t};\n\t\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\t\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\t\tthis.clear( color, depth, stencil );\n\t\n\t\t};\n\t\n\t\t// Reset\n\t\n\t\tthis.resetGLState = resetGLState;\n\t\n\t\tthis.dispose = function() {\n\t\n\t\t\ttransparentObjects = [];\n\t\t\ttransparentObjectsLastIndex = -1;\n\t\t\topaqueObjects = [];\n\t\t\topaqueObjectsLastIndex = -1;\n\t\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\n\t\t};\n\t\n\t\t// Events\n\t\n\t\tfunction onContextLost( event ) {\n\t\n\t\t\tevent.preventDefault();\n\t\n\t\t\tresetGLState();\n\t\t\tsetDefaultGLState();\n\t\n\t\t\tproperties.clear();\n\t\n\t\t}\n\t\n\t\tfunction onMaterialDispose( event ) {\n\t\n\t\t\tvar material = event.target;\n\t\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\tdeallocateMaterial( material );\n\t\n\t\t}\n\t\n\t\t// Buffer deallocation\n\t\n\t\tfunction deallocateMaterial( material ) {\n\t\n\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\tproperties.delete( material );\n\t\n\t\t}\n\t\n\t\n\t\tfunction releaseMaterialProgramReference( material ) {\n\t\n\t\t\tvar programInfo = properties.get( material ).program;\n\t\n\t\t\tmaterial.program = undefined;\n\t\n\t\t\tif ( programInfo !== undefined ) {\n\t\n\t\t\t\tprogramCache.releaseProgram( programInfo );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Buffer rendering\n\t\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\n\t\n\t\t\tstate.initAttributes();\n\t\n\t\t\tvar buffers = properties.get( object );\n\t\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\t\n\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\tif ( object.hasPositions ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasNormals ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\t\n\t\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\t\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\t\n\t\t\t\t\t\tvar array = object.normalArray;\n\t\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\t\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\n\t\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\n\t\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.normal );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasUvs && material.map ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.uv );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\t\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\n\t\t\t\tstate.enableAttribute( attributes.color );\n\t\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\t\n\t\t\tobject.count = 0;\n\t\n\t\t};\n\t\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\t\n\t\t\tsetMaterial( material );\n\t\n\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\tvar updateBuffers = false;\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\t\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\t\n\t\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t}\n\t\n\t\t\t// morph targets\n\t\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\t\n\t\t\tif ( morphTargetInfluences !== undefined ) {\n\t\n\t\t\t\tvar activeInfluences = [];\n\t\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\n\t\n\t\t\t\tif ( activeInfluences.length > 8 ) {\n\t\n\t\t\t\t\tactiveInfluences.length = 8;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\t\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\t\n\t\t\t\t\t\tvar index = influence[ 1 ];\n\t\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\t\n\t\t\t\tupdateBuffers = true;\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\n\t\n\t\t\t}\n\t\n\t\t\tvar renderer;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( index );\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderer = bufferRenderer;\n\t\n\t\t\t}\n\t\n\t\t\tif ( updateBuffers ) {\n\t\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\n\t\n\t\t\t\tif ( index !== null ) {\n\t\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tvar dataStart = 0;\n\t\t\tvar dataCount = Infinity;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tdataCount = index.count;\n\t\n\t\t\t} else if ( position !== undefined ) {\n\t\n\t\t\t\tdataCount = position.count;\n\t\n\t\t\t}\n\t\n\t\t\tvar rangeStart = geometry.drawRange.start;\n\t\t\tvar rangeCount = geometry.drawRange.count;\n\t\n\t\t\tvar groupStart = group !== null ? group.start : 0;\n\t\t\tvar groupCount = group !== null ? group.count : Infinity;\n\t\n\t\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\t\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\t\n\t\t\t//\n\t\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\t\n\t\t\t\tif ( material.wireframe === true ) {\n\t\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tswitch ( object.drawMode ) {\n\t\n\t\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\t\n\t\t\t\tvar lineWidth = material.linewidth;\n\t\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\t\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\t\n\t\t\t\tif ( object instanceof THREE.LineSegments ) {\n\t\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( object instanceof THREE.Points ) {\n\t\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\t\n\t\t\t}\n\t\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\t\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\t\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderer.render( drawStart, drawCount );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\t\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\tif ( extension === null ) {\n\t\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\n\t\n\t\t\tstate.initAttributes();\n\t\n\t\t\tvar geometryAttributes = geometry.attributes;\n\t\n\t\t\tvar programAttributes = program.getAttributes();\n\t\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\t\n\t\t\tfor ( var name in programAttributes ) {\n\t\n\t\t\t\tvar programAttribute = programAttributes[ name ];\n\t\n\t\t\t\tif ( programAttribute >= 0 ) {\n\t\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\t\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\n\t\n\t\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\t\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\t\n\t\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.SHORT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.INT;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.BYTE;\n\t\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\t\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\t\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\t\n\t\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\t\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\t\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\t\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\t\n\t\t\t\t\t\tif ( value !== undefined ) {\n\t\n\t\t\t\t\t\t\tswitch ( value.length ) {\n\t\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t}\n\t\n\t\t// Sorting\n\t\n\t\tfunction absNumericalSort( a, b ) {\n\t\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\t\n\t\t}\n\t\n\t\tfunction painterSortStable ( a, b ) {\n\t\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\t\n\t\t\t\treturn a.material.program.id - b.material.program.id;\n\t\n\t\t\t} else if ( a.material.id !== b.material.id ) {\n\t\n\t\t\t\treturn a.material.id - b.material.id;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn a.z - b.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction reversePainterSortStable ( a, b ) {\n\t\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\t\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\t\n\t\t\t} if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn a.id - b.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Rendering\n\t\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\t\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar fog = scene.fog;\n\t\n\t\t\t// reset caching for this frame\n\t\n\t\t\t_currentGeometryProgram = '';\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\t\n\t\t\t// update scene graph\n\t\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\n\t\t\t// update camera matrices and frustum\n\t\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\t\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\t\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\tlights.length = 0;\n\t\n\t\t\topaqueObjectsLastIndex = - 1;\n\t\t\ttransparentObjectsLastIndex = - 1;\n\t\n\t\t\tsprites.length = 0;\n\t\t\tlensFlares.length = 0;\n\t\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\t\n\t\t\tprojectObject( scene, camera );\n\t\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\t\n\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\t\n\t\t\tsetupShadows( lights );\n\t\n\t\t\tshadowMap.render( scene, camera );\n\t\n\t\t\tsetupLights( lights, camera );\n\t\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\t\n\t\t\t//\n\t\n\t\t\t_infoRender.calls = 0;\n\t\t\t_infoRender.vertices = 0;\n\t\t\t_infoRender.faces = 0;\n\t\t\t_infoRender.points = 0;\n\t\n\t\t\tif ( renderTarget === undefined ) {\n\t\n\t\t\t\trenderTarget = null;\n\t\n\t\t\t}\n\t\n\t\t\tthis.setRenderTarget( renderTarget );\n\t\n\t\t\t//\n\t\n\t\t\tvar background = scene.background;\n\t\n\t\t\tif ( background === null ) {\n\t\n\t\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\t\n\t\t\t} else if ( background instanceof THREE.Color ) {\n\t\n\t\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClear || forceClear ) {\n\t\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\t\n\t\t\t}\n\t\n\t\t\tif ( background instanceof THREE.CubeTexture ) {\n\t\n\t\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\t\n\t\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\t\n\t\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\t\n\t\t\t\tobjects.update( backgroundBoxMesh );\n\t\n\t\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\t\n\t\t\t} else if ( background instanceof THREE.Texture ) {\n\t\n\t\t\t\tbackgroundPlaneMesh.material.map = background;\n\t\n\t\t\t\tobjects.update( backgroundPlaneMesh );\n\t\n\t\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( scene.overrideMaterial ) {\n\t\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\t\n\t\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// opaque pass (front-to-back order)\n\t\n\t\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\t\trenderObjects( opaqueObjects, camera, fog );\n\t\n\t\t\t\t// transparent pass (back-to-front order)\n\t\n\t\t\t\trenderObjects( transparentObjects, camera, fog );\n\t\n\t\t\t}\n\t\n\t\t\t// custom render plugins (post pass)\n\t\n\t\t\tspritePlugin.render( scene, camera );\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\t\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\n\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\t\n\t\t\tstate.setDepthTest( true );\n\t\t\tstate.setDepthWrite( true );\n\t\t\tstate.setColorWrite( true );\n\t\n\t\t\t// _gl.finish();\n\t\n\t\t};\n\t\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\t\n\t\t\tvar array, index;\n\t\n\t\t\t// allocate the next position in the appropriate array\n\t\n\t\t\tif ( material.transparent ) {\n\t\n\t\t\t\tarray = transparentObjects;\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tarray = opaqueObjects;\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\n\t\n\t\t\t}\n\t\n\t\t\t// recycle existing render item or grow the array\n\t\n\t\t\tvar renderItem = array[ index ];\n\t\n\t\t\tif ( renderItem !== undefined ) {\n\t\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.z = _vector3.z;\n\t\t\t\trenderItem.group = group;\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tz: _vector3.z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\t\n\t\t\t\t// assert( index === array.length );\n\t\t\t\tarray.push( renderItem );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// TODO Duplicated code (Frustum)\n\t\n\t\tfunction isObjectViewable( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\t\n\t\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\t\tapplyMatrix4( object.matrixWorld );\n\t\n\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t}\n\t\n\t\tfunction isSpriteViewable( sprite ) {\n\t\n\t\t\t_sphere.center.set( 0, 0, 0 );\n\t\t\t_sphere.radius = 0.7071067811865476;\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\t\n\t\t\treturn isSphereViewable( _sphere );\n\t\n\t\t}\n\t\n\t\tfunction isSphereViewable( sphere ) {\n\t\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\t\n\t\t\tvar numPlanes = _clipping.numPlanes;\n\t\n\t\t\tif ( numPlanes === 0 ) return true;\n\t\n\t\t\tvar planes = _this.clippingPlanes,\n\t\n\t\t\t\tcenter = sphere.center,\n\t\t\t\tnegRad = - sphere.radius,\n\t\t\t\ti = 0;\n\t\n\t\t\tdo {\n\t\n\t\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\t\n\t\t\t} while ( ++ i !== numPlanes );\n\t\n\t\t\treturn true;\n\t\n\t\t}\n\t\n\t\tfunction projectObject( object, camera ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tif ( object.layers.test( camera.layers ) ) {\n\t\n\t\t\t\tif ( object instanceof THREE.Light ) {\n\t\n\t\t\t\t\tlights.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\t\n\t\t\t\t\t\tsprites.push( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\t\n\t\t\t\t\tlensFlares.push( object );\n\t\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\t\n\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\t\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\t\n\t\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\t\n\t\t\t\t\t\tobject.skeleton.update();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\t\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\t\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\n\t\n\t\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\t\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\t\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar children = object.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tprojectObject( children[ i ], camera );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\t\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar renderItem = renderList[ i ];\n\t\n\t\t\t\tvar object = renderItem.object;\n\t\t\t\tvar geometry = renderItem.geometry;\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\t\tvar group = renderItem.group;\n\t\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\t\n\t\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\t\n\t\t\t\t\tsetMaterial( material );\n\t\n\t\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\t\n\t\t\t\t\t_currentGeometryProgram = '';\n\t\n\t\t\t\t\tobject.render( function ( object ) {\n\t\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\t\n\t\t\t\t\t} );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction initMaterial( material, fog, object ) {\n\t\n\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\tvar parameters = programCache.getParameters(\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\t\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\n\t\n\t\t\tvar program = materialProperties.program;\n\t\t\tvar programChange = true;\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\t\n\t\t\t} else if ( program.code !== code ) {\n\t\n\t\t\t\t// changed glsl or parameters\n\t\t\t\treleaseMaterialProgramReference( material );\n\t\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\n\t\n\t\t\t\t// same glsl and uniform list\n\t\t\t\treturn;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// only rebuild uniform list\n\t\t\t\tprogramChange = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( programChange ) {\n\t\n\t\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\t\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t\t};\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\t\tname: material.type,\n\t\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t\t};\n\t\n\t\t\t\t}\n\t\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\t\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\t\n\t\t\t\tmaterialProperties.program = program;\n\t\t\t\tmaterial.program = program;\n\t\n\t\t\t}\n\t\n\t\t\tvar attributes = program.getAttributes();\n\t\n\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\t\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.morphNormals ) {\n\t\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\n\t\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\t\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\t\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\t\tmaterial.clipping === true ) {\n\t\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t// store the light setup it was created for\n\t\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\t\n\t\t\t\t// wire up the material to this renderer's lighting state\n\t\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\t\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\t\n\t\t\t}\n\t\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\t\tuniformsList =\n\t\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\t\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\t\n\t\t}\n\t\n\t\tfunction setMaterial( material ) {\n\t\n\t\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\t\tstate.enable( _gl.CULL_FACE );\n\t\t\telse\n\t\t\t\tstate.disable( _gl.CULL_FACE );\n\t\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\t\n\t\t\tif ( material.transparent === true ) {\n\t\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.setBlending( THREE.NoBlending );\n\t\n\t\t\t}\n\t\n\t\t\tstate.setDepthFunc( material.depthFunc );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\t\tstate.setColorWrite( material.colorWrite );\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\t\n\t\t}\n\t\n\t\tfunction setProgram( camera, fog, material, object ) {\n\t\n\t\t\t_usedTextureUnits = 0;\n\t\n\t\t\tvar materialProperties = properties.get( material );\n\t\n\t\t\tif ( _clippingEnabled ) {\n\t\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\t\n\t\t\t\t\tvar useCache =\n\t\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\t\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\t_clipping.setState(\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\t\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( materialProperties.program === undefined ) {\n\t\n\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\t\n\t\t\t\tmaterial.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.needsUpdate ) {\n\t\n\t\t\t\tinitMaterial( material, fog, object );\n\t\t\t\tmaterial.needsUpdate = false;\n\t\n\t\t\t}\n\t\n\t\t\tvar refreshProgram = false;\n\t\t\tvar refreshMaterial = false;\n\t\t\tvar refreshLights = false;\n\t\n\t\t\tvar program = materialProperties.program,\n\t\t\t\tp_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\t\n\t\t\tif ( program.id !== _currentProgram ) {\n\t\n\t\t\t\t_gl.useProgram( program.program );\n\t\t\t\t_currentProgram = program.id;\n\t\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\t\n\t\t\t\t_currentMaterialId = material.id;\n\t\n\t\t\t\trefreshMaterial = true;\n\t\n\t\t\t}\n\t\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\t\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\t\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\t\n\t\t\t\t}\n\t\n\t\n\t\t\t\tif ( camera !== _currentCamera ) {\n\t\n\t\t\t\t\t_currentCamera = camera;\n\t\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\t\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\t\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material.envMap ) {\n\t\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\t\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\t\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t\t material.skinning ) {\n\t\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\t\n\t\t\t}\n\t\n\t\t\t// skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// not sure why, but otherwise weird things happen\n\t\n\t\t\tif ( material.skinning ) {\n\t\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\t\n\t\t\t\tvar skeleton = object.skeleton;\n\t\n\t\t\t\tif ( skeleton ) {\n\t\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\t\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( refreshMaterial ) {\n\t\n\t\t\t\tif ( material.lights ) {\n\t\n\t\t\t\t\t// the current material requires lighting info\n\t\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\t\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// refresh uniforms common to several materials\n\t\n\t\t\t\tif ( fog && material.fog ) {\n\t\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// refresh single material specific uniforms\n\t\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\t\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\t\n\t\t\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\t\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// common matrices\n\t\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\t\n\t\n\t\t\t// dynamic uniforms\n\t\n\t\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\t\n\t\t\tif ( dynUniforms !== null ) {\n\t\n\t\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\t\n\t\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\t\n\t\t\t}\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t\t// Uniforms (refresh uniforms objects)\n\t\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\n\t\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\n\t\t\tif ( material.emissive ) {\n\t\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\t\n\t\t\t}\n\t\n\t\t\tuniforms.map.value = material.map;\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\n\t\t\tif ( material.aoMap ) {\n\t\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\t// uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. normal map\n\t\t\t// 4. bump map\n\t\t\t// 5. alpha map\n\t\t\t// 6. emissive map\n\t\n\t\t\tvar uvScaleMap;\n\t\n\t\t\tif ( material.map ) {\n\t\n\t\t\t\tuvScaleMap = material.map;\n\t\n\t\t\t} else if ( material.specularMap ) {\n\t\n\t\t\t\tuvScaleMap = material.specularMap;\n\t\n\t\t\t} else if ( material.displacementMap ) {\n\t\n\t\t\t\tuvScaleMap = material.displacementMap;\n\t\n\t\t\t} else if ( material.normalMap ) {\n\t\n\t\t\t\tuvScaleMap = material.normalMap;\n\t\n\t\t\t} else if ( material.bumpMap ) {\n\t\n\t\t\t\tuvScaleMap = material.bumpMap;\n\t\n\t\t\t} else if ( material.roughnessMap ) {\n\t\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\n\t\t\t} else if ( material.metalnessMap ) {\n\t\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\n\t\t\t} else if ( material.alphaMap ) {\n\t\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\n\t\t\t} else if ( material.emissiveMap ) {\n\t\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( uvScaleMap !== undefined ) {\n\t\n\t\t\t\t// backwards compatibility\n\t\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar offset = uvScaleMap.offset;\n\t\t\t\tvar repeat = uvScaleMap.repeat;\n\t\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t}\n\t\n\t\t\tuniforms.envMap.value = material.envMap;\n\t\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\t\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\n\t\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPoints ( uniforms, material ) {\n\t\n\t\t\tuniforms.diffuse.value = material.color;\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\t\n\t\t\tuniforms.map.value = material.map;\n\t\n\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\tvar offset = material.map.offset;\n\t\t\t\tvar repeat = material.map.repeat;\n\t\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\n\t\n\t\t\tuniforms.fogColor.value = fog.color;\n\t\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\t\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\t\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\n\t\n\t\t\tuniforms.specular.value = material.specular;\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsStandard ( uniforms, material ) {\n\t\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\t\n\t\t\tif ( material.roughnessMap ) {\n\t\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.metalnessMap ) {\n\t\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.lightMap ) {\n\t\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.emissiveMap ) {\n\t\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.bumpMap ) {\n\t\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.normalMap ) {\n\t\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.displacementMap ) {\n\t\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.envMap ) {\n\t\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\t\n\t\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\t\n\t\t\trefreshUniformsStandard( uniforms, material );\n\t\n\t\t}\n\t\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\t\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\t\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\n\t\t}\n\t\n\t\t// Lighting\n\t\n\t\tfunction setupShadows ( lights ) {\n\t\n\t\t\tvar lightShadowsLength = 0;\n\t\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar light = lights[ i ];\n\t\n\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_lights.shadows.length = lightShadowsLength;\n\t\n\t\t}\n\t\n\t\tfunction setupLights ( lights, camera ) {\n\t\n\t\t\tvar l, ll, light,\n\t\t\tr = 0, g = 0, b = 0,\n\t\t\tcolor,\n\t\t\tintensity,\n\t\t\tdistance,\n\t\t\tshadowMap,\n\t\n\t\t\tviewMatrix = camera.matrixWorldInverse,\n\t\n\t\t\tdirectionalLength = 0,\n\t\t\tpointLength = 0,\n\t\t\tspotLength = 0,\n\t\t\themiLength = 0;\n\t\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\t\n\t\t\t\tlight = lights[ l ];\n\t\n\t\t\t\tcolor = light.color;\n\t\t\t\tintensity = light.intensity;\n\t\t\t\tdistance = light.distance;\n\t\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\t\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\t\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\t\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.distance = distance;\n\t\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\t\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\t\n\t\t\t\t\tuniforms.shadow = light.castShadow;\n\t\n\t\t\t\t\tif ( light.castShadow ) {\n\t\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\t\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\t\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\t\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\t\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\t\n\t\t\t\t\tvar uniforms = lightCache.get( light );\n\t\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\t\tuniforms.direction.normalize();\n\t\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\t\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_lights.ambient[ 0 ] = r;\n\t\t\t_lights.ambient[ 1 ] = g;\n\t\t\t_lights.ambient[ 2 ] = b;\n\t\n\t\t\t_lights.directional.length = directionalLength;\n\t\t\t_lights.spot.length = spotLength;\n\t\t\t_lights.point.length = pointLength;\n\t\t\t_lights.hemi.length = hemiLength;\n\t\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\t\n\t\t}\n\t\n\t\t// GL state setting\n\t\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\t\n\t\t\tstate.setCullFace( cullFace );\n\t\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\t\n\t\t};\n\t\n\t\t// Textures\n\t\n\t\tfunction allocTextureUnit() {\n\t\n\t\t\tvar textureUnit = _usedTextureUnits;\n\t\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\t\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\t\n\t\t\t}\n\t\n\t\t\t_usedTextureUnits += 1;\n\t\n\t\t\treturn textureUnit;\n\t\n\t\t}\n\t\n\t\tthis.allocTextureUnit = allocTextureUnit;\n\t\n\t\t// this.setTexture2D = setTexture2D;\n\t\tthis.setTexture2D = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\treturn function setTexture2D( texture, slot ) {\n\t\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.setTexture = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\treturn function setTexture( texture, slot ) {\n\t\n\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\t\twarned = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttextures.setTexture2D( texture, slot );\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.setTextureCube = ( function() {\n\t\n\t\t\tvar warned = false;\n\t\n\t\t\treturn function setTextureCube( texture, slot ) {\n\t\n\t\t\t\t// backwards compatibility: peel texture.texture\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\t\n\t\t\t\t\tif ( ! warned ) {\n\t\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\t\twarned = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture = texture.texture;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t\t// TODO: unify these code paths\n\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\t\n\t\t\t\t\t// CompressedTexture can have Array in image :/\n\t\n\t\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\t\ttextures.setTextureCube( texture, slot );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\t\n\t\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t}() );\n\t\n\t\tthis.getCurrentRenderTarget = function() {\n\t\n\t\t\treturn _currentRenderTarget;\n\t\n\t\t};\n\t\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\t\n\t\t\t_currentRenderTarget = renderTarget;\n\t\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\t\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tvar framebuffer;\n\t\n\t\t\tif ( renderTarget ) {\n\t\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tframebuffer = null;\n\t\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t\t_currentScissorTest = _scissorTest;\n\t\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\t\n\t\t\t}\n\t\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\n\t\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t\t_currentFramebuffer = framebuffer;\n\t\n\t\t\t}\n\t\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\t\n\t\t\tstate.viewport( _currentViewport );\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\t\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\t\n\t\t\tif ( framebuffer ) {\n\t\n\t\t\t\tvar restore = false;\n\t\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\t\t\trestore = true;\n\t\n\t\t\t\t}\n\t\n\t\t\t\ttry {\n\t\n\t\t\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\t\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\t\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} finally {\n\t\n\t\t\t\t\tif ( restore ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Map three.js constants to WebGL constants\n\t\n\t\tfunction paramThreeToGL ( p ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\t\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\t\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\t\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\t\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\t\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\t\n\t\t\t}\n\t\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\t\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\t\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\t\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\t\n\t\t\t}\n\t\n\t\t\treturn 0;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/WebGLRenderTarget.js\n\t\n\t/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\t\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\t\n\t\tthis.uuid = THREE.Math.generateUUID();\n\t\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\n\t\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\t\n\t\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\t\n\t\toptions = options || {};\n\t\n\t\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\t\n\t\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\t\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\t\tthis.depthTexture = null;\n\t\n\t};\n\t\n\tObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\t\n\t\tsetSize: function ( width, height ) {\n\t\n\t\t\tif ( this.width !== width || this.height !== height ) {\n\t\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\n\t\t\t\tthis.dispose();\n\t\n\t\t\t}\n\t\n\t\t\tthis.viewport.set( 0, 0, width, height );\n\t\t\tthis.scissor.set( 0, 0, width, height );\n\t\n\t\t},\n\t\n\t\tclone: function () {\n\t\n\t\t\treturn new this.constructor().copy( this );\n\t\n\t\t},\n\t\n\t\tcopy: function ( source ) {\n\t\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\n\t\t\tthis.viewport.copy( source.viewport );\n\t\n\t\t\tthis.texture = source.texture.clone();\n\t\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\n\t\t\treturn this;\n\t\n\t\t},\n\t\n\t\tdispose: function () {\n\t\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/renderers/WebGLRenderTargetCube.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\t\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\t\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\t\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\t\tthis.activeMipMapLevel = 0;\n\t\n\t};\n\t\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\t\n\t// File:src/renderers/webgl/WebGLBufferRenderer.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\t\n\t\tvar mode;\n\t\n\t\tfunction setMode( value ) {\n\t\n\t\t\tmode = value;\n\t\n\t\t}\n\t\n\t\tfunction render( start, count ) {\n\t\n\t\t\t_gl.drawArrays( mode, start, count );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\t\n\t\t}\n\t\n\t\tfunction renderInstances( geometry ) {\n\t\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tvar position = geometry.attributes.position;\n\t\n\t\t\tvar count = 0;\n\t\n\t\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\tcount = position.data.count;\n\t\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tcount = position.count;\n\t\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\t\n\t\t\t}\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\n\t\t}\n\t\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLClipping.js\n\t\n\tTHREE.WebGLClipping = function() {\n\t\n\t\tvar scope = this,\n\t\n\t\t\tglobalState = null,\n\t\t\tnumGlobalPlanes = 0,\n\t\t\tlocalClippingEnabled = false,\n\t\t\trenderingShadows = false,\n\t\n\t\t\tplane = new THREE.Plane(),\n\t\t\tviewNormalMatrix = new THREE.Matrix3(),\n\t\n\t\t\tuniform = { value: null, needsUpdate: false };\n\t\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\n\t\n\t\t\tvar enabled =\n\t\t\t\tplanes.length !== 0 ||\n\t\t\t\tenableLocalClipping ||\n\t\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t\t// run another frame in order to reset the state:\n\t\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\t\tlocalClippingEnabled;\n\t\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\t\tnumGlobalPlanes = planes.length;\n\t\n\t\t\treturn enabled;\n\t\n\t\t};\n\t\n\t\tthis.beginShadows = function() {\n\t\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes( null );\n\t\n\t\t};\n\t\n\t\tthis.endShadows = function() {\n\t\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\t\n\t\t};\n\t\n\t\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\t\n\t\t\tif ( ! localClippingEnabled ||\n\t\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t\t// there's no local clipping\n\t\n\t\t\t\tif ( renderingShadows ) {\n\t\t\t\t\t// there's no global clipping\n\t\n\t\t\t\t\tprojectPlanes( null );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\tlGlobal = nGlobal * 4,\n\t\n\t\t\t\t\tdstArray = cache.clippingState || null;\n\t\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\t\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\t\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\t\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcache.clippingState = dstArray;\n\t\t\t\tthis.numPlanes += nGlobal;\n\t\n\t\t\t}\n\t\n\t\n\t\t};\n\t\n\t\tfunction resetGlobalState() {\n\t\n\t\t\tif ( uniform.value !== globalState ) {\n\t\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\n\t\t\t}\n\t\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\n\t\t}\n\t\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\t\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\t\tdstArray = null;\n\t\n\t\t\tif ( nPlanes !== 0 ) {\n\t\n\t\t\t\tdstArray = uniform.value;\n\t\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\t\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\t\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\t\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\t\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\t\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\t\n\t\t\t}\n\t\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\treturn dstArray;\n\t\n\t\t}\n\t\n\t};\n\t\n\t\n\t// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\t\n\t\tvar mode;\n\t\n\t\tfunction setMode( value ) {\n\t\n\t\t\tmode = value;\n\t\n\t\t}\n\t\n\t\tvar type, size;\n\t\n\t\tfunction setIndex( index ) {\n\t\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\t\n\t\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\t\tsize = 4;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\t\tsize = 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction render( start, count ) {\n\t\n\t\t\t_gl.drawElements( mode, count, type, start * size );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\t\n\t\t}\n\t\n\t\tfunction renderInstances( geometry, start, count ) {\n\t\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\t\n\t\t\t_infoRender.calls ++;\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t\t}\n\t\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLExtensions.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLExtensions = function ( gl ) {\n\t\n\t\tvar extensions = {};\n\t\n\t\tthis.get = function ( name ) {\n\t\n\t\t\tif ( extensions[ name ] !== undefined ) {\n\t\n\t\t\t\treturn extensions[ name ];\n\t\n\t\t\t}\n\t\n\t\t\tvar extension;\n\t\n\t\t\tswitch ( name ) {\n\t\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension( name );\n\t\n\t\t\t}\n\t\n\t\t\tif ( extension === null ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\t\n\t\t\t}\n\t\n\t\t\textensions[ name ] = extension;\n\t\n\t\t\treturn extension;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLCapabilities.js\n\t\n\tTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\t\n\t\tvar maxAnisotropy;\n\t\n\t\tfunction getMaxAnisotropy() {\n\t\n\t\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\t\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\tif ( extension !== null ) {\n\t\n\t\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tmaxAnisotropy = 0;\n\t\n\t\t\t}\n\t\n\t\t\treturn maxAnisotropy;\n\t\n\t\t}\n\t\n\t\tfunction getMaxPrecision( precision ) {\n\t\n\t\t\tif ( precision === 'highp' ) {\n\t\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\treturn 'highp';\n\t\n\t\t\t\t}\n\t\n\t\t\t\tprecision = 'mediump';\n\t\n\t\t\t}\n\t\n\t\t\tif ( precision === 'mediump' ) {\n\t\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\t\n\t\t\t\t\treturn 'mediump';\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn 'lowp';\n\t\n\t\t}\n\t\n\t\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\t\tthis.getMaxPrecision = getMaxPrecision;\n\t\n\t\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\t\n\t\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\t\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\t\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\t\n\t\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\t\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\t\n\t\tthis.vertexTextures = this.maxVertexTextures > 0;\n\t\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\t\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\t\n\t\tvar _maxPrecision = getMaxPrecision( this.precision );\n\t\n\t\tif ( _maxPrecision !== this.precision ) {\n\t\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\t\tthis.precision = _maxPrecision;\n\t\n\t\t}\n\t\n\t\tif ( this.logarithmicDepthBuffer ) {\n\t\n\t\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLGeometries.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\t\n\t\tvar geometries = {};\n\t\n\t\tfunction get( object ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\t\n\t\t\t\treturn geometries[ geometry.id ];\n\t\n\t\t\t}\n\t\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\tvar buffergeometry;\n\t\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tbuffergeometry = geometry;\n\t\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\t\n\t\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\n\t\n\t\t\t}\n\t\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\n\t\n\t\t\tinfo.memory.geometries ++;\n\t\n\t\t\treturn buffergeometry;\n\t\n\t\t}\n\t\n\t\tfunction onGeometryDispose( event ) {\n\t\n\t\t\tvar geometry = event.target;\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\n\t\n\t\t\tif ( buffergeometry.index !== null ) {\n\t\n\t\t\t\tdeleteAttribute( buffergeometry.index );\n\t\n\t\t\t}\n\t\n\t\t\tdeleteAttributes( buffergeometry.attributes );\n\t\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\t\n\t\t\tdelete geometries[ geometry.id ];\n\t\n\t\t\t// TODO\n\t\n\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\tif ( property.wireframe ) {\n\t\n\t\t\t\tdeleteAttribute( property.wireframe );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( geometry );\n\t\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\n\t\n\t\t\tif ( bufferproperty.wireframe ) {\n\t\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( buffergeometry );\n\t\n\t\t\t//\n\t\n\t\t\tinfo.memory.geometries --;\n\t\n\t\t}\n\t\n\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t}\n\t\n\t\tfunction deleteAttribute( attribute ) {\n\t\n\t\t\tvar buffer = getAttributeBuffer( attribute );\n\t\n\t\t\tif ( buffer !== undefined ) {\n\t\n\t\t\t\tgl.deleteBuffer( buffer );\n\t\t\t\tremoveAttributeBuffer( attribute );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction deleteAttributes( attributes ) {\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tdeleteAttribute( attributes[ name ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction removeAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\tproperties.delete( attribute.data );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tproperties.delete( attribute );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.get = get;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLLights.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLLights = function () {\n\t\n\t\tvar lights = {};\n\t\n\t\tthis.get = function ( light ) {\n\t\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\t\n\t\t\t\treturn lights[ light.id ];\n\t\n\t\t\t}\n\t\n\t\t\tvar uniforms;\n\t\n\t\t\tswitch ( light.type ) {\n\t\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0,\n\t\n\t\t\t\t\t\tshadow: false,\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\n\t\t\t}\n\t\n\t\t\tlights[ light.id ] = uniforms;\n\t\n\t\t\treturn uniforms;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLObjects.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLObjects = function ( gl, properties, info ) {\n\t\n\t\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\t\n\t\t//\n\t\n\t\tfunction update( object ) {\n\t\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\t\n\t\t\tvar geometry = geometries.get( object );\n\t\n\t\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tgeometry.updateFromObject( object );\n\t\n\t\t\t}\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var name in attributes ) {\n\t\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\t\n\t\t\t}\n\t\n\t\t\t// morph targets\n\t\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\t\n\t\t\tfor ( var name in morphAttributes ) {\n\t\n\t\t\t\tvar array = morphAttributes[ name ];\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t\tfunction updateAttribute( attribute, bufferType ) {\n\t\n\t\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\t\n\t\t\tvar attributeProperties = properties.get( data );\n\t\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\t\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\n\t\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\t\n\t\t\tgl.bufferData( bufferType, data.array, usage );\n\t\n\t\t\tattributeProperties.version = data.version;\n\t\n\t\t}\n\t\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\t\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\t\n\t\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\t\n\t\t\t\t// Not using update ranges\n\t\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\t\n\t\t\t} else if ( data.updateRange.count === 0 ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\t\n\t\t\t\tdata.updateRange.count = 0; // reset range\n\t\n\t\t\t}\n\t\n\t\t\tattributeProperties.version = data.version;\n\t\n\t\t}\n\t\n\t\tfunction getAttributeBuffer( attribute ) {\n\t\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\t\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\t\n\t\t\t}\n\t\n\t\t\treturn properties.get( attribute ).__webglBuffer;\n\t\n\t\t}\n\t\n\t\tfunction getWireframeAttribute( geometry ) {\n\t\n\t\t\tvar property = properties.get( geometry );\n\t\n\t\t\tif ( property.wireframe !== undefined ) {\n\t\n\t\t\t\treturn property.wireframe;\n\t\n\t\t\t}\n\t\n\t\t\tvar indices = [];\n\t\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\t\t\tvar position = attributes.position;\n\t\n\t\t\t// console.time( 'wireframe' );\n\t\n\t\t\tif ( index !== null ) {\n\t\n\t\t\t\tvar edges = {};\n\t\t\t\tvar array = index.array;\n\t\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\t\tvar c = array[ i + 2 ];\n\t\n\t\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tvar array = attributes.position.array;\n\t\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\t\n\t\t\t\t\tvar a = i + 0;\n\t\t\t\t\tvar b = i + 1;\n\t\t\t\t\tvar c = i + 2;\n\t\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// console.timeEnd( 'wireframe' );\n\t\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\t\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\t\n\t\t\tproperty.wireframe = attribute;\n\t\n\t\t\treturn attribute;\n\t\n\t\t}\n\t\n\t\tfunction checkEdge( edges, a, b ) {\n\t\n\t\t\tif ( a > b ) {\n\t\n\t\t\t\tvar tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\n\t\t\t}\n\t\n\t\t\tvar list = edges[ a ];\n\t\n\t\t\tif ( list === undefined ) {\n\t\n\t\t\t\tedges[ a ] = [ b ];\n\t\t\t\treturn true;\n\t\n\t\t\t} else if ( list.indexOf( b ) === -1 ) {\n\t\n\t\t\t\tlist.push( b );\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\n\t\t}\n\t\n\t\tthis.getAttributeBuffer = getAttributeBuffer;\n\t\tthis.getWireframeAttribute = getWireframeAttribute;\n\t\n\t\tthis.update = update;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLProgram.js\n\t\n\tTHREE.WebGLProgram = ( function () {\n\t\n\t\tvar programIdCount = 0;\n\t\n\t\tfunction getEncodingComponents( encoding ) {\n\t\n\t\t\tswitch ( encoding ) {\n\t\n\t\t\t\tcase THREE.LinearEncoding:\n\t\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\t\tcase THREE.GammaEncoding:\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\t\n\t\t\tvar components = getEncodingComponents( encoding );\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\t\n\t\t}\n\t\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\t\n\t\t\tvar toneMappingName;\n\t\n\t\t\tswitch ( toneMapping ) {\n\t\n\t\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\t\tbreak;\n\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\t\n\t\t\t}\n\t\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\t\n\t\t}\n\t\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\t\n\t\t\textensions = extensions || {};\n\t\n\t\t\tvar chunks = [\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t\t];\n\t\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction generateDefines( defines ) {\n\t\n\t\t\tvar chunks = [];\n\t\n\t\t\tfor ( var name in defines ) {\n\t\n\t\t\t\tvar value = defines[ name ];\n\t\n\t\t\t\tif ( value === false ) continue;\n\t\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\t\n\t\t\t}\n\t\n\t\t\treturn chunks.join( '\\n' );\n\t\n\t\t}\n\t\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\t\n\t\t\tvar attributes = {};\n\t\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\t\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\n\t\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\t\tvar name = info.name;\n\t\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\t\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\t\n\t\t\t}\n\t\n\t\t\treturn attributes;\n\t\n\t\t}\n\t\n\t\tfunction filterEmptyLine( string ) {\n\t\n\t\t\treturn string !== '';\n\t\n\t\t}\n\t\n\t\tfunction replaceLightNums( string, parameters ) {\n\t\n\t\t\treturn string\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\t\n\t\t}\n\t\n\t\tfunction parseIncludes( string ) {\n\t\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\t\n\t\t\tfunction replace( match, include ) {\n\t\n\t\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\t\n\t\t\t\tif ( replace === undefined ) {\n\t\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn parseIncludes( replace );\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\tfunction unrollLoops( string ) {\n\t\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\t\n\t\t\tfunction replace( match, start, end, snippet ) {\n\t\n\t\t\t\tvar unroll = '';\n\t\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\t\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn unroll;\n\t\n\t\t\t}\n\t\n\t\t\treturn string.replace( pattern, replace );\n\t\n\t\t}\n\t\n\t\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\t\n\t\t\tvar gl = renderer.context;\n\t\n\t\t\tvar extensions = material.extensions;\n\t\t\tvar defines = material.defines;\n\t\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\t\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\t\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\t\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\n\t\t\t}\n\t\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\n\t\t\tif ( parameters.envMap ) {\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.envMap.mapping ) {\n\t\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tswitch ( material.combine ) {\n\t\n\t\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\t\n\t\t\t// console.log( 'building new program ' );\n\t\n\t\t\t//\n\t\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\t\n\t\t\tvar customDefines = generateDefines( defines );\n\t\n\t\t\t//\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar prefixVertex, prefixFragment;\n\t\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomDefines\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tprefixVertex = [\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\t\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t'attribute vec3 position;',\n\t\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t\t'#ifdef USE_COLOR',\n\t\n\t\t\t\t\t'\tattribute vec3 color;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\t\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\n\t\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\t\n\t\t\t\t\t'\t#else',\n\t\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\t\n\t\t\t\t\t'\t#endif',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'#ifdef USE_SKINNING',\n\t\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\n\t\n\t\t\t\t\t'#endif',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t\tprefixFragment = [\n\t\n\t\t\t\t\tcustomExtensions,\n\t\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\n\t\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\t\n\t\t\t\t\tcustomDefines,\n\t\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\t\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\t\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\t\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\t\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\t\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\t\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\t\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\t\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\t\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\t\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\t\n\t\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t\t'uniform vec3 cameraPosition;',\n\t\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\t\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\t\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\t\n\t\t\t\t\t'\\n'\n\t\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\t\n\t\t\t}\n\t\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\t\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\t\n\t\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\t\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\t\n\t\t\t}\n\t\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\t\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\t\n\t\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\t\n\t\t\tgl.attachShader( program, glVertexShader );\n\t\t\tgl.attachShader( program, glFragmentShader );\n\t\n\t\t\t// Force a particular attribute to index 0.\n\t\n\t\t\tif ( material.index0AttributeName !== undefined ) {\n\t\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\t\n\t\t\t} else if ( parameters.morphTargets === true ) {\n\t\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\t\n\t\t\t}\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\t\n\t\t\tvar runnable = true;\n\t\t\tvar haveDiagnostics = true;\n\t\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\t\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\t\n\t\t\t\trunnable = false;\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\t\n\t\t\t} else if ( programLog !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\t\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\t\n\t\t\t\thaveDiagnostics = false;\n\t\n\t\t\t}\n\t\n\t\t\tif ( haveDiagnostics ) {\n\t\n\t\t\t\tthis.diagnostics = {\n\t\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tmaterial: material,\n\t\n\t\t\t\t\tprogramLog: programLog,\n\t\n\t\t\t\t\tvertexShader: {\n\t\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\n\t\t\t\t\t},\n\t\n\t\t\t\t\tfragmentShader: {\n\t\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t};\n\t\n\t\t\t}\n\t\n\t\t\t// clean up\n\t\n\t\t\tgl.deleteShader( glVertexShader );\n\t\t\tgl.deleteShader( glFragmentShader );\n\t\n\t\t\t// set up caching for uniform locations\n\t\n\t\t\tvar cachedUniforms;\n\t\n\t\t\tthis.getUniforms = function() {\n\t\n\t\t\t\tif ( cachedUniforms === undefined ) {\n\t\n\t\t\t\t\tcachedUniforms =\n\t\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedUniforms;\n\t\n\t\t\t};\n\t\n\t\t\t// set up caching for attribute locations\n\t\n\t\t\tvar cachedAttributes;\n\t\n\t\t\tthis.getAttributes = function() {\n\t\n\t\t\t\tif ( cachedAttributes === undefined ) {\n\t\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn cachedAttributes;\n\t\n\t\t\t};\n\t\n\t\t\t// free resource\n\t\n\t\t\tthis.destroy = function() {\n\t\n\t\t\t\tgl.deleteProgram( program );\n\t\t\t\tthis.program = undefined;\n\t\n\t\t\t};\n\t\n\t\t\t// DEPRECATED\n\t\n\t\t\tObject.defineProperties( this, {\n\t\n\t\t\t\tuniforms: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\t\treturn this.getUniforms();\n\t\n\t\t\t\t\t}\n\t\t\t\t},\n\t\n\t\t\t\tattributes: {\n\t\t\t\t\tget: function() {\n\t\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\t\treturn this.getAttributes();\n\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\n\t\t\t//\n\t\n\t\t\tthis.id = programIdCount ++;\n\t\t\tthis.code = code;\n\t\t\tthis.usedTimes = 1;\n\t\t\tthis.program = program;\n\t\t\tthis.vertexShader = glVertexShader;\n\t\t\tthis.fragmentShader = glFragmentShader;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/WebGLPrograms.js\n\t\n\tTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\t\n\t\tvar programs = [];\n\t\n\t\tvar shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points'\n\t\t};\n\t\n\t\tvar parameterNames = [\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t\t];\n\t\n\t\n\t\tfunction allocateBones ( object ) {\n\t\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\t\n\t\t\t\treturn 1024;\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//  - leave some extra space for other uniforms\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//    (up to 54 should be safe)\n\t\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\t\n\t\t\t\tvar maxBones = nVertexMatrices;\n\t\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\t\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\t\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\t\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn maxBones;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\t\n\t\t\tvar encoding;\n\t\n\t\t\tif ( ! map ) {\n\t\n\t\t\t\tencoding = THREE.LinearEncoding;\n\t\n\t\t\t} else if ( map instanceof THREE.Texture ) {\n\t\n\t\t\t\tencoding = map.encoding;\n\t\n\t\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\t\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\tencoding = map.texture.encoding;\n\t\n\t\t\t}\n\t\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\t\n\t\t\t\tencoding = THREE.GammaEncoding;\n\t\n\t\t\t}\n\t\n\t\t\treturn encoding;\n\t\n\t\t}\n\t\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\t\n\t\t\tvar shaderID = shaderIDs[ material.type ];\n\t\n\t\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\t\n\t\t\tvar maxBones = allocateBones( object );\n\t\t\tvar precision = renderer.getPrecision();\n\t\n\t\t\tif ( material.precision !== null ) {\n\t\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\t\n\t\t\t\tif ( precision !== material.precision ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\t\n\t\t\tvar parameters = {\n\t\n\t\t\t\tshaderID: shaderID,\n\t\n\t\t\t\tprecision: precision,\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\t\tmap: !! material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\t\tenvMap: !! material.envMap,\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\t\tlightMap: !! material.lightMap,\n\t\t\t\taoMap: !! material.aoMap,\n\t\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\t\tbumpMap: !! material.bumpMap,\n\t\t\t\tnormalMap: !! material.normalMap,\n\t\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\t\tspecularMap: !! material.specularMap,\n\t\t\t\talphaMap: !! material.alphaMap,\n\t\n\t\t\t\tcombine: material.combine,\n\t\n\t\t\t\tvertexColors: material.vertexColors,\n\t\n\t\t\t\tfog: !! fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\t\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\n\t\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\t\n\t\t\t\tskinning: material.skinning,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\t\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\t\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\n\t\t\t\tnumClippingPlanes: nClipPlanes,\n\t\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\n\t\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\t\tflipSided: material.side === THREE.BackSide,\n\t\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\t\n\t\t\t};\n\t\n\t\t\treturn parameters;\n\t\n\t\t};\n\t\n\t\tthis.getProgramCode = function ( material, parameters ) {\n\t\n\t\t\tvar array = [];\n\t\n\t\t\tif ( parameters.shaderID ) {\n\t\n\t\t\t\tarray.push( parameters.shaderID );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tarray.push( material.fragmentShader );\n\t\t\t\tarray.push( material.vertexShader );\n\t\n\t\t\t}\n\t\n\t\t\tif ( material.defines !== undefined ) {\n\t\n\t\t\t\tfor ( var name in material.defines ) {\n\t\n\t\t\t\t\tarray.push( name );\n\t\t\t\t\tarray.push( material.defines[ name ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\t\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn array.join();\n\t\n\t\t};\n\t\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\n\t\n\t\t\tvar program;\n\t\n\t\t\t// Check if code has been already compiled\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\t\n\t\t\t\tvar programInfo = programs[ p ];\n\t\n\t\t\t\tif ( programInfo.code === code ) {\n\t\n\t\t\t\t\tprogram = programInfo;\n\t\t\t\t\t++ program.usedTimes;\n\t\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\t\tprograms.push( program );\n\t\n\t\t\t}\n\t\n\t\t\treturn program;\n\t\n\t\t};\n\t\n\t\tthis.releaseProgram = function( program ) {\n\t\n\t\t\tif ( -- program.usedTimes === 0 ) {\n\t\n\t\t\t\t// Remove from unordered set\n\t\t\t\tvar i = programs.indexOf( program );\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\t\tprograms.pop();\n\t\n\t\t\t\t// Free WebGL resources\n\t\t\t\tprogram.destroy();\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tthis.programs = programs;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLProperties.js\n\t\n\t/**\n\t* @author fordacious / fordacious.github.io\n\t*/\n\t\n\tTHREE.WebGLProperties = function () {\n\t\n\t\tvar properties = {};\n\t\n\t\tthis.get = function ( object ) {\n\t\n\t\t\tvar uuid = object.uuid;\n\t\t\tvar map = properties[ uuid ];\n\t\n\t\t\tif ( map === undefined ) {\n\t\n\t\t\t\tmap = {};\n\t\t\t\tproperties[ uuid ] = map;\n\t\n\t\t\t}\n\t\n\t\t\treturn map;\n\t\n\t\t};\n\t\n\t\tthis.delete = function ( object ) {\n\t\n\t\t\tdelete properties[ object.uuid ];\n\t\n\t\t};\n\t\n\t\tthis.clear = function () {\n\t\n\t\t\tproperties = {};\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLShader.js\n\t\n\tTHREE.WebGLShader = ( function () {\n\t\n\t\tfunction addLineNumbers( string ) {\n\t\n\t\t\tvar lines = string.split( '\\n' );\n\t\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\t\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\t\n\t\t\t}\n\t\n\t\t\treturn lines.join( '\\n' );\n\t\n\t\t}\n\t\n\t\treturn function WebGLShader( gl, type, string ) {\n\t\n\t\t\tvar shader = gl.createShader( type );\n\t\n\t\t\tgl.shaderSource( shader, string );\n\t\t\tgl.compileShader( shader );\n\t\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\t\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\t\n\t\t\t}\n\t\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\t\n\t\t\t}\n\t\n\t\t\t// --enable-privileged-webgl-extension\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\t\n\t\t\treturn shader;\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/WebGLShadowMap.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects, capabilities ) {\n\t\n\t\tvar _gl = _renderer.context,\n\t\t_state = _renderer.state,\n\t\t_frustum = new THREE.Frustum(),\n\t\t_projScreenMatrix = new THREE.Matrix4(),\n\t\n\t\t_lightShadows = _lights.shadows,\n\t\n\t\t_shadowMapSize = new THREE.Vector2(),\n\t\t_maxShadowMapSize = new THREE.Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\t\n\t\t_lookTarget = new THREE.Vector3(),\n\t\t_lightPositionWorld = new THREE.Vector3(),\n\t\n\t\t_renderList = [],\n\t\n\t\t_MorphingFlag = 1,\n\t\t_SkinningFlag = 2,\n\t\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\t\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\t\n\t\t_materialCache = {};\n\t\n\t\tvar cubeDirections = [\n\t\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t\t];\n\t\n\t\tvar cubeUps = [\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t\t];\n\t\n\t\tvar cube2DViewPorts = [\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t\t];\n\t\n\t\t// init\n\t\n\t\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\t\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\t\tdepthMaterialTemplate.clipping = true;\n\t\n\t\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\t\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\t\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\t\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\t\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\t\tdepthMaterial.morphTargets = useMorphing;\n\t\t\tdepthMaterial.skinning = useSkinning;\n\t\n\t\t\t_depthMaterials[ i ] = depthMaterial;\n\t\n\t\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\t\tdefines: {\n\t\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t\t},\n\t\t\t\tuniforms: distanceUniforms,\n\t\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\t\tmorphTargets: useMorphing,\n\t\t\t\tskinning: useSkinning,\n\t\t\t\tclipping: true\n\t\t\t} );\n\t\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar scope = this;\n\t\n\t\tthis.enabled = false;\n\t\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\t\n\t\tthis.type = THREE.PCFShadowMap;\n\t\n\t\tthis.renderReverseSided = true;\n\t\tthis.renderSingleSided = true;\n\t\n\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\tif ( scope.enabled === false ) return;\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\t\n\t\t\tif ( _lightShadows.length === 0 ) return;\n\t\n\t\t\t// Set GL state for depth map.\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t\t_state.disable( _gl.BLEND );\n\t\t\t_state.setDepthTest( true );\n\t\t\t_state.setScissorTest( false );\n\t\n\t\t\t// render depth map\n\t\n\t\t\tvar faceCount, isPointLight;\n\t\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\t\n\t\t\t\tvar light = _lightShadows[ i ];\n\t\t\t\tvar shadow = light.shadow;\n\t\n\t\t\t\tif ( shadow === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\t\tcontinue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar shadowCamera = shadow.camera;\n\t\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\t\n\t\t\t\tif ( light instanceof THREE.PointLight ) {\n\t\n\t\t\t\t\tfaceCount = 6;\n\t\t\t\t\tisPointLight = true;\n\t\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\t\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t\t// following orientation:\n\t\t\t\t\t//\n\t\t\t\t\t//  xzXZ\n\t\t\t\t\t//   y Y\n\t\t\t\t\t//\n\t\t\t\t\t// X - Positive x direction\n\t\t\t\t\t// x - Negative x direction\n\t\t\t\t\t// Y - Positive y direction\n\t\t\t\t\t// y - Negative y direction\n\t\t\t\t\t// Z - Positive z direction\n\t\t\t\t\t// z - Negative z direction\n\t\n\t\t\t\t\t// positive X\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative X\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Z\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// negative Z\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t\t// positive Y\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t\t// negative Y\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\t\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfaceCount = 1;\n\t\t\t\t\tisPointLight = false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( shadow.map === null ) {\n\t\n\t\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\t\n\t\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\t\n\t\t\t\t\tshadow.update( light );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar shadowMap = shadow.map;\n\t\t\t\tvar shadowMatrix = shadow.matrix;\n\t\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\t\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t\t_renderer.clear();\n\t\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t\t// run a single pass if not\n\t\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\t\n\t\t\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t\t_state.viewport( vpDimensions );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\t\n\t\t\t\t\t// compute shadow matrix\n\t\n\t\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t\t);\n\t\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\t\n\t\t\t\t\t// update camera matrices and frustum\n\t\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\t\n\t\t\t\t\t// set object matrices & frustum culling\n\t\n\t\t\t\t\t_renderList.length = 0;\n\t\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\t\n\t\t\t\t\t// render shadow map\n\t\t\t\t\t// render regular objects\n\t\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\t\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\t\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\t\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\t\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\t\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Restore GL state.\n\t\t\tvar clearColor = _renderer.getClearColor(),\n\t\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\t\n\t\t\tscope.needsUpdate = false;\n\t\n\t\t};\n\t\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\t\n\t\t\tvar geometry = object.geometry;\n\t\n\t\t\tvar result = null;\n\t\n\t\t\tvar materialVariants = _depthMaterials;\n\t\t\tvar customMaterial = object.customDepthMaterial;\n\t\n\t\t\tif ( isPointLight ) {\n\t\n\t\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tif ( ! customMaterial ) {\n\t\n\t\t\t\tvar useMorphing = false;\n\t\n\t\t\t\tif ( material.morphTargets ) {\n\t\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\t\n\t\t\t\tvar variantIndex = 0;\n\t\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\t\n\t\t\t\tresult = materialVariants[ variantIndex ];\n\t\n\t\t\t} else {\n\t\n\t\t\t\tresult = customMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t\t material.clipShadows === true &&\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\t\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\t\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\t\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\t\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\t\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\t\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\t\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tresult = cachedMaterial;\n\t\n\t\t\t}\n\t\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\t\n\t\t\tvar side = material.side;\n\t\n\t\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\t\n\t\t\t\tside = THREE.FrontSide;\n\t\n\t\t\t}\n\t\n\t\t\tif ( scope.renderReverseSided ) {\n\t\n\t\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\t\n\t\t\t}\n\t\n\t\t\tresult.side = side;\n\t\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\t\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\t\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\t\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\n\t\t}\n\t\n\t\tfunction projectObject( object, camera, shadowCamera ) {\n\t\n\t\t\tif ( object.visible === false ) return;\n\t\n\t\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\t\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\t\n\t\t\t\t\tvar material = object.material;\n\t\n\t\t\t\t\tif ( material.visible === true ) {\n\t\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t\t_renderList.push( object );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar children = object.children;\n\t\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\t\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLState.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\t\n\t\tvar _this = this;\n\t\n\t\tthis.buffers = {\n\t\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t\t};\n\t\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\t\n\t\tvar capabilities = {};\n\t\n\t\tvar compressedTextureFormats = null;\n\t\n\t\tvar currentBlending = null;\n\t\tvar currentBlendEquation = null;\n\t\tvar currentBlendSrc = null;\n\t\tvar currentBlendDst = null;\n\t\tvar currentBlendEquationAlpha = null;\n\t\tvar currentBlendSrcAlpha = null;\n\t\tvar currentBlendDstAlpha = null;\n\t\tvar currentPremultipledAlpha = false;\n\t\n\t\tvar currentFlipSided = null;\n\t\tvar currentCullFace = null;\n\t\n\t\tvar currentLineWidth = null;\n\t\n\t\tvar currentPolygonOffsetFactor = null;\n\t\tvar currentPolygonOffsetUnits = null;\n\t\n\t\tvar currentScissorTest = null;\n\t\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\t\n\t\tvar currentTextureSlot = null;\n\t\tvar currentBoundTextures = {};\n\t\n\t\tvar currentScissor = new THREE.Vector4();\n\t\tvar currentViewport = new THREE.Vector4();\n\t\n\t\tfunction createTexture( type, target, count ) {\n\t\n\t\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\t\tvar texture = gl.createTexture();\n\t\n\t\t\tgl.bindTexture( type, texture );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\t\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\t\n\t\t\t}\n\t\n\t\t\treturn texture;\n\t\n\t\t}\n\t\n\t\tvar emptyTextures = {};\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\t\n\t\t//\n\t\n\t\tthis.init = function () {\n\t\n\t\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\t\tthis.clearDepth( 1 );\n\t\t\tthis.clearStencil( 0 );\n\t\n\t\t\tthis.enable( gl.DEPTH_TEST );\n\t\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\t\n\t\t\tthis.setFlipSided( false );\n\t\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\t\tthis.enable( gl.CULL_FACE );\n\t\n\t\t\tthis.enable( gl.BLEND );\n\t\t\tthis.setBlending( THREE.NormalBlending );\n\t\n\t\t};\n\t\n\t\tthis.initAttributes = function () {\n\t\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\t\n\t\t\t\tnewAttributes[ i ] = 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enableAttribute = function ( attribute ) {\n\t\n\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t}\n\t\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\t\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\t\tattributeDivisors[ attribute ] = 0;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\t\n\t\t\tnewAttributes[ attribute ] = 1;\n\t\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\t\n\t\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\t\tenabledAttributes[ attribute ] = 1;\n\t\n\t\t\t}\n\t\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\t\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.disableUnusedAttributes = function () {\n\t\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\t\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\t\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.enable = function ( id ) {\n\t\n\t\t\tif ( capabilities[ id ] !== true ) {\n\t\n\t\t\t\tgl.enable( id );\n\t\t\t\tcapabilities[ id ] = true;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.disable = function ( id ) {\n\t\n\t\t\tif ( capabilities[ id ] !== false ) {\n\t\n\t\t\t\tgl.disable( id );\n\t\t\t\tcapabilities[ id ] = false;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getCompressedTextureFormats = function () {\n\t\n\t\t\tif ( compressedTextureFormats === null ) {\n\t\n\t\t\t\tcompressedTextureFormats = [];\n\t\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\t\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\t\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\t\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn compressedTextureFormats;\n\t\n\t\t};\n\t\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\t\n\t\t\tif ( blending !== THREE.NoBlending ) {\n\t\n\t\t\t\tthis.enable( gl.BLEND );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.BLEND );\n\t\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\t\treturn;\n\t\n\t\t\t}\n\t\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\t\n\t\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( premultipliedAlpha ) {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\n\t\t\t}\n\t\n\t\t\tif ( blending === THREE.CustomBlending ) {\n\t\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\t\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\t\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\t\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\t\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\t\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tcurrentBlendEquation = null;\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO Deprecate\n\t\n\t\tthis.setColorWrite = function ( colorWrite ) {\n\t\n\t\t\tthis.buffers.color.setMask( colorWrite );\n\t\n\t\t};\n\t\n\t\tthis.setDepthTest = function ( depthTest ) {\n\t\n\t\t\tthis.buffers.depth.setTest( depthTest );\n\t\n\t\t};\n\t\n\t\tthis.setDepthWrite = function ( depthWrite ) {\n\t\n\t\t\tthis.buffers.depth.setMask( depthWrite );\n\t\n\t\t};\n\t\n\t\tthis.setDepthFunc = function ( depthFunc ) {\n\t\n\t\t\tthis.buffers.depth.setFunc( depthFunc );\n\t\n\t\t};\n\t\n\t\tthis.setStencilTest = function ( stencilTest ) {\n\t\n\t\t\tthis.buffers.stencil.setTest( stencilTest );\n\t\n\t\t};\n\t\n\t\tthis.setStencilWrite = function ( stencilWrite ) {\n\t\n\t\t\tthis.buffers.stencil.setMask( stencilWrite );\n\t\n\t\t};\n\t\n\t\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\t\n\t\t};\n\t\n\t\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.setFlipSided = function ( flipSided ) {\n\t\n\t\t\tif ( currentFlipSided !== flipSided ) {\n\t\n\t\t\t\tif ( flipSided ) {\n\t\n\t\t\t\t\tgl.frontFace( gl.CW );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.frontFace( gl.CCW );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentFlipSided = flipSided;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setCullFace = function ( cullFace ) {\n\t\n\t\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\t\n\t\t\t\tthis.enable( gl.CULL_FACE );\n\t\n\t\t\t\tif ( cullFace !== currentCullFace ) {\n\t\n\t\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\n\t\n\t\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.CULL_FACE );\n\t\n\t\t\t}\n\t\n\t\t\tcurrentCullFace = cullFace;\n\t\n\t\t};\n\t\n\t\tthis.setLineWidth = function ( width ) {\n\t\n\t\t\tif ( width !== currentLineWidth ) {\n\t\n\t\t\t\tgl.lineWidth( width );\n\t\n\t\t\t\tcurrentLineWidth = width;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\t\n\t\t\tif ( polygonOffset ) {\n\t\n\t\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\t\n\t\t\t\t\tgl.polygonOffset( factor, units );\n\t\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.getScissorTest = function () {\n\t\n\t\t\treturn currentScissorTest;\n\t\n\t\t};\n\t\n\t\tthis.setScissorTest = function ( scissorTest ) {\n\t\n\t\t\tcurrentScissorTest = scissorTest;\n\t\n\t\t\tif ( scissorTest ) {\n\t\n\t\t\t\tthis.enable( gl.SCISSOR_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.disable( gl.SCISSOR_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// texture\n\t\n\t\tthis.activeTexture = function ( webglSlot ) {\n\t\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\t\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\t\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.bindTexture = function ( webglType, webglTexture ) {\n\t\n\t\t\tif ( currentTextureSlot === null ) {\n\t\n\t\t\t\t_this.activeTexture();\n\t\n\t\t\t}\n\t\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\t\n\t\t\tif ( boundTexture === undefined ) {\n\t\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\t\n\t\t\t}\n\t\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\t\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\t\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.compressedTexImage2D = function () {\n\t\n\t\t\ttry {\n\t\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( error );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.texImage2D = function () {\n\t\n\t\t\ttry {\n\t\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\n\t\n\t\t\t} catch ( error ) {\n\t\n\t\t\t\tconsole.error( error );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// TODO Deprecate\n\t\n\t\tthis.clearColor = function ( r, g, b, a ) {\n\t\n\t\t\tthis.buffers.color.setClear( r, g, b, a );\n\t\n\t\t};\n\t\n\t\tthis.clearDepth = function ( depth ) {\n\t\n\t\t\tthis.buffers.depth.setClear( depth );\n\t\n\t\t};\n\t\n\t\tthis.clearStencil = function ( stencil ) {\n\t\n\t\t\tthis.buffers.stencil.setClear( stencil );\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.scissor = function ( scissor ) {\n\t\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\n\t\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\t\tcurrentScissor.copy( scissor );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.viewport = function ( viewport ) {\n\t\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\n\t\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\t\tcurrentViewport.copy( viewport );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t//\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\t\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\t\n\t\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\t\tenabledAttributes[ i ] = 0;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tcapabilities = {};\n\t\n\t\t\tcompressedTextureFormats = null;\n\t\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\t\n\t\t\tcurrentBlending = null;\n\t\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\t\n\t\t\tthis.buffers.color.reset();\n\t\t\tthis.buffers.depth.reset();\n\t\t\tthis.buffers.stencil.reset();\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLColorBuffer = function ( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar color = new THREE.Vector4();\n\t\tvar currentColorMask = null;\n\t\tvar currentColorClear = new THREE.Vector4();\n\t\n\t\tthis.setMask = function ( colorMask ) {\n\t\n\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\t\n\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\tcurrentColorMask = colorMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( r, g, b, a ) {\n\t\n\t\t\tcolor.set( r, g, b, a );\n\t\n\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\t\n\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\tcurrentColorClear.copy( color );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentColorMask = null;\n\t\t\tcurrentColorClear = new THREE.Vector4();\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLDepthBuffer = function( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar currentDepthMask = null;\n\t\tvar currentDepthFunc = null;\n\t\tvar currentDepthClear = null;\n\t\n\t\tthis.setTest = function ( depthTest ) {\n\t\n\t\t\tif ( depthTest ) {\n\t\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setMask = function( depthMask ){\n\t\n\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\t\n\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\tcurrentDepthMask = depthMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setFunc = function ( depthFunc ) {\n\t\n\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\t\n\t\t\t\tif ( depthFunc ) {\n\t\n\t\t\t\t\tswitch ( depthFunc ) {\n\t\n\t\t\t\t\t\tcase THREE.NeverDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.AlwaysDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.LessDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.LessEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.EqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.GreaterDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase THREE.NotEqualDepth:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( depth ) {\n\t\n\t\t\tif ( currentDepthClear !== depth ) {\n\t\n\t\t\t\tgl.clearDepth( depth );\n\t\t\t\tcurrentDepthClear = depth;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentDepthMask = null;\n\t\t\tcurrentDepthFunc = null;\n\t\t\tcurrentDepthClear = null;\n\t\n\t\t};\n\t\n\t};\n\t\n\tTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\t\n\t\tvar locked = false;\n\t\n\t\tvar currentStencilMask = null;\n\t\tvar currentStencilFunc = null;\n\t\tvar currentStencilRef = null;\n\t\tvar currentStencilFuncMask = null;\n\t\tvar currentStencilFail  = null;\n\t\tvar currentStencilZFail = null;\n\t\tvar currentStencilZPass = null;\n\t\tvar currentStencilClear = null;\n\t\n\t\tthis.setTest = function ( stencilTest ) {\n\t\n\t\t\tif ( stencilTest ) {\n\t\n\t\t\t\tstate.enable( gl.STENCIL_TEST );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.disable( gl.STENCIL_TEST );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setMask = function ( stencilMask ) {\n\t\n\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\t\n\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\tcurrentStencilMask = stencilMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\t\n\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\t\n\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\t\n\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\t\n\t\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t     currentStencilZPass !== stencilZPass ) {\n\t\n\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\t\n\t\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.setLocked = function ( lock ) {\n\t\n\t\t\tlocked = lock;\n\t\n\t\t};\n\t\n\t\tthis.setClear = function ( stencil ) {\n\t\n\t\t\tif ( currentStencilClear !== stencil ) {\n\t\n\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\tcurrentStencilClear = stencil;\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tthis.reset = function () {\n\t\n\t\t\tlocked = false;\n\t\n\t\t\tcurrentStencilMask = null;\n\t\t\tcurrentStencilFunc = null;\n\t\t\tcurrentStencilRef = null;\n\t\t\tcurrentStencilFuncMask = null;\n\t\t\tcurrentStencilFail = null;\n\t\t\tcurrentStencilZFail = null;\n\t\t\tcurrentStencilZPass = null;\n\t\t\tcurrentStencilClear = null;\n\t\n\t\t};\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLTextures.js\n\t\n\t/**\n\t* @author mrdoob / http://mrdoob.com/\n\t*/\n\t\n\tTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\t\n\t\tvar _infoMemory = info.memory;\n\t\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\t\n\t\t//\n\t\n\t\tfunction clampToMaxSize ( image, maxSize ) {\n\t\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\t\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t\t// premultiplied alpha.\n\t\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\treturn canvas;\n\t\n\t\t\t}\n\t\n\t\t\treturn image;\n\t\n\t\t}\n\t\n\t\tfunction isPowerOfTwo( image ) {\n\t\n\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\t\n\t\t}\n\t\n\t\tfunction makePowerOfTwo( image ) {\n\t\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\t\n\t\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\t\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\t\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\t\n\t\t\t\treturn canvas;\n\t\n\t\t\t}\n\t\n\t\t\treturn image;\n\t\n\t\t}\n\t\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\n\t\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\t\n\t\t\treturn false;\n\t\n\t\t}\n\t\n\t\t// Fallback filters for non-power-of-2 textures\n\t\n\t\tfunction filterFallback ( f ) {\n\t\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\t\n\t\t\t\treturn _gl.NEAREST;\n\t\n\t\t\t}\n\t\n\t\t\treturn _gl.LINEAR;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction onTextureDispose( event ) {\n\t\n\t\t\tvar texture = event.target;\n\t\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\tdeallocateTexture( texture );\n\t\n\t\t\t_infoMemory.textures --;\n\t\n\t\n\t\t}\n\t\n\t\tfunction onRenderTargetDispose( event ) {\n\t\n\t\t\tvar renderTarget = event.target;\n\t\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\tdeallocateRenderTarget( renderTarget );\n\t\n\t\t\t_infoMemory.textures --;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tfunction deallocateTexture( texture ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t// cube texture\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// 2D texture\n\t\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\t// remove all webgl properties\n\t\t\tproperties.delete( texture );\n\t\n\t\t}\n\t\n\t\tfunction deallocateRenderTarget( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\tif ( ! renderTarget ) return;\n\t\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\t\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\t\n\t\t\t}\n\t\n\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\trenderTarget.depthTexture.dispose();\n\t\n\t\t\t}\n\t\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\n\t\t\t}\n\t\n\t\t\tproperties.delete( renderTarget.texture );\n\t\t\tproperties.delete( renderTarget );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\n\t\n\t\tfunction setTexture2D( texture, slot ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\tvar image = texture.image;\n\t\n\t\t\t\tif ( image === undefined ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\t\n\t\t\t\t} else if ( image.complete === false ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\t\treturn;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t}\n\t\n\t\tfunction setTextureCube ( texture, slot ) {\n\t\n\t\t\tvar textureProperties = properties.get( texture );\n\t\n\t\t\tif ( texture.image.length === 6 ) {\n\t\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\t\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\t\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\t\n\t\t\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\t\n\t\t\t\t\tvar cubeImage = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\t\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\tif ( ! isCompressed ) {\n\t\n\t\t\t\t\t\t\tif ( isDataTexture ) {\n\t\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\t\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\t\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\t\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction setTextureCubeDynamic ( texture, slot ) {\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\t\n\t\t}\n\t\n\t\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\t\n\t\t\tvar extension;\n\t\n\t\t\tif ( isPowerOfTwoImage ) {\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\t\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\t\n\t\t\tif ( extension ) {\n\t\n\t\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\t\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\t\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\n\t\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\n\t\n\t\t\t\ttextureProperties.__webglInit = true;\n\t\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\t\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t\t_infoMemory.textures ++;\n\t\n\t\t\t}\n\t\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\t\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\t\n\t\t\t\timage = makePowerOfTwo( image );\n\t\n\t\t\t}\n\t\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\t\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\t\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\t\n\t\t\tif ( texture instanceof THREE.DepthTexture ) {\n\t\n\t\t\t\t// populate depth texture with dummy data\n\t\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\t\n\t\t\t\tif ( texture.type === THREE.FloatType ) {\n\t\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\n\t\t\t\t} else if ( _isWebGL2 ) {\n\t\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\t\n\t\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\t\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\t\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\t\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\t\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// regular Texture (image, video, canvas)\n\t\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\t\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\t\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\n\t\t\ttextureProperties.__version = texture.version;\n\t\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\t\n\t\t}\n\t\n\t\t// Render targets\n\t\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\t\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\t\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\t\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\t\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\t\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\t\n\t\t\t}\n\t\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\t\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\t\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\n\t\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\t\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\n\t\t\t}\n\t\n\t\t\t// upload an empty depth texture with framebuffer size\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\t\n\t\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\t\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\t\n\t\t}\n\t\n\t\t// Setup GL resources for a non-texture depth buffer\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\n\t\t\tif ( renderTarget.depthTexture ) {\n\t\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tif ( isCube ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\t\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\n\t\t}\n\t\n\t\t// Set up GL resources for the render target\n\t\tfunction setupRenderTarget( renderTarget ) {\n\t\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\t\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\n\t\t\t_infoMemory.textures ++;\n\t\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\t\n\t\t\t// Setup framebuffer\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\t\n\t\t\t}\n\t\n\t\t\t// Setup color buffer\n\t\n\t\t\tif ( isCube ) {\n\t\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\t\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\t\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\t\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\t\n\t\t\t}\n\t\n\t\t\t// Setup depth and stencil buffers\n\t\n\t\t\tif ( renderTarget.depthBuffer ) {\n\t\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\n\t\n\t\t\tvar texture = renderTarget.texture;\n\t\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\t\n\t\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\t\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\t_gl.generateMipmap( target );\n\t\t\t\tstate.bindTexture( target, null );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/WebGLUniforms.js\n\t\n\t/**\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t * .splitDynamic( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t *\n\t * @author tschw\n\t *\n\t */\n\t\n\tTHREE.WebGLUniforms = ( function() { // scope\n\t\n\t\tvar emptyTexture = new THREE.Texture();\n\t\tvar emptyCubeTexture = new THREE.CubeTexture();\n\t\n\t\t// --- Base for inner nodes (including the root) ---\n\t\n\t\tvar UniformContainer = function() {\n\t\n\t\t\t\tthis.seq = [];\n\t\t\t\tthis.map = {};\n\t\n\t\t\t},\n\t\n\t\t// --- Utilities ---\n\t\n\t\t// Array Caches (provide typed arrays for temporary by size)\n\t\n\t\t\tarrayCacheF32 = [],\n\t\t\tarrayCacheI32 = [],\n\t\n\t\t\tuncacheTemporaryArrays = function() {\n\t\n\t\t\t\tarrayCacheF32.length = 0;\n\t\t\t\tarrayCacheI32.length = 0;\n\t\n\t\t\t},\n\t\n\t\t// Flattening for arrays of vectors and matrices\n\t\n\t\t\tflatten = function( array, nBlocks, blockSize ) {\n\t\n\t\t\t\tvar firstElem = array[ 0 ];\n\t\n\t\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t\t// see http://jacksondunstan.com/articles/983\n\t\n\t\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\t\tr = arrayCacheF32[ n ];\n\t\n\t\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\t\tr = new Float32Array( n );\n\t\t\t\t\tarrayCacheF32[ n ] = r;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( nBlocks !== 0 ) {\n\t\n\t\t\t\t\tfirstElem.toArray( r, 0 );\n\t\n\t\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\t\n\t\t\t\t\t\toffset += blockSize;\n\t\t\t\t\t\tarray[ i ].toArray( r, offset );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn r;\n\t\n\t\t\t},\n\t\n\t\t// Texture unit allocation\n\t\n\t\t\tallocTexUnits = function( renderer, n ) {\n\t\n\t\t\t\tvar r = arrayCacheI32[ n ];\n\t\n\t\t\t\tif ( r === undefined ) {\n\t\n\t\t\t\t\tr = new Int32Array( n );\n\t\t\t\t\tarrayCacheI32[ n ] = r;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\t\n\t\t\t\treturn r;\n\t\n\t\t\t},\n\t\n\t\t// --- Setters ---\n\t\n\t\t// Note: Defining these methods externally, because they come in a bunch\n\t\t// and this way their names minify.\n\t\n\t\t\t// Single scalar\n\t\n\t\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\t\n\t\t\t// Single float vector (from flat array or THREE.VectorN)\n\t\n\t\t\tsetValue2fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue3fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x !== undefined )\n\t\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\t\telse if ( v.r !== undefined )\n\t\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\t\telse\n\t\t\t\t\tgl.uniform3fv( this.addr, v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue4fv = function( gl, v ) {\n\t\n\t\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\t\n\t\t\t},\n\t\n\t\t\t// Single matrix (from flat array or MatrixN)\n\t\n\t\t\tsetValue2fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue3fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\tsetValue4fm = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\t\n\t\t\t},\n\t\n\t\t\t// Single texture (2D / Cube)\n\t\n\t\t\tsetValueT1 = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueT6 = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\t\n\t\t\t},\n\t\n\t\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\t\n\t\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\t\n\t\t\t// Helper to pick the right setter for the singular case\n\t\n\t\t\tgetSingularSetter = function( type ) {\n\t\n\t\t\t\tswitch ( type ) {\n\t\n\t\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\t\n\t\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\t\n\t\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\t\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// Array of scalars\n\t\n\t\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\t\n\t\t\t// Array of vectors (flat or from THREE classes)\n\t\n\t\t\tsetValueV2a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueV3a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueV4a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Array of matrices (flat or from THREE clases)\n\t\n\t\t\tsetValueM2a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueM3a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\t\n\t\t\t},\n\t\n\t\t\tsetValueM4a = function( gl, v ) {\n\t\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\t\n\t\t\t},\n\t\n\t\t\t// Array of textures (2D / Cube)\n\t\n\t\t\tsetValueT1a = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar n = v.length,\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tsetValueT6a = function( gl, v, renderer ) {\n\t\n\t\t\t\tvar n = v.length,\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\n\t\n\t\t\t\tgl.uniform1iv( this.addr, units );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\n\t\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\t\n\t\t\tgetPureArraySetter = function( type ) {\n\t\n\t\t\t\tswitch ( type ) {\n\t\n\t\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\t\n\t\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\t\n\t\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\t\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t// --- Uniform Classes ---\n\t\n\t\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\t\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.addr = addr;\n\t\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\t\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t\t},\n\t\n\t\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\t\n\t\t\t\tthis.id = id;\n\t\t\t\tthis.addr = addr;\n\t\t\t\tthis.size = activeInfo.size;\n\t\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\t\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\n\t\n\t\t\t},\n\t\n\t\t\tStructuredUniform = function( id ) {\n\t\n\t\t\t\tthis.id = id;\n\t\n\t\t\t\tUniformContainer.call( this ); // mix-in\n\t\n\t\t\t};\n\t\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\t\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t\t// are not allowed in structured uniforms.\n\t\n\t\t\tvar seq = this.seq;\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tu.setValue( gl, value[ u.id ] );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\t// --- Top-level ---\n\t\n\t\t// Parser - builds up the property tree from the path strings\n\t\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t\t// extracts\n\t\t\t// \t- the identifier (member name or array index)\n\t\t\t//  - followed by an optional right bracket (found when array index)\n\t\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t\t//\n\t\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t\t// in the uniform names.\n\t\n\t\t\taddUniform = function( container, uniformObject ) {\n\t\n\t\t\t\tcontainer.seq.push( uniformObject );\n\t\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\t\n\t\t\t},\n\t\n\t\t\tparseUniform = function( activeInfo, addr, container ) {\n\t\n\t\t\t\tvar path = activeInfo.name,\n\t\t\t\t\tpathLength = path.length;\n\t\n\t\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\t\tRePathPart.lastIndex = 0;\n\t\n\t\t\t\tfor (; ;) {\n\t\n\t\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\t\n\t\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\t\tsubscript = match[ 3 ];\n\t\n\t\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\t\n\t\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\n\t\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\t\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\n\t\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\t\tnext = map[ id ];\n\t\n\t\t\t\t\t\tif ( next === undefined ) {\n\t\n\t\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\t\taddUniform( container, next );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tcontainer = next;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t// Root Container\n\t\n\t\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\t\n\t\t\t\tUniformContainer.call( this );\n\t\n\t\t\t\tthis.renderer = renderer;\n\t\n\t\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\t\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\t\tpath = info.name,\n\t\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\t\n\t\t\t\t\tparseUniform( info, addr, this );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\t\n\t\t\tvar u = this.map[ name ];\n\t\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\t\n\t\t\tvar v = object[ name ];\n\t\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\t\n\t\t};\n\t\n\t\n\t\t// Static interface\n\t\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\t\n\t\t\tvar r = [];\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ];\n\t\t\t\tif ( u.id in values ) r.push( u );\n\t\n\t\t\t}\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\t\n\t\t\tvar r = null,\n\t\t\t\tn = seq.length,\n\t\t\t\tw = 0;\n\t\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\t\n\t\t\t\tvar u = seq[ i ],\n\t\t\t\t\tv = values[ u.id ];\n\t\n\t\t\t\tif ( v && v.dynamic === true ) {\n\t\n\t\t\t\t\tif ( r === null ) r = [];\n\t\t\t\t\tr.push( u );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t\t++ w;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( w < n ) seq.length = w;\n\t\n\t\t\treturn r;\n\t\n\t\t};\n\t\n\t\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\t\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\t\n\t\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\t\tf = v.onUpdateCallback;\n\t\n\t\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t\treturn WebGLUniforms;\n\t\n\t} )();\n\t\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\t\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\t\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar shader, program, attributes, uniforms;\n\t\n\t\tvar tempTexture, occlusionTexture;\n\t\n\t\tfunction init() {\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 1, - 1,  0, 0,\n\t\t\t\t 1, - 1,  1, 0,\n\t\t\t\t 1,  1,  1, 1,\n\t\t\t\t- 1,  1,  0, 1\n\t\t\t] );\n\t\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\t\n\t\t\t// buffers\n\t\n\t\t\tvertexBuffer     = gl.createBuffer();\n\t\t\telementBuffer    = gl.createBuffer();\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\t// textures\n\t\n\t\t\ttempTexture      = gl.createTexture();\n\t\t\tocclusionTexture = gl.createTexture();\n\t\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\n\t\t\tshader = {\n\t\n\t\t\t\tvertexShader: [\n\t\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\t\"uniform float rotation;\",\n\t\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\n\t\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\t\"attribute vec2 uv;\",\n\t\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t\"vUV = uv;\",\n\t\n\t\t\t\t\t\t\"vec2 pos = position;\",\n\t\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\t\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\t\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\t\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\t\n\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\t\n\t\t\t\t\t\"}\"\n\t\n\t\t\t\t].join( \"\\n\" ),\n\t\n\t\t\t\tfragmentShader: [\n\t\n\t\t\t\t\t\"uniform lowp int renderType;\",\n\t\n\t\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\t\"uniform vec3 color;\",\n\t\n\t\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\t\"varying float vVisibility;\",\n\t\n\t\t\t\t\t\"void main() {\",\n\t\n\t\t\t\t\t\t// pink square\n\t\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\t\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\t\n\t\t\t\t\t\t// restore\n\t\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\t\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\t\n\t\t\t\t\t\t// flare\n\t\n\t\t\t\t\t\t\"} else {\",\n\t\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\t\n\t\t\t\t\t\t\"}\",\n\t\n\t\t\t\t\t\"}\"\n\t\n\t\t\t\t].join( \"\\n\" )\n\t\n\t\t\t};\n\t\n\t\t\tprogram = createProgram( shader );\n\t\n\t\t\tattributes = {\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t\t};\n\t\n\t\t\tuniforms = {\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t\t};\n\t\n\t\t}\n\t\n\t\t/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\t\n\t\tthis.render = function ( scene, camera, viewport ) {\n\t\n\t\t\tif ( flares.length === 0 ) return;\n\t\n\t\t\tvar tempPosition = new THREE.Vector3();\n\t\n\t\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\n\t\n\t\t\tvar size = 16 / viewport.w,\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\t\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\t\n\t\t\tvar validArea = new THREE.Box2();\n\t\n\t\t\tvalidArea.min.set( 0, 0 );\n\t\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tinit();\n\t\n\t\t\t}\n\t\n\t\t\tgl.useProgram( program );\n\t\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.vertex );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\t// loop through all lens flares to update their occlusion and positions\n\t\t\t// setup gl and common used attribs/uniforms\n\t\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t\tgl.uniform1i( uniforms.map, 1 );\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.setDepthWrite( false );\n\t\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\t\n\t\t\t\tsize = 16 / viewport.w;\n\t\t\t\tscale.set( size * invAspect, size );\n\t\n\t\t\t\t// calc object screen position\n\t\n\t\t\t\tvar flare = flares[ i ];\n\t\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\t\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\t\n\t\t\t\t// setup arrays for gl programs\n\t\n\t\t\t\tscreenPosition.copy( tempPosition );\n\t\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\t\n\t\t\t\t// screen cull\n\t\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\t\n\t\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t// render pink quad\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\n\t\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\t\n\t\n\t\t\t\t\t// restore graphics\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\t\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\n\t\t\t\t\t// update object positions\n\t\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\n\t\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\n\t\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tflare.updateLensFlares();\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// render flares\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\t\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\t\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\t\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\t\n\t\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\t\tscale.y = size;\n\t\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\t\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\t\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\t\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// restore gl\n\t\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\t\t\tstate.setDepthWrite( true );\n\t\n\t\t\trenderer.resetGLState();\n\t\n\t\t};\n\t\n\t\tfunction createProgram ( shader ) {\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\t\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\t\n\t\t\tgl.compileShader( fragmentShader );\n\t\t\tgl.compileShader( vertexShader );\n\t\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\t\tgl.attachShader( program, vertexShader );\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\n\t\n\t/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\n\t\n\t\tvar gl = renderer.context;\n\t\tvar state = renderer.state;\n\t\n\t\tvar vertexBuffer, elementBuffer;\n\t\tvar program, attributes, uniforms;\n\t\n\t\tvar texture;\n\t\n\t\t// decompose matrixWorld\n\t\n\t\tvar spritePosition = new THREE.Vector3();\n\t\tvar spriteRotation = new THREE.Quaternion();\n\t\tvar spriteScale = new THREE.Vector3();\n\t\n\t\tfunction init() {\n\t\n\t\t\tvar vertices = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t\t- 0.5,   0.5,  0, 1\n\t\t\t] );\n\t\n\t\t\tvar faces = new Uint16Array( [\n\t\t\t\t0, 1, 2,\n\t\t\t\t0, 2, 3\n\t\t\t] );\n\t\n\t\t\tvertexBuffer  = gl.createBuffer();\n\t\t\telementBuffer = gl.createBuffer();\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\t\n\t\t\tprogram = createProgram();\n\t\n\t\t\tattributes = {\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t\t};\n\t\n\t\t\tuniforms = {\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\t\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\t\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\t\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\t\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\t\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t\t};\n\t\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = 8;\n\t\t\tcanvas.height = 8;\n\t\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\n\t\n\t\t\ttexture = new THREE.Texture( canvas );\n\t\t\ttexture.needsUpdate = true;\n\t\n\t\t}\n\t\n\t\tthis.render = function ( scene, camera ) {\n\t\n\t\t\tif ( sprites.length === 0 ) return;\n\t\n\t\t\t// setup gl\n\t\n\t\t\tif ( program === undefined ) {\n\t\n\t\t\t\tinit();\n\t\n\t\t\t}\n\t\n\t\t\tgl.useProgram( program );\n\t\n\t\t\tstate.initAttributes();\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\tstate.enableAttribute( attributes.uv );\n\t\t\tstate.disableUnusedAttributes();\n\t\n\t\t\tstate.disable( gl.CULL_FACE );\n\t\t\tstate.enable( gl.BLEND );\n\t\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\t\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\t\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\tgl.uniform1i( uniforms.map, 0 );\n\t\n\t\t\tvar oldFogType = 0;\n\t\t\tvar sceneFogType = 0;\n\t\t\tvar fog = scene.fog;\n\t\n\t\t\tif ( fog ) {\n\t\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\t\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\t\toldFogType = 1;\n\t\t\t\t\tsceneFogType = 1;\n\t\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\t\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\t\toldFogType = 2;\n\t\t\t\t\tsceneFogType = 2;\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\t\toldFogType = 0;\n\t\t\t\tsceneFogType = 0;\n\t\n\t\t\t}\n\t\n\t\n\t\t\t// update positions and sort\n\t\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar sprite = sprites[ i ];\n\t\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\t\n\t\t\t}\n\t\n\t\t\tsprites.sort( painterSortStable );\n\t\n\t\t\t// render all sprites\n\t\n\t\t\tvar scale = [];\n\t\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar sprite = sprites[ i ];\n\t\t\t\tvar material = sprite.material;\n\t\n\t\t\t\tif ( material.visible === false ) continue;\n\t\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\t\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\t\n\t\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\t\tscale[ 1 ] = spriteScale.y;\n\t\n\t\t\t\tvar fogType = 0;\n\t\n\t\t\t\tif ( scene.fog && material.fog ) {\n\t\n\t\t\t\t\tfogType = sceneFogType;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( oldFogType !== fogType ) {\n\t\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\t\toldFogType = fogType;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( material.map !== null ) {\n\t\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\t\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\t\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\n\t\n\t\t\t\tif ( material.map ) {\n\t\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\t\n\t\t\t}\n\t\n\t\t\t// restore gl\n\t\n\t\t\tstate.enable( gl.CULL_FACE );\n\t\n\t\t\trenderer.resetGLState();\n\t\n\t\t};\n\t\n\t\tfunction createProgram () {\n\t\n\t\t\tvar program = gl.createProgram();\n\t\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\n\t\t\tgl.shaderSource( vertexShader, [\n\t\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform float rotation;',\n\t\t\t\t'uniform vec2 scale;',\n\t\t\t\t'uniform vec2 uvOffset;',\n\t\t\t\t'uniform vec2 uvScale;',\n\t\n\t\t\t\t'attribute vec2 position;',\n\t\t\t\t'attribute vec2 uv;',\n\t\n\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\t\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\n\t\n\t\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\t\n\t\t\t\t\t'vec4 finalPosition;',\n\t\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\t\n\t\t\t\t\t'gl_Position = finalPosition;',\n\t\n\t\t\t\t'}'\n\t\n\t\t\t].join( '\\n' ) );\n\t\n\t\t\tgl.shaderSource( fragmentShader, [\n\t\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\t\n\t\t\t\t'uniform vec3 color;',\n\t\t\t\t'uniform sampler2D map;',\n\t\t\t\t'uniform float opacity;',\n\t\n\t\t\t\t'uniform int fogType;',\n\t\t\t\t'uniform vec3 fogColor;',\n\t\t\t\t'uniform float fogDensity;',\n\t\t\t\t'uniform float fogNear;',\n\t\t\t\t'uniform float fogFar;',\n\t\t\t\t'uniform float alphaTest;',\n\t\n\t\t\t\t'varying vec2 vUV;',\n\t\n\t\t\t\t'void main() {',\n\t\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\t\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\t\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\t\n\t\t\t\t\t'if ( fogType > 0 ) {',\n\t\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t\t'float fogFactor = 0.0;',\n\t\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\n\t\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\t\n\t\t\t\t\t\t'} else {',\n\t\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\t\n\t\t\t\t\t\t'}',\n\t\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\t\n\t\t\t\t\t'}',\n\t\n\t\t\t\t'}'\n\t\n\t\t\t].join( '\\n' ) );\n\t\n\t\t\tgl.compileShader( vertexShader );\n\t\t\tgl.compileShader( fragmentShader );\n\t\n\t\t\tgl.attachShader( program, vertexShader );\n\t\t\tgl.attachShader( program, fragmentShader );\n\t\n\t\t\tgl.linkProgram( program );\n\t\n\t\t\treturn program;\n\t\n\t\t}\n\t\n\t\tfunction painterSortStable ( a, b ) {\n\t\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\n\t\n\t\t\t\treturn a.renderOrder - b.renderOrder;\n\t\n\t\t\t} else if ( a.z !== b.z ) {\n\t\n\t\t\t\treturn b.z - a.z;\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn b.id - a.id;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/Three.Legacy.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tObject.assign( THREE, {\n\t\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t\t},\n\t\tLineStrip: 0,\n\t\tLinePieces: 1,\n\t\tMeshFaceMaterial: THREE.MultiMaterial,\n\t\tPointCloud: function ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\t\treturn new THREE.Points( geometry, material );\n\t\t},\n\t\tParticle: THREE.Sprite,\n\t\tParticleSystem: function ( geometry, material ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\t\treturn new THREE.Points( geometry, material );\n\t\t},\n\t\tPointCloudMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tParticleBasicMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tParticleSystemMaterial: function ( parameters ) {\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\t\treturn new THREE.PointsMaterial( parameters );\n\t\t},\n\t\tVertex: function ( x, y, z ) {\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\t\treturn new THREE.Vector3( x, y, z );\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Box2.prototype, {\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Box3.prototype, {\n\t\tempty: function () {\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\t\treturn this.isEmpty();\n\t\t},\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Matrix3.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix3( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Matrix4.prototype, {\n\t\textractPosition: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\t\treturn this.copyPosition( m );\n\t\t},\n\t\tsetRotationFromQuaternion: function ( q ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\t\treturn this.makeRotationFromQuaternion( q );\n\t\t},\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\t\treturn vector.applyProjection( this );\n\t\t},\n\t\tmultiplyVector4: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\tmultiplyVector3Array: function ( a ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\t\treturn this.applyToVector3Array( a );\n\t\t},\n\t\trotateAxis: function ( v ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\t\tv.transformDirection( this );\n\t\t},\n\t\tcrossVector: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\t\treturn vector.applyMatrix4( this );\n\t\t},\n\t\ttranslate: function ( v ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t\t},\n\t\trotateX: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t\t},\n\t\trotateY: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t\t},\n\t\trotateZ: function ( angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t\t},\n\t\trotateByAxis: function ( axis, angle ) {\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Plane.prototype, {\n\t\tisIntersectionLine: function ( line ) {\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\t\treturn this.intersectsLine( line );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Quaternion.prototype, {\n\t\tmultiplyVector3: function ( vector ) {\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\t\treturn vector.applyQuaternion( this );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Ray.prototype, {\n\t\tisIntersectionBox: function ( box ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\t\treturn this.intersectsBox( box );\n\t\t},\n\t\tisIntersectionPlane: function ( plane ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\t\treturn this.intersectsPlane( plane );\n\t\t},\n\t\tisIntersectionSphere: function ( sphere ) {\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\t\treturn this.intersectsSphere( sphere );\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.Vector3.prototype, {\n\t\tsetEulerFromRotationMatrix: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t\t},\n\t\tsetEulerFromQuaternion: function () {\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t\t},\n\t\tgetPositionFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\t\treturn this.setFromMatrixPosition( m );\n\t\t},\n\t\tgetScaleFromMatrix: function ( m ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\t\treturn this.setFromMatrixScale( m );\n\t\t},\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Object3D.prototype, {\n\t\tgetChildByName: function ( name ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\t\treturn this.getObjectByName( name );\n\t\t},\n\t\trenderDepth: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t\t},\n\t\ttranslate: function ( distance, axis ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\t\treturn this.translateOnAxis( axis, distance );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.LOD.prototype, {\n\t\tobjects: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\t\treturn this.levels;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\t\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\t\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength( focalLength );\n\t\n\t};\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.BufferGeometry.prototype, {\n\t\taddIndex: function ( index ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\t\tthis.setIndex( index );\n\t\t},\n\t\taddDrawCall: function ( start, count, indexOffset ) {\n\t\t\tif ( indexOffset !== undefined ) {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t\t}\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\t\tthis.addGroup( start, count );\n\t\t},\n\t\tclearDrawCalls: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\t\tthis.clearGroups();\n\t\t},\n\t\tcomputeTangents: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t\t},\n\t\tcomputeOffsets: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\t\treturn new THREE.Color();\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\t\tmetal: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\t\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\n\t\n\t\tconstructor: THREE.EventDispatcher,\n\t\n\t\tapply: function ( target ) {\n\t\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\t\n\t\t\tObject.assign( target, this );\n\t\n\t\t}\n\t\n\t} ), THREE.EventDispatcher.prototype );\n\t\n\t//\n\t\n\tObject.assign( THREE.WebGLRenderer.prototype, {\n\t\tsupportsFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\n\t\t},\n\t\tsupportsHalfFloatTextures: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t\t},\n\t\tsupportsStandardDerivatives: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t\t},\n\t\tsupportsCompressedTextureS3TC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t\t},\n\t\tsupportsCompressedTexturePVRTC: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t\t},\n\t\tsupportsBlendMinMax: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t\t},\n\t\tsupportsVertexTextures: function () {\n\t\t\treturn this.capabilities.vertexTextures;\n\t\t},\n\t\tsupportsInstancedArrays: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t\t},\n\t\tenableScissorTest: function ( boolean ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\t\tthis.setScissorTest( boolean );\n\t\t},\n\t\tinitMaterial: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t\t},\n\t\taddPrePlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t\t},\n\t\taddPostPlugin: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t\t},\n\t\tupdateShadowMap: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.cullFace;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\t\tthis.shadowMap.cullFace = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\tObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t\t},\n\t\t\tset: function ( cullFace ) {\n\t\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\t\tthis.renderReverseSided = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tObject.assign( THREE.Audio.prototype, {\n\t\tload: function ( file ) {\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\t\tvar scope = this;\n\t\t\tvar audioLoader = new THREE.AudioLoader();\n\t\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\t\tscope.setBuffer( buffer );\n\t\t\t} );\n\t\t\treturn this;\n\t\t}\n\t} );\n\t\n\tObject.assign( THREE.AudioAnalyser.prototype, {\n\t\tgetData: function ( file ) {\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\t\treturn this.getFrequencyData();\n\t\t}\n\t} );\n\t\n\t//\n\t\n\tTHREE.GeometryUtils = {\n\t\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\t\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\t\n\t\t\tvar matrix;\n\t\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\t\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\t\n\t\t\t\tmatrix = geometry2.matrix;\n\t\t\t\tgeometry2 = geometry2.geometry;\n\t\n\t\t\t}\n\t\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\t\n\t\t},\n\t\n\t\tcenter: function ( geometry ) {\n\t\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\t\treturn geometry.center();\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ImageUtils = {\n\t\n\t\tcrossOrigin: undefined,\n\t\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\t\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\t\n\t\t\tvar loader = new THREE.TextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\t\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\t\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\t\n\t\t\tvar loader = new THREE.CubeTextureLoader();\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\t\n\t\t\tif ( mapping ) texture.mapping = mapping;\n\t\n\t\t\treturn texture;\n\t\n\t\t},\n\t\n\t\tloadCompressedTexture: function () {\n\t\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t},\n\t\n\t\tloadCompressedTextureCube: function () {\n\t\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\t\n\t\t}\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.Projector = function () {\n\t\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\t\n\t\tthis.projectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\t\tvector.project( camera );\n\t\n\t\t};\n\t\n\t\tthis.unprojectVector = function ( vector, camera ) {\n\t\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\t\tvector.unproject( camera );\n\t\n\t\t};\n\t\n\t\tthis.pickingRay = function ( vector, camera ) {\n\t\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\t\n\t\t};\n\t\n\t};\n\t\n\t//\n\t\n\tTHREE.CanvasRenderer = function () {\n\t\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\t\n\t\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tthis.clear = function () {};\n\t\tthis.render = function () {};\n\t\tthis.setClearColor = function () {};\n\t\tthis.setSize = function () {};\n\t\n\t};\n\t\n\t// File:src/extras/CurveUtils.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.CurveUtils = {\n\t\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\t\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\t\n\t\t},\n\t\n\t\t// Puay Bing, thanks for helping with this derivative!\n\t\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t\t3 * t * t * p3;\n\t\n\t\t},\n\t\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t// To check if my formulas are correct\n\t\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\t\n\t\t\treturn h00 + h10 + h01 + h11;\n\t\n\t\t},\n\t\n\t\t// Catmull-Rom\n\t\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\n\t\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/SceneUtils.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.SceneUtils = {\n\t\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\t\n\t\t\tvar group = new THREE.Group();\n\t\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\t\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn group;\n\t\n\t\t},\n\t\n\t\tdetach: function ( child, parent, scene ) {\n\t\n\t\t\tchild.applyMatrix( parent.matrixWorld );\n\t\t\tparent.remove( child );\n\t\t\tscene.add( child );\n\t\n\t\t},\n\t\n\t\tattach: function ( child, scene, parent ) {\n\t\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\t\tchild.applyMatrix( matrixWorldInverse );\n\t\n\t\t\tscene.remove( child );\n\t\t\tparent.add( child );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/ShapeUtils.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\t\n\tTHREE.ShapeUtils = {\n\t\n\t\t// calculate area of the contour polygon\n\t\n\t\tarea: function ( contour ) {\n\t\n\t\t\tvar n = contour.length;\n\t\t\tvar a = 0.0;\n\t\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\t\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\t\n\t\t\t}\n\t\n\t\t\treturn a * 0.5;\n\t\n\t\t},\n\t\n\t\ttriangulate: ( function () {\n\t\n\t\t\t/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\t\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\n\t\n\t\t\t\tvar p;\n\t\t\t\tvar ax, ay, bx, by;\n\t\t\t\tvar cx, cy, px, py;\n\t\n\t\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\t\tay = contour[ verts[ u ] ].y;\n\t\n\t\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\t\tby = contour[ verts[ v ] ].y;\n\t\n\t\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\t\tcy = contour[ verts[ w ] ].y;\n\t\n\t\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\t\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\t\n\t\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\t\tcX = bx - ax;  cY = by - ay;\n\t\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\n\t\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\n\t\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\t\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\t\n\t\t\t\t\t// see if p is inside triangle abc\n\t\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\t\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn true;\n\t\n\t\t\t}\n\t\n\t\t\t// takes in an contour array and returns\n\t\n\t\t\treturn function triangulate( contour, indices ) {\n\t\n\t\t\t\tvar n = contour.length;\n\t\n\t\t\t\tif ( n < 3 ) return null;\n\t\n\t\t\t\tvar result = [],\n\t\t\t\t\tverts = [],\n\t\t\t\t\tvertIndices = [];\n\t\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\n\t\n\t\t\t\tvar u, v, w;\n\t\n\t\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\t\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar nv = n;\n\t\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\t\n\t\t\t\tvar count = 2 * nv;   /* error detection */\n\t\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\t\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\t\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\n\t\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\t\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t\t//return null;\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\t\n\t\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\t\treturn result;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\t\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\t\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\t\n\t\t\t\t\t\tvar a, b, c, s, t;\n\t\n\t\t\t\t\t\t/* true names of the vertices */\n\t\n\t\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\t\tc = verts[ w ];\n\t\n\t\t\t\t\t\t/* output Triangle */\n\t\n\t\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\t\tcontour[ c ] ] );\n\t\n\t\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\t\n\t\t\t\t\t\t/* remove v from the remaining polygon */\n\t\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\t\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tnv --;\n\t\n\t\t\t\t\t\t/* reset error detection counter */\n\t\n\t\t\t\t\t\tcount = 2 * nv;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\t\n\t\t\t}\n\t\n\t\t} )(),\n\t\n\t\ttriangulateShape: function ( contour, holes ) {\n\t\n\t\t\tfunction removeDupEndPts(points) {\n\t\n\t\t\t\tvar l = points.length;\n\t\n\t\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\t\tpoints.pop();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tremoveDupEndPts( contour );\n\t\t\tholes.forEach( removeDupEndPts );\n\t\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\t\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\t\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\t\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\t\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\t\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\t\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// not parallel\n\t\n\t\t\t\t\tvar perpSeg2;\n\t\t\t\t\tif ( limit > 0 ) {\n\t\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\n\t\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( perpSeg2 === limit ) {\n\t\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\t\n\t\t\t\t\t// return real intersection point\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\t\n\t\t\t\t\t// they are collinear or degenerate\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t\t// both segments are points\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\t\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// segment#1  is a single point\n\t\t\t\t\tif ( seg1Pt ) {\n\t\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\n\t\n\t\t\t\t\t}\n\t\t\t\t\t// segment#2  is a single point\n\t\t\t\t\tif ( seg2Pt ) {\n\t\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\t\tif ( seg1dx !== 0 ) {\n\t\n\t\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\t\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\t\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg2min ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\t\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\t\treturn [ seg1min ];\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\t\n\t\t\t\t// The order of legs is important\n\t\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\t\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\t\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t// angle != 180 deg.\n\t\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\t\n\t\t\t\t\tif ( from2toAngle > 0 ) {\n\t\n\t\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// angle == 180 deg.\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\n\t\t\tfunction removeHoles( contour, holes ) {\n\t\n\t\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\t\tvar hole;\n\t\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\t\n\t\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\t\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\t\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\t\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\t\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\t\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\t\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\t\tif ( ! insideAngle ) {\n\t\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\ttrue;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t// checks for intersections with shape edges\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\t\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar indepHoles = [];\n\t\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\t\n\t\t\t\t\t// checks for intersections with hole edges\n\t\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\t\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t\treturn\tfalse;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\t\tshapePt, holePt,\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\t\ttmpHole1, tmpHole2;\n\t\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\t\tindepHoles.push( h );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar minShapeIndex = 0;\n\t\t\t\tvar counter = indepHoles.length * 2;\n\t\t\t\twhile ( indepHoles.length > 0 ) {\n\t\n\t\t\t\t\tcounter --;\n\t\t\t\t\tif ( counter < 0 ) {\n\t\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t\t// which can be connected without intersections\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\t\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\t\tholeIndex\t= - 1;\n\t\n\t\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\t\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\t\n\t\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\t\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\t\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\t\n\t\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\t\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\t\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\t\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\t\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\n\t\n\t\t\t}\n\t\n\t\n\t\t\tvar i, il, f, face,\n\t\t\t\tkey, index,\n\t\t\t\tallPointsMap = {};\n\t\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\t\n\t\t\tvar allpoints = contour.concat();\n\t\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\t\n\t\t\t}\n\t\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\t\n\t\t\t// prepare all points map\n\t\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\t\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\t\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\t\n\t\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tallPointsMap[ key ] = i;\n\t\n\t\t\t}\n\t\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\t\n\t\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\n\t\t\t// check all face vertices against all points map\n\t\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\t\n\t\t\t\tface = triangles[ i ];\n\t\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\t\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\t\n\t\t\t\t\tindex = allPointsMap[ key ];\n\t\n\t\t\t\t\tif ( index !== undefined ) {\n\t\n\t\t\t\t\t\tface[ f ] = index;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn triangles.concat();\n\t\n\t\t},\n\t\n\t\tisClockWise: function ( pts ) {\n\t\n\t\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\t\n\t\t},\n\t\n\t\t// Bezier Curves formulas obtained from\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\t\n\t\t// Quad Bezier Functions\n\t\n\t\tb2: ( function () {\n\t\n\t\t\tfunction b2p0( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b2p1( t, p ) {\n\t\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b2p2( t, p ) {\n\t\n\t\t\t\treturn t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function b2( t, p0, p1, p2 ) {\n\t\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\t\n\t\t\t};\n\t\n\t\t} )(),\n\t\n\t\t// Cubic Bezier Functions\n\t\n\t\tb3: ( function () {\n\t\n\t\t\tfunction b3p0( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn k * k * k * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p1( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * k * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p2( t, p ) {\n\t\n\t\t\t\tvar k = 1 - t;\n\t\t\t\treturn 3 * k * t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\tfunction b3p3( t, p ) {\n\t\n\t\t\t\treturn t * t * t * p;\n\t\n\t\t\t}\n\t\n\t\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\t\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\t\n\t\t\t};\n\t\n\t\t} )()\n\t\n\t};\n\t\n\t// File:src/extras/core/Curve.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTagentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.SplineCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\t\n\t/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\t\n\tTHREE.Curve = function () {\n\t\n\t};\n\t\n\tTHREE.Curve.prototype = {\n\t\n\t\tconstructor: THREE.Curve,\n\t\n\t\t// Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\t\n\t\tgetPoint: function ( t ) {\n\t\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\t\treturn null;\n\t\n\t\t},\n\t\n\t\t// Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\t\n\t\tgetPointAt: function ( u ) {\n\t\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getPoint( t );\n\t\n\t\t},\n\t\n\t\t// Get sequence of points using getPoint( t )\n\t\n\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\tvar points = [];\n\t\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\t// Get sequence of points using getPointAt( u )\n\t\n\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 5;\n\t\n\t\t\tvar points = [];\n\t\n\t\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\t\n\t\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\t// Get total curve arc length\n\t\n\t\tgetLength: function () {\n\t\n\t\t\tvar lengths = this.getLengths();\n\t\t\treturn lengths[ lengths.length - 1 ];\n\t\n\t\t},\n\t\n\t\t// Get list of cumulative segment lengths\n\t\n\t\tgetLengths: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\t\n\t\t\tif ( this.cacheArcLengths\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t\t&& ! this.needsUpdate ) {\n\t\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\t\treturn this.cacheArcLengths;\n\t\n\t\t\t}\n\t\n\t\t\tthis.needsUpdate = false;\n\t\n\t\t\tvar cache = [];\n\t\t\tvar current, last = this.getPoint( 0 );\n\t\t\tvar p, sum = 0;\n\t\n\t\t\tcache.push( 0 );\n\t\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\t\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\t\tsum += current.distanceTo( last );\n\t\t\t\tcache.push( sum );\n\t\t\t\tlast = current;\n\t\n\t\t\t}\n\t\n\t\t\tthis.cacheArcLengths = cache;\n\t\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\t\n\t\t},\n\t\n\t\tupdateArcLengths: function() {\n\t\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\t\n\t\t},\n\t\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\t\n\t\tgetUtoTmapping: function ( u, distance ) {\n\t\n\t\t\tvar arcLengths = this.getLengths();\n\t\n\t\t\tvar i = 0, il = arcLengths.length;\n\t\n\t\t\tvar targetArcLength; // The targeted u distance value to get\n\t\n\t\t\tif ( distance ) {\n\t\n\t\t\t\ttargetArcLength = distance;\n\t\n\t\t\t} else {\n\t\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\t\n\t\t\t}\n\t\n\t\t\t//var time = Date.now();\n\t\n\t\t\t// binary search for the index with largest value smaller than target u distance\n\t\n\t\t\tvar low = 0, high = il - 1, comparison;\n\t\n\t\t\twhile ( low <= high ) {\n\t\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\t\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\t\n\t\t\t\tif ( comparison < 0 ) {\n\t\n\t\t\t\t\tlow = i + 1;\n\t\n\t\t\t\t} else if ( comparison > 0 ) {\n\t\n\t\t\t\t\thigh = i - 1;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t// DONE\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\ti = high;\n\t\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\n\t\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\t\n\t\t\t\tvar t = i / ( il - 1 );\n\t\t\t\treturn t;\n\t\n\t\t\t}\n\t\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\t\n\t\t\tvar lengthBefore = arcLengths[ i ];\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\t\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\n\t\n\t\t\t// determine where we are between the 'before' and 'after' points\n\t\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\t\n\t\t\t// add that fractional amount to t\n\t\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\t\n\t\t\treturn t;\n\t\n\t\t},\n\t\n\t\t// Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\t\n\t\tgetTangent: function( t ) {\n\t\n\t\t\tvar delta = 0.0001;\n\t\t\tvar t1 = t - delta;\n\t\t\tvar t2 = t + delta;\n\t\n\t\t\t// Capping in case of danger\n\t\n\t\t\tif ( t1 < 0 ) t1 = 0;\n\t\t\tif ( t2 > 1 ) t2 = 1;\n\t\n\t\t\tvar pt1 = this.getPoint( t1 );\n\t\t\tvar pt2 = this.getPoint( t2 );\n\t\n\t\t\tvar vec = pt2.clone().sub( pt1 );\n\t\t\treturn vec.normalize();\n\t\n\t\t},\n\t\n\t\tgetTangentAt: function ( u ) {\n\t\n\t\t\tvar t = this.getUtoTmapping( u );\n\t\t\treturn this.getTangent( t );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// TODO: Transformation for Curves?\n\t\n\t/**************************************************************\n\t *\t3D Curves\n\t **************************************************************/\n\t\n\t// A Factory method for creating new curve subclasses\n\t\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\t\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\t\tconstructor.prototype.constructor = constructor;\n\t\tconstructor.prototype.getPoint = getPointFunc;\n\t\n\t\treturn constructor;\n\t\n\t};\n\t\n\t// File:src/extras/core/CurvePath.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\t\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\t\n\tTHREE.CurvePath = function () {\n\t\n\t\tthis.curves = [];\n\t\n\t\tthis.autoClose = false; // Automatically closes the path\n\t\n\t};\n\t\n\tTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\t\n\t\tconstructor: THREE.CurvePath,\n\t\n\t\tadd: function ( curve ) {\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t},\n\t\n\t\tclosePath: function () {\n\t\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\t\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\n\t\n\t\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\t// To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\t\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\t\n\t\tgetPoint: function ( t ) {\n\t\n\t\t\tvar d = t * this.getLength();\n\t\t\tvar curveLengths = this.getCurveLengths();\n\t\t\tvar i = 0;\n\t\n\t\t\t// To think about boundaries points.\n\t\n\t\t\twhile ( i < curveLengths.length ) {\n\t\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\n\t\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\t\tvar curve = this.curves[ i ];\n\t\n\t\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\n\t\t\t\t\treturn curve.getPointAt( u );\n\t\n\t\t\t\t}\n\t\n\t\t\t\ti ++;\n\t\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\n\t\n\t\t},\n\t\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\t\n\t\tgetLength: function () {\n\t\n\t\t\tvar lens = this.getCurveLengths();\n\t\t\treturn lens[ lens.length - 1 ];\n\t\n\t\t},\n\t\n\t\t// cacheLengths must be recalculated.\n\t\tupdateArcLengths: function () {\n\t\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getLengths();\n\t\n\t\t},\n\t\n\t\t// Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\t\n\t\tgetCurveLengths: function () {\n\t\n\t\t\t// We use cache values if curves and cache array are same length\n\t\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\t\n\t\t\t\treturn this.cacheLengths;\n\t\n\t\t\t}\n\t\n\t\t\t// Get length of sub-curve\n\t\t\t// Push sums into cached array\n\t\n\t\t\tvar lengths = [], sums = 0;\n\t\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\t\n\t\t\t\tsums += this.curves[ i ].getLength();\n\t\t\t\tlengths.push( sums );\n\t\n\t\t\t}\n\t\n\t\t\tthis.cacheLengths = lengths;\n\t\n\t\t\treturn lengths;\n\t\n\t\t},\n\t\n\t\tgetSpacedPoints: function ( divisions ) {\n\t\n\t\t\tif ( ! divisions ) divisions = 40;\n\t\n\t\t\tvar points = [];\n\t\n\t\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\t\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClose ) {\n\t\n\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\tgetPoints: function ( divisions ) {\n\t\n\t\t\tdivisions = divisions || 12;\n\t\n\t\t\tvar points = [], last;\n\t\n\t\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\t\n\t\t\t\tvar curve = curves[ i ];\n\t\t\t\tvar resolution = curve instanceof THREE.EllipseCurve ? divisions * 2\n\t\t\t\t\t: curve instanceof THREE.LineCurve ? 1\n\t\t\t\t\t: curve instanceof THREE.SplineCurve ? divisions * curve.points.length\n\t\t\t\t\t: divisions;\n\t\n\t\t\t\tvar pts = curve.getPoints( resolution );\n\t\n\t\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\t\n\t\t\t\t\tvar point = pts[ j ];\n\t\n\t\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\t\n\t\t\t\t\tpoints.push( point );\n\t\t\t\t\tlast = point;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\t\n\t\t\t\tpoints.push( points[ 0 ] );\n\t\n\t\t\t}\n\t\n\t\t\treturn points;\n\t\n\t\t},\n\t\n\t\t/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\t\n\t\t/// Generate geometry from path points (for Line or Points objects)\n\t\n\t\tcreatePointsGeometry: function ( divisions ) {\n\t\n\t\t\tvar pts = this.getPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\t\n\t\t},\n\t\n\t\t// Generate geometry from equidistant sampling along the path\n\t\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\n\t\n\t\t\tvar pts = this.getSpacedPoints( divisions );\n\t\t\treturn this.createGeometry( pts );\n\t\n\t\t},\n\t\n\t\tcreateGeometry: function ( points ) {\n\t\n\t\t\tvar geometry = new THREE.Geometry();\n\t\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar point = points[ i ];\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\t\n\t\t\t}\n\t\n\t\t\treturn geometry;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/core/Font.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Font = function ( data ) {\n\t\n\t\tthis.data = data;\n\t\n\t};\n\t\n\tObject.assign( THREE.Font.prototype, {\n\t\n\t\tgenerateShapes: function ( text, size, divisions ) {\n\t\n\t\t\tfunction createPaths( text ) {\n\t\n\t\t\t\tvar chars = String( text ).split( '' );\n\t\t\t\tvar scale = size / data.resolution;\n\t\t\t\tvar offset = 0;\n\t\n\t\t\t\tvar paths = [];\n\t\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\t\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\t\toffset += ret.offset;\n\t\n\t\t\t\t\tpaths.push( ret.path );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn paths;\n\t\n\t\t\t}\n\t\n\t\t\tfunction createPath( c, scale, offset ) {\n\t\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\t\n\t\t\t\tif ( ! glyph ) return;\n\t\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\n\t\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\t\n\t\t\t\tif ( glyph.o ) {\n\t\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\t\n\t\t\t\t\t\tvar action = outline[ i ++ ];\n\t\n\t\t\t\t\t\tswitch ( action ) {\n\t\n\t\t\t\t\t\t\tcase 'm': // moveTo\n\t\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'l': // lineTo\n\t\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\t\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\t\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\t\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\t\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\t\n\t\t\t\t\t\t\t\tif ( laste ) {\n\t\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\t\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\t\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\t\n\t\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\n\t\n\t\t\t}\n\t\n\t\t\t//\n\t\n\t\t\tif ( size === undefined ) size = 100;\n\t\t\tif ( divisions === undefined ) divisions = 4;\n\t\n\t\t\tvar data = this.data;\n\t\n\t\t\tvar paths = createPaths( text );\n\t\t\tvar shapes = [];\n\t\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\t\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\t\n\t\t\t}\n\t\n\t\t\treturn shapes;\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/core/Path.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t *\n\t **/\n\t\n\tTHREE.Path = function ( points ) {\n\t\n\t\tTHREE.CurvePath.call( this );\n\t\tthis.currentPoint = new THREE.Vector2();\n\t\n\t\tif ( points ) {\n\t\n\t\t\tthis.fromPoints( points );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\t\n\t\tconstructor: THREE.Path,\n\t\n\t\t// Create path using straight lines to connect all points\n\t\t// - vectors: array of Vector2\n\t\tfromPoints: function ( vectors ) {\n\t\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\t\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\t\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\t\n\t\t\t}\n\t\n\t\t},\n\t\n\t\tmoveTo: function ( x, y ) {\n\t\n\t\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\t\n\t\t},\n\t\n\t\tlineTo: function ( x, y ) {\n\t\n\t\t\tvar curve = new THREE.LineCurve( this.currentPoint.clone(), new THREE.Vector2( x, y ) );\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.currentPoint.set( x, y );\n\t\n\t\t},\n\t\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\n\t\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\tnew THREE.Vector2( aX, aY )\n\t\t\t);\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t},\n\t\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\n\t\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\t\tthis.currentPoint.clone(),\n\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\tnew THREE.Vector2( aX, aY )\n\t\t\t);\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.currentPoint.set( aX, aY );\n\t\n\t\t},\n\t\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\t\n\t\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\t\n\t\t\tvar curve = new THREE.SplineCurve( npts );\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\t\n\t\t},\n\t\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\t\n\t\t},\n\t\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t\t},\n\t\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tvar x0 = this.currentPoint.x;\n\t\t\tvar y0 = this.currentPoint.y;\n\t\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t},\n\t\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\t\n\t\t\tif ( this.curves.length > 0 ) {\n\t\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tvar firstPoint = curve.getPoint( 0 );\n\t\n\t\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\t\n\t\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.curves.push( curve );\n\t\n\t\t\tvar lastPoint = curve.getPoint( 1 );\n\t\t\tthis.currentPoint.copy( lastPoint );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t\n\t// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\tTHREE.ShapePath = function() {\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\t}\n\t\n\tTHREE.ShapePath.prototype = {\n\t\tmoveTo: function ( x, y ) {\n\t\t\tthis.currentPath = new THREE.Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo( x, y );\n\t\t},\n\t\tlineTo: function ( x, y ) {\n\t\t\tthis.currentPath.lineTo( x, y );\n\t\t},\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t\t},\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t\t},\n\t\tsplineThru: function ( pts ) {\n\t\t\tthis.currentPath.splineThru( pts );\n\t\t},\n\t\n\t\ttoShapes: function ( isCCW, noHoles ) {\n\t\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\n\t\n\t\t\t\tvar shapes = [];\n\t\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\t\n\t\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\n\t\t\t\t\tshapes.push( tmpShape );\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\t\n\t\t\t\tvar polyLen = inPolygon.length;\n\t\n\t\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\t\tvar inside = false;\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\t\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\t\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\t\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\t\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\n\t\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\t\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\t\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\n\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\treturn\tinside;\n\t\n\t\t\t}\n\t\n\t\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\t\n\t\t\tvar subPaths = this.subPaths;\n\t\t\tif ( subPaths.length === 0 ) return [];\n\t\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\t\n\t\t\tif ( subPaths.length === 1 ) {\n\t\n\t\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\treturn shapes;\n\t\n\t\t\t}\n\t\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\t\n\t\t\t// console.log(\"Holes first\", holesFirst);\n\t\n\t\t\tvar betterShapeHoles = [];\n\t\t\tvar newShapes = [];\n\t\t\tvar newShapeHoles = [];\n\t\t\tvar mainIdx = 0;\n\t\t\tvar tmpPoints;\n\t\n\t\t\tnewShapes[ mainIdx ] = undefined;\n\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\t\n\t\t\t\ttmpPath = subPaths[ i ];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\t\tsolid = isCCW ? ! solid : solid;\n\t\n\t\t\t\tif ( solid ) {\n\t\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\t\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\t\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\t\n\t\t\t\t\t//console.log('cw', i);\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\t\n\t\t\t\t\t//console.log('ccw', i);\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\t\n\t\n\t\t\tif ( newShapes.length > 1 ) {\n\t\n\t\t\t\tvar ambiguous = false;\n\t\t\t\tvar toChange = [];\n\t\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\t\n\t\t\t\t}\n\t\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\t\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\t\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\t\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\t\tvar hole_unassigned = true;\n\t\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\t\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\t\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\t\n\t\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( hole_unassigned ) {\n\t\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\t\tif ( toChange.length > 0 ) {\n\t\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar tmpHoles;\n\t\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\t\n\t\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\n\t\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t//console.log(\"shape\", shapes);\n\t\n\t\t\treturn shapes;\n\t\n\t\t}\n\t}\n\t\n\t// File:src/extras/core/Shape.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\t\n\t// STEP 1 Create a path.\n\t// STEP 2 Turn path into shape.\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n\t// STEP 3a - Extract points from each shape, turn to vertices\n\t// STEP 3b - Triangulate each shape, add faces.\n\t\n\tTHREE.Shape = function () {\n\t\n\t\tTHREE.Path.apply( this, arguments );\n\t\n\t\tthis.holes = [];\n\t\n\t};\n\t\n\tTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\t\n\t\tconstructor: THREE.Shape,\n\t\n\t\t// Convenience method to return ExtrudeGeometry\n\t\n\t\textrude: function ( options ) {\n\t\n\t\t\treturn new THREE.ExtrudeGeometry( this, options );\n\t\n\t\t},\n\t\n\t\t// Convenience method to return ShapeGeometry\n\t\n\t\tmakeGeometry: function ( options ) {\n\t\n\t\t\treturn new THREE.ShapeGeometry( this, options );\n\t\n\t\t},\n\t\n\t\tgetPointsHoles: function ( divisions ) {\n\t\n\t\t\tvar holesPts = [];\n\t\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\t\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\t\n\t\t\t}\n\t\n\t\t\treturn holesPts;\n\t\n\t\t},\n\t\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\n\t\n\t\textractAllPoints: function ( divisions ) {\n\t\n\t\t\treturn {\n\t\n\t\t\t\tshape: this.getPoints( divisions ),\n\t\t\t\tholes: this.getPointsHoles( divisions )\n\t\n\t\t\t};\n\t\n\t\t},\n\t\n\t\textractPoints: function ( divisions ) {\n\t\n\t\t\treturn this.extractAllPoints( divisions );\n\t\n\t\t}\n\t\n\t} );\n\t\n\t// File:src/extras/curves/LineCurve.js\n\t\n\t/**************************************************************\n\t *\tLine\n\t **************************************************************/\n\t\n\tTHREE.LineCurve = function ( v1, v2 ) {\n\t\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\n\t};\n\t\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\t\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tif ( t === 1 ) {\n\t\n\t\t\treturn this.v2.clone();\n\t\n\t\t}\n\t\n\t\tvar point = this.v2.clone().sub( this.v1 );\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\t\n\t\treturn point;\n\t\n\t};\n\t\n\t// Line curve is linear, so we can overwrite default getPointAt\n\t\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\t\n\t\treturn this.getPoint( u );\n\t\n\t};\n\t\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\n\t\n\t\treturn tangent.normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/QuadraticBezierCurve.js\n\t\n\t/**************************************************************\n\t *\tQuadratic Bezier curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\t\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\n\t};\n\t\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\t\n\t\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar b2 = THREE.ShapeUtils.b2;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t);\n\t\n\t};\n\t\n\t\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t\t).normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/CubicBezierCurve.js\n\t\n\t/**************************************************************\n\t *\tCubic Bezier curve\n\t **************************************************************/\n\t\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\t\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\t\n\t};\n\t\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\t\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\t\n\t\treturn new THREE.Vector2( \n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t);\n\t\n\t};\n\t\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\t\n\t\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\t\n\t\treturn new THREE.Vector2( \n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t\t).normalize();\n\t\n\t};\n\t\n\t// File:src/extras/curves/SplineCurve.js\n\t\n\t/**************************************************************\n\t *\tSpline curve\n\t **************************************************************/\n\t\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\t\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\t\n\t};\n\t\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\t\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\t\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\t\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\t\n\t\treturn new THREE.Vector2(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t\t);\n\t\n\t};\n\t\n\t// File:src/extras/curves/EllipseCurve.js\n\t\n\t/**************************************************************\n\t *\tEllipse curve\n\t **************************************************************/\n\t\n\tTHREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\t\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\t\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\t\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\t\n\t\tthis.aClockwise = aClockwise;\n\t\n\t\tthis.aRotation = aRotation || 0;\n\t\n\t};\n\t\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\t\n\tTHREE.EllipseCurve.prototype.getPoint = function( t ) {\n\t\n\t\tvar twoPi = Math.PI * 2;\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\t\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\t\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\t\n\t\t\tif ( samePoints ) {\n\t\n\t\t\t\tdeltaAngle = 0;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tdeltaAngle = twoPi;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\t\n\t\t\tif ( deltaAngle === twoPi ) {\n\t\n\t\t\t\tdeltaAngle = - twoPi;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tvar angle = this.aStartAngle + t * deltaAngle;\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\t\n\t\tif ( this.aRotation !== 0 ) {\n\t\n\t\t\tvar cos = Math.cos( this.aRotation );\n\t\t\tvar sin = Math.sin( this.aRotation );\n\t\n\t\t\tvar tx = x - this.aX;\n\t\t\tvar ty = y - this.aY;\n\t\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\n\t\t}\n\t\n\t\treturn new THREE.Vector2( x, y );\n\t\n\t};\n\t\n\t// File:src/extras/curves/ArcCurve.js\n\t\n\t/**************************************************************\n\t *\tArc curve\n\t **************************************************************/\n\t\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\t\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\t\n\t};\n\t\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\t\n\t// File:src/extras/curves/LineCurve3.js\n\t\n\t/**************************************************************\n\t *\tLine3D\n\t **************************************************************/\n\t\n\tTHREE.LineCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v1, v2 ) {\n\t\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tif ( t === 1 ) {\n\t\n\t\t\t\treturn this.v2.clone();\n\t\n\t\t\t}\n\t\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\t\tvector.multiplyScalar( t );\n\t\t\tvector.add( this.v1 );\n\t\n\t\t\treturn vector;\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\n\t\n\t/**************************************************************\n\t *\tQuadratic Bezier 3D curve\n\t **************************************************************/\n\t\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v0, v1, v2 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/CubicBezierCurve3.js\n\t\n\t/**************************************************************\n\t *\tCubic Bezier 3D curve\n\t **************************************************************/\n\t\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( v0, v1, v2, v3 ) {\n\t\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/SplineCurve3.js\n\t\n\t/**************************************************************\n\t *\tSpline 3D curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.SplineCurve3 = THREE.Curve.create(\n\t\n\t\tfunction ( points /* array of Vector3 */ ) {\n\t\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\n\t\n\t\t},\n\t\n\t\tfunction ( t ) {\n\t\n\t\t\tvar points = this.points;\n\t\t\tvar point = ( points.length - 1 ) * t;\n\t\n\t\t\tvar intPoint = Math.floor( point );\n\t\t\tvar weight = point - intPoint;\n\t\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\t\tvar point1 = points[ intPoint ];\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\t\n\t\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\t\n\t\t\treturn new THREE.Vector3(\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t\t);\n\t\n\t\t}\n\t\n\t);\n\t\n\t// File:src/extras/curves/CatmullRomCurve3.js\n\t\n\t/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\t\n\tTHREE.CatmullRomCurve3 = ( function() {\n\t\n\t\tvar\n\t\t\ttmp = new THREE.Vector3(),\n\t\t\tpx = new CubicPoly(),\n\t\t\tpy = new CubicPoly(),\n\t\t\tpz = new CubicPoly();\n\t\n\t\t/*\n\t\tBased on an optimized c++ solution in\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t\t - http://ideone.com/NoEbVM\n\t\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\t\twhich can be placed in CurveUtils.\n\t\t*/\n\t\n\t\tfunction CubicPoly() {\n\t\n\t\t}\n\t\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\t\n\t\t\tthis.c0 = x0;\n\t\t\tthis.c1 = t0;\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\n\t\t};\n\t\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\t\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\t\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\t\n\t\t\t// initCubicPoly\n\t\t\tthis.init( x1, x2, t1, t2 );\n\t\n\t\t};\n\t\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\t\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\t\n\t\t};\n\t\n\t\tCubicPoly.prototype.calc = function( t ) {\n\t\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t2 * t;\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\t\n\t\t};\n\t\n\t\t// Subclass Three.js curve\n\t\treturn THREE.Curve.create(\n\t\n\t\t\tfunction ( p /* array of Vector3 */ ) {\n\t\n\t\t\t\tthis.points = p || [];\n\t\t\t\tthis.closed = false;\n\t\n\t\t\t},\n\t\n\t\t\tfunction ( t ) {\n\t\n\t\t\t\tvar points = this.points,\n\t\t\t\t\tpoint, intPoint, weight, l;\n\t\n\t\t\t\tl = points.length;\n\t\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\t\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\t\tintPoint = Math.floor( point );\n\t\t\t\tweight = point - intPoint;\n\t\n\t\t\t\tif ( this.closed ) {\n\t\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\t\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\t\n\t\t\t\t\tintPoint = l - 2;\n\t\t\t\t\tweight = 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\n\t\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\n\t\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// extrapolate first point\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\t\tp0 = tmp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tp1 = points[ intPoint % l ];\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\t\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\t\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// extrapolate last point\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\t\tp3 = tmp;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\t\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\t\n\t\t\t\t\t// safety check for repeated points\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\t\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\t\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\n\t\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar v = new THREE.Vector3(\n\t\t\t\t\tpx.calc( weight ),\n\t\t\t\t\tpy.calc( weight ),\n\t\t\t\t\tpz.calc( weight )\n\t\t\t\t);\n\t\n\t\t\t\treturn v;\n\t\n\t\t\t}\n\t\n\t\t);\n\t\n\t} )();\n\t\n\t// File:src/extras/curves/ClosedSplineCurve3.js\n\t\n\t/**************************************************************\n\t *\tClosed Spline 3D curve\n\t **************************************************************/\n\t\n\t\n\tTHREE.ClosedSplineCurve3 = function ( points ) {\n\t\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\t\n\t\tTHREE.CatmullRomCurve3.call( this, points );\n\t\tthis.type = 'catmullrom';\n\t\tthis.closed = true;\n\t\n\t};\n\t\n\tTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\t\n\t// File:src/extras/geometries/BoxGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\t\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'BoxGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\t\n\tTHREE.CubeGeometry = THREE.BoxGeometry;\n\t\n\t// File:src/extras/geometries/BoxBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'BoxBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\t\n\t\tvar scope = this;\n\t\n\t\t// segments\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\t\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\tvar numberOfVertices = 0;\n\t\n\t\t// group variables\n\t\tvar groupStart = 0;\n\t\n\t\t// build each side of the box geometry\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\t\n\t\t// build geometry\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t\t// helper functions\n\t\n\t\tfunction calculateVertexCount ( w, h, d ) {\n\t\n\t\t\tvar vertices = 0;\n\t\n\t\t\t// calculate the amount of vertices for each side (plane)\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\t\n\t\t\treturn vertices;\n\t\n\t\t}\n\t\n\t\tfunction calculateIndexCount ( w, h, d ) {\n\t\n\t\t\tvar index = 0;\n\t\n\t\t\t// calculate the amount of squares for each side\n\t\t\tindex += w * h * 2; // xy\n\t\t\tindex += w * d * 2; // xz\n\t\t\tindex += d * h * 2; // zy\n\t\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\n\t\n\t\t}\n\t\n\t\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\t\n\t\t\tvar segmentWidth\t= width / gridX;\n\t\t\tvar segmentHeight = height / gridY;\n\t\n\t\t\tvar widthHalf = width / 2;\n\t\t\tvar heightHalf = height / 2;\n\t\t\tvar depthHalf = depth / 2;\n\t\n\t\t\tvar gridX1 = gridX + 1;\n\t\t\tvar gridY1 = gridY + 1;\n\t\n\t\t\tvar vertexCounter = 0;\n\t\t\tvar groupCount = 0;\n\t\n\t\t\tvar vector = new THREE.Vector3();\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\n\t\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\t\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\t\n\t\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t// set values to correct vector component\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\t\n\t\t\t\t\t// now apply vector to normal buffer\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\t\n\t\t\t\t\t// uvs\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\t\tuvBufferOffset += 2;\n\t\t\t\t\tvertexCounter += 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\t\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\t\t// indices\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t\t// update offsets and counters\n\t\t\t\t\tindexBufferOffset += 6;\n\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t\t// update total number of vertices\n\t\t\tnumberOfVertices += vertexCounter;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\t\n\t// File:src/extras/geometries/CircleGeometry.js\n\t\n\t/**\n\t * @author hughes\n\t */\n\t\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'CircleGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\t\n\t// File:src/extras/geometries/CircleBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\t\n\tTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'CircleBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tradius = radius || 50;\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\tvar vertices = segments + 2;\n\t\n\t\tvar positions = new Float32Array( vertices * 3 );\n\t\tvar normals = new Float32Array( vertices * 3 );\n\t\tvar uvs = new Float32Array( vertices * 2 );\n\t\n\t\t// center data is already zero, but need to set a few extras\n\t\tnormals[ 2 ] = 1.0;\n\t\tuvs[ 0 ] = 0.5;\n\t\tuvs[ 1 ] = 0.5;\n\t\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\t\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\n\t\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\t\n\t\t\tnormals[ i + 2 ] = 1; // normal z\n\t\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\t\n\t\t}\n\t\n\t\tvar indices = [];\n\t\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\n\t\n\t\t\tindices.push( i, i + 1, 0 );\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t};\n\t\n\tTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\t\n\t// File:src/extras/geometries/CylinderBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'CylinderBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tvar scope = this;\n\t\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\t\theight = height !== undefined ? height : 100;\n\t\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\theightSegments = Math.floor( heightSegments ) || 1;\n\t\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\t\n\t\t// used to calculate buffer length\n\t\n\t\tvar nbCap = 0;\n\t\n\t\tif ( openEnded === false ) {\n\t\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\n\t\n\t\t}\n\t\n\t\tvar vertexCount = calculateVertexCount();\n\t\tvar indexCount = calculateIndexCount();\n\t\n\t\t// buffers\n\t\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\n\t\tvar index = 0,\n\t\t    indexOffset = 0,\n\t\t    indexArray = [],\n\t\t    halfHeight = height / 2;\n\t\n\t\t// group variables\n\t\tvar groupStart = 0;\n\t\n\t\t// generate geometry\n\t\n\t\tgenerateTorso();\n\t\n\t\tif ( openEnded === false ) {\n\t\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// helper functions\n\t\n\t\tfunction calculateVertexCount() {\n\t\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\t\n\t\t\t}\n\t\n\t\t\treturn count;\n\t\n\t\t}\n\t\n\t\tfunction calculateIndexCount() {\n\t\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\t\n\t\t\tif ( openEnded === false ) {\n\t\n\t\t\t\tcount += radialSegments * nbCap * 3;\n\t\n\t\t\t}\n\t\n\t\t\treturn count;\n\t\n\t\t}\n\t\n\t\tfunction generateTorso() {\n\t\n\t\t\tvar x, y;\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar vertex = new THREE.Vector3();\n\t\n\t\t\tvar groupCount = 0;\n\t\n\t\t\t// this will be used to calculate the normal\n\t\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\t\n\t\t\t// generate vertices, normals and uvs\n\t\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\t\tvar indexRow = [];\n\t\n\t\t\t\tvar v = y / heightSegments;\n\t\n\t\t\t\t// calculate the radius of the current row\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\t\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t\tvar u = x / radialSegments;\n\t\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t\t// normal\n\t\t\t\t\tnormal.copy( vertex );\n\t\n\t\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\t\n\t\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\t\n\t\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t\t// uv\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\t\t// save index of vertex in respective row\n\t\t\t\t\tindexRow.push( index );\n\t\n\t\t\t\t\t// increase index\n\t\t\t\t\tindex ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// now save vertices of the row in our index array\n\t\t\t\tindexArray.push( indexRow );\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\t\n\t\t\t\t\t// face one\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t// face two\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\t\n\t\t\t\t\t// update counters\n\t\t\t\t\tgroupCount += 6;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t}\n\t\n\t\tfunction generateCap( top ) {\n\t\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\n\t\n\t\t\tvar uv = new THREE.Vector2();\n\t\t\tvar vertex = new THREE.Vector3();\n\t\n\t\t\tvar groupCount = 0;\n\t\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\n\t\n\t\t\t// save the index of the first center vertex\n\t\t\tcenterIndexStart = index;\n\t\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\t\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = 0.5;\n\t\t\t\tuv.y = 0.5;\n\t\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\t// save the index of the last center vertex\n\t\t\tcenterIndexEnd = index;\n\t\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\t\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\t\n\t\t\t\tvar u = x / radialSegments;\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\n\t\n\t\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\t\tvar sinTheta = Math.sin( theta );\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\t// generate indices\n\t\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\t\n\t\t\t\tvar c = centerIndexStart + x;\n\t\t\t\tvar i = centerIndexEnd + x;\n\t\n\t\t\t\tif ( top === true ) {\n\t\n\t\t\t\t\t// face top\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// face bottom\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 3;\n\t\n\t\t\t}\n\t\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\t\n\t\t\t// calculate new start value for groups\n\t\t\tgroupStart += groupCount;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\t\n\t// File:src/extras/geometries/CylinderGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'CylinderGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\t\n\t// File:src/extras/geometries/ConeBufferGeometry.js\n\t\n\t/*\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\t\n\tTHREE.ConeBufferGeometry = function (\n\t\tradius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.CylinderBufferGeometry.call( this,\n\t\t\t0, radius, height,\n\t\t\tradialSegments, heightSegments,\n\t\t\topenEnded, thetaStart, thetaLength );\n\t\n\t\tthis.type = 'ConeBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t};\n\t\n\tTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\t\n\t// File:src/extras/geometries/ConeGeometry.js\n\t\n\t/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\t\n\tTHREE.ConeGeometry = function (\n\t\tradius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.CylinderGeometry.call( this,\n\t\t\t0, radius, height,\n\t\t\tradialSegments, heightSegments,\n\t\t\topenEnded, thetaStart, thetaLength );\n\t\n\t\tthis.type = 'ConeGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t};\n\t\n\tTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\n\tTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\t\n\t// File:src/extras/geometries/EdgesGeometry.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\t\n\t\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\t\n\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\treturn a - b;\n\t\n\t\t}\n\t\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\tvar geometry2;\n\t\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tgeometry2 = new THREE.Geometry();\n\t\t\tgeometry2.fromBufferGeometry( geometry );\n\t\n\t\t} else {\n\t\n\t\t\tgeometry2 = geometry.clone();\n\t\n\t\t}\n\t\n\t\tgeometry2.mergeVertices();\n\t\tgeometry2.computeFaceNormals();\n\t\n\t\tvar vertices = geometry2.vertices;\n\t\tvar faces = geometry2.faces;\n\t\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\tvar face = faces[ i ];\n\t\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\thash[ key ].face2 = i;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tvar coords = [];\n\t\n\t\tfor ( var key in hash ) {\n\t\n\t\t\tvar h = hash[ key ];\n\t\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\t\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\t\tcoords.push( vertex.x );\n\t\t\t\tcoords.push( vertex.y );\n\t\t\t\tcoords.push( vertex.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\t\n\t};\n\t\n\tTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\t\n\t// File:src/extras/geometries/ExtrudeGeometry.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\t\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\t\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\n\t\t\tshapes = [];\n\t\t\treturn;\n\t\n\t\t}\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ExtrudeGeometry';\n\t\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\t\n\t\tthis.addShapeList( shapes, options );\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t\t// can't really use automatic vertex normals\n\t\t// as then front and back sides get smoothed too\n\t\t// should do separate smoothing just for sides\n\t\n\t\t//this.computeVertexNormals();\n\t\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\t\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\tvar sl = shapes.length;\n\t\n\t\tfor ( var s = 0; s < sl; s ++ ) {\n\t\n\t\t\tvar shape = shapes[ s ];\n\t\t\tthis.addShape( shape, options );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\n\t\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\t\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\n\t\n\t\tvar extrudePath = options.extrudePath;\n\t\tvar extrudePts, extrudeByPath = false;\n\t\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\t\n\t\tvar splineTube, binormal, normal, position2;\n\t\tif ( extrudePath ) {\n\t\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\t\n\t\t\textrudeByPath = true;\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\n\t\t\t// SETUP TNB variables\n\t\n\t\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t\t// TODO1 - have a .isClosed in spline?\n\t\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\t\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\t\n\t\t\tbinormal = new THREE.Vector3();\n\t\t\tnormal = new THREE.Vector3();\n\t\t\tposition2 = new THREE.Vector3();\n\t\n\t\t}\n\t\n\t\t// Safeguards if bevels are not enabled\n\t\n\t\tif ( ! bevelEnabled ) {\n\t\n\t\t\tbevelSegments = 0;\n\t\t\tbevelThickness = 0;\n\t\t\tbevelSize = 0;\n\t\n\t\t}\n\t\n\t\t// Variables initialization\n\t\n\t\tvar ahole, h, hl; // looping of holes\n\t\tvar scope = this;\n\t\n\t\tvar shapesOffset = this.vertices.length;\n\t\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\t\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\t\n\t\tif ( reverse ) {\n\t\n\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\t\n\t\t\t\t\tholes[ h ] = ahole.reverse();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\t\n\t\t}\n\t\n\t\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t/* Vertices */\n\t\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\t\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\tahole = holes[ h ];\n\t\n\t\t\tvertices = vertices.concat( ahole );\n\t\n\t\t}\n\t\n\t\n\t\tfunction scalePt2 ( pt, vec, size ) {\n\t\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\t\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\t\n\t\t}\n\t\n\t\tvar b, bs, t, z,\n\t\t\tvert, vlen = vertices.length,\n\t\t\tface, flen = faces.length;\n\t\n\t\n\t\t// Find directions for point movement\n\t\n\t\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\t\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t//\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\t\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\t\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\t\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\t\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\t\n\t\t\t// check for collinear edges\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\t\n\t\t\t\t// not collinear\n\t\n\t\t\t\t// length of vectors for normalizing\n\t\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\t\n\t\t\t\t// shift adjacent points by unit vectors to the left\n\t\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\t\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\t\n\t\t\t\t// scaling factor for v_prev to intersection point\n\t\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\t\n\t\t\t\t// vector from inPt to intersection point\n\t\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\t\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t//  but prevent crazy spikes\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\t\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// handle special case of collinear edges\n\t\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\t\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\t\n\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\t\n\t\t\t\t\t\t\tdirection_eq = true;\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( direction_eq ) {\n\t\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\t\n\t\t}\n\t\n\t\n\t\tvar contourMovements = [];\n\t\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t//  (j)---(i)---(k)\n\t\t\t// console.log('i,j,k', i, j , k)\n\t\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\t\n\t\t}\n\t\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\t\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\tahole = holes[ h ];\n\t\n\t\t\toneHoleMovements = [];\n\t\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\t\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\t\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\t\n\t\t\t}\n\t\n\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\t\n\t\t}\n\t\n\t\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\t\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * ( 1 - t );\n\t\n\t\t\t//z = bevelThickness * t;\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t\t//bs = bevelSize * t; // linear\n\t\n\t\t\t// contract shape\n\t\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\n\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t}\n\t\n\t\t\t// expand holes\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\tv( vert.x, vert.y,  - z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tbs = bevelSize;\n\t\n\t\t// Back facing vertices\n\t\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\tv( vert.x, vert.y, 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\t\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Add stepped vertices...\n\t\t// Including front facing vertices\n\t\n\t\tvar s;\n\t\n\t\tfor ( s = 1; s <= steps; s ++ ) {\n\t\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\t\n\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\t\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\t\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Add bevel segments planes\n\t\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\t\n\t\t\tt = b / bevelSegments;\n\t\t\tz = bevelThickness * ( 1 - t );\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\t\n\t\t\t// contract shape\n\t\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\t\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t}\n\t\n\t\t\t// expand holes\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\toneHoleMovements = holesMovements[ h ];\n\t\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t/* Faces */\n\t\n\t\t// Top and bottom faces\n\t\n\t\tbuildLidFaces();\n\t\n\t\t// Sides faces\n\t\n\t\tbuildSideFaces();\n\t\n\t\n\t\t/////  Internal functions\n\t\n\t\tfunction buildLidFaces() {\n\t\n\t\t\tif ( bevelEnabled ) {\n\t\n\t\t\t\tvar layer = 0; // steps + 1\n\t\t\t\tvar offset = vlen * layer;\n\t\n\t\t\t\t// Bottom faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\toffset = vlen * layer;\n\t\n\t\t\t\t// Top faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// Bottom faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// Top faces\n\t\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\t\t\tface = faces[ i ];\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// Create faces for the z-sides of the shape\n\t\n\t\tfunction buildSideFaces() {\n\t\n\t\t\tvar layeroffset = 0;\n\t\t\tsidewalls( contour, layeroffset );\n\t\t\tlayeroffset += contour.length;\n\t\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\t\n\t\t\t\tahole = holes[ h ];\n\t\t\t\tsidewalls( ahole, layeroffset );\n\t\n\t\t\t\t//, true\n\t\t\t\tlayeroffset += ahole.length;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfunction sidewalls( contour, layeroffset ) {\n\t\n\t\t\tvar j, k;\n\t\t\ti = contour.length;\n\t\n\t\t\twhile ( -- i >= 0 ) {\n\t\n\t\t\t\tj = i;\n\t\t\t\tk = i - 1;\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\t\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\t\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\t\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\t\n\t\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\t\n\t\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\tfunction v( x, y, z ) {\n\t\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\t\n\t\t}\n\t\n\t\tfunction f3( a, b, c ) {\n\t\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\t\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\t\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\t\n\t\t}\n\t\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\t\n\t\t\ta += shapesOffset;\n\t\t\tb += shapesOffset;\n\t\t\tc += shapesOffset;\n\t\t\td += shapesOffset;\n\t\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\t\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\t\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\t\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t\t];\n\t\n\t\t},\n\t\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\n\t\t\tvar a = vertices[ indexA ];\n\t\t\tvar b = vertices[ indexB ];\n\t\t\tvar c = vertices[ indexC ];\n\t\t\tvar d = vertices[ indexD ];\n\t\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t\t];\n\t\n\t\t\t} else {\n\t\n\t\t\t\treturn [\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t\t];\n\t\n\t\t\t}\n\t\n\t\t}\n\t};\n\t\n\t// File:src/extras/geometries/ShapeGeometry.js\n\t\n\t/**\n\t * @author jonobr1 / http://jonobr1.com\n\t *\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\n\t * ExtrudeGeometry.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n\t *\n\t *\tmaterial: <int> // material index for front and back faces\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\t\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ShapeGeometry';\n\t\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\t\n\t\tthis.addShapeList( shapes, options );\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t};\n\t\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\t\n\t/**\n\t * Add an array of shapes to THREE.ShapeGeometry.\n\t */\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\t\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\t\n\t\t\tthis.addShape( shapes[ i ], options );\n\t\n\t\t}\n\t\n\t\treturn this;\n\t\n\t};\n\t\n\t/**\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n\t */\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\t\n\t\tif ( options === undefined ) options = {};\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\n\t\tvar material = options.material;\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\t\n\t\t//\n\t\n\t\tvar i, l, hole;\n\t\n\t\tvar shapesOffset = this.vertices.length;\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\n\t\n\t\tvar vertices = shapePoints.shape;\n\t\tvar holes = shapePoints.holes;\n\t\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\t\n\t\tif ( reverse ) {\n\t\n\t\t\tvertices = vertices.reverse();\n\t\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\t\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\t\thole = holes[ i ];\n\t\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\t\n\t\t\t\t\tholes[ i ] = hole.reverse();\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\treverse = false;\n\t\n\t\t}\n\t\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\t\n\t\t// Vertices\n\t\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\t\n\t\t\thole = holes[ i ];\n\t\t\tvertices = vertices.concat( hole );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar vert, vlen = vertices.length;\n\t\tvar face, flen = faces.length;\n\t\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\t\n\t\t\tvert = vertices[ i ];\n\t\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\t\n\t\t}\n\t\n\t\tfor ( i = 0; i < flen; i ++ ) {\n\t\n\t\t\tface = faces[ i ];\n\t\n\t\t\tvar a = face[ 0 ] + shapesOffset;\n\t\t\tvar b = face[ 1 ] + shapesOffset;\n\t\t\tvar c = face[ 2 ] + shapesOffset;\n\t\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/geometries/LatheBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\t // points - to create a closed torus, one must use a set of points\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\n\t // segments - the number of circumference segments to create\n\t // phiStart - the starting radian\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\n\t //    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\tTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'LatheBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\t\n\t\tsegments = Math.floor( segments ) || 12;\n\t\tphiStart = phiStart || 0;\n\t\tphiLength = phiLength || Math.PI * 2;\n\t\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\t\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\n\t\tvar indexCount = segments * points.length * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\tvar index = 0, indexOffset = 0, base;\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\t\tvar inverseSegments = 1.0 / segments;\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\tvar i, j;\n\t\n\t\t// generate vertices and uvs\n\t\n\t\tfor ( i = 0; i <= segments; i ++ ) {\n\t\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\t\n\t\t\tvar sin = Math.sin( phi );\n\t\t\tvar cos = Math.cos( phi );\n\t\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\t\n\t\t\t\tbase = j + i * points.length;\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = base;\n\t\t\t\tvar b = base + points.length;\n\t\t\t\tvar c = base + points.length + 1;\n\t\t\t\tvar d = base + 1;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// generate normals\n\t\n\t\tthis.computeVertexNormals();\n\t\n\t\t// if the geometry is closed, we need to average the normals along the seam.\n\t\t// because the corresponding vertices are identical (but still have different UVs).\n\t\n\t\tif( phiLength === Math.PI * 2 ) {\n\t\n\t\t\tvar normals = this.attributes.normal.array;\n\t\t\tvar n1 = new THREE.Vector3();\n\t\t\tvar n2 = new THREE.Vector3();\n\t\t\tvar n = new THREE.Vector3();\n\t\n\t\t\t// this is the buffer offset for the last line of vertices\n\t\t\tbase = segments * points.length * 3;\n\t\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\t\n\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\tn1.x = normals[ j + 0 ];\n\t\t\t\tn1.y = normals[ j + 1 ];\n\t\t\t\tn1.z = normals[ j + 2 ];\n\t\n\t\t\t\t// select the normal of the vertex in the last line\n\t\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\t\tn2.z = normals[ base + j + 2 ];\n\t\n\t\t\t\t// average normals\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\n\t\n\t\t\t\t// assign the new values to both normals\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\t\n\t\t\t} // next row\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\t\n\t// File:src/extras/geometries/LatheGeometry.js\n\t\n\t/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\t\n\t// points - to create a closed torus, one must use a set of points\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\n\t// segments - the number of circumference segments to create\n\t// phiStart - the starting radian\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\n\t//    2PI is a closed lathe, less than 2PI is a portion.\n\t\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'LatheGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\t\n\t// File:src/extras/geometries/PlaneGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\t\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'PlaneGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\t\n\t};\n\t\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\t\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\t\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'PlaneBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\t\n\t\tvar width_half = width / 2;\n\t\tvar height_half = height / 2;\n\t\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\n\t\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\t\n\t\tvar segment_width = width / gridX;\n\t\tvar segment_height = height / gridY;\n\t\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\t\n\t\tvar offset = 0;\n\t\tvar offset2 = 0;\n\t\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\t\n\t\t\tvar y = iy * segment_height - height_half;\n\t\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\t\n\t\t\t\tvar x = ix * segment_width - width_half;\n\t\n\t\t\t\tvertices[ offset ] = x;\n\t\t\t\tvertices[ offset + 1 ] = - y;\n\t\n\t\t\t\tnormals[ offset + 2 ] = 1;\n\t\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\t\n\t\t\t\toffset += 3;\n\t\t\t\toffset2 += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\toffset = 0;\n\t\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\t\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\t\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\t\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\t\n\t\t\t\tindices[ offset ] = a;\n\t\t\t\tindices[ offset + 1 ] = b;\n\t\t\t\tindices[ offset + 2 ] = d;\n\t\n\t\t\t\tindices[ offset + 3 ] = b;\n\t\t\t\tindices[ offset + 4 ] = c;\n\t\t\t\tindices[ offset + 5 ] = d;\n\t\n\t\t\t\toffset += 6;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t};\n\t\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\t\n\t// File:src/extras/geometries/RingBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'RingBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tinnerRadius = innerRadius || 20;\n\t\touterRadius = outerRadius || 50;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\t\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\t\n\t\t// these are used to calculate buffer length\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// some helper variables\n\t\tvar index = 0, indexOffset = 0, segment;\n\t\tvar radius = innerRadius;\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\tvar j, i;\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\t// values are generate from the inside of the ring to the outside\n\t\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\t\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex++;\n\t\n\t\t\t}\n\t\n\t\t\t// increase the radius for next row of vertices\n\t\t\tradius += radiusStep;\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\n\t\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\t\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\t\n\t\t\t\tsegment = i + thetaSegmentLevel;\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = segment;\n\t\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\t\tvar d = segment + 1;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t};\n\t\n\tTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\t\n\t// File:src/extras/geometries/RingGeometry.js\n\t\n\t/**\n\t * @author Kaleb Murphy\n\t */\n\t\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'RingGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\t\n\t// File:src/extras/geometries/SphereGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'SphereGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\t\n\t};\n\t\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\t\n\t// File:src/extras/geometries/SphereBufferGeometry.js\n\t\n\t/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * based on THREE.SphereGeometry\n\t */\n\t\n\tTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'SphereBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\t\n\t\tradius = radius || 50;\n\t\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\t\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\t\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\t\n\t\tvar thetaEnd = thetaStart + thetaLength;\n\t\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\t\n\t\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\t\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\t\n\t\t\tvar verticesRow = [];\n\t\n\t\t\tvar v = y / heightSegments;\n\t\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\t\n\t\t\t\tvar u = x / widthSegments;\n\t\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\n\t\t\t\tnormal.set( px, py, pz ).normalize();\n\t\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\t\n\t\t\t\tverticesRow.push( index );\n\t\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t\tvertices.push( verticesRow );\n\t\n\t\t}\n\t\n\t\tvar indices = [];\n\t\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\t\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\t\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\t\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\t\tthis.addAttribute( 'position', positions );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t};\n\t\n\tTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\t\n\t// File:src/extras/geometries/TextGeometry.js\n\t\n\t/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\t\n\tTHREE.TextGeometry = function ( text, parameters ) {\n\t\n\t\tparameters = parameters || {};\n\t\n\t\tvar font = parameters.font;\n\t\n\t\tif ( font instanceof THREE.Font === false ) {\n\t\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\t\treturn new THREE.Geometry();\n\t\n\t\t}\n\t\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\t\n\t\t// translate parameters to ExtrudeGeometry API\n\t\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\t\n\t\t// defaults\n\t\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\t\n\t\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\t\n\t\tthis.type = 'TextGeometry';\n\t\n\t};\n\t\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\t\n\t// File:src/extras/geometries/TorusBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\t\n\tTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'TorusBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\t\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\t\tarc = arc || Math.PI * 2;\n\t\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\n\t\tvar normals = new Float32Array( vertexCount * 3 );\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\n\t\n\t\t// offset variables\n\t\tvar vertexBufferOffset = 0;\n\t\tvar uvBufferOffset = 0;\n\t\tvar indexBufferOffset = 0;\n\t\n\t\t// helper variables\n\t\tvar center = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\n\t\tvar j, i;\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\tvar u = i / tubularSegments * arc;\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\t\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\t\n\t\t\t\t// this vector is used to calculate the normal\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\n\t\t\t\t// normal\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\t\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\t\n\t\t\t\t// uv\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\t\n\t\t\t\t// update offsets\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\t\n\t\t\t\t// update offset\n\t\t\t\tindexBufferOffset += 6;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\t\n\t};\n\t\n\tTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\t\n\t// File:src/extras/geometries/TorusGeometry.js\n\t\n\t/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\t\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TorusGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\t\n\t\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\t\n\t};\n\t\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\t\n\t// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\tTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tthis.type = 'TorusKnotBufferGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\t\n\t\tradius = radius || 100;\n\t\ttube = tube || 40;\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\n\t\tp = p || 2;\n\t\tq = q || 3;\n\t\n\t\t// used to calculate buffer length\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\t\n\t\t// buffers\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\t\n\t\t// helper variables\n\t\tvar i, j, index = 0, indexOffset = 0;\n\t\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\t\n\t\tvar P1 = new THREE.Vector3();\n\t\tvar P2 = new THREE.Vector3();\n\t\n\t\tvar B = new THREE.Vector3();\n\t\tvar T = new THREE.Vector3();\n\t\tvar N = new THREE.Vector3();\n\t\n\t\t// generate vertices, normals and uvs\n\t\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\t\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\t\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\t\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\t\n\t\t\t// calculate orthonormal basis\n\t\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\t\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\t\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\t\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\t\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\t\tvar cy = tube * Math.sin( v );\n\t\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\t\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\t\n\t\t\t\t// vertex\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\t\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\n\t\t\t\t// uv\n\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\n\t\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// generate indices\n\t\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\t\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\t\n\t\t\t\t// indices\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\t\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// build geometry\n\t\n\t\tthis.setIndex( indices );\n\t\tthis.addAttribute( 'position', vertices );\n\t\tthis.addAttribute( 'normal', normals );\n\t\tthis.addAttribute( 'uv', uvs );\n\t\n\t\t// this function calculates the current position on the torus curve\n\t\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\t\n\t\t\tvar cu = Math.cos( u );\n\t\t\tvar su = Math.sin( u );\n\t\t\tvar quOverP = q / p * u;\n\t\t\tvar cs = Math.cos( quOverP );\n\t\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\t\n\t// File:src/extras/geometries/TorusKnotGeometry.js\n\t\n\t/**\n\t * @author oosmoxiecode\n\t */\n\t\n\tTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TorusKnotGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\t\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\t\n\t\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\t\tthis.mergeVertices();\n\t\n\t};\n\t\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\t\n\t// File:src/extras/geometries/TubeGeometry.js\n\t\n\t/**\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\n\t *\n\t * Creates a tube which extrudes along a 3d spline\n\t *\n\t * Uses parallel transport frames as described in\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t */\n\t\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'TubeGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\tsegments: segments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed,\n\t\t\ttaper: taper\n\t\t};\n\t\n\t\tsegments = segments || 64;\n\t\tradius = radius || 1;\n\t\tradialSegments = radialSegments || 8;\n\t\tclosed = closed || false;\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\t\n\t\tvar grid = [];\n\t\n\t\tvar scope = this,\n\t\n\t\t\ttangent,\n\t\t\tnormal,\n\t\t\tbinormal,\n\t\n\t\t\tnumpoints = segments + 1,\n\t\n\t\t\tu, v, r,\n\t\n\t\t\tcx, cy,\n\t\t\tpos, pos2 = new THREE.Vector3(),\n\t\t\ti, j,\n\t\t\tip, jp,\n\t\t\ta, b, c, d,\n\t\t\tuva, uvb, uvc, uvd;\n\t\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\t\ttangents = frames.tangents,\n\t\t\tnormals = frames.normals,\n\t\t\tbinormals = frames.binormals;\n\t\n\t\t// proxy internals\n\t\tthis.tangents = tangents;\n\t\tthis.normals = normals;\n\t\tthis.binormals = binormals;\n\t\n\t\tfunction vert( x, y, z ) {\n\t\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\t\n\t\t}\n\t\n\t\t// construct the grid\n\t\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\n\t\n\t\t\tgrid[ i ] = [];\n\t\n\t\t\tu = i / ( numpoints - 1 );\n\t\n\t\t\tpos = path.getPointAt( u );\n\t\n\t\t\ttangent = tangents[ i ];\n\t\t\tnormal = normals[ i ];\n\t\t\tbinormal = binormals[ i ];\n\t\n\t\t\tr = radius * taper( u );\n\t\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\t\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\n\t\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\t\tcy = r * Math.sin( v );\n\t\n\t\t\t\tpos2.copy( pos );\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\t\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// construct the mesh\n\t\n\t\tfor ( i = 0; i < segments; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\t\n\t\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\t\tjp = ( j + 1 ) % radialSegments;\n\t\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\t\tb = grid[ ip ][ j ];\n\t\t\t\tc = grid[ ip ][ jp ];\n\t\t\t\td = grid[ i ][ jp ];\n\t\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\t\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\t\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tthis.computeFaceNormals();\n\t\tthis.computeVertexNormals();\n\t\n\t};\n\t\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\t\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\n\t\n\t\treturn 1;\n\t\n\t};\n\t\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\t\n\t\treturn Math.sin( Math.PI * u );\n\t\n\t};\n\t\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\t\n\t\tvar\tnormal = new THREE.Vector3(),\n\t\n\t\t\ttangents = [],\n\t\t\tnormals = [],\n\t\t\tbinormals = [],\n\t\n\t\t\tvec = new THREE.Vector3(),\n\t\t\tmat = new THREE.Matrix4(),\n\t\n\t\t\tnumpoints = segments + 1,\n\t\t\ttheta,\n\t\t\tsmallest,\n\t\n\t\t\ttx, ty, tz,\n\t\t\ti, u;\n\t\n\t\n\t\t// expose internals\n\t\tthis.tangents = tangents;\n\t\tthis.normals = normals;\n\t\tthis.binormals = binormals;\n\t\n\t\t// compute the tangent vectors for each segment on the path\n\t\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\n\t\n\t\t\tu = i / ( numpoints - 1 );\n\t\n\t\t\ttangents[ i ] = path.getTangentAt( u );\n\t\t\ttangents[ i ].normalize();\n\t\n\t\t}\n\t\n\t\tinitialNormal3();\n\t\n\t\t/*\n\t\tfunction initialNormal1(lastBinormal) {\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t\t}\n\t\n\t\tfunction initialNormal2() {\n\t\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\t\tvar t2 = path.getTangentAt( epsilon );\n\t\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t\n\t\t}\n\t\t*/\n\t\n\t\tfunction initialNormal3() {\n\t\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the smallest tangent xyz component\n\t\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\t\tsmallest = Number.MAX_VALUE;\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\t\tty = Math.abs( tangents[ 0 ].y );\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\n\t\n\t\t\tif ( tx <= smallest ) {\n\t\n\t\t\t\tsmallest = tx;\n\t\t\t\tnormal.set( 1, 0, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( ty <= smallest ) {\n\t\n\t\t\t\tsmallest = ty;\n\t\t\t\tnormal.set( 0, 1, 0 );\n\t\n\t\t\t}\n\t\n\t\t\tif ( tz <= smallest ) {\n\t\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\n\t\t\t}\n\t\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\t\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t\n\t\t}\n\t\n\t\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\t\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\t\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\t\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\t\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\t\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\t\n\t\t\t\tvec.normalize();\n\t\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\t\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\t\n\t\t\t}\n\t\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t}\n\t\n\t\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\t\n\t\tif ( closed ) {\n\t\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\t\ttheta /= ( numpoints - 1 );\n\t\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\t\n\t\t\t\ttheta = - theta;\n\t\n\t\t\t}\n\t\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\t\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\t// File:src/extras/geometries/PolyhedronGeometry.js\n\t\n\t/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'PolyhedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\t\n\t\tvar that = this;\n\t\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\t\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\t\n\t\t}\n\t\n\t\tvar p = this.vertices;\n\t\n\t\tvar faces = [];\n\t\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\t\n\t\t\tvar v1 = p[ indices[ i ] ];\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\n\t\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\n\t\t}\n\t\n\t\tvar centroid = new THREE.Vector3();\n\t\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\tsubdivide( faces[ i ], detail );\n\t\n\t\t}\n\t\n\t\n\t\t// Handle case when face straddles the seam\n\t\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\t\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\t\n\t\t\tvar x0 = uvs[ 0 ].x;\n\t\t\tvar x1 = uvs[ 1 ].x;\n\t\t\tvar x2 = uvs[ 2 ].x;\n\t\n\t\t\tvar max = Math.max( x0, x1, x2 );\n\t\t\tvar min = Math.min( x0, x1, x2 );\n\t\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\t\n\t\t\t\t// 0.9 is somewhat arbitrary\n\t\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Apply radius\n\t\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\t\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\n\t\n\t\t}\n\t\n\t\n\t\t// Merge vertices\n\t\n\t\tthis.mergeVertices();\n\t\n\t\tthis.computeFaceNormals();\n\t\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\t\n\t\n\t\t// Project vector onto sphere's surface\n\t\n\t\tfunction prepare( vector ) {\n\t\n\t\t\tvar vertex = vector.normalize().clone();\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\t\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\t\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\t\n\t\t\treturn vertex;\n\t\n\t\t}\n\t\n\t\n\t\t// Approximate a curved face with recursively sub-divided triangles.\n\t\n\t\tfunction make( v1, v2, v3 ) {\n\t\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\t\tthat.faces.push( face );\n\t\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\t\n\t\t\tvar azi = azimuth( centroid );\n\t\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t\t] );\n\t\n\t\t}\n\t\n\t\n\t\t// Analytically subdivide a face to the required detail level.\n\t\n\t\tfunction subdivide( face, detail ) {\n\t\n\t\t\tvar cols = Math.pow( 2, detail );\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\t\tvar v = [];\n\t\n\t\t\t// Construct all of the vertices for this subdivision.\n\t\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\t\n\t\t\t\tv[ i ] = [];\n\t\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\t\tvar rows = cols - i;\n\t\n\t\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\t\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\t\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\t// Construct all of the faces.\n\t\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\t\n\t\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\t\n\t\t\t\t\tvar k = Math.floor( j / 2 );\n\t\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\t\n\t\t\t\t\t\tmake(\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tmake(\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t\t);\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\t\n\t\tfunction azimuth( vector ) {\n\t\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\t\n\t\t}\n\t\n\t\n\t\t// Angle above the XZ plane.\n\t\n\t\tfunction inclination( vector ) {\n\t\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\t\n\t\t}\n\t\n\t\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\n\t\n\t\tfunction correctUV( uv, vector, azimuth ) {\n\t\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\t\treturn uv.clone();\n\t\n\t\t}\n\t\n\t\n\t};\n\t\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\t\n\t// File:src/extras/geometries/DodecahedronGeometry.js\n\t\n\t/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\t\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tvar r = 1 / t;\n\t\n\t\tvar vertices = [\n\t\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t\t 1,  1, - 1,     1,  1,  1,\n\t\n\t\t\t// (0, 1/, )\n\t\t\t 0, - r, - t,     0, - r,  t,\n\t\t\t 0,  r, - t,     0,  r,  t,\n\t\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t,  0,    - r,  t,  0,\n\t\t\t r, - t,  0,     r,  t,  0,\n\t\n\t\t\t// (, 0, 1/)\n\t\t\t- t,  0, - r,     t,  0, - r,\n\t\t\t- t,  0,  r,     t,  0,  r\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'DodecahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\t\n\t// File:src/extras/geometries/IcosahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\n\t\tvar vertices = [\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'IcosahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\t\n\t// File:src/extras/geometries/OctahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar vertices = [\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'OctahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\t\n\t// File:src/extras/geometries/TetrahedronGeometry.js\n\t\n\t/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\t\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\t\n\t\tvar vertices = [\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t\t];\n\t\n\t\tvar indices = [\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t\t];\n\t\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\t\n\t\tthis.type = 'TetrahedronGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\t\n\t};\n\t\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\t\n\t// File:src/extras/geometries/ParametricGeometry.js\n\t\n\t/**\n\t * @author zz85 / https://github.com/zz85\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t *\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n\t *\n\t */\n\t\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\t\n\t\tTHREE.Geometry.call( this );\n\t\n\t\tthis.type = 'ParametricGeometry';\n\t\n\t\tthis.parameters = {\n\t\t\tfunc: func,\n\t\t\tslices: slices,\n\t\t\tstacks: stacks\n\t\t};\n\t\n\t\tvar verts = this.vertices;\n\t\tvar faces = this.faces;\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\t\n\t\tvar i, j, p;\n\t\tvar u, v;\n\t\n\t\tvar sliceCount = slices + 1;\n\t\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\n\t\n\t\t\tv = i / stacks;\n\t\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\n\t\n\t\t\t\tu = j / slices;\n\t\n\t\t\t\tp = func( u, v );\n\t\t\t\tverts.push( p );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tvar a, b, c, d;\n\t\tvar uva, uvb, uvc, uvd;\n\t\n\t\tfor ( i = 0; i < stacks; i ++ ) {\n\t\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\n\t\n\t\t\t\ta = i * sliceCount + j;\n\t\t\t\tb = i * sliceCount + j + 1;\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\n\t\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\t\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\t\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\t// console.log(this);\n\t\n\t\t// magic bullet\n\t\t// var diff = this.mergeVertices();\n\t\t// console.log('removed ', diff, ' vertices by merging');\n\t\n\t\tthis.computeFaceNormals();\n\t\tthis.computeVertexNormals();\n\t\n\t};\n\t\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\t\n\t// File:src/extras/geometries/WireframeGeometry.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WireframeGeometry = function ( geometry ) {\n\t\n\t\tTHREE.BufferGeometry.call( this );\n\t\n\t\tvar edge = [ 0, 0 ], hash = {};\n\t\n\t\tfunction sortFunction( a, b ) {\n\t\n\t\t\treturn a - b;\n\t\n\t\t}\n\t\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\tif ( geometry instanceof THREE.Geometry ) {\n\t\n\t\t\tvar vertices = geometry.vertices;\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar numEdges = 0;\n\t\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\t\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tif ( geometry.index !== null ) {\n\t\n\t\t\t\t// Indexed BufferGeometry\n\t\n\t\t\t\tvar indices = geometry.index.array;\n\t\t\t\tvar vertices = geometry.attributes.position;\n\t\t\t\tvar groups = geometry.groups;\n\t\t\t\tvar numEdges = 0;\n\t\n\t\t\t\tif ( groups.length === 0 ) {\n\t\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\n\t\n\t\t\t\t}\n\t\n\t\t\t\t// allocate maximal size\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\t\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\t\n\t\t\t\t\tvar group = groups[ o ];\n\t\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\t\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\t\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\t\tedge.sort( sortFunction );\n\t\n\t\t\t\t\t\t\tvar key = edge.toString();\n\t\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\t\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\t\tnumEdges ++;\n\t\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\t\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\t\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t\t} else {\n\t\n\t\t\t\t// non-indexed BufferGeometry\n\t\n\t\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\t\tvar numEdges = vertices.length / 3;\n\t\t\t\tvar numTris = numEdges / 3;\n\t\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\t\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\t\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\t\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\n\t\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\t\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\t\n\t// File:src/extras/helpers/AxisHelper.js\n\t\n\t/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.AxisHelper = function ( size ) {\n\t\n\t\tsize = size || 1;\n\t\n\t\tvar vertices = new Float32Array( [\n\t\t\t0, 0, 0,  size, 0, 0,\n\t\t\t0, 0, 0,  0, size, 0,\n\t\t\t0, 0, 0,  0, 0, size\n\t\t] );\n\t\n\t\tvar colors = new Float32Array( [\n\t\t\t1, 0, 0,  1, 0.6, 0,\n\t\t\t0, 1, 0,  0.6, 1, 0,\n\t\t\t0, 0, 1,  0, 0.6, 1\n\t\t] );\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t};\n\t\n\tTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\t\n\t// File:src/extras/helpers/ArrowHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\t\n\tTHREE.ArrowHelper = ( function () {\n\t\n\t\tvar lineGeometry = new THREE.BufferGeometry();\n\t\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\t\n\t\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\n\t\n\t\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tTHREE.Object3D.call( this );\n\t\n\t\t\tif ( color === undefined ) color = 0xffff00;\n\t\t\tif ( length === undefined ) length = 1;\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\t\tthis.position.copy( origin );\n\t\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add( this.line );\n\t\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add( this.cone );\n\t\n\t\t\tthis.setDirection( dir );\n\t\t\tthis.setLength( length, headLength, headWidth );\n\t\n\t\t};\n\t\n\t}() );\n\t\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\t\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\t\n\t\tvar axis = new THREE.Vector3();\n\t\tvar radians;\n\t\n\t\treturn function setDirection( dir ) {\n\t\n\t\t\t// dir is assumed to be normalized\n\t\n\t\t\tif ( dir.y > 0.99999 ) {\n\t\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\t\n\t\t\t} else if ( dir.y < - 0.99999 ) {\n\t\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\t\n\t\t\t} else {\n\t\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\t\n\t\t\t\tradians = Math.acos( dir.y );\n\t\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\t\n\t\t\t}\n\t\n\t\t};\n\t\n\t}() );\n\t\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\t\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\t\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\t\tthis.line.updateMatrix();\n\t\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\t\n\t};\n\t\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\t\n\t\tthis.line.material.color.copy( color );\n\t\tthis.cone.material.color.copy( color );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/BoxHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.BoxHelper = function ( object, color ) {\n\t\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tvar positions = new Float32Array( 8 * 3 );\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tif ( object !== undefined ) {\n\t\n\t\t\tthis.update( object );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\t\n\tTHREE.BoxHelper.prototype.update = ( function () {\n\t\n\t\tvar box = new THREE.Box3();\n\t\n\t\treturn function update( object ) {\n\t\n\t\t\tif ( object instanceof THREE.Box3 ) {\n\t\n\t\t\t\tbox.copy( object );\n\t\n\t\t\t} else {\n\t\n\t\t\t\tbox.setFromObject( object );\n\t\n\t\t\t}\n\t\n\t\t\tif ( box.isEmpty() ) return;\n\t\n\t\t\tvar min = box.min;\n\t\t\tvar max = box.max;\n\t\n\t\t\t/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\t\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\t\tvar array = position.array;\n\t\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\n\t\t};\n\t\n\t} )();\n\t\n\t// File:src/extras/helpers/BoundingBoxHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\t// a helper to show the world-axis-aligned bounding box for an object\n\t\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.box = new THREE.Box3();\n\t\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\t\n\t};\n\t\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\t\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\n\t\n\t\tthis.box.setFromObject( this.object );\n\t\n\t\tthis.box.size( this.scale );\n\t\n\t\tthis.box.center( this.position );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/CameraHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\t\n\tTHREE.CameraHelper = function ( camera ) {\n\t\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\t\n\t\tvar pointMap = {};\n\t\n\t\t// colors\n\t\n\t\tvar hexFrustum = 0xffaa00;\n\t\tvar hexCone = 0xff0000;\n\t\tvar hexUp = 0x00aaff;\n\t\tvar hexTarget = 0xffffff;\n\t\tvar hexCross = 0x333333;\n\t\n\t\t// near\n\t\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\n\t\n\t\t// far\n\t\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\n\t\n\t\t// sides\n\t\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\n\t\n\t\t// cone\n\t\n\t\taddLine( \"p\", \"n1\", hexCone );\n\t\taddLine( \"p\", \"n2\", hexCone );\n\t\taddLine( \"p\", \"n3\", hexCone );\n\t\taddLine( \"p\", \"n4\", hexCone );\n\t\n\t\t// up\n\t\n\t\taddLine( \"u1\", \"u2\", hexUp );\n\t\taddLine( \"u2\", \"u3\", hexUp );\n\t\taddLine( \"u3\", \"u1\", hexUp );\n\t\n\t\t// target\n\t\n\t\taddLine( \"c\", \"t\", hexTarget );\n\t\taddLine( \"p\", \"c\", hexCross );\n\t\n\t\t// cross\n\t\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\n\t\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\n\t\n\t\tfunction addLine( a, b, hex ) {\n\t\n\t\t\taddPoint( a, hex );\n\t\t\taddPoint( b, hex );\n\t\n\t\t}\n\t\n\t\tfunction addPoint( id, hex ) {\n\t\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\t\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\t\n\t\t\t\tpointMap[ id ] = [];\n\t\n\t\t\t}\n\t\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\t\n\t\t}\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t\tthis.camera = camera;\n\t\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\t\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.pointMap = pointMap;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\t\n\tTHREE.CameraHelper.prototype.update = function () {\n\t\n\t\tvar geometry, pointMap;\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\tvar camera = new THREE.Camera();\n\t\n\t\tfunction setPoint( point, x, y, z ) {\n\t\n\t\t\tvector.set( x, y, z ).unproject( camera );\n\t\n\t\t\tvar points = pointMap[ point ];\n\t\n\t\t\tif ( points !== undefined ) {\n\t\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\t\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\treturn function update() {\n\t\n\t\t\tgeometry = this.geometry;\n\t\t\tpointMap = this.pointMap;\n\t\n\t\t\tvar w = 1, h = 1;\n\t\n\t\t\t// we need just camera projection matrix\n\t\t\t// world matrix must be identity\n\t\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\n\t\t\t// center / target\n\t\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\n\t\n\t\t\t// near\n\t\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\t\n\t\t\t// far\n\t\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\n\t\n\t\t\t// up\n\t\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\t\n\t\t\t// cross\n\t\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\t\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\t\n\t\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/DirectionalLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\t\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tif ( size === undefined ) size = 1;\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t\t- size,   size, 0,\n\t\t\t  size,   size, 0,\n\t\t\t  size, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size,   size, 0\n\t\t], 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\t\n\t\tthis.add( new THREE.Line( geometry, material ) );\n\t\n\t\tgeometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\t\n\t\tthis.add( new THREE.Line( geometry, material ));\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\t\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\t\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\tlightPlane.geometry.dispose();\n\t\tlightPlane.material.dispose();\n\t\ttargetLine.geometry.dispose();\n\t\ttargetLine.material.dispose();\n\t\n\t};\n\t\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar v3 = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t\tv3.subVectors( v2, v1 );\n\t\n\t\t\tvar lightPlane = this.children[ 0 ];\n\t\t\tvar targetLine = this.children[ 1 ];\n\t\n\t\t\tlightPlane.lookAt( v3 );\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t\ttargetLine.lookAt( v3 );\n\t\t\ttargetLine.scale.z = v3.length();\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/EdgesHelper.js\n\t\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @param object THREE.Mesh whose geometry will be used\n\t * @param hex line color\n\t * @param thresholdAngle the minimum angle (in degrees),\n\t * between the face normals of adjacent faces,\n\t * that is required to render an edge. A value of 10 means\n\t * an edge is only rendered if the angle is at least 10 degrees.\n\t */\n\t\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\t\n\t\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\t\n\t// File:src/extras/helpers/FaceNormalsHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\t\n\t\t// FaceNormalsHelper only supports THREE.Geometry\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\t\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t//\n\t\n\t\tvar nNormals = 0;\n\t\n\t\tvar objGeometry = this.object.geometry;\n\t\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\tnNormals = objGeometry.faces.length;\n\t\n\t\t} else {\n\t\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t//\n\t\n\t\tthis.matrixAutoUpdate = false;\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\t\n\tTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t//\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\tvar idx = 0;\n\t\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\tvar normal = face.normal;\n\t\n\t\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t\t.divideScalar( 3 )\n\t\t\t\t\t.applyMatrix4( matrixWorld );\n\t\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\tidx = idx + 1;\n\t\n\t\t\t}\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t}() );\n\t\n\t// File:src/extras/helpers/GridHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.GridHelper = function ( size, divisions, color1, color2 ) {\n\t\n\t\tdivisions = divisions || 1;\n\t\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\t\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\t\n\t\tvar center = divisions / 2;\n\t\tvar step = ( size * 2 ) / divisions;\n\t\tvar vertices = [], colors = [];\n\t\n\t\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\t\n\t\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\t\tvertices.push( k, 0, - size, k, 0, size );\n\t\n\t\t\tvar color = i === center ? color1 : color2;\n\t\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\n\t\t}\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\t\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t};\n\t\n\tTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\t\n\tTHREE.GridHelper.prototype.setColors = function () {\n\t\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\t\n\t};\n\t\n\t// File:src/extras/helpers/HemisphereLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\t\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\t\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\t\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\t\n\t\t}\n\t\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\t\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\t\tthis.add( this.lightSphere );\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\t\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.lightSphere.geometry.dispose();\n\t\tthis.lightSphere.material.dispose();\n\t\n\t};\n\t\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\t\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/PointLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\t/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\n\t\tvar d = light.distance;\n\t\n\t\tif ( d === 0.0 ) {\n\t\n\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t} else {\n\t\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t}\n\t\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\t\n\t};\n\t\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\t\n\tTHREE.PointLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\n\t};\n\t\n\tTHREE.PointLightHelper.prototype.update = function () {\n\t\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t/*\n\t\tvar d = this.light.distance;\n\t\n\t\tif ( d === 0.0 ) {\n\t\n\t\t\tthis.lightDistance.visible = false;\n\t\n\t\t} else {\n\t\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\n\t\t}\n\t\t*/\n\t\n\t};\n\t\n\t// File:src/extras/helpers/SkeletonHelper.js\n\t\n\t/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t */\n\t\n\tTHREE.SkeletonHelper = function ( object ) {\n\t\n\t\tthis.bones = this.getBoneList( object );\n\t\n\t\tvar geometry = new THREE.Geometry();\n\t\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tgeometry.dynamic = true;\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, material );\n\t\n\t\tthis.root = object;\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\t\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\t\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\t\n\t\tvar boneList = [];\n\t\n\t\tif ( object instanceof THREE.Bone ) {\n\t\n\t\t\tboneList.push( object );\n\t\n\t\t}\n\t\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\t\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\t\n\t\t}\n\t\n\t\treturn boneList;\n\t\n\t};\n\t\n\tTHREE.SkeletonHelper.prototype.update = function () {\n\t\n\t\tvar geometry = this.geometry;\n\t\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\t\n\t\tvar boneMatrix = new THREE.Matrix4();\n\t\n\t\tvar j = 0;\n\t\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\t\n\t\t\tvar bone = this.bones[ i ];\n\t\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\t\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\t\n\t\t\t\tj += 2;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tgeometry.verticesNeedUpdate = true;\n\t\n\t\tgeometry.computeBoundingSphere();\n\t\n\t};\n\t\n\t// File:src/extras/helpers/SpotLightHelper.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.SpotLightHelper = function ( light ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.light = light;\n\t\tthis.light.updateMatrixWorld();\n\t\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = [\n\t\t\t0, 0, 0,   0,   0,   1,\n\t\t\t0, 0, 0,   1,   0,   1,\n\t\t\t0, 0, 0, - 1,   0,   1,\n\t\t\t0, 0, 0,   0,   1,   1,\n\t\t\t0, 0, 0,   0, - 1,   1\n\t\t];\n\t\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\t\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\t\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\t\n\t\t}\n\t\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\t\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\t\n\t\tthis.cone = new THREE.LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\t\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\n\t\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\t\n\t};\n\t\n\tTHREE.SpotLightHelper.prototype.update = function () {\n\t\n\t\tvar vector = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\t\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\t\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\t\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\n\t\t};\n\t\n\t}();\n\t\n\t// File:src/extras/helpers/VertexNormalsHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\t\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\t\n\t\tthis.object = object;\n\t\n\t\tthis.size = ( size !== undefined ) ? size : 1;\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\t\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\t\n\t\t//\n\t\n\t\tvar nNormals = 0;\n\t\n\t\tvar objGeometry = this.object.geometry;\n\t\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\tnNormals = objGeometry.faces.length * 3;\n\t\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\tnNormals = objGeometry.attributes.normal.count;\n\t\n\t\t}\n\t\n\t\t//\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\t\n\t\tgeometry.addAttribute( 'position', positions );\n\t\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\t\n\t\t//\n\t\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t\tthis.update();\n\t\n\t};\n\t\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\t\n\tTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\t\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar normalMatrix = new THREE.Matrix3();\n\t\n\t\treturn function update() {\n\t\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\n\t\n\t\t\tthis.object.updateMatrixWorld( true );\n\t\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\t\n\t\t\tvar matrixWorld = this.object.matrixWorld;\n\t\n\t\t\tvar position = this.geometry.attributes.position;\n\t\n\t\t\t//\n\t\n\t\t\tvar objGeometry = this.object.geometry;\n\t\n\t\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\t\n\t\t\t\tvar vertices = objGeometry.vertices;\n\t\n\t\t\t\tvar faces = objGeometry.faces;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\t\n\t\t\t\t\tvar face = faces[ i ];\n\t\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\t\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\t\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\t\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\t\n\t\t\t\tvar objPos = objGeometry.attributes.position;\n\t\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\n\t\n\t\t\t\tvar idx = 0;\n\t\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\t\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\t\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\t\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\t\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\t\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\t\n\t\t\t\t\tidx = idx + 1;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tposition.needsUpdate = true;\n\t\n\t\t\treturn this;\n\t\n\t\t};\n\t\n\t}() );\n\t\n\t// File:src/extras/helpers/WireframeHelper.js\n\t\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.WireframeHelper = function ( object, hex ) {\n\t\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\t\n\t\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\t\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\t\n\t};\n\t\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\t\n\t// File:src/extras/objects/ImmediateRenderObject.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.ImmediateRenderObject = function ( material ) {\n\t\n\t\tTHREE.Object3D.call( this );\n\t\n\t\tthis.material = material;\n\t\tthis.render = function ( renderCallback ) {};\n\t\n\t};\n\t\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\t\n\t// File:src/extras/objects/MorphBlendMesh.js\n\t\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\t\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\n\t\n\t\tTHREE.Mesh.call( this, geometry, material );\n\t\n\t\tthis.animationsMap = {};\n\t\tthis.animationsList = [];\n\t\n\t\t// prepare default animation\n\t\t// (all frames played together in 1 second)\n\t\n\t\tvar numFrames = this.geometry.morphTargets.length;\n\t\n\t\tvar name = \"__default\";\n\t\n\t\tvar startFrame = 0;\n\t\tvar endFrame = numFrames - 1;\n\t\n\t\tvar fps = numFrames / 1;\n\t\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\n\t\tthis.setAnimationWeight( name, 1 );\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\t\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\t\n\t\tvar animation = {\n\t\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\n\t\t\tlength: end - start + 1,\n\t\n\t\t\tfps: fps,\n\t\t\tduration: ( end - start ) / fps,\n\t\n\t\t\tlastFrame: 0,\n\t\t\tcurrentFrame: 0,\n\t\n\t\t\tactive: false,\n\t\n\t\t\ttime: 0,\n\t\t\tdirection: 1,\n\t\t\tweight: 1,\n\t\n\t\t\tdirectionBackwards: false,\n\t\t\tmirroredLoop: false\n\t\n\t\t};\n\t\n\t\tthis.animationsMap[ name ] = animation;\n\t\tthis.animationsList.push( animation );\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\t\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\t\n\t\tvar firstAnimation, frameRanges = {};\n\t\n\t\tvar geometry = this.geometry;\n\t\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\t\n\t\t\tvar morph = geometry.morphTargets[ i ];\n\t\t\tvar chunks = morph.name.match( pattern );\n\t\n\t\t\tif ( chunks && chunks.length > 1 ) {\n\t\n\t\t\t\tvar name = chunks[ 1 ];\n\t\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\t\n\t\t\t\tvar range = frameRanges[ name ];\n\t\n\t\t\t\tif ( i < range.start ) range.start = i;\n\t\t\t\tif ( i > range.end ) range.end = i;\n\t\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t\tfor ( var name in frameRanges ) {\n\t\n\t\t\tvar range = frameRanges[ name ];\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\n\t\n\t\t}\n\t\n\t\tthis.firstAnimation = firstAnimation;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.direction = 1;\n\t\t\tanimation.directionBackwards = false;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.direction = - 1;\n\t\t\tanimation.directionBackwards = true;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.fps = fps;\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.duration = duration;\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.weight = weight;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.time = time;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\t\n\t\tvar time = 0;\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\ttime = animation.time;\n\t\n\t\t}\n\t\n\t\treturn time;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\t\n\t\tvar duration = - 1;\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tduration = animation.duration;\n\t\n\t\t}\n\t\n\t\treturn duration;\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.time = 0;\n\t\t\tanimation.active = true;\n\t\n\t\t} else {\n\t\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\t\n\t\tvar animation = this.animationsMap[ name ];\n\t\n\t\tif ( animation ) {\n\t\n\t\t\tanimation.active = false;\n\t\n\t\t}\n\t\n\t};\n\t\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\t\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\t\n\t\t\tvar animation = this.animationsList[ i ];\n\t\n\t\t\tif ( ! animation.active ) continue;\n\t\n\t\t\tvar frameTime = animation.duration / animation.length;\n\t\n\t\t\tanimation.time += animation.direction * delta;\n\t\n\t\t\tif ( animation.mirroredLoop ) {\n\t\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\t\n\t\t\t\t\tanimation.direction *= - 1;\n\t\n\t\t\t\t\tif ( animation.time > animation.duration ) {\n\t\n\t\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\t\tanimation.directionBackwards = true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif ( animation.time < 0 ) {\n\t\n\t\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\t\tanimation.directionBackwards = false;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t}\n\t\n\t\t\t} else {\n\t\n\t\t\t\tanimation.time = animation.time % animation.duration;\n\t\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\t\n\t\t\t}\n\t\n\t\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\t\tvar weight = animation.weight;\n\t\n\t\t\tif ( keyframe !== animation.currentFrame ) {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\t\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\t\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\t\tanimation.currentFrame = keyframe;\n\t\n\t\t\t}\n\t\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\t\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\t\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\t\n\t\t\t} else {\n\t\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\t\n\t\t\t}\n\t\n\t\t}\n\t\n\t};\n\t\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Camera = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Loop = __webpack_require__(95);\n\t\n\tvar _defaults = __webpack_require__(96);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Camera = function (_WHSObject) {\n\t  (0, _inherits3.default)(Camera, _WHSObject);\n\t\n\t  function Camera(params, type) {\n\t    var _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, Camera);\n\t\n\t    if (!type) console.error('@constructor: Please specify \" type \".');\n\t\n\t    var _set = function _set(x, y, z) {\n\t      _this.x = x;\n\t      _this.y = y;\n\t      _this.z = z;\n\t    };\n\t\n\t    params.useTarget = Boolean(params.target);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Camera).call(this, {\n\t      camera: {\n\t        fov: 45,\n\t        aspect: window.innerWidth / window.innerHeight,\n\t        near: 1,\n\t        far: 1000,\n\t        left: window.innerWidth / -2,\n\t        right: window.innerWidth / 2,\n\t        top: window.innerHeight / 2,\n\t        bottom: window.innerHeight / -2,\n\t        cubeResolution: 128\n\t      },\n\t\n\t      helper: false,\n\t\n\t      pos: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      rot: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      target: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      }\n\t    }));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Camera.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var scope = Object.assign(_this, {\n\t      _type: type,\n\t      helper: false\n\t    });\n\t\n\t    if (_defaults.defaults.debug) console.debug('@WHS.Camera: Camera ' + scope._type + ' found.', scope);\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(Camera, [{\n\t    key: 'wrap',\n\t    value: function wrap() {\n\t      var _this2 = this;\n\t\n\t      for (var _len = arguments.length, tags = Array(_len), _key = 0; _key < _len; _key++) {\n\t        tags[_key] = arguments[_key];\n\t      }\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _this2.position.set(_this2.__params.pos.x, _this2.__params.pos.y, _this2.__params.pos.z);\n\t\n\t          _this2.rotation.set(_this2.__params.rot.x, _this2.__params.rot.y, _this2.__params.rot.z);\n\t\n\t          if (_this2.__params.useTarget) _this2.lookAt(_this2.__params.target);\n\t\n\t          if (_this2.__params.helper) {\n\t            _this2.helper = new THREE.CameraHelper(_this2.getNative());\n\t          }\n\t\n\t          tags.forEach(function (tag) {\n\t            _this2[tag] = true;\n\t          });\n\t\n\t          if (_defaults.defaults.debug) console.debug('@WHS.Camera: Camera ' + _this2._type + ' is ready.', _this2);\n\t\n\t          _this2.emit('ready');\n\t\n\t          resolve(_this2);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'addTo',\n\t    value: function addTo(parent) {\n\t      this.parent = parent;\n\t\n\t      var _helper = this.helper,\n\t          _scope = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _scope.parent.getScene().add(_scope.getNative());\n\t          _scope.parent.children.push(_scope);\n\t\n\t          if (_helper) _scope.parent.getScene().add(_helper);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        } finally {\n\t          if (_defaults.defaults.debug) {\n\t            console.debug('@WHS.Camera: Camera ' + _scope._type + ' was added to world.', [_scope, _scope.parent]);\n\t          }\n\t\n\t          resolve(_scope);\n\t\n\t          _scope.emit('ready');\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Clone camera.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Shape(this.__params, this._type).copy(this);\n\t    }\n\t\n\t    /**\r\n\t     * Copy camera.\r\n\t     *\r\n\t     * @param {WHS.Camera} source - Source object, that will be applied to this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(source) {\n\t      this.mesh = source.mesh.clone();\n\t\n\t      this.wrap();\n\t\n\t      this.position = source.position.clone();\n\t      this.rotation = source.rotation.clone();\n\t\n\t      this._type = source._type;\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'follow',\n\t    value: function follow(curve) {\n\t      var time = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];\n\t      var loop = arguments[2];\n\t      var lookAt = arguments[3];\n\t\n\t      var _scope = this,\n\t          gEnd = time;\n\t\n\t      var animation = new _Loop.Loop(function (clock) {\n\t        var u = clock.getElapsedTime() * 1000 / gEnd,\n\t            vec1 = curve.getPoint(u),\n\t            vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t        _scope.position.set(vec1.x, vec1.y, vec1.z);\n\t\n\t        if (!lookAt) _scope.lookAt(vec2);else if (lookAt instanceof TVector3) _scope.lookAt(lookAt);else if (lookAt instanceof TCurve || lookAt instanceof TCurvePath) _scope.lookAt(lookAt.getPoint(u));\n\t      });\n\t\n\t      animation.start();\n\t\n\t      if (loop) {\n\t        setInterval(function () {\n\t          animation.stop();\n\t\n\t          animation = new _Loop.Loop(function (clock) {\n\t            var u = clock.getElapsedTime() * 1000 / gEnd,\n\t                vec1 = curve.getPoint(u),\n\t                vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t            _scope.position.set(vec1.x, vec1.y, vec1.z);\n\t\n\t            if (!lookAt) _scope.lookAt(vec2);else if (lookAt instanceof TVector3) _scope.lookAt(lookAt);else if (lookAt instanceof TCurve || lookAt instanceof TCurvePath) _scope.lookAt(lookAt.getPoint(u));\n\t          });\n\t\n\t          animation.start();\n\t        }, time);\n\t      } else {\n\t        setTimeout(function () {\n\t          animation.stop();\n\t        }, time);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'lookAt',\n\t    value: function lookAt(vector3) {\n\t      return this.getNative().lookAt(vector3);\n\t    }\n\t  }, {\n\t    key: 'getWorldDirection',\n\t    value: function getWorldDirection(vector3) {\n\t      return this.getNative().getWorldDirection(vector3);\n\t    }\n\t  }, {\n\t    key: 'position',\n\t    get: function get() {\n\t      return this.getNative().position;\n\t    },\n\t    set: function set(vector3) {\n\t      return this.getNative().position.copy(vector3);\n\t    }\n\t  }, {\n\t    key: 'rotation',\n\t    get: function get() {\n\t      return this.getNative().rotation;\n\t    },\n\t    set: function set(euler) {\n\t      return this.getNative().rotation.copy(euler);\n\t    }\n\t  }]);\n\t  return Camera;\n\t}(_Object.WHSObject);\n\t\n\texports.Camera = Camera;\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Loop = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Loop = function () {\n\t  function Loop(func) {\n\t    (0, _classCallCheck3.default)(this, Loop);\n\t\n\t    this.func = func;\n\t    this.clock = new THREE.Clock();\n\t    this.enabled = false;\n\t  }\n\t\n\t  (0, _createClass3.default)(Loop, [{\n\t    key: 'start',\n\t    value: function start() {\n\t      this.clock.start();\n\t      this.enabled = true;\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      this.clock.stop();\n\t      this.enabled = false;\n\t    }\n\t  }, {\n\t    key: 'execute',\n\t    value: function execute() {\n\t      return this.func(this.clock);\n\t    }\n\t  }]);\n\t  return Loop;\n\t}();\n\t\n\texports.Loop = Loop;\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar defaults = {\n\t  debug: false\n\t};\n\t\n\texports.defaults = defaults;\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.WHSObject = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _minivents = __webpack_require__(98);\n\t\n\tvar _minivents2 = _interopRequireDefault(_minivents);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar WHSObject = function () {\n\t  /**\r\n\t   * Constructing WHS.Shape object.\r\n\t   *\r\n\t   * @param {Boolean} structurable - true if object has parents and children.\r\n\t   * @param {String} type - Shape type.\r\n\t   * @return {WHS.Object}\r\n\t   */\n\t\n\t  function WHSObject() {\n\t    var defaults = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    var structurable = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\t    (0, _classCallCheck3.default)(this, WHSObject);\n\t\n\t    var scope = structurable ? Object.assign(this, {\n\t      __whsobject: true,\n\t      __releaseTime: new Date().getTime(),\n\t      __params: {},\n\t      __defaults: defaults,\n\t\n\t      parent: null,\n\t      children: []\n\t    }, new _minivents2.default()) : Object.assign(this, {\n\t      __whsobject: true,\n\t      __releaseTime: new Date().getTime(),\n\t      __params: {},\n\t      __defaults: defaults\n\t    }, new _minivents2.default());\n\t\n\t    return scope;\n\t  }\n\t\n\t  (0, _createClass3.default)(WHSObject, [{\n\t    key: 'setParams',\n\t    value: function setParams() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      this.__params = (0, _api.extend)(params, this.__defaults);\n\t    }\n\t  }, {\n\t    key: 'updateParams',\n\t    value: function updateParams() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      this.__params = (0, _api.extend)(params, this.__params);\n\t      return this.__params;\n\t    }\n\t  }, {\n\t    key: 'getParams',\n\t    value: function getParams() {\n\t      return this.__params;\n\t    }\n\t  }, {\n\t    key: 'setNative',\n\t    value: function setNative(native) {\n\t      this._native = native;\n\t      return this.native;\n\t    }\n\t  }, {\n\t    key: 'getNative',\n\t    value: function getNative() {\n\t      return this._native;\n\t    }\n\t  }, {\n\t    key: 'add',\n\t    value: function add(children) {\n\t      var _scope = this;\n\t\n\t      if (children.addTo) return children.addTo(this);else if (children instanceof Object) {\n\t        return new Promise(function (resolve) {\n\t          children.parent = _scope;\n\t\n\t          _scope.getNative().add(children.getNative());\n\t          _scope.children.push(_scope);\n\t\n\t          resolve();\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Remove this shape from world.\r\n\t     *\r\n\t     * @return {WHS.Shape} - this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(source) {\n\t      this.getNative().remove(source.getNative());\n\t\n\t      this.children.splice(this.children.indexOf(source), 1);\n\t      source.parent = null;\n\t\n\t      source.emit('remove');\n\t\n\t      if (WHS.debug) {\n\t        console.debug('@WHS.Shape: Shape ' + source._type + ' was removed from world', [source]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t  return WHSObject;\n\t}();\n\t\n\texports.WHSObject = WHSObject;\n\n/***/ },\n/* 98 */\n/***/ function(module, exports) {\n\n\tmodule.exports=function(n){var t={},e=[];n=n||this,n.on=function(n,e,l){(t[n]=t[n]||[]).push([e,l])},n.off=function(n,l){n||(t={});for(var o=t[n]||e,i=o.length=l?o.length:0;i--;)l==o[i][0]&&o.splice(i,1)},n.emit=function(n){for(var l,o=t[n]||e,i=o.length>0?o.slice(0,o.length):o,c=0;l=i[c++];)l[0].apply(l[1],e.slice.call(arguments,1))}};\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.loadMaterial = exports.extend = exports.texture = exports.TextureLoader = exports.JSONLoader = exports.FontLoader = undefined;\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _loaders = __webpack_require__(101);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar extend = function extend(object) {\n\t  for (var _len = arguments.length, extensions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    extensions[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  // $.extend alternative, ... is the spread operator.\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var extension = _step.value;\n\t\n\t      // console.log(extension);\n\t      // console.log(typeof extension);\n\t\n\t      if (!extension) continue; // Ignore null and undefined objects and paramaters.\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.getOwnPropertyNames(extension)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var prop = _step2.value;\n\t          // Do not traverse the prototype chain.\n\t          if (object[prop] !== undefined && object[prop].toString() === '[object Object]' && extension[prop].toString() === '[object Object]')\n\t\n\t            // Goes deep only if object[prop] and extension[prop] are both objects !\n\t            extend(object[prop], extension[prop]);else object[prop] = object[prop] === 0 ? 0 : object[prop];\n\t          if (typeof object[prop] === 'undefined') object[prop] = extension[prop]; // Add values that do not already exist.\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return object;\n\t};\n\t\n\tvar texture = function texture(url) {\n\t  var repeat = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t  var texture = _loaders.TextureLoader.load(url);\n\t\n\t  if (repeat) {\n\t    var opt = extend(repeat, {\n\t      offset: {\n\t        x: 0,\n\t        y: 0\n\t      },\n\t      repeat: {\n\t        x: 1,\n\t        y: 1\n\t      }\n\t    });\n\t\n\t    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\n\t    texture.offset.set(opt.offset.x, opt.offset.y);\n\t    texture.repeat.set(opt.repeat.x, opt.repeat.y);\n\t\n\t    texture.magFilter = THREE.NearestFilter;\n\t    texture.minFilter = THREE.LinearMipMapLinearFilter;\n\t  }\n\t\n\t  return texture;\n\t};\n\t\n\tvar loadMaterial = function loadMaterial() {\n\t  var material = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t  if (typeof material.kind !== 'string') console.error('Type of material is undefined or not a string. @loadMaterial');\n\t\n\t  var materialThree = void 0;\n\t\n\t  var params = Object.assign({}, material);\n\t\n\t  delete params.kind;\n\t  delete params.useCustomMaterial;\n\t  delete params.useVertexColors;\n\t\n\t  switch (material.kind) {\n\t    case 'basic':\n\t      materialThree = new THREE.MeshBasicMaterial(params);\n\t      break;\n\t\n\t    case 'linebasic':\n\t      materialThree = new THREE.LineBasicMaterial(params);\n\t      break;\n\t\n\t    case 'linedashed':\n\t      materialThree = new THREE.LineDashedMaterial(params);\n\t      break;\n\t\n\t    case 'material':\n\t      materialThree = new THREE.Material(params);\n\t      break;\n\t\n\t    case 'depth':\n\t      materialThree = new THREE.MeshDepthMaterial(params);\n\t      break;\n\t\n\t    case 'face':\n\t      materialThree = new THREE.MeshFaceMaterial(params);\n\t      break;\n\t\n\t    case 'lambert':\n\t      materialThree = new THREE.MeshLambertMaterial(params);\n\t      break;\n\t\n\t    case 'normal':\n\t      materialThree = new THREE.MeshNormalMaterial(params);\n\t      break;\n\t\n\t    case 'phong':\n\t      materialThree = new THREE.MeshPhongMaterial(params);\n\t      break;\n\t\n\t    case 'points':\n\t      materialThree = new THREE.PointsMaterial(params);\n\t      break;\n\t\n\t    case 'standard':\n\t      materialThree = new THREE.MeshStandardMaterial(params);\n\t      break;\n\t\n\t    case 'pointcloud':\n\t      materialThree = new THREE.PointCloudMaterial(params);\n\t      break;\n\t\n\t    case 'rawshader':\n\t      materialThree = new THREE.RawShaderMaterial(params);\n\t      break;\n\t\n\t    case 'shader':\n\t      materialThree = new THREE.ShaderMaterial(params);\n\t      break;\n\t\n\t    case 'spritecanvas':\n\t      materialThree = new THREE.SpriteCanvasMaterial(params);\n\t      break;\n\t\n\t    case 'sprite':\n\t      materialThree = new THREE.SpriteMaterial(params);\n\t      break;\n\t\n\t    default:\n\t  }\n\t\n\t  return materialThree;\n\t};\n\t\n\texports.FontLoader = _loaders.FontLoader;\n\texports.JSONLoader = _loaders.JSONLoader;\n\texports.TextureLoader = _loaders.TextureLoader;\n\texports.texture = texture;\n\texports.extend = extend;\n\texports.loadMaterial = loadMaterial;\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function () {\n\t  return {};\n\t};\n\t\n\tmodule.exports = exports[\"default\"];\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.MaterialLoader = exports.ImageLoader = exports.AudioLoader = exports.XHRLoader = exports.FontLoader = exports.TextureLoader = exports.ObjectLoader = exports.BufferGeometryLoader = exports.OBJLoader = exports.JSONLoader = undefined;\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _threeObjLoader = __webpack_require__(102);\n\t\n\tvar _threeObjLoader2 = _interopRequireDefault(_threeObjLoader);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\t(0, _threeObjLoader2.default)(THREE);\n\t\n\t// Models.\n\tvar JSONLoader = new THREE.JSONLoader();\n\tvar OBJLoader = new THREE.OBJLoader();\n\t// const BabylonLoader = new THREE.BabylonLoader();\n\tvar BufferGeometryLoader = new THREE.BufferGeometryLoader();\n\t// const ColladaLoader = new THREE.ColladaLoader();\n\t// const glTFLoader = new THREE.glTFLoader();\n\tvar ObjectLoader = new THREE.ObjectLoader();\n\t// const PDBLoader = new THREE.PDBLoader();\n\t// const SVGLoader = new THREE.SVGLoader();\n\t// const TGALoader = new THREE.TGALoader();\n\t\n\t// Other.\n\tvar TextureLoader = new THREE.TextureLoader();\n\tvar FontLoader = new THREE.FontLoader();\n\tvar XHRLoader = new THREE.XHRLoader();\n\tvar AudioLoader = new THREE.AudioLoader();\n\tvar ImageLoader = new THREE.ImageLoader();\n\tvar MaterialLoader = new THREE.MaterialLoader();\n\t// const MTLLoader = new THREE.MTLLoader();\n\t\n\texports.JSONLoader = JSONLoader;\n\texports.OBJLoader = OBJLoader;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.ObjectLoader = ObjectLoader;\n\texports.TextureLoader = TextureLoader;\n\texports.FontLoader = FontLoader;\n\texports.XHRLoader = XHRLoader;\n\texports.AudioLoader = AudioLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.MaterialLoader = MaterialLoader;\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function (THREE) {\n\t\n\t  /**\n\t   * @author mrdoob / http://mrdoob.com/\n\t   */\n\t  THREE.OBJLoader = function (manager) {\n\t\n\t    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t  };\n\t\n\t  THREE.OBJLoader.prototype = {\n\t\n\t    constructor: THREE.OBJLoader,\n\t\n\t    load: function load(url, onLoad, onProgress, onError) {\n\t\n\t      var scope = this;\n\t\n\t      var loader = new THREE.XHRLoader(scope.manager);\n\t      loader.load(url, function (text) {\n\t\n\t        onLoad(scope.parse(text));\n\t      }, onProgress, onError);\n\t    },\n\t\n\t    parse: function parse(text) {\n\t\n\t      console.time('OBJLoader');\n\t\n\t      var object,\n\t          objects = [];\n\t      var geometry, material;\n\t\n\t      function parseVertexIndex(value) {\n\t\n\t        var index = parseInt(value);\n\t\n\t        return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;\n\t      }\n\t\n\t      function parseNormalIndex(value) {\n\t\n\t        var index = parseInt(value);\n\t\n\t        return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;\n\t      }\n\t\n\t      function parseUVIndex(value) {\n\t\n\t        var index = parseInt(value);\n\t\n\t        return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;\n\t      }\n\t\n\t      function addVertex(a, b, c) {\n\t\n\t        geometry.vertices.push(vertices[a], vertices[a + 1], vertices[a + 2], vertices[b], vertices[b + 1], vertices[b + 2], vertices[c], vertices[c + 1], vertices[c + 2]);\n\t      }\n\t\n\t      function addNormal(a, b, c) {\n\t\n\t        geometry.normals.push(normals[a], normals[a + 1], normals[a + 2], normals[b], normals[b + 1], normals[b + 2], normals[c], normals[c + 1], normals[c + 2]);\n\t      }\n\t\n\t      function addUV(a, b, c) {\n\t\n\t        geometry.uvs.push(uvs[a], uvs[a + 1], uvs[b], uvs[b + 1], uvs[c], uvs[c + 1]);\n\t      }\n\t\n\t      function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {\n\t\n\t        var ia = parseVertexIndex(a);\n\t        var ib = parseVertexIndex(b);\n\t        var ic = parseVertexIndex(c);\n\t        var id;\n\t\n\t        if (d === undefined) {\n\t\n\t          addVertex(ia, ib, ic);\n\t        } else {\n\t\n\t          id = parseVertexIndex(d);\n\t\n\t          addVertex(ia, ib, id);\n\t          addVertex(ib, ic, id);\n\t        }\n\t\n\t        if (ua !== undefined) {\n\t\n\t          ia = parseUVIndex(ua);\n\t          ib = parseUVIndex(ub);\n\t          ic = parseUVIndex(uc);\n\t\n\t          if (d === undefined) {\n\t\n\t            addUV(ia, ib, ic);\n\t          } else {\n\t\n\t            id = parseUVIndex(ud);\n\t\n\t            addUV(ia, ib, id);\n\t            addUV(ib, ic, id);\n\t          }\n\t        }\n\t\n\t        if (na !== undefined) {\n\t\n\t          ia = parseNormalIndex(na);\n\t          ib = parseNormalIndex(nb);\n\t          ic = parseNormalIndex(nc);\n\t\n\t          if (d === undefined) {\n\t\n\t            addNormal(ia, ib, ic);\n\t          } else {\n\t\n\t            id = parseNormalIndex(nd);\n\t\n\t            addNormal(ia, ib, id);\n\t            addNormal(ib, ic, id);\n\t          }\n\t        }\n\t      }\n\t\n\t      // create mesh if no objects in text\n\t\n\t      if (/^o /gm.test(text) === false) {\n\t\n\t        geometry = {\n\t          vertices: [],\n\t          normals: [],\n\t          uvs: []\n\t        };\n\t\n\t        material = {\n\t          name: ''\n\t        };\n\t\n\t        object = {\n\t          name: '',\n\t          geometry: geometry,\n\t          material: material\n\t        };\n\t\n\t        objects.push(object);\n\t      }\n\t\n\t      var vertices = [];\n\t      var normals = [];\n\t      var uvs = [];\n\t\n\t      // v float float float\n\t\n\t      var vertex_pattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\t\n\t      // vn float float float\n\t\n\t      var normal_pattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\t\n\t      // vt float float\n\t\n\t      var uv_pattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\t\n\t      // f vertex vertex vertex ...\n\t\n\t      var face_pattern1 = /f( +-?\\d+)( +-?\\d+)( +-?\\d+)( +-?\\d+)?/;\n\t\n\t      // f vertex/uv vertex/uv vertex/uv ...\n\t\n\t      var face_pattern2 = /f( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))?/;\n\t\n\t      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n\t\n\t      var face_pattern3 = /f( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/;\n\t\n\t      // f vertex//normal vertex//normal vertex//normal ...\n\t\n\t      var face_pattern4 = /f( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))?/;\n\t\n\t      //\n\t\n\t      var lines = text.split('\\n');\n\t\n\t      for (var i = 0; i < lines.length; i++) {\n\t\n\t        var line = lines[i];\n\t        line = line.trim();\n\t\n\t        var result;\n\t\n\t        if (line.length === 0 || line.charAt(0) === '#') {\n\t\n\t          continue;\n\t        } else if ((result = vertex_pattern.exec(line)) !== null) {\n\t\n\t          // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\t\n\t          vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t        } else if ((result = normal_pattern.exec(line)) !== null) {\n\t\n\t          // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\t\n\t          normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t        } else if ((result = uv_pattern.exec(line)) !== null) {\n\t\n\t          // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\t\n\t          uvs.push(parseFloat(result[1]), parseFloat(result[2]));\n\t        } else if ((result = face_pattern1.exec(line)) !== null) {\n\t\n\t          // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\t\n\t          addFace(result[1], result[2], result[3], result[4]);\n\t        } else if ((result = face_pattern2.exec(line)) !== null) {\n\t\n\t          // [\"f 1/1 2/2 3/3\", \" 1/1\", \"1\", \"1\", \" 2/2\", \"2\", \"2\", \" 3/3\", \"3\", \"3\", undefined, undefined, undefined]\n\t\n\t          addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);\n\t        } else if ((result = face_pattern3.exec(line)) !== null) {\n\t\n\t          // [\"f 1/1/1 2/2/2 3/3/3\", \" 1/1/1\", \"1\", \"1\", \"1\", \" 2/2/2\", \"2\", \"2\", \"2\", \" 3/3/3\", \"3\", \"3\", \"3\", undefined, undefined, undefined, undefined]\n\t\n\t          addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);\n\t        } else if ((result = face_pattern4.exec(line)) !== null) {\n\t\n\t          // [\"f 1//1 2//2 3//3\", \" 1//1\", \"1\", \"1\", \" 2//2\", \"2\", \"2\", \" 3//3\", \"3\", \"3\", undefined, undefined, undefined]\n\t\n\t          addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);\n\t        } else if (/^o /.test(line)) {\n\t\n\t          geometry = {\n\t            vertices: [],\n\t            normals: [],\n\t            uvs: []\n\t          };\n\t\n\t          material = {\n\t            name: ''\n\t          };\n\t\n\t          object = {\n\t            name: line.substring(2).trim(),\n\t            geometry: geometry,\n\t            material: material\n\t          };\n\t\n\t          objects.push(object);\n\t        } else if (/^g /.test(line)) {\n\t\n\t          // group\n\t\n\t        } else if (/^usemtl /.test(line)) {\n\t\n\t            // material\n\t\n\t            material.name = line.substring(7).trim();\n\t          } else if (/^mtllib /.test(line)) {\n\t\n\t            // mtl file\n\t\n\t          } else if (/^s /.test(line)) {\n\t\n\t              // smooth shading\n\t\n\t            } else {\n\t\n\t                // console.log( \"THREE.OBJLoader: Unhandled line \" + line );\n\t\n\t              }\n\t      }\n\t\n\t      var container = new THREE.Object3D();\n\t      var l;\n\t\n\t      for (i = 0, l = objects.length; i < l; i++) {\n\t\n\t        object = objects[i];\n\t        geometry = object.geometry;\n\t\n\t        var buffergeometry = new THREE.BufferGeometry();\n\t\n\t        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));\n\t\n\t        if (geometry.normals.length > 0) {\n\t\n\t          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));\n\t        }\n\t\n\t        if (geometry.uvs.length > 0) {\n\t\n\t          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));\n\t        }\n\t\n\t        material = new THREE.MeshLambertMaterial({\n\t          color: 0xff0000\n\t        });\n\t        material.name = object.material.name;\n\t\n\t        var mesh = new THREE.Mesh(buffergeometry, material);\n\t        mesh.name = object.name;\n\t\n\t        container.add(mesh);\n\t      }\n\t\n\t      console.timeEnd('OBJLoader');\n\t\n\t      return container;\n\t    }\n\t\n\t  };\n\t};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.OrtographicCamera = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Camera2 = __webpack_require__(94);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar OrtographicCamera = function (_Camera) {\n\t  (0, _inherits3.default)(OrtographicCamera, _Camera);\n\t\n\t  function OrtographicCamera() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, OrtographicCamera);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(OrtographicCamera).call(this, params, 'ortographiccamera'));\n\t\n\t    _this.build(params);\n\t    (0, _get3.default)(Object.getPrototypeOf(OrtographicCamera.prototype), 'wrap', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(OrtographicCamera, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new THREE.OrtographicCamera(params.camera.left, params.camera.right, params.camera.top, params.camera.bottom, params.camera.near, params.camera.far));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return OrtographicCamera;\n\t}(_Camera2.Camera);\n\t\n\texports.OrtographicCamera = OrtographicCamera;\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.PerspectiveCamera = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Camera2 = __webpack_require__(94);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PerspectiveCamera = function (_Camera) {\n\t  (0, _inherits3.default)(PerspectiveCamera, _Camera);\n\t\n\t  function PerspectiveCamera() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, PerspectiveCamera);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(PerspectiveCamera).call(this, params, 'perspectivecamera'));\n\t\n\t    _this.build(params);\n\t    (0, _get3.default)(Object.getPrototypeOf(PerspectiveCamera.prototype), 'wrap', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(PerspectiveCamera, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new THREE.PerspectiveCamera(params.camera.fov, params.camera.aspect, params.camera.near, params.camera.far));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return PerspectiveCamera;\n\t}(_Camera2.Camera);\n\t\n\texports.PerspectiveCamera = PerspectiveCamera;\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Camera = __webpack_require__(94);\n\t\n\tObject.keys(_Camera).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Camera[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Light = __webpack_require__(106);\n\t\n\tObject.keys(_Light).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Light[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tObject.keys(_Object).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Object[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Shape = __webpack_require__(107);\n\t\n\tObject.keys(_Shape).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Shape[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _World = __webpack_require__(108);\n\t\n\tObject.keys(_World).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _World[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Light = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Loop = __webpack_require__(95);\n\t\n\tvar _defaults = __webpack_require__(96);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Light = function (_WHSObject) {\n\t  (0, _inherits3.default)(Light, _WHSObject);\n\t\n\t  /**\r\n\t   * Constructing WHS.Light object.\r\n\t   *\r\n\t   * @param {Object} params - Inputed parameters.\r\n\t   * @param {String} type - Light type.\r\n\t   * @return {WHS.Light}\r\n\t   */\n\t\n\t  function Light(params, type) {\n\t    var _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, Light);\n\t\n\t    if (!type) console.error('@constructor: Please specify \" type \".');\n\t\n\t    var _set = function _set(x, y, z) {\n\t      _this.x = x;\n\t      _this.y = y;\n\t      _this.z = z;\n\t    };\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Light).call(this, {\n\t      light: {\n\t        color: 0xffffff,\n\t        skyColor: 0xffffff,\n\t        groundColor: 0xffffff,\n\t\n\t        intensity: 1,\n\t        distance: 100,\n\t        angle: Math.PI / 3,\n\t        exponent: 0,\n\t        decay: 1\n\t      },\n\t\n\t      helper: false,\n\t\n\t      shadowmap: {\n\t        cast: true,\n\t\n\t        bias: 0,\n\t\n\t        width: 1024,\n\t        height: 1024,\n\t\n\t        near: true,\n\t        far: 400,\n\t        fov: 60,\n\t\n\t        top: 200,\n\t        bottom: -200,\n\t        left: -200,\n\t        right: 200\n\t      },\n\t\n\t      pos: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      rot: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      target: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      }\n\t    }));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Light.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var scope = Object.assign(_this, {\n\t      _type: type,\n\t\n\t      _light: _this.__params.light,\n\t      _shadowmap: _this.__params.shadowmap\n\t    });\n\t\n\t    if (_defaults.defaults.debug) console.debug('@WHS.Light: Light ' + scope._type + ' found.', scope);\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  /**\r\n\t   * Applying shadow & position & rotation.\r\n\t   *\r\n\t   * @param {...String} tags - Tags that defines what to do with light\r\n\t   * additionally.\r\n\t   */\n\t\n\t\n\t  (0, _createClass3.default)(Light, [{\n\t    key: 'wrap',\n\t    value: function wrap() {\n\t      var _this2 = this;\n\t\n\t      for (var _len = arguments.length, tags = Array(_len), _key = 0; _key < _len; _key++) {\n\t        tags[_key] = arguments[_key];\n\t      }\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          if (tags.indexOf('no-shadows') < 0) {\n\t            _scope.getNative().castShadow = _this2._shadowmap.cast;\n\t          }\n\t\n\t          if (tags.indexOf('no-transforms') < 0) {\n\t            _scope.position.set(_scope.__params.pos.x, _scope.__params.pos.y, _scope.__params.pos.z);\n\t\n\t            _scope.rotation.set(_scope.__params.rot.x, _scope.__params.rot.y, _scope.__params.rot.z);\n\t\n\t            if (_scope.getNative().target) {\n\t              _scope.target.set(_scope.__params.target.x, _scope.__params.target.y, _scope.__params.target.z);\n\t            }\n\t          }\n\t\n\t          tags.forEach(function (tag) {\n\t            _scope[tag] = true;\n\t          });\n\t\n\t          if (_defaults.defaults.debug) console.debug('@WHS.Light: Light ' + _scope._type + ' + \\' is ready.', _scope);\n\t\n\t          _scope.emit('ready');\n\t\n\t          resolve(_scope);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Add light to WHS.World object.\r\n\t     *\r\n\t     * @param {WHS.World} root - World, were this light will be.\r\n\t     * @param {...String} tags - Tags for compiling.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'addTo',\n\t    value: function addTo(parent) {\n\t      this.parent = parent;\n\t\n\t      var _helper = this.helper,\n\t          _scope = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _scope.parent.getScene().add(_scope.getNative());\n\t          _scope.parent.children.push(_scope);\n\t\n\t          if (_helper) _scope.parent.getScene().add(_helper);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        } finally {\n\t          if (_defaults.defaults.debug) {\n\t            console.debug('@WHS.Camera: Camera ' + _scope._type + ' was added to world.', [_scope, _scope.parent]);\n\t          }\n\t\n\t          resolve(_scope);\n\t          _scope.emit('ready');\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Set shadow properties for light.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'wrapShadow',\n\t    value: function wrapShadow() {\n\t      var _this3 = this;\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _scope.getNative().shadow.mapSize.width = _this3._shadowmap.width;\n\t          _scope.getNative().shadow.mapSize.height = _this3._shadowmap.height;\n\t          _scope.getNative().shadow.bias = _this3._shadowmap.bias;\n\t\n\t          _scope.getNative().shadow.camera.near = _this3._shadowmap.near;\n\t          _scope.getNative().shadow.camera.far = _this3._shadowmap.far;\n\t          _scope.getNative().shadow.camera.fov = _this3._shadowmap.fov;\n\t\n\t          _scope.getNative().shadow.camera.left = _this3._shadowmap.left;\n\t          _scope.getNative().shadow.camera.right = _this3._shadowmap.right;\n\t          _scope.getNative().shadow.camera.top = _this3._shadowmap.top;\n\t          _scope.getNative().shadow.camera.bottom = _this3._shadowmap.bottom;\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        } finally {\n\t          resolve(_scope);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Clone light.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Light(this.__params, this._type).copy(this);\n\t    }\n\t\n\t    /**\r\n\t     * Copy light.\r\n\t     *\r\n\t     * @param {WHS.Light} source - Source object, that will be applied to this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(source) {\n\t      this.light = source.getNative().clone();\n\t      if (source.helper) this.helper = source.helper.clone();\n\t\n\t      this.wrap();\n\t\n\t      this.position = source.position.clone();\n\t      this.rotation = source.rotation.clone();\n\t\n\t      this._type = source._type;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Remove this light from world.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove() {\n\t      this.parent.getScene().remove(this.getNative());\n\t      if (source.helper) this.parent.getScene().remove(this.helper);\n\t\n\t      this.parent.children.splice(this.parent.children.indexOf(this), 1);\n\t      this.parent = null;\n\t\n\t      this.emit('remove');\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'follow',\n\t    value: function follow(curve) {\n\t      var time = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];\n\t      var loop = arguments[2];\n\t      var lookAt = arguments[3];\n\t\n\t      var _scope = this,\n\t          gEnd = time;\n\t\n\t      var animation = new _Loop.Loop(function (clock) {\n\t        var u = clock.getElapsedTime() * 1000 / gEnd,\n\t            vec1 = curve.getPoint(u),\n\t            vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t        _scope.position.set(vec1.x, vec1.y, vec1.z);\n\t\n\t        if (!lookAt) _scope.lookAt(vec2);else if (lookAt instanceof THREE.Vector3) _scope.lookAt(lookAt);else if (lookAt instanceof THREE.Curve || lookAt instanceof THREE.CurvePath) _scope.lookAt(lookAt.getPoint(u));\n\t      });\n\t\n\t      animation.start();\n\t\n\t      if (loop) {\n\t        setInterval(function () {\n\t          animation.stop();\n\t\n\t          animation = new _Loop.Loop(function (clock) {\n\t            var u = clock.getElapsedtime() * 1000 / gEnd,\n\t                vec1 = curve.getPoint(u),\n\t                vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t            _scope.position.set(vec1.x, vec1.y, vec1.z);\n\t\n\t            if (!lookAt) _scope.lookAt(vec2);else if (lookAt instanceof THREE.Vector3) _scope.lookAt(lookAt);else if (lookAt instanceof THREE.Curve || lookAt instanceof THREE.CurvePath) _scope.lookAt(lookAt.getPoint(u));\n\t          });\n\t\n\t          animation.start();\n\t        }, time);\n\t      } else {\n\t        setTimeout(function () {\n\t          animation.stop();\n\t        }, time);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'position',\n\t    get: function get() {\n\t      return this.getNative().position;\n\t    },\n\t    set: function set(vector3) {\n\t      return this.getNative().position.copy(vector3);\n\t    }\n\t  }, {\n\t    key: 'rotation',\n\t    get: function get() {\n\t      return this.getNative().rotation;\n\t    },\n\t    set: function set(euler) {\n\t      return this.getNative().rotation.copy(euler);\n\t    }\n\t  }, {\n\t    key: 'target',\n\t    get: function get() {\n\t      return this.getNative().target.position;\n\t    },\n\t    set: function set(vector3) {\n\t      return this.getNative().target.position.copy(vector3);\n\t    }\n\t  }]);\n\t  return Light;\n\t}(_Object.WHSObject);\n\t\n\texports.Light = Light;\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Shape = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tvar _Loop = __webpack_require__(95);\n\t\n\tvar _defaults = __webpack_require__(96);\n\t\n\tvar _World = __webpack_require__(108);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Shape = function (_WHSObject) {\n\t  (0, _inherits3.default)(Shape, _WHSObject);\n\t\n\t  /**\r\n\t   * Constructing WHS.Shape object.\r\n\t   *\r\n\t   * @param {Object} params - Inputed parameters.\r\n\t   * @param {String} type - Shape type.\r\n\t   * @return {WHS.Shape}\r\n\t   */\n\t\n\t  function Shape() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t    var _ret;\n\t\n\t    var type = arguments.length <= 1 || arguments[1] === undefined ? 'mesh' : arguments[1];\n\t    (0, _classCallCheck3.default)(this, Shape);\n\t\n\t    var _set = function _set(x, y, z) {\n\t      _this.x = x;\n\t      _this.y = y;\n\t      _this.z = z;\n\t    };\n\t\n\t    var physicsDefaults = false ? {\n\t      restitution: 0.3,\n\t      friction: 0.8,\n\t      damping: 0,\n\t      pressure: 100,\n\t      margin: 0\n\t    } : false;\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Shape).call(this, {\n\t      mass: 10,\n\t      build: true,\n\t      softbody: false,\n\t      geometry: {},\n\t\n\t      material: {\n\t        kind: 'basic'\n\t      },\n\t\n\t      helpers: {\n\t        box: false,\n\t        boundingBox: false,\n\t        edges: false,\n\t        faceNormals: false\n\t      },\n\t\n\t      pos: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      rot: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      scale: {\n\t        x: 1,\n\t        y: 1,\n\t        z: 1,\n\t        set: _set\n\t      },\n\t\n\t      target: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0,\n\t        set: _set\n\t      },\n\t\n\t      physics: physicsDefaults\n\t    }));\n\t\n\t    if (params instanceof THREE.Object3D) {\n\t      (0, _get3.default)(Object.getPrototypeOf(Shape.prototype), 'setParams', _this).call(_this, {\n\t        pos: { x: params.position.x, y: params.position.y, z: params.position.z },\n\t        rot: { x: params.rotation.x, y: params.rotation.y, z: params.rotation.z },\n\t        scale: { x: params.scale.x, y: params.scale.y, z: params.scale.z },\n\t        mass: params.mass,\n\t        physics: Boolean(params._physijs)\n\t      });\n\t    } else (0, _get3.default)(Object.getPrototypeOf(Shape.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var scope = Object.assign(_this, {\n\t      _type: type,\n\t      __c_rot: false,\n\t\n\t      _wait: [],\n\t\n\t      helpers: {\n\t        box: false,\n\t        boundingBox: false,\n\t        edges: false,\n\t        faceNormals: false\n\t      },\n\t\n\t      physics: params.physics\n\t    });\n\t\n\t    if (params instanceof THREE.Object3D) _this.setNative(params);\n\t    if (_defaults.defaults.debug) console.debug('@WHS.Shape: Shape ' + scope._type + ' found.', scope);\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  (0, _createClass3.default)(Shape, [{\n\t    key: 'wait',\n\t    value: function wait(promise) {\n\t      this._wait.push(promise);\n\t    }\n\t\n\t    /**\r\n\t     * Applying shadow & position & rotation.\r\n\t     *\r\n\t     * @param {...String} tags - Tags that defines what to do with shape\r\n\t     * additionally.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'wrap',\n\t    value: function wrap() {\n\t      var _this2 = this;\n\t\n\t      for (var _len = arguments.length, tags = Array(_len), _key = 0; _key < _len; _key++) {\n\t        tags[_key] = arguments[_key];\n\t      }\n\t\n\t      if (this._wait.length) {\n\t        return new Promise(function (resolve, reject) {\n\t          Promise.all(_this2._wait).then(function () {\n\t            var _native = _this2.getNative(),\n\t                _params = _this2.getParams(),\n\t                _params_helpers = _params.helpers;\n\t\n\t            if (!_native) reject();\n\t\n\t            if (tags.indexOf('no-shadows') < 0) {\n\t              _native.castShadow = true;\n\t              _native.receiveShadow = true;\n\t            }\n\t\n\t            if (tags.indexOf('no-transforms') < 0) {\n\t              if (!_params.softbody) {\n\t                var _params_pos = _params.pos,\n\t                    _params_rot = _params.rot,\n\t                    _params_scale = _params.scale;\n\t\n\t                _this2.position.set(_params_pos.x, _params_pos.y, _params_pos.z);\n\t\n\t                _this2.rotation.set(_params_rot.x, _params_rot.y, _params_rot.z);\n\t\n\t                _this2.scale.set(_params_scale.x, _params_scale.y, _params_scale.z);\n\t              }\n\t            }\n\t\n\t            // Box helper.\n\t            if (_params_helpers.box) {\n\t              _this2.helpers.box = new THREE.BoxHelper(_native);\n\t            }\n\t\n\t            // Bounding box helper.\n\t            if (_params_helpers.boundingBox) {\n\t              (0, _api.extend)(_params_helpers.boundingBox, {\n\t                color: 0xffffff\n\t              });\n\t\n\t              _this2.helpers.boundingBox = new THREE.BoundingBoxHelper(_native, _params_helpers.boundingBox.color ? _params_helpers.boundingBox.color : 0xffffff);\n\t            }\n\t\n\t            // Edges helper.\n\t            if (_params_helpers.edges) {\n\t              (0, _api.extend)(_params_helpers.edges, {\n\t                color: 0xffffff\n\t              });\n\t\n\t              _this2.helpers.edges = new THREE.EdgesHelper(_native, _params_helpers.edges.color);\n\t            }\n\t\n\t            // faceNormals helper.\n\t            if (_params_helpers.faceNormals) {\n\t              var _params_helpers_faceNormals = _params_helpers.faceNormals;\n\t\n\t              (0, _api.extend)(_params_helpers_faceNormals, {\n\t                size: 2,\n\t                color: 0xffffff,\n\t                linewidth: 1\n\t              });\n\t\n\t              _this2.helpers.faceNormals = new THREE.FaceNormalsHelper(_native, _params_helpers_faceNormals.size, _params_helpers_faceNormals.color, _params_helpers_faceNormals.linewidth);\n\t            }\n\t\n\t            // vertexNormals helper.\n\t            if (_params_helpers.vertexNormals) {\n\t              var _params_helpers_vertexNormals = _params_helpers.vertexNormals;\n\t\n\t              (0, _api.extend)(_params_helpers_vertexNormals, {\n\t                size: 2,\n\t                color: 0xffffff,\n\t                linewidth: 1\n\t              });\n\t\n\t              _this2.helpers.vertexNormals = new THREE.VertexNormalsHelper(_native, _params_helpers_vertexNormals.size, _params_helpers_vertexNormals.color, _params_helpers_vertexNormals.linewidth);\n\t            }\n\t\n\t            resolve(_this2);\n\t\n\t            if (WHS.debug) console.debug('@WHS.Shape: Shape ' + _this2._type + ' is ready.', _this2);\n\t          });\n\t        });\n\t      } else {\n\t        return new Promise(function (resolve, reject) {\n\t          var _native = _this2.getNative(),\n\t              _params = _this2.getParams(),\n\t              _params_helpers = _params.helpers;\n\t\n\t          if (!_native) reject();\n\t\n\t          if (tags.indexOf('no-shadows') < 0) {\n\t            _native.castShadow = true;\n\t            _native.receiveShadow = true;\n\t          }\n\t\n\t          if (tags.indexOf('no-transforms') < 0) {\n\t            if (!_params.softbody) {\n\t              var _params_pos = _params.pos,\n\t                  _params_rot = _params.rot,\n\t                  _params_scale = _params.scale;\n\t\n\t              _this2.position.set(_params_pos.x, _params_pos.y, _params_pos.z);\n\t\n\t              _this2.rotation.set(_params_rot.x, _params_rot.y, _params_rot.z);\n\t\n\t              _this2.scale.set(_params_scale.x, _params_scale.y, _params_scale.z);\n\t            }\n\t          }\n\t\n\t          // Box helper.\n\t          if (_params_helpers.box) {\n\t            _this2.helpers.box = new THREE.BoxHelper(_native);\n\t          }\n\t\n\t          // Bounding box helper.\n\t          if (_params_helpers.boundingBox) {\n\t            (0, _api.extend)(_params_helpers.boundingBox, {\n\t              color: 0xffffff\n\t            });\n\t\n\t            _this2.helpers.boundingBox = new THREE.BoundingBoxHelper(_native, _params_helpers.boundingBox.color ? _params_helpers.boundingBox.color : 0xffffff);\n\t          }\n\t\n\t          // Edges helper.\n\t          if (_params_helpers.edges) {\n\t            (0, _api.extend)(_params_helpers.edges, {\n\t              color: 0xffffff\n\t            });\n\t\n\t            _this2.helpers.edges = new THREE.EdgesHelper(_native, _params_helpers.edges.color);\n\t          }\n\t\n\t          // faceNormals helper.\n\t          if (_params_helpers.faceNormals) {\n\t            var _params_helpers_faceNormals = _params_helpers.faceNormals;\n\t\n\t            (0, _api.extend)(_params_helpers_faceNormals, {\n\t              size: 2,\n\t              color: 0xffffff,\n\t              linewidth: 1\n\t            });\n\t\n\t            _this2.helpers.faceNormals = new THREE.FaceNormalsHelper(_native, _params_helpers_faceNormals.size, _params_helpers_faceNormals.color, _params_helpers_faceNormals.linewidth);\n\t          }\n\t\n\t          // vertexNormals helper.\n\t          if (_params_helpers.vertexNormals) {\n\t            var _params_helpers_vertexNormals = _params_helpers.vertexNormals;\n\t\n\t            (0, _api.extend)(_params_helpers_vertexNormals, {\n\t              size: 2,\n\t              color: 0xffffff,\n\t              linewidth: 1\n\t            });\n\t\n\t            _this2.helpers.vertexNormals = new THREE.VertexNormalsHelper(_native, _params_helpers_vertexNormals.size, _params_helpers_vertexNormals.color, _params_helpers_vertexNormals.linewidth);\n\t          }\n\t\n\t          resolve(_this2);\n\t\n\t          if (WHS.debug) console.debug('@WHS.Shape: Shape ' + _this2._type + ' is ready.', _this2);\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Add shape to WHS.World object.\r\n\t     *\r\n\t     * @param {WHS.World} parent - World, were this shape will be.\r\n\t     * @param {...String} tags - Tags for compiling.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'addTo',\n\t    value: function addTo(parent) {\n\t      var _this3 = this;\n\t\n\t      var _helpers = this.helpers;\n\t      this.parent = parent;\n\t\n\t      if (this._wait.length) {\n\t        return new Promise(function (resolve, reject) {\n\t          Promise.all(_this3._wait).then(function () {\n\t            var _native = _this3.getNative(),\n\t                _params = _this3.getParams(),\n\t                _params_helpers = _params.helpers,\n\t                _parent = _this3.parent;\n\t\n\t            if (!_native) reject();\n\t\n\t            var parentNative = _parent instanceof _World.World ? _parent.getScene() : _parent.getNative();\n\t\n\t            parentNative.add(_native);\n\t            _this3.parent.children.push(_this3);\n\t\n\t            if (_params.softbody) {\n\t              _native.position.set(0, 0, 0);\n\t              _native.rotation.set(0, 0, 0);\n\t            }\n\t\n\t            if (_params_helpers.box) parentNative.add(_helpers.box);\n\t            if (_params_helpers.boundingBox) parentNative.add(_helpers.boundingBox);\n\t            if (_params_helpers.edges) parentNative.add(_helpers.edges);\n\t            if (_params_helpers.faceNormals) parentNative.add(_helpers.faceNormals);\n\t            if (_params_helpers.vertexNormals) parentNative.add(_helpers.vertexNormals);\n\t\n\t            resolve(_this3);\n\t\n\t            _native.addEventListener('collide', function () {\n\t              _this3.emit('collide');\n\t            });\n\t\n\t            if (WHS.debug) {\n\t              console.debug('@WHS.Shape: Shape ' + _this3._type + ' was added to world.', [_this3, _parent]);\n\t            }\n\t          });\n\t        });\n\t      } else {\n\t        return new Promise(function (resolve, reject) {\n\t          var _native = _this3.getNative(),\n\t              _params = _this3.getParams(),\n\t              _params_helpers = _params.helpers,\n\t              _parent = _this3.parent;\n\t\n\t          if (!_native) reject();\n\t\n\t          var parentNative = _parent instanceof _World.World ? _parent.getScene() : _parent.getNative();\n\t\n\t          parentNative.add(_native);\n\t          _this3.parent.children.push(_this3);\n\t\n\t          if (_params.softbody) {\n\t            _native.position.set(0, 0, 0);\n\t            _native.rotation.set(0, 0, 0);\n\t          }\n\t\n\t          if (_params_helpers.box) parentNative.add(_helpers.box);\n\t          if (_params_helpers.boundingBox) parentNative.add(_helpers.boundingBox);\n\t          if (_params_helpers.edges) parentNative.add(_helpers.edges);\n\t          if (_params_helpers.faceNormals) parentNative.add(_helpers.faceNormals);\n\t          if (_params_helpers.vertexNormals) parentNative.add(_helpers.vertexNormals);\n\t\n\t          resolve(_this3);\n\t\n\t          _native.addEventListener('collide', function () {\n\t            _this3.emit('collide');\n\t          });\n\t\n\t          if (WHS.debug) {\n\t            console.debug('@WHS.Shape: Shape ' + _this3._type + ' was added to world.', [_this3, _parent]);\n\t          }\n\t        });\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Initialize shape's material object.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initMaterial',\n\t    value: function _initMaterial() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      return (0, _api.loadMaterial)(params);\n\t    }\n\t\n\t    /**\r\n\t     * Clone shape.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new WHS.Shape(this.getParams(), this._type).copy(this);\n\t    }\n\t\n\t    /**\r\n\t     * Copy shape.\r\n\t     *\r\n\t     * @param {WHS.Shape} source - Source object, that will be applied to this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(source) {\n\t      var sourceNative = source.getNative();\n\t\n\t      if (source.getParams().softbody) this.setNative(new sourceNative.constructor(sourceNative.tempGeometry.clone(), sourceNative.material, source.getParams()));else this.setNative(sourceNative.clone(source.getParams()));\n\t\n\t      this.wrap();\n\t\n\t      this.position.copy(source.position);\n\t      this.rotation.copy(source.rotation);\n\t      this.quaternion.copy(source.quaternion);\n\t\n\t      this.getNative().mass = source.getNative().mass;\n\t\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'getParent',\n\t    value: function getParent() {\n\t      return this.parent;\n\t    }\n\t\n\t    /**\r\n\t     * @return {WHS.World} - World object.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'getWorld',\n\t    value: function getWorld() {\n\t      var p = this.parent;\n\t\n\t      while (!(p instanceof _World.World)) {\n\t        if (p) p = p.parent;else return false;\n\t      }\n\t\n\t      return p;\n\t    }\n\t  }, {\n\t    key: 'G_',\n\t    value: function G_() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      if (this.buildGeometry) {\n\t        this.getNative().geometry = this.buildGeometry(this.updateParams({ geometry: params }));\n\t      }\n\t    }\n\t  }, {\n\t    key: 'M_',\n\t    value: function M_() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      this.getNative().material = this._initMaterial(this.updateParams({ material: params }).material);\n\t    }\n\t  }, {\n\t    key: 'proccessSoftbodyGeometry',\n\t    value: function proccessSoftbodyGeometry(geometry) {\n\t      geometry.rotateX(this.__params.rot.x);\n\t      geometry.rotateY(this.__params.rot.x);\n\t      geometry.rotateZ(this.__params.rot.x);\n\t\n\t      geometry.scale(this.__params.scale.x, this.__params.scale.y, this.__params.scale.z);\n\t\n\t      geometry.translate(this.__params.pos.x, this.__params.pos.y, this.__params.pos.z);\n\t    }\n\t\n\t    /* Access private data */\n\t\n\t  }, {\n\t    key: 'setNative',\n\t    value: function setNative(native) {\n\t      this._native = native;\n\t\n\t      this.position = native.position.clone();\n\t      this.quaternion = native.quaternion.clone();\n\t      this.rotation = native.rotation.clone();\n\t    }\n\t  }, {\n\t    key: 'setMaterial',\n\t    value: function setMaterial(material) {\n\t      this._native.material = material;\n\t      return this._native.material;\n\t    }\n\t\n\t    /* Physics */\n\t\n\t  }, {\n\t    key: 'setAngularVelocity',\n\t    value: function setAngularVelocity() {\n\t      var _getNative;\n\t\n\t      return (_getNative = this.getNative()).setAngularVelocity.apply(_getNative, arguments);\n\t    }\n\t  }, {\n\t    key: 'setLinearVelocity',\n\t    value: function setLinearVelocity() {\n\t      var _getNative2;\n\t\n\t      return (_getNative2 = this.getNative()).setLinearVelocity.apply(_getNative2, arguments);\n\t    }\n\t  }, {\n\t    key: 'applyCentralImpulse',\n\t    value: function applyCentralImpulse() {\n\t      var _getNative3;\n\t\n\t      return (_getNative3 = this.getNative()).applyCentralImpulse.apply(_getNative3, arguments);\n\t    }\n\t  }, {\n\t    key: 'applyImpulse',\n\t    value: function applyImpulse() {\n\t      var _getNative4;\n\t\n\t      return (_getNative4 = this.getNative()).applyImpulse.apply(_getNative4, arguments);\n\t    }\n\t  }, {\n\t    key: 'applyTorque',\n\t    value: function applyTorque() {\n\t      var _getNative5;\n\t\n\t      return (_getNative5 = this.getNative()).applyTorque.apply(_getNative5, arguments);\n\t    }\n\t  }, {\n\t    key: 'applyCentralForce',\n\t    value: function applyCentralForce() {\n\t      var _getNative6;\n\t\n\t      return (_getNative6 = this.getNative()).applyCentralForce.apply(_getNative6, arguments);\n\t    }\n\t  }, {\n\t    key: 'applyForce',\n\t    value: function applyForce() {\n\t      var _getNative7;\n\t\n\t      return (_getNative7 = this.getNative()).applyForce.apply(_getNative7, arguments);\n\t    }\n\t  }, {\n\t    key: 'getAngularVelocity',\n\t    value: function getAngularVelocity() {\n\t      var _getNative8;\n\t\n\t      return (_getNative8 = this.getNative()).getAngularVelocity.apply(_getNative8, arguments);\n\t    }\n\t  }, {\n\t    key: 'getLinearVelocity',\n\t    value: function getLinearVelocity() {\n\t      var _getNative9;\n\t\n\t      return (_getNative9 = this.getNative()).getLinearVelocity.apply(_getNative9, arguments);\n\t    }\n\t  }, {\n\t    key: 'setAngularFactor',\n\t    value: function setAngularFactor() {\n\t      var _getNative10;\n\t\n\t      return (_getNative10 = this.getNative()).setAngularFactor.apply(_getNative10, arguments);\n\t    }\n\t  }, {\n\t    key: 'setLinearFactor',\n\t    value: function setLinearFactor() {\n\t      var _getNative11;\n\t\n\t      return (_getNative11 = this.getNative()).setLinearFactor.apply(_getNative11, arguments);\n\t    }\n\t  }, {\n\t    key: 'setDamping',\n\t    value: function setDamping() {\n\t      var _getNative12;\n\t\n\t      return (_getNative12 = this.getNative()).setDamping.apply(_getNative12, arguments);\n\t    }\n\t  }, {\n\t    key: 'setCcdMotionThreshold',\n\t    value: function setCcdMotionThreshold() {\n\t      var _getNative13;\n\t\n\t      return (_getNative13 = this.getNative()).setCcdMotionThreshold.apply(_getNative13, arguments);\n\t    }\n\t  }, {\n\t    key: 'setCcdSweptSphereRadius',\n\t    value: function setCcdSweptSphereRadius() {\n\t      var _getNative14;\n\t\n\t      return (_getNative14 = this.getNative()).setCcdSweptSphereRadius.apply(_getNative14, arguments);\n\t    }\n\t\n\t    /* Three.js */\n\t\n\t  }, {\n\t    key: 'raycast',\n\t    value: function raycast() {\n\t      var _getNative15;\n\t\n\t      return (_getNative15 = this.getNative()).lookAt.apply(_getNative15, arguments);\n\t    }\n\t\n\t    /* API */\n\t\n\t  }, {\n\t    key: 'follow',\n\t    value: function follow(curve) {\n\t      var _this4 = this;\n\t\n\t      var time = arguments.length <= 1 || arguments[1] === undefined ? 1000 : arguments[1];\n\t      var loop = arguments[2];\n\t\n\t      var gEnd = time;\n\t\n\t      var animation = new _Loop.Loop(function (clock) {\n\t        var u = clock.getElapsedTime() * 1000 / gEnd,\n\t            vec1 = curve.getPoint(u % 1),\n\t            vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t        _this4.position.set(vec1.x, vec1.y, vec1.z);\n\t        _this4.getNative().lookAt(vec2);\n\t      });\n\t\n\t      this.getWorld().addLoop(animation);\n\t\n\t      animation.start();\n\t\n\t      if (loop) {\n\t        setInterval(function () {\n\t          animation.stop();\n\t\n\t          animation = new _Loop.Loop(function (clock) {\n\t            var u = clock.getElapsedTime() * 1000 / gEnd,\n\t                vec1 = curve.getPoint(u % 1),\n\t                vec2 = curve.getPoint((u + 0.01) % 1);\n\t\n\t            _this4.position.set(vec1.x, vec1.y, vec1.z);\n\t            _this4.getNative().lookAt(vec2);\n\t          });\n\t\n\t          _this4.getWorld().addLoop(animation);\n\t\n\t          animation.start();\n\t        }, time);\n\t      } else {\n\t        setTimeout(function () {\n\t          animation.stop();\n\t          _this4.getWorld().removeLoop(animation);\n\t        }, time);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'position',\n\t    get: function get() {\n\t      return this.getNative().position;\n\t    },\n\t    set: function set(vector3) {\n\t      var pos = this.getNative().position,\n\t          native = this.getNative();\n\t\n\t      Object.defineProperties(pos, {\n\t        x: {\n\t          get: function get() {\n\t            return this._x;\n\t          },\n\t          set: function set(x) {\n\t            native.__dirtyPosition = true;\n\t            this._x = x;\n\t          }\n\t        },\n\t        y: {\n\t          get: function get() {\n\t            return this._y;\n\t          },\n\t          set: function set(y) {\n\t            native.__dirtyPosition = true;\n\t            this._y = y;\n\t          }\n\t        },\n\t        z: {\n\t          get: function get() {\n\t            return this._z;\n\t          },\n\t          set: function set(z) {\n\t            native.__dirtyPosition = true;\n\t            this._z = z;\n\t          }\n\t        }\n\t      });\n\t\n\t      native.__dirtyPosition = true;\n\t\n\t      return pos.copy(vector3);\n\t    }\n\t  }, {\n\t    key: 'quaternion',\n\t    get: function get() {\n\t      this.__c_rot = true;\n\t      return this.getNative().quaternion;\n\t    },\n\t    set: function set(quaternion) {\n\t      var _this5 = this;\n\t\n\t      var quat = this.getNative().quaternion,\n\t          native = this.getNative();\n\t\n\t      quat.copy(quaternion);\n\t\n\t      quat.onChange(function () {\n\t        if (_this5.__c_rot) {\n\t          if (native.__dirtyRotation === true) {\n\t            _this5.__c_rot = false;\n\t            native.__dirtyRotation = false;\n\t          }\n\t          native.__dirtyRotation = true;\n\t        }\n\t      });\n\t\n\t      return quat;\n\t    }\n\t  }, {\n\t    key: 'rotation',\n\t    get: function get() {\n\t      this.__c_rot = true;\n\t      return this.getNative().rotation;\n\t    },\n\t    set: function set(euler) {\n\t      var _this6 = this;\n\t\n\t      var rot = this.getNative().rotation,\n\t          native = this.getNative();\n\t\n\t      rot.copy(euler);\n\t\n\t      rot.onChange(function () {\n\t        if (_this6.__c_rot) {\n\t          _this6.quaternion.copy(new THREE.Quaternion().setFromEuler(rot));\n\t          native.__dirtyRotation = true;\n\t        }\n\t      });\n\t\n\t      return rot;\n\t    }\n\t  }, {\n\t    key: 'scale',\n\t    get: function get() {\n\t      return this.getNative().scale;\n\t    },\n\t    set: function set(vector3) {\n\t      this.getNative().scale = vector3;\n\t      return this.getNative().scale;\n\t    }\n\t  }, {\n\t    key: 'M_color',\n\t    set: function set(val) {\n\t      this.updateParams({ material: { color: val } });\n\t      this.getNative().material.color = new THREE.Color(val);\n\t    },\n\t    get: function get() {\n\t      return this.getNative().material.color;\n\t    }\n\t  }]);\n\t  return Shape;\n\t}(_Object.WHSObject);\n\t\n\texports.Shape = Shape;\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.World = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _stats = __webpack_require__(109);\n\t\n\tvar _stats2 = _interopRequireDefault(_stats);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _PerspectiveCamera = __webpack_require__(104);\n\t\n\tvar _Camera = __webpack_require__(94);\n\t\n\tvar _Shape = __webpack_require__(107);\n\t\n\tvar _Light = __webpack_require__(106);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar World = function (_WHSObject) {\n\t  (0, _inherits3.default)(World, _WHSObject);\n\t\n\t  /**\r\n\t   * Create a 3D world and define defaults.\r\n\t   *\r\n\t   * @param {object} params - The scene settings object.\r\n\t   * @return {World} A 3D world whs object.\r\n\t   */\n\t\n\t  function World() {\n\t    var _ret;\n\t\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, World);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(World).call(this, {\n\t      stats: false,\n\t      autoresize: false,\n\t      softbody: false,\n\t\n\t      shadowmap: {\n\t        enabled: true,\n\t        type: THREE.PCFSoftShadowMap\n\t      },\n\t\n\t      helpers: {\n\t        grid: false,\n\t        axis: false\n\t      },\n\t\n\t      gravity: {\n\t        x: 0,\n\t        y: 0,\n\t        z: 0\n\t      },\n\t\n\t      camera: {\n\t        aspect: 75,\n\t        near: 1,\n\t        far: 1000,\n\t\n\t        x: 0,\n\t        y: 0,\n\t        z: 0\n\t      },\n\t\n\t      rWidth: 1, // Resolution(width).\n\t      rHeight: 1, // Resolution(height).\n\t\n\t      width: window.innerWidth, // Container(width).\n\t      height: window.innerHeight, // Container(height).\n\t\n\t      physics: {\n\t        fixedTimeStep: 1 / 60\n\t      },\n\t\n\t      fog: {\n\t        type: false,\n\t\n\t        density: 0.00025,\n\t        hex: 0x000000,\n\t        near: 1,\n\t        far: 1000\n\t      },\n\t\n\t      init: {\n\t        scene: true,\n\t        stats: true,\n\t        camera: true,\n\t        helpers: true,\n\t        renderer: true\n\t      },\n\t\n\t      background: {\n\t        color: 0x000000,\n\t        opacity: 1\n\t      },\n\t\n\t      renderer: {},\n\t      container: document.body\n\t    }));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(World.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var initParams = _this.getParams().init;\n\t\n\t    // INIT.\n\t    _this._initDOM();\n\t    if (initParams.scene) _this._initScene();\n\t    if (initParams.scene && initParams.stats) _this._initStats();\n\t\n\t    if (initParams.scene && initParams.camera) _this._initCamera();\n\t    if (initParams.scene && initParams.renderer) _this._initRenderer();\n\t    if (initParams.scene && initParams.helpers) _this._initHelpers();\n\t\n\t    // NOTE: ==================== Autoresize. ======================\n\t    var scope = _this;\n\t\n\t    if (_this.getParams().autoresize) {\n\t      window.addEventListener('resize', function () {\n\t        scope.setSize(window.innerWidth, window.innerHeight);\n\t      });\n\t    }\n\t\n\t    scope.loops = [];\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  /**\r\n\t   * Initialize THREE.js scene object.\r\n\t   */\n\t\n\t\n\t  (0, _createClass3.default)(World, [{\n\t    key: '_initScene',\n\t    value: function _initScene() {\n\t      var _this2 = this;\n\t\n\t      var params = this.getParams(),\n\t          scene = false ? new Physijs.Scene({\n\t        fixedTimeStep: params.physics.fixedTimeStep\n\t      }, {\n\t        stats: params.stats,\n\t        world: this,\n\t        softbody: params.softbody\n\t      }) : new THREE.Scene();\n\t\n\t      if (false) {\n\t        scene.setGravity(new THREE.Vector3(params.gravity.x, params.gravity.y, params.gravity.z));\n\t\n\t        this.simulate = true;\n\t        scene.addEventListener('update', function () {\n\t          if (_this2.simulate) scene.simulate(undefined, 1);\n\t        });\n\t\n\t        scene.simulate();\n\t      } else this.simulate = false;\n\t\n\t      if (params.fog.type === 'regular') scene.fog = new THREE.Fog(params.fog.hex, params.fog.near, params.fog.far);else if (params.fog.type === 'exp' || params.fog.type === 'expodential') scene.fog = new THREE.FogExp2(params.fog.hex, params.fog.density);\n\t\n\t      this.setScene(scene, false);\n\t\n\t      // Array for processing.\n\t      this.children = [];\n\t    }\n\t  }, {\n\t    key: 'addLoop',\n\t    value: function addLoop(loop) {\n\t      this.loops.push(loop); // TODO: Process loops on start\n\t      // like: this.loops.forEach((elem) => elem.start());\n\t    }\n\t  }, {\n\t    key: 'removeLoop',\n\t    value: function removeLoop(loop) {\n\t      this.loops.filter(function (l) {\n\t        return l !== loop;\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Initialize DOM structure for whitestorm.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initDOM',\n\t    value: function _initDOM() {\n\t      var params = this.getParams();\n\t\n\t      params.container.style.margin = 0;\n\t      params.container.style.padding = 0;\n\t      params.container.style.position = 'relative';\n\t      params.container.style.overflow = 'hidden';\n\t\n\t      this._dom = document.createElement('div');\n\t      this._dom.className = 'whs';\n\t\n\t      params.container.appendChild(this._dom);\n\t\n\t      return this._dom;\n\t    }\n\t\n\t    /**\r\n\t     * Inititialize stats plugin.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initStats',\n\t    value: function _initStats() {\n\t      var params = this.getParams();\n\t\n\t      if (params.stats) {\n\t        this._stats = new _stats2.default();\n\t\n\t        if (params.stats === 'fps') this._stats.setMode(0);else if (params.stats === 'ms') this._stats.setMode(1);else if (params.stats === 'mb') this._stats.setMode(1);else {\n\t          this._stats.setMode(0);\n\t          console.warn([this._stats], 'Please, apply stats mode [fps, ms, mb] .');\n\t        }\n\t\n\t        this._stats.domElement.style.position = 'absolute';\n\t        this._stats.domElement.style.left = '0px';\n\t        this._stats.domElement.style.bottom = '0px';\n\t\n\t        this._dom.appendChild(this._stats.domElement);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Create a camera and add it to scene.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initCamera',\n\t    value: function _initCamera() {\n\t      var params = this.getParams();\n\t\n\t      this.setCamera(new _PerspectiveCamera.PerspectiveCamera({\n\t        camera: {\n\t          fov: params.camera.aspect,\n\t          aspect: params.width / params.height,\n\t          near: params.camera.near,\n\t          far: params.camera.far\n\t        },\n\t\n\t        pos: {\n\t          x: params.camera.x,\n\t          y: params.camera.y,\n\t          z: params.camera.z\n\t        }\n\t      }));\n\t\n\t      this.getCamera().addTo(this);\n\t    }\n\t\n\t    /**\r\n\t     * Create a renderer and apply it's options.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initRenderer',\n\t    value: function _initRenderer() {\n\t      this.render = true;\n\t\n\t      // Renderer.\n\t      this.setRenderer(new THREE.WebGLRenderer(this.getParams().renderer));\n\t\n\t      var renderer = this.getRenderer();\n\t      renderer.setClearColor(this.getParams().background.color, this.getParams().background.opacity);\n\t\n\t      // Shadowmap.\n\t      renderer.shadowMap.enabled = this.getParams().shadowmap.enabled;\n\t      renderer.shadowMap.type = this.getParams().shadowmap.type;\n\t      renderer.shadowMap.cascade = true;\n\t\n\t      renderer.setSize(Number(this.getParams().width * this.getParams().rWidth).toFixed(), Number(this.getParams().height * this.getParams().rHeight).toFixed());\n\t\n\t      renderer.render(this.getScene(), this.getCamera().getNative());\n\t\n\t      this._dom.appendChild(renderer.domElement);\n\t\n\t      renderer.domElement.style.width = '100%';\n\t      renderer.domElement.style.height = '100%';\n\t    }\n\t\n\t    /**\r\n\t     * Add helpers to scene.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_initHelpers',\n\t    value: function _initHelpers() {\n\t      var params = this.getParams(),\n\t          scene = this.getScene();\n\t\n\t      if (params.helpers.axis) {\n\t        scene.add(new THREE.AxisHelper(params.helpers.axis.size ? params.helpers.axis.size : 5));\n\t      }\n\t\n\t      if (params.helpers.grid) {\n\t        scene.add(new THREE.GridHelper(params.helpers.grid.size ? params.helpers.grid.size : 10, params.helpers.grid.step ? params.helpers.grid.step : 1, params.helpers.grid.color1, params.helpers.grid.color2));\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Start animation.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'start',\n\t    value: function start() {\n\t      var clock = new THREE.Clock(),\n\t          _scope = this,\n\t          scene = _scope.getScene(),\n\t          cameraNative = _scope.getCamera().getNative(),\n\t          renderer = _scope.getRenderer();\n\t\n\t      window.requestAnimFrame = function () {\n\t        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {\n\t          window.setTimeout(callback, 1000 / 60);\n\t        };\n\t      }();\n\t\n\t      function reDraw(time) {\n\t        window.requestAnimFrame(reDraw);\n\t\n\t        // Init stats.\n\t        if (_scope._stats) _scope._stats.begin();\n\t\n\t        _scope._process(clock.getDelta());\n\t        if (_scope.controls) _scope._updateControls();\n\t\n\t        // Effects rendering.\n\t        if (_scope._composer && _scope.render) {\n\t          _scope._composer.reset();\n\t          _scope._composer.render(scene, cameraNative);\n\t          _scope._composer.pass(_scope._composer.stack);\n\t          _scope._composer.toScreen();\n\t        } else if (_scope.render) renderer.render(scene, cameraNative);\n\t\n\t        _scope._execLoops();\n\t\n\t        // End helper.\n\t        if (_scope._stats) _scope._stats.end();\n\t      }\n\t\n\t      this._update = reDraw;\n\t\n\t      _scope._update();\n\t    }\n\t\n\t    /**\r\n\t     * Execute all loops with a specific time.\r\n\t     *\r\n\t     * @params {number} time - The time value that will be passed to loops.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_execLoops',\n\t    value: function _execLoops() {\n\t      for (var i = 0; i < this.loops.length; i++) {\n\t        var e = this.loops[i];\n\t        if (e.enabled) e.execute(e.clock);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * Update controls time values.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_updateControls',\n\t    value: function _updateControls() {\n\t      this.controls.update(Date.now() - this.time);\n\t      this.time = Date.now();\n\t    }\n\t\n\t    /**\r\n\t     * Update morphs animations.\r\n\t     *\r\n\t     * @params {THREE.Clock} clock - The clock object, which.\r\n\t     */\n\t\n\t  }, {\n\t    key: '_process',\n\t    value: function _process(delta) {\n\t      for (var i = 0; i < this.children.length; i++) {\n\t        if (this.children[i]._type === 'morph') this.children[i].getNative().mixer.update(delta);\n\t      }\n\t    }\n\t\n\t    /**\r\n\t     * This functon will scene properties when it's called.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setSize',\n\t    value: function setSize() {\n\t      var width = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\t      var height = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];\n\t\n\t      this.getCamera().getNative().aspect = width / height;\n\t      this.getCamera().getNative().updateProjectionMatrix();\n\t\n\t      this.getRenderer().setSize(Number(width * this.getParams().rWidth).toFixed(), Number(height * this.getParams().rHeight).toFixed());\n\t    }\n\t  }, {\n\t    key: 'setScene',\n\t    value: function setScene(scene) {\n\t      var _this3 = this;\n\t\n\t      var import_three = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\t\n\t      this.scene = scene;\n\t\n\t      if (import_three) {\n\t        (function () {\n\t          _this3.children = [];\n\t\n\t          var moveChildren = function moveChildren(object) {\n\t            for (var i = 0, max = object.children.length; i < max; i++) {\n\t              var obj3D = object.children[i];\n\t              var WHSobj = void 0;\n\t\n\t              if (obj3D instanceof THREE.Light) WHSobj = new _Light.Light(obj3D);else WHSobj = new _Shape.Shape(obj3D);\n\t\n\t              WHSobj.addTo(_this3);\n\t\n\t              if (obj3D.children.length) moveChildren(obj3D, WHSobj);\n\t            }\n\t          };\n\t\n\t          moveChildren(scene, _this3);\n\t        })();\n\t      }\n\t\n\t      return this.scene;\n\t    }\n\t  }, {\n\t    key: 'getScene',\n\t    value: function getScene() {\n\t      return this.scene;\n\t    }\n\t  }, {\n\t    key: 'setRenderer',\n\t    value: function setRenderer(renderer) {\n\t      this.renderer = renderer;\n\t      return this.renderer;\n\t    }\n\t  }, {\n\t    key: 'getRenderer',\n\t    value: function getRenderer() {\n\t      return this.renderer;\n\t    }\n\t  }, {\n\t    key: 'setControls',\n\t    value: function setControls(controls) {\n\t      var recieved = controls(this);\n\t\n\t      this.controls = recieved instanceof Array ? recieved[0] : recieved;\n\t\n\t      if (recieved instanceof Array && typeof recieved[1] === 'function') recieved[1](this);\n\t\n\t      return this.controls;\n\t    }\n\t\n\t    /**\r\n\t     * Set a camera for rendering world.\r\n\t     *\r\n\t     * @params {WHS.Camera} camera - The camera to be rendered.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'setCamera',\n\t    value: function setCamera(camera) {\n\t      if (camera instanceof _Camera.Camera) this.camera = camera;else console.error('@WHS.World: camera in not an instance of WHS.Camera.');\n\t    }\n\t  }, {\n\t    key: 'getCamera',\n\t    value: function getCamera() {\n\t      return this.camera;\n\t    }\n\t\n\t    /**\r\n\t     * Remove this shape from world.\r\n\t     *\r\n\t     * @return {WHS.Shape} - this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove(source) {\n\t      this.getScene().remove(source.getNative());\n\t\n\t      this.children.splice(this.children.indexOf(source), 1);\n\t      source.parent = null;\n\t\n\t      source.emit('remove');\n\t\n\t      if (WHS.debug) {\n\t        console.debug('@WHS.Shape: Shape ' + source._type + ' was removed from world', [source]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t  return World;\n\t}(_Object.WHSObject);\n\t\n\texports.World = World;\n\n/***/ },\n/* 109 */\n/***/ function(module, exports) {\n\n\t// stats.js - http://github.com/mrdoob/stats.js\n\tvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\n\tif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\n\tStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\n\tv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Loop = __webpack_require__(95);\n\t\n\tObject.keys(_Loop).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Loop[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _firstPersonControls = __webpack_require__(112);\n\t\n\tObject.keys(_firstPersonControls).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _firstPersonControls[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _orbitControls = __webpack_require__(113);\n\t\n\tObject.keys(_orbitControls).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _orbitControls[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tObject.keys(_api).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _api[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Curve = __webpack_require__(115);\n\t\n\tObject.keys(_Curve).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Curve[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Points = __webpack_require__(116);\n\t\n\tObject.keys(_Points).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Points[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Group = __webpack_require__(117);\n\t\n\tObject.keys(_Group).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Group[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Skybox = __webpack_require__(118);\n\t\n\tObject.keys(_Skybox).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Skybox[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.firstPersonControls = firstPersonControls;\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar PI_2 = Math.PI / 2;\n\t\n\tfunction firstPersonControls(object) {\n\t  var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t  return function (world) {\n\t    var target = (0, _api.extend)(params, {\n\t      block: document.getElementById('blocker'),\n\t      speed: 1,\n\t      ypos: 1\n\t    });\n\t\n\t    var controls = new function (camera, mesh, params) {\n\t      var velocityFactor = 1;\n\t      var runVelocity = 0.25;\n\t\n\t      mesh.setAngularFactor({ x: 0, y: 0, z: 0 });\n\t\n\t      /* Init */\n\t      var scope = this;\n\t      var player = mesh,\n\t          pitchObject = new THREE.Object3D();\n\t\n\t      pitchObject.add(camera.getNative());\n\t\n\t      var yawObject = new THREE.Object3D();\n\t\n\t      yawObject.position.y = params.ypos; // eyes are 2 meters above the ground\n\t      yawObject.add(pitchObject);\n\t\n\t      var quat = new THREE.Quaternion();\n\t\n\t      var canJump = false,\n\t\n\t      // Moves.\n\t      moveForward = false,\n\t          moveBackward = false,\n\t          moveLeft = false,\n\t          moveRight = false;\n\t\n\t      player.addEventListener('collision', function (otherObject, v, r, contactNormal) {\n\t        if (contactNormal.y < 0.5) // Use a \"good\" threshold value between 0 and 1 here!\n\t          canJump = true;\n\t      });\n\t\n\t      function onMouseMove(event) {\n\t        if (scope.enabled === false) return;\n\t\n\t        var movementX = typeof event.movementX === 'number' ? event.movementX : typeof event.mozMovementX === 'number' ? event.mozMovementX : typeof event.getMovementX === 'function' ? event.getMovementX() : 0;\n\t        var movementY = typeof event.movementY === 'number' ? event.movementY : typeof event.mozMovementY === 'number' ? event.mozMovementY : typeof event.getMovementY === 'function' ? event.getMovementY() : 0;\n\t\n\t        yawObject.rotation.y -= movementX * 0.002;\n\t        pitchObject.rotation.x -= movementY * 0.002;\n\t\n\t        pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));\n\t      }\n\t\n\t      function onKeyDown(event) {\n\t        switch (event.keyCode) {\n\t          case 38: // up\n\t          case 87:\n\t            // w\n\t            moveForward = true;\n\t            break;\n\t\n\t          case 37: // left\n\t          case 65:\n\t            // a\n\t            moveLeft = true;\n\t            break;\n\t\n\t          case 40: // down\n\t          case 83:\n\t            // s\n\t            moveBackward = true;\n\t            break;\n\t\n\t          case 39: // right\n\t          case 68:\n\t            // d\n\t            moveRight = true;\n\t            break;\n\t\n\t          case 32:\n\t            // space\n\t            if (canJump === true) {\n\t              player.applyCentralImpulse({ x: 0, y: 300, z: 0 });\n\t            }\n\t            canJump = false;\n\t            break;\n\t\n\t          case 16:\n\t            // shift\n\t            runVelocity = 0.5;\n\t            break;\n\t\n\t          default:\n\t        }\n\t      }\n\t\n\t      function onKeyUp(event) {\n\t        switch (event.keyCode) {\n\t          case 38: // up\n\t          case 87:\n\t            // w\n\t            moveForward = false;\n\t            break;\n\t\n\t          case 37: // left\n\t          case 65:\n\t            // a\n\t            moveLeft = false;\n\t            break;\n\t\n\t          case 40: // down\n\t          case 83:\n\t            // a\n\t            moveBackward = false;\n\t            break;\n\t\n\t          case 39: // right\n\t          case 68:\n\t            // d\n\t            moveRight = false;\n\t            break;\n\t\n\t          case 16:\n\t            // shift\n\t            runVelocity = 0.25;\n\t            break;\n\t\n\t          default:\n\t        }\n\t      }\n\t\n\t      document.body.addEventListener('mousemove', onMouseMove, false);\n\t      document.body.addEventListener('keydown', onKeyDown, false);\n\t      document.body.addEventListener('keyup', onKeyUp, false);\n\t\n\t      this.enabled = false;\n\t\n\t      this.getObject = function () {\n\t        return yawObject;\n\t      };\n\t\n\t      this.getDirection = function (targetVec) {\n\t        targetVec.set(0, 0, -1);\n\t        quat.multiplyVector3(targetVec);\n\t      };\n\t\n\t      // Moves the camera to the Cannon.js object position\n\t      // and adds velocity to the object if the run key is down.\n\t      var inputVelocity = new THREE.Vector3(),\n\t          euler = new THREE.Euler();\n\t\n\t      this.update = function (delta) {\n\t        if (scope.enabled === false) return;\n\t\n\t        delta = delta || 0.5;\n\t        delta = Math.min(delta, 0.5);\n\t\n\t        inputVelocity.set(0, 0, 0);\n\t\n\t        var speed = velocityFactor * delta * params.speed * runVelocity;\n\t\n\t        if (moveForward) inputVelocity.z = -speed;\n\t        if (moveBackward) inputVelocity.z = speed;\n\t        if (moveLeft) inputVelocity.x = -speed;\n\t        if (moveRight) inputVelocity.x = speed;\n\t\n\t        // Convert velocity to world coordinates\n\t        euler.x = pitchObject.rotation.x;\n\t        euler.y = yawObject.rotation.y;\n\t        euler.order = 'XYZ';\n\t\n\t        quat.setFromEuler(euler);\n\t\n\t        inputVelocity.applyQuaternion(quat);\n\t\n\t        player.applyCentralImpulse({ x: inputVelocity.x * 10, y: 0, z: inputVelocity.z * 10 });\n\t        player.setAngularVelocity({ x: inputVelocity.z * 10, y: 0, z: -inputVelocity.x * 10 });\n\t        player.setAngularFactor({ x: 0, y: 0, z: 0 });\n\t\n\t        yawObject.position.copy(player.position);\n\t      };\n\t    }(world.getCamera(), object.getNative(), target);\n\t\n\t    if ('pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document) {\n\t      (function () {\n\t        var element = document.body;\n\t\n\t        world.pointerlockchange = function () {\n\t          if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {\n\t            controls.enabled = true;\n\t            target.block.style.display = 'none';\n\t          } else {\n\t            controls.enabled = false;\n\t            target.block.style.display = 'block';\n\t          }\n\t        };\n\t\n\t        document.addEventListener('pointerlockchange', world.pointerlockchange, false);\n\t        document.addEventListener('mozpointerlockchange', world.pointerlockchange, false);\n\t        document.addEventListener('webkitpointerlockchange', world.pointerlockchange, false);\n\t\n\t        world.pointerlockerror = function () {\n\t          console.warn('Pointer lock error.');\n\t        };\n\t\n\t        document.addEventListener('pointerlockerror', world.pointerlockerror, false);\n\t        document.addEventListener('mozpointerlockerror', world.pointerlockerror, false);\n\t        document.addEventListener('webkitpointerlockerror', world.pointerlockerror, false);\n\t\n\t        target.block.addEventListener('click', function () {\n\t          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;\n\t\n\t          element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;\n\t\n\t          if (/Firefox/i.test(navigator.userAgent)) {\n\t            (function () {\n\t              var fullscreenchange = function fullscreenchange() {\n\t                if (document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element) {\n\t                  document.removeEventListener('fullscreenchange', fullscreenchange);\n\t                  document.removeEventListener('mozfullscreenchange', fullscreenchange);\n\t\n\t                  element.requestPointerLock();\n\t                }\n\t              };\n\t\n\t              document.addEventListener('fullscreenchange', fullscreenchange, false);\n\t              document.addEventListener('mozfullscreenchange', fullscreenchange, false);\n\t\n\t              element.requestFullscreen();\n\t            })();\n\t          } else element.requestPointerLock();\n\t        });\n\t      })();\n\t    } else console.warn('Your browser does not support the PointerLock WHS.API.');\n\t\n\t    function callback(world) {\n\t      world.getScene().add(world.controls.getObject());\n\t    }\n\t\n\t    return [controls, callback];\n\t  };\n\t}\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.orbitControls = orbitControls;\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _threeOrbitControls = __webpack_require__(114);\n\t\n\tvar _threeOrbitControls2 = _interopRequireDefault(_threeOrbitControls);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar ThreeOrbitControls = (0, _threeOrbitControls2.default)(THREE);\n\t\n\tfunction orbitControls(object) {\n\t  return function (world) {\n\t    var controls = new ThreeOrbitControls(world.getCamera().getNative(), world.getRenderer().domElement);\n\t\n\t    if (object && object.__whsobject) {\n\t      var target = object ? object.mesh.position : new THREE.Vector3(0, 0, 0);\n\t\n\t      controls.target = target;\n\t    } else if (object instanceof THREE.Vector3) controls.target.copy(object);\n\t\n\t    return controls;\n\t  };\n\t}\n\n/***/ },\n/* 114 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(THREE) {\n\t\tvar MOUSE = THREE.MOUSE\n\t\tif (!MOUSE)\n\t\t\tMOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\t\n\t\t/**\n\t\t * @author qiao / https://github.com/qiao\n\t\t * @author mrdoob / http://mrdoob.com\n\t\t * @author alteredq / http://alteredqualia.com/\n\t\t * @author WestLangley / http://github.com/WestLangley\n\t\t * @author erich666 / http://erichaines.com\n\t\t */\n\t\t/*global THREE, console */\n\t\n\t\tfunction OrbitConstraint ( object ) {\n\t\n\t\t\tthis.object = object;\n\t\n\t\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\t\t// and where it pans with respect to.\n\t\t\tthis.target = new THREE.Vector3();\n\t\n\t\t\t// Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\t\t\tthis.minDistance = 0;\n\t\t\tthis.maxDistance = Infinity;\n\t\n\t\t\t// Limits to how far you can zoom in and out ( OrthographicCamera only )\n\t\t\tthis.minZoom = 0;\n\t\t\tthis.maxZoom = Infinity;\n\t\n\t\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t\t// Range is 0 to Math.PI radians.\n\t\t\tthis.minPolarAngle = 0; // radians\n\t\t\tthis.maxPolarAngle = Math.PI; // radians\n\t\n\t\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\t\tthis.maxAzimuthAngle = Infinity; // radians\n\t\n\t\t\t// Set to true to enable damping (inertia)\n\t\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\t\tthis.enableDamping = false;\n\t\t\tthis.dampingFactor = 0.25;\n\t\n\t\t\t////////////\n\t\t\t// internals\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar EPS = 0.000001;\n\t\n\t\t\t// Current position in spherical coordinate system.\n\t\t\tvar theta;\n\t\t\tvar phi;\n\t\n\t\t\t// Pending changes\n\t\t\tvar phiDelta = 0;\n\t\t\tvar thetaDelta = 0;\n\t\t\tvar scale = 1;\n\t\t\tvar panOffset = new THREE.Vector3();\n\t\t\tvar zoomChanged = false;\n\t\n\t\t\t// API\n\t\n\t\t\tthis.getPolarAngle = function () {\n\t\n\t\t\t\treturn phi;\n\t\n\t\t\t};\n\t\n\t\t\tthis.getAzimuthalAngle = function () {\n\t\n\t\t\t\treturn theta;\n\t\n\t\t\t};\n\t\n\t\t\tthis.rotateLeft = function ( angle ) {\n\t\n\t\t\t\tthetaDelta -= angle;\n\t\n\t\t\t};\n\t\n\t\t\tthis.rotateUp = function ( angle ) {\n\t\n\t\t\t\tphiDelta -= angle;\n\t\n\t\t\t};\n\t\n\t\t\t// pass in distance in world space to move left\n\t\t\tthis.panLeft = function() {\n\t\n\t\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\t\treturn function panLeft ( distance ) {\n\t\n\t\t\t\t\tvar te = this.object.matrix.elements;\n\t\n\t\t\t\t\t// get X column of matrix\n\t\t\t\t\tv.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\t\t\t\tv.multiplyScalar( - distance );\n\t\n\t\t\t\t\tpanOffset.add( v );\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\t// pass in distance in world space to move up\n\t\t\tthis.panUp = function() {\n\t\n\t\t\t\tvar v = new THREE.Vector3();\n\t\n\t\t\t\treturn function panUp ( distance ) {\n\t\n\t\t\t\t\tvar te = this.object.matrix.elements;\n\t\n\t\t\t\t\t// get Y column of matrix\n\t\t\t\t\tv.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\t\t\t\tv.multiplyScalar( distance );\n\t\n\t\t\t\t\tpanOffset.add( v );\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t\t// pass in x,y of change desired in pixel space,\n\t\t\t// right and down are positive\n\t\t\tthis.pan = function ( deltaX, deltaY, screenWidth, screenHeight ) {\n\t\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\t\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\t\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tscope.panLeft( 2 * deltaX * targetDistance / screenHeight );\n\t\t\t\t\tscope.panUp( 2 * deltaY * targetDistance / screenHeight );\n\t\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\t// orthographic\n\t\t\t\t\tscope.panLeft( deltaX * ( scope.object.right - scope.object.left ) / screenWidth );\n\t\t\t\t\tscope.panUp( deltaY * ( scope.object.top - scope.object.bottom ) / screenHeight );\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// camera neither orthographic or perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.dollyIn = function ( dollyScale ) {\n\t\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tscale /= dollyScale;\n\t\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );\n\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.dollyOut = function ( dollyScale ) {\n\t\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\t\n\t\t\t\t\tscale *= dollyScale;\n\t\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\t\n\t\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );\n\t\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\t\tzoomChanged = true;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.update = function() {\n\t\n\t\t\t\tvar offset = new THREE.Vector3();\n\t\n\t\t\t\t// so camera.up is the orbit axis\n\t\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\t\tvar quatInverse = quat.clone().inverse();\n\t\n\t\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\t\n\t\t\t\treturn function () {\n\t\n\t\t\t\t\tvar position = this.object.position;\n\t\n\t\t\t\t\toffset.copy( position ).sub( this.target );\n\t\n\t\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\t\toffset.applyQuaternion( quat );\n\t\n\t\t\t\t\t// angle from z-axis around y-axis\n\t\n\t\t\t\t\ttheta = Math.atan2( offset.x, offset.z );\n\t\n\t\t\t\t\t// angle from y-axis\n\t\n\t\t\t\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\t\n\t\t\t\t\ttheta += thetaDelta;\n\t\t\t\t\tphi += phiDelta;\n\t\n\t\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\t\n\t\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\t\n\t\t\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\t\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\t\n\t\t\t\t\tvar radius = offset.length() * scale;\n\t\n\t\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\t\n\t\t\t\t\t// move target to panned location\n\t\t\t\t\tthis.target.add( panOffset );\n\t\n\t\t\t\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\t\t\t\toffset.y = radius * Math.cos( phi );\n\t\t\t\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\t\n\t\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\t\toffset.applyQuaternion( quatInverse );\n\t\n\t\t\t\t\tposition.copy( this.target ).add( offset );\n\t\n\t\t\t\t\tthis.object.lookAt( this.target );\n\t\n\t\t\t\t\tif ( this.enableDamping === true ) {\n\t\n\t\t\t\t\t\tthetaDelta *= ( 1 - this.dampingFactor );\n\t\t\t\t\t\tphiDelta *= ( 1 - this.dampingFactor );\n\t\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tthetaDelta = 0;\n\t\t\t\t\t\tphiDelta = 0;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tscale = 1;\n\t\t\t\t\tpanOffset.set( 0, 0, 0 );\n\t\n\t\t\t\t\t// update condition is:\n\t\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\t\n\t\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\t\t lastPosition.distanceToSquared( this.object.position ) > EPS ||\n\t\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( this.object.quaternion ) ) > EPS ) {\n\t\n\t\t\t\t\t\tlastPosition.copy( this.object.position );\n\t\t\t\t\t\tlastQuaternion.copy( this.object.quaternion );\n\t\t\t\t\t\tzoomChanged = false;\n\t\n\t\t\t\t\t\treturn true;\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn false;\n\t\n\t\t\t\t};\n\t\n\t\t\t}();\n\t\n\t\t};\n\t\n\t\n\t\t// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n\t\t// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n\t\t// supported.\n\t\t//\n\t\t//    Orbit - left mouse / touch: one finger move\n\t\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n\t\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\t\n\t\tfunction OrbitControls ( object, domElement ) {\n\t\n\t\t\tvar constraint = new OrbitConstraint( object );\n\t\n\t\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\t\n\t\t\t// API\n\t\n\t\t\tObject.defineProperty( this, 'constraint', {\n\t\n\t\t\t\tget: function() {\n\t\n\t\t\t\t\treturn constraint;\n\t\n\t\t\t\t}\n\t\n\t\t\t} );\n\t\n\t\t\tthis.getPolarAngle = function () {\n\t\n\t\t\t\treturn constraint.getPolarAngle();\n\t\n\t\t\t};\n\t\n\t\t\tthis.getAzimuthalAngle = function () {\n\t\n\t\t\t\treturn constraint.getAzimuthalAngle();\n\t\n\t\t\t};\n\t\n\t\t\t// Set to false to disable this control\n\t\t\tthis.enabled = true;\n\t\n\t\t\t// center is old, deprecated; use \"target\" instead\n\t\t\tthis.center = this.target;\n\t\n\t\t\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t\t\t// backwards compatibility.\n\t\t\t// Set to false to disable zooming\n\t\t\tthis.enableZoom = true;\n\t\t\tthis.zoomSpeed = 1.0;\n\t\n\t\t\t// Set to false to disable rotating\n\t\t\tthis.enableRotate = true;\n\t\t\tthis.rotateSpeed = 1.0;\n\t\n\t\t\t// Set to false to disable panning\n\t\t\tthis.enablePan = true;\n\t\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\t\n\t\t\t// Set to true to automatically rotate around the target\n\t\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\t\tthis.autoRotate = false;\n\t\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\t\n\t\t\t// Set to false to disable use of the keys\n\t\t\tthis.enableKeys = true;\n\t\n\t\t\t// The four arrow keys\n\t\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\t\n\t\t\t// Mouse buttons\n\t\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\t\n\t\t\t////////////\n\t\t\t// internals\n\t\n\t\t\tvar scope = this;\n\t\n\t\t\tvar rotateStart = new THREE.Vector2();\n\t\t\tvar rotateEnd = new THREE.Vector2();\n\t\t\tvar rotateDelta = new THREE.Vector2();\n\t\n\t\t\tvar panStart = new THREE.Vector2();\n\t\t\tvar panEnd = new THREE.Vector2();\n\t\t\tvar panDelta = new THREE.Vector2();\n\t\n\t\t\tvar dollyStart = new THREE.Vector2();\n\t\t\tvar dollyEnd = new THREE.Vector2();\n\t\t\tvar dollyDelta = new THREE.Vector2();\n\t\n\t\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\t\n\t\t\tvar state = STATE.NONE;\n\t\n\t\t\t// for reset\n\t\n\t\t\tthis.target0 = this.target.clone();\n\t\t\tthis.position0 = this.object.position.clone();\n\t\t\tthis.zoom0 = this.object.zoom;\n\t\n\t\t\t// events\n\t\n\t\t\tvar changeEvent = { type: 'change' };\n\t\t\tvar startEvent = { type: 'start' };\n\t\t\tvar endEvent = { type: 'end' };\n\t\n\t\t\t// pass in x,y of change desired in pixel space,\n\t\t\t// right and down are positive\n\t\t\tfunction pan( deltaX, deltaY ) {\n\t\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\tconstraint.pan( deltaX, deltaY, element.clientWidth, element.clientHeight );\n\t\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\n\t\t\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\t\n\t\t\t\t\tconstraint.rotateLeft( getAutoRotationAngle() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( constraint.update() === true ) {\n\t\n\t\t\t\t\tthis.dispatchEvent( changeEvent );\n\t\n\t\t\t\t}\n\t\n\t\t\t};\n\t\n\t\t\tthis.reset = function () {\n\t\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t\tthis.target.copy( this.target0 );\n\t\t\t\tthis.object.position.copy( this.position0 );\n\t\t\t\tthis.object.zoom = this.zoom0;\n\t\n\t\t\t\tthis.object.updateProjectionMatrix();\n\t\t\t\tthis.dispatchEvent( changeEvent );\n\t\n\t\t\t\tthis.update();\n\t\n\t\t\t};\n\t\n\t\t\tfunction getAutoRotationAngle() {\n\t\n\t\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t\n\t\t\t}\n\t\n\t\t\tfunction getZoomScale() {\n\t\n\t\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseDown( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\t\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\tstate = STATE.ROTATE;\n\t\n\t\t\t\t\trotateStart.set( event.clientX, event.clientY );\n\t\n\t\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\t\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\tstate = STATE.DOLLY;\n\t\n\t\t\t\t\tdollyStart.set( event.clientX, event.clientY );\n\t\n\t\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\t\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\tstate = STATE.PAN;\n\t\n\t\t\t\t\tpanStart.set( event.clientX, event.clientY );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( state !== STATE.NONE ) {\n\t\n\t\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\t\t\tscope.dispatchEvent( startEvent );\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseMove( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\tif ( state === STATE.ROTATE ) {\n\t\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\n\t\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t\t} else if ( state === STATE.DOLLY ) {\n\t\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\t\n\t\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\t\n\t\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\t\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t\t} else if ( state === STATE.PAN ) {\n\t\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\t\tpan( panDelta.x, panDelta.y );\n\t\n\t\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( state !== STATE.NONE ) scope.update();\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseUp( /* event */ ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t\tfunction onMouseWheel( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\n\t\t\t\tvar delta = 0;\n\t\n\t\t\t\tif ( event.wheelDelta !== undefined ) {\n\t\n\t\t\t\t\t// WebKit / Opera / Explorer 9\n\t\n\t\t\t\t\tdelta = event.wheelDelta;\n\t\n\t\t\t\t} else if ( event.detail !== undefined ) {\n\t\n\t\t\t\t\t// Firefox\n\t\n\t\t\t\t\tdelta = - event.detail;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( delta > 0 ) {\n\t\n\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\t\n\t\t\t\t} else if ( delta < 0 ) {\n\t\n\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\t\n\t\t\t\t}\n\t\n\t\t\t\tscope.update();\n\t\t\t\tscope.dispatchEvent( startEvent );\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\n\t\t\t}\n\t\n\t\t\tfunction onKeyDown( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\t\n\t\t\t\tswitch ( event.keyCode ) {\n\t\n\t\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction touchstart( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\t\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\t\n\t\t\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\t\n\t\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\t\n\t\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\n\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\t\n\t\t\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t\t}\n\t\n\t\t\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\t\n\t\t\t}\n\t\n\t\t\tfunction touchmove( event ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\t\n\t\t\t\tswitch ( event.touches.length ) {\n\t\n\t\t\t\t\tcase 1: // one-fingered touch: rotate\n\t\n\t\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\t\n\t\t\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\t\n\t\t\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\t\n\t\t\t\t\t\trotateStart.copy( rotateEnd );\n\t\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 2: // two-fingered touch: dolly\n\t\n\t\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\t\n\t\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\n\t\t\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\t\n\t\t\t\t\t\tif ( dollyDelta.y > 0 ) {\n\t\n\t\t\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\t\n\t\t\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\t\n\t\t\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\t\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tdollyStart.copy( dollyEnd );\n\t\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase 3: // three-fingered touch: pan\n\t\n\t\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\t\n\t\t\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\t\n\t\t\t\t\t\tpan( panDelta.x, panDelta.y );\n\t\n\t\t\t\t\t\tpanStart.copy( panEnd );\n\t\n\t\t\t\t\t\tscope.update();\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tdefault:\n\t\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t\tfunction touchend( /* event */ ) {\n\t\n\t\t\t\tif ( scope.enabled === false ) return;\n\t\n\t\t\t\tscope.dispatchEvent( endEvent );\n\t\t\t\tstate = STATE.NONE;\n\t\n\t\t\t}\n\t\n\t\t\tfunction contextmenu( event ) {\n\t\n\t\t\t\tevent.preventDefault();\n\t\n\t\t\t}\n\t\n\t\t\tthis.dispose = function() {\n\t\n\t\t\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\t\t\tthis.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\t\tthis.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );\n\t\t\t\tthis.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\t\n\t\t\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\n\t\t\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\n\t\t\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\n\t\n\t\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\n\t\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\t\n\t\t\t}\n\t\n\t\t\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\t\n\t\t\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\t\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\t\t\tthis.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\t\n\t\t\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\t\t\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\t\t\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\t\n\t\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\t\n\t\t\t// force an update at start\n\t\t\tthis.update();\n\t\n\t\t};\n\t\n\t\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\t\tOrbitControls.prototype.constructor = OrbitControls;\n\t\n\t\tObject.defineProperties( OrbitControls.prototype, {\n\t\n\t\t\tobject: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.object;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\ttarget: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.target;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: target is now immutable. Use target.set() instead.' );\n\t\t\t\t\tthis.constraint.target.copy( value );\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tminDistance : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.minDistance;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.minDistance = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmaxDistance : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.maxDistance;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.maxDistance = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tminZoom : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.minZoom;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.minZoom = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmaxZoom : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.maxZoom;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.maxZoom = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tminPolarAngle : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.minPolarAngle;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.minPolarAngle = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmaxPolarAngle : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.maxPolarAngle;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.maxPolarAngle = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tminAzimuthAngle : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.minAzimuthAngle;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.minAzimuthAngle = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tmaxAzimuthAngle : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.maxAzimuthAngle;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.maxAzimuthAngle = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tenableDamping : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.enableDamping;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.enableDamping = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdampingFactor : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\treturn this.constraint.dampingFactor;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tthis.constraint.dampingFactor = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\t// backward compatibility\n\t\n\t\t\tnoZoom: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\t\treturn ! this.enableZoom;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\t\tthis.enableZoom = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoRotate: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\t\treturn ! this.enableRotate;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\t\tthis.enableRotate = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoPan: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\t\treturn ! this.enablePan;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\t\tthis.enablePan = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tnoKeys: {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\t\treturn ! this.enableKeys;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\t\tthis.enableKeys = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tstaticMoving : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\t\treturn ! this.constraint.enableDamping;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\t\tthis.constraint.enableDamping = ! value;\n\t\n\t\t\t\t}\n\t\n\t\t\t},\n\t\n\t\t\tdynamicDampingFactor : {\n\t\n\t\t\t\tget: function () {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\t\treturn this.constraint.dampingFactor;\n\t\n\t\t\t\t},\n\t\n\t\t\t\tset: function ( value ) {\n\t\n\t\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\t\tthis.constraint.dampingFactor = value;\n\t\n\t\t\t\t}\n\t\n\t\t\t}\n\t\n\t\t} );\n\t\n\t\treturn OrbitControls;\n\t}\n\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Curve = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Curve = function (_WHSObject) {\n\t  (0, _inherits3.default)(Curve, _WHSObject);\n\t\n\t  /**\r\n\t   * Create curve.\r\n\t   *\r\n\t   * Todo\r\n\t   */\n\t\n\t  function Curve(params) {\n\t    var _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, Curve);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Curve).call(this, {\n\t      curve: false,\n\t      points: 50\n\t    }));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Curve.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var geometry = new THREE.Geometry();\n\t    geometry.vertices = params.curve.getPoints(params.points);\n\t\n\t    var curve = new THREE.Line(geometry, (0, _api.loadMaterial)(params.material)._material);\n\t\n\t    _this.setNative(curve);\n\t\n\t    var scope = Object.assign(_this, {\n\t      _type: 'curve'\n\t    });\n\t\n\t    scope.setNative(param.curve);\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  /**\r\n\t   * Add curve to scene.\r\n\t   */\n\t\n\t\n\t  (0, _createClass3.default)(Curve, [{\n\t    key: 'addTo',\n\t    value: function addTo(parent) {\n\t      var _scope = this;\n\t      _scope.parent = parent;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _scope.parent.getScene().add(_scope.getNative());\n\t          _scope.parent.children.push(_scope);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        } finally {\n\t          if (defaults.debug) {\n\t            console.debug('@WHS.Curve: Curve ' + _scope._type + ' was added to world.', [_scope, _scope.parent]);\n\t          }\n\t\n\t          resolve(_scope);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Clone curve.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Curve(this.__params).copy(this);\n\t    }\n\t\n\t    /**\r\n\t     * Copy curve.\r\n\t     *\r\n\t     * @param {WHS.Curve} source - Source object, that will be applied to this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(source) {\n\t      this.setNative(source.getNative().clone());\n\t\n\t      this._type = source._type;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Remove this curve from world.\r\n\t     *\r\n\t     * @return {WHS.Curve} - this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove() {\n\t      this.parent.getScene().remove(this.getNative());\n\t\n\t      this.parent.children.splice(this.parent.children.indexOf(this), 1);\n\t      this.parent = null;\n\t\n\t      this.emit('remove');\n\t\n\t      if (defaults.debug) {\n\t        console.debug('@WHS.Curve: Curve ' + this._type + ' was removed from world', [_scope]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t  return Curve;\n\t}(_Object.WHSObject);\n\t\n\texports.Curve = Curve;\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Points = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tvar _defaults = __webpack_require__(96);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Points = function (_WHSObject) {\n\t  (0, _inherits3.default)(Points, _WHSObject);\n\t\n\t  /**\r\n\t   * Create points.\r\n\t   *\r\n\t   * Todo\r\n\t   */\n\t\n\t  function Points(params) {\n\t    var _ret;\n\t\n\t    (0, _classCallCheck3.default)(this, Points);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Points).call(this, {\n\t      geometry: false,\n\t\n\t      material: {\n\t        kind: 'points'\n\t      }\n\t    }));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Points.prototype), 'setParams', _this).call(_this, params);\n\t\n\t    var _verts = params.geometry.points;\n\t\n\t    var points = new THREE.Points(params.geometry, (0, _api.loadMaterial)(params.material));\n\t\n\t    _this.setNative(points);\n\t\n\t    var scope = Object.assign(_this, {\n\t      _type: 'points'\n\t    });\n\t\n\t    return _ret = scope, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t\n\t  /**\r\n\t   * Add curve to scene.\r\n\t   */\n\t\n\t\n\t  (0, _createClass3.default)(Points, [{\n\t    key: 'addTo',\n\t    value: function addTo(parent) {\n\t      var _scope = this;\n\t      _scope.parent = parent;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _scope.parent.getScene().add(_scope.getNative());\n\t          _scope.parent.children.push(_scope);\n\t        } catch (err) {\n\t          console.error(err.message);\n\t          reject();\n\t        } finally {\n\t          if (_defaults.defaults.debug) {\n\t            console.debug('@WHS.Curve: Curve ' + _scope._type + ' was added to world.', [_scope, _scope.parent]);\n\t          }\n\t\n\t          resolve(_scope);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\r\n\t     * Clone curve.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Points(this.__params).copy(this);\n\t    }\n\t\n\t    /**\r\n\t     * Copy curve.\r\n\t     *\r\n\t     * @param {WHS.Points} source - Source object, that will be applied to this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'copy',\n\t    value: function copy(source) {\n\t      this.setNative(source.getNative().clone());\n\t\n\t      this._type = source._type;\n\t\n\t      return this;\n\t    }\n\t\n\t    /**\r\n\t     * Remove this curve from world.\r\n\t     *\r\n\t     * @return {WHS.Points} - this.\r\n\t     */\n\t\n\t  }, {\n\t    key: 'remove',\n\t    value: function remove() {\n\t      this.parent.getScene().remove(this.getNative());\n\t\n\t      this.parent.children.splice(this.parent.children.indexOf(this), 1);\n\t      this.parent = null;\n\t\n\t      this.emit('remove');\n\t\n\t      if (_defaults.defaults.debug) {\n\t        console.debug('@WHS.Points: Curve ' + this._type + ' was removed from world', [_scope]);\n\t      }\n\t\n\t      return this;\n\t    }\n\t  }]);\n\t  return Points;\n\t}(_Object.WHSObject);\n\t\n\texports.Points = Points;\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Group = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _Object = __webpack_require__(97);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Group = function (_Shape) {\n\t  (0, _inherits3.default)(Group, _Shape);\n\t\n\t  function Group() {\n\t    (0, _classCallCheck3.default)(this, Group);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Group).call(this, {}, 'group'));\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Group.prototype), 'setNative', _this).call(_this, new THREE.Object3D());\n\t    (0, _get3.default)(Object.getPrototypeOf(Group.prototype), 'wrap', _this).call(_this);\n\t\n\t    for (var _len = arguments.length, objects = Array(_len), _key = 0; _key < _len; _key++) {\n\t      objects[_key] = arguments[_key];\n\t    }\n\t\n\t    for (var i = 0; i < objects.length; i++) {\n\t      var obj = objects[i];\n\t\n\t      if (obj instanceof _Object.WHSObject) obj.addTo(_this);else if (obj instanceof THREE.Object3D) _this.getNative().add(obj);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  return Group;\n\t}(_Shape2.Shape);\n\t\n\texports.Group = Group;\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Skybox = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Skybox = function (_Shape) {\n\t  (0, _inherits3.default)(Skybox, _Shape);\n\t\n\t  function Skybox() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Skybox);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Skybox).call(this, params, 'skybox'));\n\t\n\t    (0, _api.extend)(params, {\n\t      skyType: 'box',\n\t      imgSuffix: '.png',\n\t      radius: 10,\n\t      fog: true,\n\t      path: ''\n\t    });\n\t\n\t    var skyGeometry = void 0,\n\t        skyMat = void 0;\n\t\n\t    switch (params.skyType) {\n\t      case 'box':\n\t        {\n\t          var directions = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'],\n\t              matArray = [];\n\t\n\t          skyGeometry = new THREE.CubeGeometry(params.radius, params.radius, params.radius);\n\t\n\t          for (var i = 0; i < 6; i++) {\n\t            matArray.push(new MeshBasicMaterial({\n\t              map: (0, _api.texture)(params.path + directions[i] + params.imgSuffix, false),\n\t              side: THREE.BackSide,\n\t              fog: params.fog\n\t            }));\n\t          }\n\t\n\t          skyMat = new THREE.MeshFaceMaterial(matArray);\n\t\n\t          break;\n\t        }\n\t      case 'sphere':\n\t        {\n\t          skyGeometry = new THREE.SphereGeometry(params.radius / 2, 60, 40);\n\t          skyMat = new THREE.MeshBasicMaterial({\n\t            map: (0, _api.texture)(params.path + params.imgSuffix, false),\n\t            side: THREE.BackSide,\n\t            fog: params.fog\n\t          });\n\t\n\t          break;\n\t        }\n\t      default:\n\t    }\n\t\n\t    var mesh = new THREE.Mesh(skyGeometry, skyMat);\n\t    mesh.renderDepth = 1000.0;\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(Skybox.prototype), 'setNative', _this).call(_this, mesh);\n\t    (0, _get3.default)(Object.getPrototypeOf(Skybox.prototype), 'wrap', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  return Skybox;\n\t}(_Shape2.Shape);\n\t\n\texports.Skybox = Skybox;\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _AmbientLight = __webpack_require__(120);\n\t\n\tObject.keys(_AmbientLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _AmbientLight[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _DirectionalLight = __webpack_require__(121);\n\t\n\tObject.keys(_DirectionalLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _DirectionalLight[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _HemisphereLight = __webpack_require__(122);\n\t\n\tObject.keys(_HemisphereLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _HemisphereLight[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _NormalLight = __webpack_require__(123);\n\t\n\tObject.keys(_NormalLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _NormalLight[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _PointLight = __webpack_require__(124);\n\t\n\tObject.keys(_PointLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _PointLight[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _SpotLight = __webpack_require__(125);\n\t\n\tObject.keys(_SpotLight).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _SpotLight[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.AmbientLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar AmbientLight = function (_Light) {\n\t  (0, _inherits3.default)(AmbientLight, _Light);\n\t\n\t  function AmbientLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, AmbientLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(AmbientLight).call(this, params, 'ambientlight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(AmbientLight.prototype), 'wrap', _this).call(_this, 'no-shadows');\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(AmbientLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.AmbientLight(params.light.color, params.light.intensity));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return AmbientLight;\n\t}(_Light2.Light);\n\t\n\texports.AmbientLight = AmbientLight;\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.DirectionalLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar DirectionalLight = function (_Light) {\n\t  (0, _inherits3.default)(DirectionalLight, _Light);\n\t\n\t  function DirectionalLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, DirectionalLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(DirectionalLight).call(this, params, 'directionallight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(DirectionalLight.prototype), 'wrap', _this).call(_this);\n\t    (0, _get3.default)(Object.getPrototypeOf(DirectionalLight.prototype), 'wrapShadow', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(DirectionalLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.DirectionalLight(params.light.color, params.light.intensity));\n\t\n\t        if (params.helper) {\n\t          _scope.helper = new THREE.DirectionalLightHelper(_scope.light, params.helper.size ? params.helper.size : 0);\n\t        }\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return DirectionalLight;\n\t}(_Light2.Light);\n\t\n\texports.DirectionalLight = DirectionalLight;\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.HemisphereLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar HemisphereLight = function (_Light) {\n\t  (0, _inherits3.default)(HemisphereLight, _Light);\n\t\n\t  function HemisphereLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, HemisphereLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(HemisphereLight).call(this, params, 'hemispherelight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(HemisphereLight.prototype), 'wrap', _this).call(_this);\n\t    (0, _get3.default)(Object.getPrototypeOf(HemisphereLight.prototype), 'wrapShadow', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(HemisphereLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.HemisphereLight(params.light.skyColor, params.light.groundColor, params.light.intensity));\n\t\n\t        if (params.helper) {\n\t          _scope.helper = new THREE.HemisphereLightHelper(_scope.light, params.helper.size ? params.helper.size : 0);\n\t        }\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return HemisphereLight;\n\t}(_Light2.Light);\n\t\n\texports.HemisphereLight = HemisphereLight;\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.NormalLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar NormalLight = function (_Light) {\n\t  (0, _inherits3.default)(NormalLight, _Light);\n\t\n\t  function NormalLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, NormalLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(NormalLight).call(this, params, 'normallight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(NormalLight.prototype), 'wrap', _this).call(_this);\n\t    (0, _get3.default)(Object.getPrototypeOf(NormalLight.prototype), 'wrapShadow', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(NormalLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.Light(params.light.color));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return NormalLight;\n\t}(_Light2.Light);\n\t\n\texports.NormalLight = NormalLight;\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.PointLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar PointLight = function (_Light) {\n\t  (0, _inherits3.default)(PointLight, _Light);\n\t\n\t  function PointLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, PointLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(PointLight).call(this, params, 'pointlight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(PointLight.prototype), 'wrap', _this).call(_this);\n\t    (0, _get3.default)(Object.getPrototypeOf(PointLight.prototype), 'wrapShadow', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(PointLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.PointLight(params.light.color, params.light.intensity, params.light.distance, params.light.decay));\n\t\n\t        if (params.helper) {\n\t          _scope.helper = new THREE.PointLightHelper(_scope.light, params.helper.size ? params.helper.size : 0);\n\t        }\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return PointLight;\n\t}(_Light2.Light);\n\t\n\texports.PointLight = PointLight;\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.SpotLight = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Light2 = __webpack_require__(106);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar SpotLight = function (_Light) {\n\t  (0, _inherits3.default)(SpotLight, _Light);\n\t\n\t  function SpotLight() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, SpotLight);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(SpotLight).call(this, params, 'spotlight'));\n\t\n\t    _this.build(params);\n\t\n\t    (0, _get3.default)(Object.getPrototypeOf(SpotLight.prototype), 'wrap', _this).call(_this);\n\t    (0, _get3.default)(Object.getPrototypeOf(SpotLight.prototype), 'wrapShadow', _this).call(_this);\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(SpotLight, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var _scope = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _scope.setNative(new THREE.SpotLight(params.light.color, params.light.intensity, params.light.distance, params.light.angle, params.light.exponent, params.light.decay));\n\t\n\t        if (params.helper) _scope.helper = new THREE.SpotLightHelper(_scope.light);\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t  return SpotLight;\n\t}(_Light2.Light);\n\t\n\texports.SpotLight = SpotLight;\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _Box = __webpack_require__(127);\n\t\n\tObject.keys(_Box).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Box[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Cylinder = __webpack_require__(128);\n\t\n\tObject.keys(_Cylinder).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Cylinder[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Dodecahedron = __webpack_require__(129);\n\t\n\tObject.keys(_Dodecahedron).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Dodecahedron[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Extrude = __webpack_require__(130);\n\t\n\tObject.keys(_Extrude).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Extrude[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Icosahedron = __webpack_require__(131);\n\t\n\tObject.keys(_Icosahedron).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Icosahedron[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Lathe = __webpack_require__(132);\n\t\n\tObject.keys(_Lathe).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Lathe[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Model = __webpack_require__(133);\n\t\n\tObject.keys(_Model).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Model[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Morph = __webpack_require__(134);\n\t\n\tObject.keys(_Morph).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Morph[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Octahedron = __webpack_require__(135);\n\t\n\tObject.keys(_Octahedron).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Octahedron[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Parametric = __webpack_require__(136);\n\t\n\tObject.keys(_Parametric).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Parametric[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Plane = __webpack_require__(137);\n\t\n\tObject.keys(_Plane).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Plane[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Polyhedron = __webpack_require__(138);\n\t\n\tObject.keys(_Polyhedron).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Polyhedron[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Ring = __webpack_require__(139);\n\t\n\tObject.keys(_Ring).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Ring[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Shape2D = __webpack_require__(140);\n\t\n\tObject.keys(_Shape2D).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Shape2D[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Sphere = __webpack_require__(141);\n\t\n\tObject.keys(_Sphere).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Sphere[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Tetrahedron = __webpack_require__(142);\n\t\n\tObject.keys(_Tetrahedron).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Tetrahedron[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Text = __webpack_require__(143);\n\t\n\tObject.keys(_Text).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Text[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Torus = __webpack_require__(144);\n\t\n\tObject.keys(_Torus).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Torus[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Torusknot = __webpack_require__(145);\n\t\n\tObject.keys(_Torusknot).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Torusknot[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _Tube = __webpack_require__(146);\n\t\n\tObject.keys(_Tube).forEach(function (key) {\n\t  if (key === \"default\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _Tube[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Box = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Box = function (_Shape) {\n\t  (0, _inherits3.default)(Box, _Shape);\n\t\n\t  function Box() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Box);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Box).call(this, params, 'box'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      width: 1,\n\t      height: 1,\n\t      depth: 1\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Box.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Box, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Box.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.BoxMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.BoxBufferGeometry : THREE.BoxGeometry;\n\t\n\t      var geometry = new GConstruct(params.geometry.width, params.geometry.height, params.geometry.depth);\n\t\n\t      if (params.softbody) this.proccessSoftbodyGeometry(geometry);\n\t\n\t      return geometry;\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return this.getParams().softbody ? new Box(this.getParams()) : new Box({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_width',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { width: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.width;\n\t    }\n\t  }, {\n\t    key: 'G_height',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { height: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.height;\n\t    }\n\t  }, {\n\t    key: 'G_depth',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { depth: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.depth;\n\t    }\n\t  }]);\n\t  return Box;\n\t}(_Shape2.Shape);\n\t\n\texports.Box = Box;\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Cylinder = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Cylinder = function (_Shape) {\n\t  (0, _inherits3.default)(Cylinder, _Shape);\n\t\n\t  function Cylinder() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Cylinder);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Cylinder).call(this, params, 'cylinder'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radiusTop: 0,\n\t      radiusBottom: 1,\n\t      height: 1,\n\t      radiusSegments: 32\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Cylinder.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Cylinder, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Cylinder.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.CylinderMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.CylinderBufferGeometry : THREE.CylinderGeometry;\n\t\n\t      return new GConstruct(params.geometry.radiusTop, params.geometry.radiusBottom, params.geometry.height, params.geometry.radiusSegments);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Cylinder({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radiusTop',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radiusTop: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radiusTop;\n\t    }\n\t  }, {\n\t    key: 'G_radiusBottom',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radiusBottom: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radiusBottom;\n\t    }\n\t  }, {\n\t    key: 'G_height',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { height: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.height;\n\t    }\n\t  }, {\n\t    key: 'G_radiusSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radiusSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radiusSegments;\n\t    }\n\t  }]);\n\t  return Cylinder;\n\t}(_Shape2.Shape);\n\t\n\texports.Cylinder = Cylinder;\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Dodecahedron = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Dodecahedron = function (_Shape) {\n\t  (0, _inherits3.default)(Dodecahedron, _Shape);\n\t\n\t  function Dodecahedron() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Dodecahedron);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Dodecahedron).call(this, params, 'dodecahedron'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 1,\n\t      detail: 0\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Dodecahedron.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Dodecahedron, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Dodecahedron.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.DodecahedronBufferGeometry : THREE.DodecahedronGeometry;\n\t\n\t      return new GConstruct(params.geometry.radius, params.geometry.detail);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Dodecahedron({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_detail',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { detail: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.detail;\n\t    }\n\t  }]);\n\t  return Dodecahedron;\n\t}(_Shape2.Shape);\n\t\n\texports.Dodecahedron = Dodecahedron;\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Extrude = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar _nophysi2 = _interopRequireDefault(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Extrude = function (_Shape) {\n\t  (0, _inherits3.default)(Extrude, _Shape);\n\t\n\t  function Extrude() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Extrude);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Extrude).call(this, params, 'extrude'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      shapes: [],\n\t      options: {}\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Extrude.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Extrude, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Extrude.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = _nophysi2.default.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = _nophysi2.default.ConcaveMesh;else if (this.physics) Mesh = _nophysi2.default.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.ExtrudeBufferGeometry : THREE.ExtrudeGeometry;\n\t\n\t      return new GConstruct(params.geometry.shapes, params.geometry.options);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Extrude({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_shapes',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { shapes: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.shapes;\n\t    }\n\t  }, {\n\t    key: 'G_options',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { options: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.options;\n\t    }\n\t  }]);\n\t  return Extrude;\n\t}(_Shape2.Shape);\n\t\n\texports.Extrude = Extrude;\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Icosahedron = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar _nophysi2 = _interopRequireDefault(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Icosahedron = function (_Shape) {\n\t  (0, _inherits3.default)(Icosahedron, _Shape);\n\t\n\t  function Icosahedron() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Icosahedron);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Icosahedron).call(this, params, 'icosahedron'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 1,\n\t      detail: 0\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Icosahedron.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Icosahedron, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Icosahedron.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = _nophysi2.default.SoftMesh;else if (this.physics) Mesh = _nophysi2.default.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.IcosahedronBufferGeometry : THREE.IcosahedronGeometry;\n\t\n\t      return new GConstruct(params.geometry.radius, params.geometry.detail);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Icosahderon({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_detail',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { detail: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.detail;\n\t    }\n\t  }]);\n\t  return Icosahedron;\n\t}(_Shape2.Shape);\n\t\n\texports.Icosahedron = Icosahedron;\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Lathe = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Lathe = function (_Shape) {\n\t  (0, _inherits3.default)(Lathe, _Shape);\n\t\n\t  function Lathe() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Lathe);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Lathe).call(this, params, 'lathe'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      points: []\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Lathe.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Lathe, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Lathe.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.LatheBufferGeometry : THREE.LatheGeometry;\n\t\n\t      return new GConstruct(params.geometry.points);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Lathe({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_points',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { points: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.points;\n\t    }\n\t  }]);\n\t  return Lathe;\n\t}(_Shape2.Shape);\n\t\n\texports.Lathe = Lathe;\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Model = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Model = function (_Shape) {\n\t  (0, _inherits3.default)(Model, _Shape);\n\t\n\t  function Model() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Model);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Model).call(this, params, 'model'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      path: '',\n\t      physics: '',\n\t      loader: _api.JSONLoader\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Model.prototype), 'wrap', _this).call(_this, 'wait');\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Model, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      var promise = new Promise(function (resolve) {\n\t        var pGeometry = params.geometry;\n\t        var Loader = pGeometry.loader;\n\t\n\t        Loader.load(pGeometry.path, function (data, materials) {\n\t          if (pGeometry.physics) {\n\t            Loader.load(pGeometry.physics, function (data2) {\n\t              var material = void 0;\n\t\n\t              if (params.material.useVertexColors) {\n\t                material = (0, _api.loadMaterial)((0, _api.extend)(params.material, {\n\t                  morphTargets: true,\n\t                  vertexColors: THREE.FaceColors\n\t                }));\n\t              } else if (!materials || params.material.useCustomMaterial) {\n\t                material = (0, _api.loadMaterial)(params.material);\n\t              } else material = new THREE.MultiMaterial(materials);\n\t\n\t              data.computeFaceNormals();\n\t              data.computeVertexNormals();\n\t\n\t              _this2.setNative(new Mesh(data, material, _this2.getParams(), data2));\n\t\n\t              resolve();\n\t            });\n\t          } else {\n\t            var material = void 0;\n\t\n\t            if (params.material.useVertexColors) {\n\t              material = (0, _api.loadMaterial)((0, _api.extend)(params.material, {\n\t                morphTargets: true,\n\t                vertexColors: THREE.FaceColors\n\t              }));\n\t            } else if (!materials || params.material.useCustomMaterial) {\n\t              material = (0, _api.loadMaterial)(params.material);\n\t            } else material = new THREE.MultiMaterial(materials);\n\t\n\t            data.computeFaceNormals();\n\t            data.computeVertexNormals();\n\t\n\t            console.log(_this2.getParams());\n\t\n\t            _this2.setNative(new Mesh(data, material, _this2.getParams()));\n\t\n\t            resolve();\n\t          }\n\t        });\n\t      });\n\t\n\t      (0, _get3.default)(Object.getPrototypeOf(Model.prototype), 'wait', this).call(this, promise);\n\t\n\t      return promise;\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Model({ build: false }).copy(this);\n\t    }\n\t  }]);\n\t  return Model;\n\t}(_Shape2.Shape);\n\t\n\texports.Model = Model;\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Morph = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tvar _loaders = __webpack_require__(101);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Morph = function (_Shape) {\n\t  (0, _inherits3.default)(Morph, _Shape);\n\t\n\t  function Morph() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Morph);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Morph).call(this, params, 'morph'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      path: '',\n\t      loader: _loaders.JSONLoader\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Morph.prototype), 'wrap', _this).call(_this, 'wait');\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Morph, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var promise = new Promise(function (resolve) {\n\t        var Loader = params.geometry.loader;\n\t\n\t        Loader.load(params.geometry.path, function (data, materials) {\n\t          var material = void 0;\n\t          if (params.material.useVertexColors) {\n\t            material = (0, _api.loadMaterial)((0, _api.extend)(params.material, {\n\t              morphTargets: true,\n\t              vertexColors: THREE.FaceColors\n\t            }));\n\t          } else if (!materials || params.material.useCustomMaterial) {\n\t            material = (0, _api.loadMaterial)(params.material);\n\t          } else material = new THREE.MultiMaterial(materials);\n\t\n\t          data.computeFaceNormals();\n\t          data.computeVertexNormals();\n\t\n\t          // Visualization.\n\t          var mesh = new THREE.Mesh(data, material);\n\t          mesh.speed = params.morph.speed;\n\t          mesh.mixer = new THREE.AnimationMixer(mesh);\n\t\n\t          mesh.mixer.clipAction(data.animations[0]).setDuration(params.morph.duration).play();\n\t\n\t          _this2.setNative(mesh);\n\t\n\t          resolve();\n\t        });\n\t      });\n\t\n\t      (0, _get3.default)(Object.getPrototypeOf(Morph.prototype), 'wait', this).call(this, promise);\n\t      return promise;\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Morph({ build: false }).copy(this);\n\t    }\n\t  }]);\n\t  return Morph;\n\t}(_Shape2.Shape);\n\t\n\texports.Morph = Morph;\n\n/***/ },\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Octahedron = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Octahedron = function (_Shape) {\n\t  (0, _inherits3.default)(Octahedron, _Shape);\n\t\n\t  function Octahedron() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Octahedron);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Octahedron).call(this, params, 'octahedron'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 1,\n\t      detail: 0\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Octahedron.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Octahedron, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Octahedron.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.OctahedronBufferGeometry : THREE.OctahedronGeometry;\n\t\n\t      return new GConstruct(params.geometry.radius, params.geometry.detail);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Octahedron({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_detail',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { detail: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.detail;\n\t    }\n\t  }]);\n\t  return Octahedron;\n\t}(_Shape2.Shape);\n\t\n\texports.Octahedron = Octahedron;\n\n/***/ },\n/* 136 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Parametric = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Parametric = function (_Shape) {\n\t  (0, _inherits3.default)(Parametric, _Shape);\n\t\n\t  function Parametric() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Parametric);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Parametric).call(this, params, 'parametric'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      func: function func() {},\n\t\n\t      slices: 10,\n\t      stacks: 10\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Parametric.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Parametric, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Parametric.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.ParametricBufferGeometry : THREE.ParametricGeometry;\n\t\n\t      return new GConstruct(params.geometry.func, params.geometry.slices, params.geometry.stacks);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Parametric({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_func',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { func: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.func;\n\t    }\n\t  }, {\n\t    key: 'G_slices',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { slices: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.slices;\n\t    }\n\t  }, {\n\t    key: 'G_stacks',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { stacks: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.stacks;\n\t    }\n\t  }]);\n\t  return Parametric;\n\t}(_Shape2.Shape);\n\t\n\texports.Parametric = Parametric;\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Plane = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Plane = function (_Shape) {\n\t  (0, _inherits3.default)(Plane, _Shape);\n\t\n\t  function Plane() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Plane);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Plane).call(this, params, 'plane'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      width: 10,\n\t      height: 10,\n\t      wSegments: 32,\n\t      hSegments: 32\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Plane.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Plane, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Plane.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.PlaneMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.PlaneBufferGeometry : THREE.PlaneGeometry;\n\t\n\t      return new GConstruct(params.geometry.width, params.geometry.height, params.geometry.wSegments, params.geometry.hSegments);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Plane({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_width',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { width: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.width;\n\t    }\n\t  }, {\n\t    key: 'G_height',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { height: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.height;\n\t    }\n\t  }, {\n\t    key: 'G_segments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { segments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.segments;\n\t    }\n\t  }]);\n\t  return Plane;\n\t}(_Shape2.Shape);\n\t\n\texports.Plane = Plane;\n\n/***/ },\n/* 138 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Polyhedron = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Polyhedron = function (_Shape) {\n\t  (0, _inherits3.default)(Polyhedron, _Shape);\n\t\n\t  function Polyhedron() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Polyhedron);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Polyhedron).call(this, params, 'polyhedron'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      verticesOfCube: _this.verticesOfCube,\n\t      indicesOfFaces: _this.indicesOfFaces,\n\t      radius: 6,\n\t      detail: 2\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Polyhedron.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Polyhedron, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Polyhedron.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.PolyhedronBufferGeometry : THREE.PolyhedronGeometry;\n\t\n\t      return new GConstruct(params.geometry.verticesOfCube, params.geometry.indicesOfFaces, params.geometry.radius, params.geometry.detail);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Polyhedron({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'verticesOfCube',\n\t    get: function get() {\n\t      return [-1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1];\n\t    }\n\t  }, {\n\t    key: 'indicesOfFaces',\n\t    get: function get() {\n\t      return [2, 1, 0, 0, 3, 2, 0, 4, 7, 7, 3, 0, 0, 1, 5, 5, 4, 0, 1, 2, 6, 6, 5, 1, 2, 3, 7, 7, 6, 2, 4, 5, 6, 6, 7, 4];\n\t    }\n\t  }, {\n\t    key: 'G_verticesOfCube',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { verticesOfCube: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.verticesOfCube;\n\t    }\n\t  }, {\n\t    key: 'G_indicesOfFaces',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { indicesOfFaces: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.indicesOfFaces;\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_detail',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { detail: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.detail;\n\t    }\n\t  }]);\n\t  return Polyhedron;\n\t}(_Shape2.Shape);\n\t\n\texports.Polyhedron = Polyhedron;\n\n/***/ },\n/* 139 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Ring = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Ring = function (_Shape) {\n\t  (0, _inherits3.default)(Ring, _Shape);\n\t\n\t  function Ring() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Ring);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Ring).call(this, params, 'ring'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      innerRadius: 0,\n\t      outerRadius: 50,\n\t      thetaSegments: 8,\n\t      phiSegments: 8,\n\t      thetaStart: 0,\n\t      thetaLength: Math.PI * 2\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Ring.prototype), 'wrap', _this).call(_this, 'onlyvis');\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Ring, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Ring.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new THREE.Mesh(new THREE.RingGeometry(params.geometry.innerRadius, params.geometry.outerRadius, params.geometry.thetaSegments, params.geometry.phiSegments, params.geometry.thetaStart, params.geometry.thetaLength), material));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.RingBufferGeometry : THREE.RingGeometry;\n\t\n\t      return new GConstruct(params.geometry.innerRadius, params.geometry.outerRadius, params.geometry.thetaSegments, params.geometry.phiSegments, params.geometry.thetaStart, params.geometry.thetaLength);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Ring({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_innerRadius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { innerRadius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.innerRadius;\n\t    }\n\t  }, {\n\t    key: 'G_outerRadius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { outerRadius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.outerRadius;\n\t    }\n\t  }, {\n\t    key: 'G_thetaSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { thetaSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.thetaSegments;\n\t    }\n\t  }, {\n\t    key: 'G_phiSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { phiSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.phiSegments;\n\t    }\n\t  }, {\n\t    key: 'G_thetaStart',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { thetaStart: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.thetaStart;\n\t    }\n\t  }, {\n\t    key: 'G_thetaLength',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { thetaLength: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.thetaLength;\n\t    }\n\t  }]);\n\t  return Ring;\n\t}(_Shape2.Shape);\n\t\n\texports.Ring = Ring;\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Shape2D = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Shape2D = function (_Shape) {\n\t  (0, _inherits3.default)(Shape2D, _Shape);\n\t\n\t  function Shape2D() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Shape2D);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Shape2D).call(this, params, 'shape2D'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      shapes: []\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Shape2D.prototype), 'wrap', _this).call(_this, 'onlyvis');\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Shape2D, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Shape2D.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new THREE.Mesh(_this2.buildGeometry(params), material));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.ShapeBufferGeometry : THREE.ShapeGeometry;\n\t\n\t      return new GConstruct(params.geometry.shapes);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Shape2D({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_shapes',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { shapes: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.shapes;\n\t    }\n\t  }]);\n\t  return Shape2D;\n\t}(_Shape2.Shape);\n\t\n\texports.Shape2D = Shape2D;\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Sphere = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Sphere = function (_Shape) {\n\t  (0, _inherits3.default)(Sphere, _Shape);\n\t\n\t  function Sphere() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Sphere);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Sphere).call(this, params, 'sphere'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 1,\n\t      widthSegments: 8,\n\t      heightSegments: 6\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Sphere.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Sphere, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Sphere.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.SphereMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.SphereBufferGeometry : THREE.SphereGeometry;\n\t\n\t      var geometry = new GConstruct(params.geometry.radius, params.geometry.widthSegments, params.geometry.heightSegments);\n\t\n\t      if (params.softbody) this.proccessSoftbodyGeometry(geometry);\n\t\n\t      return geometry;\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return this.getParams().softbody ? new Sphere(this.getParams()) : new Sphere({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_widthSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { widthSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.widthSegments;\n\t    }\n\t  }, {\n\t    key: 'G_heightSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { widthSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.widthSegments;\n\t    }\n\t  }]);\n\t  return Sphere;\n\t}(_Shape2.Shape);\n\t\n\texports.Sphere = Sphere;\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Tetrahedron = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Tetrahedron = function (_Shape) {\n\t  (0, _inherits3.default)(Tetrahedron, _Shape);\n\t\n\t  function Tetrahedron() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Tetrahedron);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Tetrahedron).call(this, params, 'tetrahedron'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 1,\n\t      detail: 0\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Tetrahedron.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Tetrahedron, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Tetrahedron.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.TetrahedronBufferGeometry : THREE.TetrahedronGeometry;\n\t\n\t      return new GConstruct(params.geometry.radius, params.geometry.detail);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Tetrahedron({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_detail',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { detail: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.detail;\n\t    }\n\t  }]);\n\t  return Tetrahedron;\n\t}(_Shape2.Shape);\n\t\n\texports.Tetrahedron = Tetrahedron;\n\n/***/ },\n/* 143 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Text = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar _nophysi2 = _interopRequireDefault(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Text = function (_Shape) {\n\t  (0, _inherits3.default)(Text, _Shape);\n\t\n\t  function Text() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Text);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Text).call(this, params, 'text'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      text: 'Hello World!',\n\t\n\t      parameters: {\n\t        size: 12,\n\t        height: 50,\n\t        curveSegments: 12,\n\t        font: new THREE.Font(),\n\t        bevelEnabled: false,\n\t        bevelThickness: 10,\n\t        bevelSize: 8\n\t      }\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Text.prototype), 'wrap', _this).call(_this, 'wait');\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Text, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Text.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = _nophysi2.default.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = _nophysi2.default.ConcaveMesh;else if (this.physics) Mesh = _nophysi2.default.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      var promise = new Promise(function (resolve) {\n\t        _api.FontLoader.load(params.geometry.parameters.font, function (font) {\n\t          params.geometry.parameters.font = font;\n\t\n\t          _this2.setNative(new Mesh(new THREE.TextGeometry(params.geometry.text, params.geometry.parameters), material, _this2.getParams()));\n\t\n\t          resolve();\n\t        });\n\t      });\n\t\n\t      (0, _get3.default)(Object.getPrototypeOf(Text.prototype), 'wait', this).call(this, promise);\n\t\n\t      return promise;\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Text({ build: false }).copy(this);\n\t    }\n\t  }]);\n\t  return Text;\n\t}(_Shape2.Shape);\n\t\n\texports.Text = Text;\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Torus = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Torus = function (_Shape) {\n\t  (0, _inherits3.default)(Torus, _Shape);\n\t\n\t  function Torus() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Torus);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Torus).call(this, params, 'torus'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 100,\n\t      tube: 40,\n\t      radialSegments: 8,\n\t      tubularSegments: 6,\n\t      arc: Math.PI * 2\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Torus.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Torus, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Torus.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.TorusBufferGeometry : THREE.TorusGeometry;\n\t\n\t      return new THREE.TorusGeometry(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.arc);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Torus({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_tube',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { tube: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.tube;\n\t    }\n\t  }, {\n\t    key: 'G_radialSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radialSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radialSegments;\n\t    }\n\t  }, {\n\t    key: 'G_tubularSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { tubularSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.tubularSegments;\n\t    }\n\t  }, {\n\t    key: 'G_arc',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { arc: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.arc;\n\t    }\n\t  }]);\n\t  return Torus;\n\t}(_Shape2.Shape);\n\t\n\texports.Torus = Torus;\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Torusknot = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar Physijs = _interopRequireWildcard(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Torusknot = function (_Shape) {\n\t  (0, _inherits3.default)(Torusknot, _Shape);\n\t\n\t  function Torusknot() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Torusknot);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Torusknot).call(this, params, 'Torusknot'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      radius: 100,\n\t      tube: 40,\n\t      radialSegments: 64,\n\t      tubularSegments: 8,\n\t      p: 2,\n\t      q: 3,\n\t      heightScale: 1\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Torusknot.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Torusknot, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Torusknot.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;else if (this.physics) Mesh = Physijs.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.TorusKnotBufferGeometry : THREE.TorusKnotGeometry;\n\t\n\t      return new GConstruct(params.geometry.radius, params.geometry.tube, params.geometry.radialSegments, params.geometry.tubularSegments, params.geometry.p, params.geometry.q, params.geometry.heightScale);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Torusknot(this.getParams(), this._type).copy(this);\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_tube',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { tube: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.tube;\n\t    }\n\t  }, {\n\t    key: 'G_radialSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radialSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radialSegments;\n\t    }\n\t  }, {\n\t    key: 'G_tubularSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { tubularSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.tubularSegments;\n\t    }\n\t  }, {\n\t    key: 'G_p',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { p: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.p;\n\t    }\n\t  }, {\n\t    key: 'G_q',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { q: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.q;\n\t    }\n\t  }, {\n\t    key: 'G_heightScale',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { heightScale: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.heightScale;\n\t    }\n\t  }]);\n\t  return Torusknot;\n\t}(_Shape2.Shape);\n\t\n\texports.Torusknot = Torusknot;\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Tube = undefined;\n\t\n\tvar _classCallCheck2 = __webpack_require__(3);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(4);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tvar _possibleConstructorReturn2 = __webpack_require__(23);\n\t\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\t\n\tvar _inherits2 = __webpack_require__(77);\n\t\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\t\n\tvar _get2 = __webpack_require__(85);\n\t\n\tvar _get3 = _interopRequireDefault(_get2);\n\t\n\tvar _three = __webpack_require__(93);\n\t\n\tvar THREE = _interopRequireWildcard(_three);\n\t\n\tvar _nophysi = __webpack_require__(100);\n\t\n\tvar _nophysi2 = _interopRequireDefault(_nophysi);\n\t\n\tvar _Shape2 = __webpack_require__(107);\n\t\n\tvar _api = __webpack_require__(99);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Tube = function (_Shape) {\n\t  (0, _inherits3.default)(Tube, _Shape);\n\t\n\t  function Tube() {\n\t    var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Tube);\n\t\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, Object.getPrototypeOf(Tube).call(this, params, 'tube'));\n\t\n\t    (0, _api.extend)(params.geometry, {\n\t      path: options.geometryOptions.path ? new _this.CustomSinCurve(100) : false,\n\t      segments: 20,\n\t      radius: 2,\n\t      radiusSegments: 8,\n\t      closed: false\n\t    });\n\t\n\t    if (params.build) {\n\t      _this.build(params);\n\t      (0, _get3.default)(Object.getPrototypeOf(Tube.prototype), 'wrap', _this).call(_this);\n\t    }\n\t    return _this;\n\t  }\n\t\n\t  (0, _createClass3.default)(Tube, [{\n\t    key: 'build',\n\t    value: function build() {\n\t      var _this2 = this;\n\t\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var material = (0, _get3.default)(Object.getPrototypeOf(Tube.prototype), '_initMaterial', this).call(this, params.material);\n\t\n\t      var Mesh = void 0;\n\t\n\t      if (this.physics && this.getParams().softbody) Mesh = _nophysi2.default.SoftMesh;else if (this.physics && this.physics.type === 'concave') Mesh = _nophysi2.default.ConcaveMesh;else if (this.physics) Mesh = _nophysi2.default.ConvexMesh;else Mesh = THREE.Mesh;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this2.setNative(new Mesh(_this2.buildGeometry(params), material, _this2.getParams()));\n\t\n\t        resolve();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'buildGeometry',\n\t    value: function buildGeometry() {\n\t      var params = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\n\t      var GConstruct = params.buffer && !params.softbody ? THREE.TubeBufferGeometry : THREE.TubeGeometry;\n\t\n\t      return new GConstruct(params.geometry.path, params.geometry.segments, params.geometry.radius, params.geometry.radiusSegments, params.geometry.closed);\n\t    }\n\t  }, {\n\t    key: 'clone',\n\t    value: function clone() {\n\t      return new Tube({ build: false }).copy(this);\n\t    }\n\t  }, {\n\t    key: 'CustomSinCurve',\n\t    get: function get() {\n\t      var _this3 = this;\n\t\n\t      return THREE.Curve.create(function (scale) {\n\t        // custom curve constructor\n\t        _this3.scale = scale || 1;\n\t      }, function (t) {\n\t        // getPoint: t is between 0-1\n\t        var tx = t * 3 - 1.5,\n\t            ty = Math.sin(2 * Math.PI * t),\n\t            tz = 0;\n\t\n\t        return new THREE.Vector3(tx, ty, tz).multiplyScalar(_this3.scale);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'G_path',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { path: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.path;\n\t    }\n\t  }, {\n\t    key: 'G_segments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { segments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.segments;\n\t    }\n\t  }, {\n\t    key: 'G_radius',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radius: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radius;\n\t    }\n\t  }, {\n\t    key: 'G_radiusSegments',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { radiusSegments: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.radiusSegments;\n\t    }\n\t  }, {\n\t    key: 'G_closed',\n\t    set: function set(val) {\n\t      this.native.geometry = this.buildGeometry(this.updateParams({ geometry: { closed: val } }));\n\t    },\n\t    get: function get() {\n\t      return this.native.geometry.parameters.closed;\n\t    }\n\t  }]);\n\t  return Tube;\n\t}(_Shape2.Shape);\n\t\n\texports.Tube = Tube;\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** whitestorm.light.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 275062868896bd46ab55\n **/","import * as THREE from 'three';\r\nimport * as Physijs from './physics/nophysi.js';\r\n\r\nexport * from './cameras/index';\r\nexport * from './core/index';\r\nexport * from './extensions/index';\r\nexport * from './extras/index';\r\nexport * from './lights/index';\r\nexport * from './meshes/index';\r\n\r\nif (typeof window !== 'undefined') {\r\n  window.THREE = THREE;\r\n  window.Physijs = Physijs;\r\n} else if (typeof global !== 'undefined') {\r\n  global.THREE = THREE;\r\n  global.Physijs = Physijs;\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","export * from './CubeCamera';\r\nexport * from './OrtographicCamera';\r\nexport * from './PerspectiveCamera';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cameras/index.js\n **/","import * as THREE from 'three';\r\nimport {Camera} from '../core/Camera';\r\n\r\nclass CubeCamera extends Camera {\r\n  constructor(params = {}) {\r\n    super(params, 'cubecamera');\r\n\r\n    this.build(params);\r\n    super.wrap();\r\n  }\r\n\r\n  build(params = {}) {\r\n    return new Promse((resolve) => {\r\n      this.setNative(new THREE.CubeCamera(\r\n        params.camera.near,\r\n        params.camera.far,\r\n        params.camera.cubeResolution\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  CubeCamera\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cameras/CubeCamera.js\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/classCallCheck.js\n ** module id = 3\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/createClass.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 5\n ** module chunks = 0\n **/","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/define-property.js\n ** module id = 6\n ** module chunks = 0\n **/","var $export = require('./_export');\r\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\r\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.define-property.js\n ** module id = 7\n ** module chunks = 0\n **/","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_export.js\n ** module id = 8\n ** module chunks = 0\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_global.js\n ** module id = 9\n ** module chunks = 0\n **/","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_core.js\n ** module id = 10\n ** module chunks = 0\n **/","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_ctx.js\n ** module id = 11\n ** module chunks = 0\n **/","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_a-function.js\n ** module id = 12\n ** module chunks = 0\n **/","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_hide.js\n ** module id = 13\n ** module chunks = 0\n **/","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-dp.js\n ** module id = 14\n ** module chunks = 0\n **/","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_an-object.js\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_is-object.js\n ** module id = 16\n ** module chunks = 0\n **/","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\r\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\r\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_ie8-dom-define.js\n ** module id = 17\n ** module chunks = 0\n **/","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_descriptors.js\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_fails.js\n ** module id = 19\n ** module chunks = 0\n **/","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_dom-create.js\n ** module id = 20\n ** module chunks = 0\n **/","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-primitive.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_property-desc.js\n ** module id = 22\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/possibleConstructorReturn.js\n ** module id = 23\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/typeof.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol/iterator.js\n ** module id = 25\n ** module chunks = 0\n **/","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/iterator.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.string.iterator.js\n ** module id = 27\n ** module chunks = 0\n **/","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_string-at.js\n ** module id = 28\n ** module chunks = 0\n **/","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-integer.js\n ** module id = 29\n ** module chunks = 0\n **/","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_defined.js\n ** module id = 30\n ** module chunks = 0\n **/","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-define.js\n ** module id = 31\n ** module chunks = 0\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_library.js\n ** module id = 32\n ** module chunks = 0\n **/","module.exports = require('./_hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_redefine.js\n ** module id = 33\n ** module chunks = 0\n **/","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_has.js\n ** module id = 34\n ** module chunks = 0\n **/","module.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iterators.js\n ** module id = 35\n ** module chunks = 0\n **/","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-create.js\n ** module id = 36\n ** module chunks = 0\n **/","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\nvar anObject    = require('./_an-object')\r\n  , dPs         = require('./_object-dps')\r\n  , enumBugKeys = require('./_enum-bug-keys')\r\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\r\n  , Empty       = function(){ /* empty */ }\r\n  , PROTOTYPE   = 'prototype';\r\n\r\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\r\nvar createDict = function(){\r\n  // Thrash, waste and sodomy: IE GC bug\r\n  var iframe = require('./_dom-create')('iframe')\r\n    , i      = enumBugKeys.length\r\n    , gt     = '>'\r\n    , iframeDocument;\r\n  iframe.style.display = 'none';\r\n  require('./_html').appendChild(iframe);\r\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\r\n  // createDict = iframe.contentWindow.Object;\r\n  // html.removeChild(iframe);\r\n  iframeDocument = iframe.contentWindow.document;\r\n  iframeDocument.open();\r\n  iframeDocument.write('<script>document.F=Object</script' + gt);\r\n  iframeDocument.close();\r\n  createDict = iframeDocument.F;\r\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\r\n  return createDict();\r\n};\r\n\r\nmodule.exports = Object.create || function create(O, Properties){\r\n  var result;\r\n  if(O !== null){\r\n    Empty[PROTOTYPE] = anObject(O);\r\n    result = new Empty;\r\n    Empty[PROTOTYPE] = null;\r\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\r\n    result[IE_PROTO] = O;\r\n  } else result = createDict();\r\n  return Properties === undefined ? result : dPs(result, Properties);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-create.js\n ** module id = 37\n ** module chunks = 0\n **/","var dP       = require('./_object-dp')\r\n  , anObject = require('./_an-object')\r\n  , getKeys  = require('./_object-keys');\r\n\r\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\r\n  anObject(O);\r\n  var keys   = getKeys(Properties)\r\n    , length = keys.length\r\n    , i = 0\r\n    , P;\r\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\r\n  return O;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-dps.js\n ** module id = 38\n ** module chunks = 0\n **/","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\r\nvar $keys       = require('./_object-keys-internal')\r\n  , enumBugKeys = require('./_enum-bug-keys');\r\n\r\nmodule.exports = Object.keys || function keys(O){\r\n  return $keys(O, enumBugKeys);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-keys.js\n ** module id = 39\n ** module chunks = 0\n **/","var has          = require('./_has')\r\n  , toIObject    = require('./_to-iobject')\r\n  , arrayIndexOf = require('./_array-includes')(false)\r\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\r\n\r\nmodule.exports = function(object, names){\r\n  var O      = toIObject(object)\r\n    , i      = 0\r\n    , result = []\r\n    , key;\r\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\r\n  // Don't enum bug & hidden keys\r\n  while(names.length > i)if(has(O, key = names[i++])){\r\n    ~arrayIndexOf(result, key) || result.push(key);\r\n  }\r\n  return result;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-keys-internal.js\n ** module id = 40\n ** module chunks = 0\n **/","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-iobject.js\n ** module id = 41\n ** module chunks = 0\n **/","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iobject.js\n ** module id = 42\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_cof.js\n ** module id = 43\n ** module chunks = 0\n **/","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_array-includes.js\n ** module id = 44\n ** module chunks = 0\n **/","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-length.js\n ** module id = 45\n ** module chunks = 0\n **/","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-index.js\n ** module id = 46\n ** module chunks = 0\n **/","var shared = require('./_shared')('keys')\r\n  , uid    = require('./_uid');\r\nmodule.exports = function(key){\r\n  return shared[key] || (shared[key] = uid(key));\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_shared-key.js\n ** module id = 47\n ** module chunks = 0\n **/","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_shared.js\n ** module id = 48\n ** module chunks = 0\n **/","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_uid.js\n ** module id = 49\n ** module chunks = 0\n **/","// IE 8- don't enum bug keys\r\nmodule.exports = (\r\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\r\n).split(',');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_enum-bug-keys.js\n ** module id = 50\n ** module chunks = 0\n **/","module.exports = require('./_global').document && document.documentElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_html.js\n ** module id = 51\n ** module chunks = 0\n **/","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_set-to-string-tag.js\n ** module id = 52\n ** module chunks = 0\n **/","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks.js\n ** module id = 53\n ** module chunks = 0\n **/","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\r\nvar has         = require('./_has')\r\n  , toObject    = require('./_to-object')\r\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\r\n  , ObjectProto = Object.prototype;\r\n\r\nmodule.exports = Object.getPrototypeOf || function(O){\r\n  O = toObject(O);\r\n  if(has(O, IE_PROTO))return O[IE_PROTO];\r\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\r\n    return O.constructor.prototype;\r\n  } return O instanceof Object ? ObjectProto : null;\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gpo.js\n ** module id = 54\n ** module chunks = 0\n **/","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_to-object.js\n ** module id = 55\n ** module chunks = 0\n **/","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/web.dom.iterable.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.array.iterator.js\n ** module id = 57\n ** module chunks = 0\n **/","module.exports = function(){ /* empty */ };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_add-to-unscopables.js\n ** module id = 58\n ** module chunks = 0\n **/","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_iter-step.js\n ** module id = 59\n ** module chunks = 0\n **/","exports.f = require('./_wks');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-ext.js\n ** module id = 60\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/symbol.js\n ** module id = 61\n ** module chunks = 0\n **/","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/symbol/index.js\n ** module id = 62\n ** module chunks = 0\n **/","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.symbol.js\n ** module id = 63\n ** module chunks = 0\n **/","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_meta.js\n ** module id = 64\n ** module chunks = 0\n **/","var global         = require('./_global')\r\n  , core           = require('./_core')\r\n  , LIBRARY        = require('./_library')\r\n  , wksExt         = require('./_wks-ext')\r\n  , defineProperty = require('./_object-dp').f;\r\nmodule.exports = function(name){\r\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\r\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_wks-define.js\n ** module id = 65\n ** module chunks = 0\n **/","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_keyof.js\n ** module id = 66\n ** module chunks = 0\n **/","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_enum-keys.js\n ** module id = 67\n ** module chunks = 0\n **/","exports.f = Object.getOwnPropertySymbols;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gops.js\n ** module id = 68\n ** module chunks = 0\n **/","exports.f = {}.propertyIsEnumerable;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-pie.js\n ** module id = 69\n ** module chunks = 0\n **/","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_is-array.js\n ** module id = 70\n ** module chunks = 0\n **/","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn-ext.js\n ** module id = 71\n ** module chunks = 0\n **/","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\r\nvar $keys      = require('./_object-keys-internal')\r\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\r\n\r\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\r\n  return $keys(O, hiddenKeys);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopn.js\n ** module id = 72\n ** module chunks = 0\n **/","var pIE            = require('./_object-pie')\r\n  , createDesc     = require('./_property-desc')\r\n  , toIObject      = require('./_to-iobject')\r\n  , toPrimitive    = require('./_to-primitive')\r\n  , has            = require('./_has')\r\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\r\n  , gOPD           = Object.getOwnPropertyDescriptor;\r\n\r\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\r\n  O = toIObject(O);\r\n  P = toPrimitive(P, true);\r\n  if(IE8_DOM_DEFINE)try {\r\n    return gOPD(O, P);\r\n  } catch(e){ /* empty */ }\r\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\r\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-gopd.js\n ** module id = 73\n ** module chunks = 0\n **/","require('./_wks-define')('asyncIterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.async-iterator.js\n ** module id = 75\n ** module chunks = 0\n **/","require('./_wks-define')('observable');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es7.symbol.observable.js\n ** module id = 76\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = require(\"../core-js/object/set-prototype-of\");\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = require(\"../core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = require(\"../helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/inherits.js\n ** module id = 77\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/set-prototype-of.js\n ** module id = 78\n ** module chunks = 0\n **/","require('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/set-prototype-of.js\n ** module id = 79\n ** module chunks = 0\n **/","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.set-prototype-of.js\n ** module id = 80\n ** module chunks = 0\n **/","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_set-proto.js\n ** module id = 81\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/create.js\n ** module id = 82\n ** module chunks = 0\n **/","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/create.js\n ** module id = 83\n ** module chunks = 0\n **/","var $export = require('./_export')\r\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\r\n$export($export.S, 'Object', {create: require('./_object-create')});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.create.js\n ** module id = 84\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _getPrototypeOf = require(\"../core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _getOwnPropertyDescriptor = require(\"../core-js/object/get-own-property-descriptor\");\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);\n\n  if (desc === undefined) {\n    var parent = (0, _getPrototypeOf2.default)(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/get.js\n ** module id = 85\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/get-prototype-of\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/get-prototype-of.js\n ** module id = 86\n ** module chunks = 0\n **/","require('../../modules/es6.object.get-prototype-of');\nmodule.exports = require('../../modules/_core').Object.getPrototypeOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/get-prototype-of.js\n ** module id = 87\n ** module chunks = 0\n **/","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject        = require('./_to-object')\n  , $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function(){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.get-prototype-of.js\n ** module id = 88\n ** module chunks = 0\n **/","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/_object-sap.js\n ** module id = 89\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/get-own-property-descriptor\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/get-own-property-descriptor.js\n ** module id = 90\n ** module chunks = 0\n **/","require('../../modules/es6.object.get-own-property-descriptor');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function getOwnPropertyDescriptor(it, key){\n  return $Object.getOwnPropertyDescriptor(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/get-own-property-descriptor.js\n ** module id = 91\n ** module chunks = 0\n **/","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject                 = require('./_to-iobject')\n  , $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function(){\n  return function getOwnPropertyDescriptor(it, key){\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.object.get-own-property-descriptor.js\n ** module id = 92\n ** module chunks = 0\n **/","// File:src/Three.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar THREE = { REVISION: '79' };\n\n//\n\nif ( typeof define === 'function' && define.amd ) {\n\n\tdefine( 'three', THREE );\n\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\n\n\tmodule.exports = THREE;\n\n}\n\n// Polyfills\n\nif ( Number.EPSILON === undefined ) {\n\n\tNumber.EPSILON = Math.pow( 2, - 52 );\n\n}\n\n//\n\nif ( Math.sign === undefined ) {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\n\tMath.sign = function ( x ) {\n\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\n\n\t};\n\n}\n\nif ( Function.prototype.name === undefined ) {\n\n\t// Missing in IE9-11.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\n\tObject.defineProperty( Function.prototype, 'name', {\n\n\t\tget: function () {\n\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\n\n\t\t}\n\n\t} );\n\n}\n\nif ( Object.assign === undefined ) {\n\n\t// Missing in IE.\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n\t( function () {\n\n\t\tObject.assign = function ( target ) {\n\n\t\t\t'use strict';\n\n\t\t\tif ( target === undefined || target === null ) {\n\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\n\n\t\t\t}\n\n\t\t\tvar output = Object( target );\n\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\n\n\t\t\t\tvar source = arguments[ index ];\n\n\t\t\t\tif ( source !== undefined && source !== null ) {\n\n\t\t\t\t\tfor ( var nextKey in source ) {\n\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\n\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t};\n\n\t} )();\n\n}\n\n//\n\nObject.assign( THREE, {\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\n\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\n\n\t// GL STATE CONSTANTS\n\n\tCullFaceNone: 0,\n\tCullFaceBack: 1,\n\tCullFaceFront: 2,\n\tCullFaceFrontBack: 3,\n\n\tFrontFaceDirectionCW: 0,\n\tFrontFaceDirectionCCW: 1,\n\n\t// SHADOWING TYPES\n\n\tBasicShadowMap: 0,\n\tPCFShadowMap: 1,\n\tPCFSoftShadowMap: 2,\n\n\t// MATERIAL CONSTANTS\n\n\t// side\n\n\tFrontSide: 0,\n\tBackSide: 1,\n\tDoubleSide: 2,\n\n\t// shading\n\n\tFlatShading: 1,\n\tSmoothShading: 2,\n\n\t// colors\n\n\tNoColors: 0,\n\tFaceColors: 1,\n\tVertexColors: 2,\n\n\t// blending modes\n\n\tNoBlending: 0,\n\tNormalBlending: 1,\n\tAdditiveBlending: 2,\n\tSubtractiveBlending: 3,\n\tMultiplyBlending: 4,\n\tCustomBlending: 5,\n\n\t// custom blending equations\n\t// (numbers start from 100 not to clash with other\n\t// mappings to OpenGL constants defined in Texture.js)\n\n\tAddEquation: 100,\n\tSubtractEquation: 101,\n\tReverseSubtractEquation: 102,\n\tMinEquation: 103,\n\tMaxEquation: 104,\n\n\t// custom blending destination factors\n\n\tZeroFactor: 200,\n\tOneFactor: 201,\n\tSrcColorFactor: 202,\n\tOneMinusSrcColorFactor: 203,\n\tSrcAlphaFactor: 204,\n\tOneMinusSrcAlphaFactor: 205,\n\tDstAlphaFactor: 206,\n\tOneMinusDstAlphaFactor: 207,\n\n\t// custom blending source factors\n\n\t//ZeroFactor: 200,\n\t//OneFactor: 201,\n\t//SrcAlphaFactor: 204,\n\t//OneMinusSrcAlphaFactor: 205,\n\t//DstAlphaFactor: 206,\n\t//OneMinusDstAlphaFactor: 207,\n\tDstColorFactor: 208,\n\tOneMinusDstColorFactor: 209,\n\tSrcAlphaSaturateFactor: 210,\n\n\t// depth modes\n\n\tNeverDepth: 0,\n\tAlwaysDepth: 1,\n\tLessDepth: 2,\n\tLessEqualDepth: 3,\n\tEqualDepth: 4,\n\tGreaterEqualDepth: 5,\n\tGreaterDepth: 6,\n\tNotEqualDepth: 7,\n\n\n\t// TEXTURE CONSTANTS\n\n\tMultiplyOperation: 0,\n\tMixOperation: 1,\n\tAddOperation: 2,\n\n\t// Tone Mapping modes\n\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\n\tLinearToneMapping: 1, // only apply exposure.\n\tReinhardToneMapping: 2,\n\tUncharted2ToneMapping: 3, // John Hable\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\n\t// Mapping modes\n\n\tUVMapping: 300,\n\n\tCubeReflectionMapping: 301,\n\tCubeRefractionMapping: 302,\n\n\tEquirectangularReflectionMapping: 303,\n\tEquirectangularRefractionMapping: 304,\n\n\tSphericalReflectionMapping: 305,\n\tCubeUVReflectionMapping: 306,\n\tCubeUVRefractionMapping: 307,\n\n\t// Wrapping modes\n\n\tRepeatWrapping: 1000,\n\tClampToEdgeWrapping: 1001,\n\tMirroredRepeatWrapping: 1002,\n\n\t// Filters\n\n\tNearestFilter: 1003,\n\tNearestMipMapNearestFilter: 1004,\n\tNearestMipMapLinearFilter: 1005,\n\tLinearFilter: 1006,\n\tLinearMipMapNearestFilter: 1007,\n\tLinearMipMapLinearFilter: 1008,\n\n\t// Data types\n\n\tUnsignedByteType: 1009,\n\tByteType: 1010,\n\tShortType: 1011,\n\tUnsignedShortType: 1012,\n\tIntType: 1013,\n\tUnsignedIntType: 1014,\n\tFloatType: 1015,\n\tHalfFloatType: 1025,\n\n\t// Pixel types\n\n\t//UnsignedByteType: 1009,\n\tUnsignedShort4444Type: 1016,\n\tUnsignedShort5551Type: 1017,\n\tUnsignedShort565Type: 1018,\n\n\t// Pixel formats\n\n\tAlphaFormat: 1019,\n\tRGBFormat: 1020,\n\tRGBAFormat: 1021,\n\tLuminanceFormat: 1022,\n\tLuminanceAlphaFormat: 1023,\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\n\tRGBEFormat: THREE.RGBAFormat, //1024;\n\tDepthFormat: 1026,\n\n\t// DDS / ST3C Compressed texture formats\n\n\tRGB_S3TC_DXT1_Format: 2001,\n\tRGBA_S3TC_DXT1_Format: 2002,\n\tRGBA_S3TC_DXT3_Format: 2003,\n\tRGBA_S3TC_DXT5_Format: 2004,\n\n\t// PVRTC compressed texture formats\n\n\tRGB_PVRTC_4BPPV1_Format: 2100,\n\tRGB_PVRTC_2BPPV1_Format: 2101,\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\n\n\t// ETC compressed texture formats\n\n\tRGB_ETC1_Format: 2151,\n\n\t// Loop styles for AnimationAction\n\n\tLoopOnce: 2200,\n\tLoopRepeat: 2201,\n\tLoopPingPong: 2202,\n\n\t// Interpolation\n\n\tInterpolateDiscrete: 2300,\n\tInterpolateLinear: 2301,\n\tInterpolateSmooth: 2302,\n\n\t// Interpolant ending modes\n\n\tZeroCurvatureEnding: 2400,\n\tZeroSlopeEnding: 2401,\n\tWrapAroundEnding: 2402,\n\n\t// Triangle Draw modes\n\n\tTrianglesDrawMode: 0,\n\tTriangleStripDrawMode: 1,\n\tTriangleFanDrawMode: 2,\n\n\t// Texture Encodings\n\n\tLinearEncoding: 3000, // No encoding at all.\n\tsRGBEncoding: 3001,\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\n\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\n\t// These encodings should not specified as output encodings except in rare situations.\n\tRGBEEncoding: 3002, // AKA Radiance.\n\tLogLuvEncoding: 3003,\n\tRGBM7Encoding: 3004,\n\tRGBM16Encoding: 3005,\n\tRGBDEncoding: 3006, // MaxRange is 256.\n\n\t// Depth packing strategies\n\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\n\n} );\n\n// File:src/math/Color.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( r, g, b ) {\n\n\tif ( g === undefined && b === undefined ) {\n\n\t\t// r is THREE.Color, hex or string\n\t\treturn this.set( r );\n\n\t}\n\n\treturn this.setRGB( r, g, b );\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function () {\n\n\t\tfunction hue2rgb( p, q, t ) {\n\n\t\t\tif ( t < 0 ) t += 1;\n\t\t\tif ( t > 1 ) t -= 1;\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\treturn p;\n\n\t\t}\n\n\t\treturn function setHSL( h, s, l ) {\n\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\n\n\t\t\tif ( s === 0 ) {\n\n\t\t\t\tthis.r = this.g = this.b = l;\n\n\t\t\t} else {\n\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetStyle: function ( style ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar m;\n\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tvar color;\n\t\t\tvar name = m[ 1 ];\n\t\t\tvar components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\n\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\n\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tvar hex = m[ 1 ];\n\t\t\tvar size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\n\n\t\t\t\treturn this;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( style && style.length > 0 ) {\n\n\t\t\t// color keywords\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\n\n\t\t\tif ( hex !== undefined ) {\n\n\t\t\t\t// red\n\t\t\t\tthis.setHex( hex );\n\n\t\t\t} else {\n\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tthis.r = Math.pow( color.r, gammaFactor );\n\t\tthis.g = Math.pow( color.g, gammaFactor );\n\t\tthis.b = Math.pow( color.b, gammaFactor );\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\n\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\n\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\n\n\t\tthis.r = Math.pow( color.r, safeInverse );\n\t\tthis.g = Math.pow( color.g, safeInverse );\n\t\tthis.b = Math.pow( color.b, safeInverse );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\n// File:src/math/Quaternion.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tvar order = euler.order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromUnitVectors: function () {\n\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tvar v1, r;\n\n\t\tvar EPS = 0.000001;\n\n\t\treturn function setFromUnitVectors( vFrom, vTo ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tr = vFrom.dot( vTo ) + 1;\n\n\t\t\tif ( r < EPS ) {\n\n\t\t\t\tr = 0;\n\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tv1.crossVectors( vFrom, vTo );\n\n\t\t\t}\n\n\t\t\tthis._x = v1.x;\n\t\t\tthis._y = v1.y;\n\t\t\tthis._z = v1.z;\n\t\t\tthis._w = r;\n\n\t\t\treturn this.normalize();\n\n\t\t};\n\n\t}(),\n\n\tinverse: function () {\n\n\t\treturn this.conjugate().normalize();\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tpremultiply: function ( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\nObject.assign( THREE.Quaternion, {\n\n\tslerp: function( qa, qb, qm, t ) {\n\n\t\treturn qm.copy( qa ).slerp( qb, t );\n\n\t},\n\n\tslerpFlat: function(\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\n\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tvar s = 1 - t,\n\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tvar tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n} );\n\n// File:src/math/Vector2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t},\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t},\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t},\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t},\n\n\t//\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector2();\n\t\t\t\tmax = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tlengthManhattan: function() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tangle: function () {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tvar angle = Math.atan2( this.y, this.x );\n\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\n\n\t\treturn angle;\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tdistanceToManhattan: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\n\t\treturn this;\n\n\t},\n\n\trotateAround: function ( center, angle ) {\n\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tvar x = this.x - center.x;\n\t\tvar y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyEuler( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t\t}\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion;\n\n\t\treturn function applyAxisAngle( axis, angle ) {\n\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\n\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t},\n\n\tproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function project( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\tunproject: function () {\n\n\t\tvar matrix;\n\n\t\treturn function unproject( camera ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\n\t\t\treturn this.applyProjection( matrix );\n\n\t\t};\n\n\t}(),\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector3();\n\t\t\t\tmax = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tclampLength: function ( min, max ) {\n\n\t\tvar length = this.length();\n\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\n\n\t},\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tprojectOnVector: function ( vector ) {\n\n\t\tvar scalar = vector.dot( this ) / vector.lengthSq();\n\t\n\t\treturn this.copy( vector ).multiplyScalar( scalar );\n\t\n\t},\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1;\n\n\t\treturn function projectOnPlane( planeNormal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t};\n\n\t}(),\n\n\treflect: function () {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\tvar v1;\n\n\t\treturn function reflect( normal ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t\t};\n\n\t}(),\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tdistanceToManhattan: function ( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t},\n\n\tsetFromSpherical: function( s ) {\n\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\treturn this.setFromMatrixColumn( m, 3 );\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixColumn: function ( m, index ) {\n\n\t\tif ( typeof m === 'number' ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\n\t\t\tvar temp = m\n\t\t\tm = index;\n\t\t\tindex = temp;\n\n\t\t}\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Vector4.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetScalar: function ( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScaledVector: function ( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubScalar: function ( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tif ( isFinite( scalar ) ) {\n\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t},\n\n\tclampScalar: function () {\n\n\t\tvar min, max;\n\n\t\treturn function clampScalar( minVal, maxVal ) {\n\n\t\t\tif ( min === undefined ) {\n\n\t\t\t\tmin = new THREE.Vector4();\n\t\t\t\tmax = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\n\n\t\t\treturn this.clamp( min, max );\n\n\t\t};\n\n\t}(),\n\n\tfloor: function () {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tceil: function () {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tround: function () {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t},\n\n\troundToZero: function () {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( length ) {\n\n\t\treturn this.multiplyScalar( length / this.length() );\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tlerpVectors: function ( v1, v2, alpha ) {\n\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t},\n\n\tfromAttribute: function ( attribute, index, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tindex = index * attribute.itemSize + offset;\n\n\t\tthis.x = attribute.array[ index ];\n\t\tthis.y = attribute.array[ index + 1 ];\n\t\tthis.z = attribute.array[ index + 2 ];\n\t\tthis.w = attribute.array[ index + 3 ];\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/math/Euler.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis.onChangeCallback();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order, update ) {\n\n\t\tvar clamp = THREE.Math.clamp;\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function () {\n\n\t\tvar matrix;\n\n\t\treturn function setFromQuaternion( q, order, update ) {\n\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\n\n\t\t\tmatrix.makeRotationFromQuaternion( q );\n\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\n\n\t\t};\n\n\t}(),\n\n\tsetFromVector3: function ( v, order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function reorder( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\t\n\t\t\treturn this.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis.onChangeCallback();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t},\n\n\ttoVector3: function ( optionalResult ) {\n\n\t\tif ( optionalResult ) {\n\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\n\n\t\t} else {\n\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\n\n\t\t}\n\n\t},\n\n\tonChange: function ( callback ) {\n\n\t\tthis.onChangeCallback = callback;\n\n\t\treturn this;\n\n\t},\n\n\tonChangeCallback: function () {}\n\n};\n\n// File:src/math/Line3.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function () {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function closestPointToPointParameter( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n};\n\n// File:src/math/Box2.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Box3.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromArray: function ( array ) {\n\n\t\tvar minX = + Infinity;\n\t\tvar minY = + Infinity;\n\t\tvar minZ = + Infinity;\n\n\t\tvar maxX = - Infinity;\n\t\tvar maxY = - Infinity;\n\t\tvar maxZ = - Infinity;\n\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tvar x = array[ i ];\n\t\t\tvar y = array[ i + 1 ];\n\t\t\tvar z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromCenterAndSize( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function () {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function setFromObject( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\tvar array, offset, stride;\n\n\t\t\t\t\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\t\t\tarray = attribute.data.array;\n\t\t\t\t\t\t\t\toffset = attribute.offset;\n\t\t\t\t\t\t\t\tstride = attribute.data.stride;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tarray = attribute.array;\n\t\t\t\t\t\t\t\toffset = 0;\n\t\t\t\t\t\t\t\tstride = 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor ( var i = offset, il = array.length; i < il; i += stride ) {\n\n\t\t\t\t\t\t\t\tv1.fromArray( array, i );\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tisEmpty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsSphere: ( function () {\n\n\t\tvar closestPoint;\n\n\t\treturn function intersectsSphere( sphere ) {\n\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\n\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\n\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t\t};\n\n\t} )(),\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tvar min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= plane.constant && max >= plane.constant );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function getBoundingSphere( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function applyMatrix4( matrix ) {\n\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif( this.isEmpty() ) return this;\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n};\n\n// File:src/math/Matrix3.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author tschw\n */\n\nTHREE.Matrix3 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0,\n\t\t0, 1, 0,\n\t\t0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix4: function( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix3( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix3( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\n\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\n\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\n\n\t\t}\n\n\t\tvar me = matrix.elements,\n\t\t\tte = this.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetNormalMatrix: function ( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Matrix4.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Matrix4 = function () {\n\n\tthis.elements = new Float32Array( [\n\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\n\t] );\n\n\tif ( arguments.length > 0 ) {\n\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t}\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0,       0,       0,       1\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1;\n\n\t\treturn function extractRotation( m ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[ 0 ] = 1 - ( yy + zz );\n\t\tte[ 4 ] = xy - wz;\n\t\tte[ 8 ] = xz + wy;\n\n\t\tte[ 1 ] = xy + wz;\n\t\tte[ 5 ] = 1 - ( xx + zz );\n\t\tte[ 9 ] = yz - wx;\n\n\t\tte[ 2 ] = xz - wy;\n\t\tte[ 6 ] = yz + wx;\n\t\tte[ 10 ] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// bottom row\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function () {\n\n\t\tvar x, y, z;\n\n\t\treturn function lookAt( eye, target, up ) {\n\n\t\t\tif ( x === undefined ) {\n\n\t\t\t\tx = new THREE.Vector3();\n\t\t\t\ty = new THREE.Vector3();\n\t\t\t\tz = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.lengthSq() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.lengthSq() === 0 ) {\n\n\t\t\t\tz.z += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tpremultiply: function ( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tapplyToVector3Array: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToVector3Array( array, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = array.length;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\n\n\t\t\t\tv1.fromArray( array, j );\n\t\t\t\tv1.applyMatrix4( this );\n\t\t\t\tv1.toArray( array, j );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t};\n\n\t}(),\n\n\tapplyToBuffer: function () {\n\n\t\tvar v1;\n\n\t\treturn function applyToBuffer( buffer, offset, length ) {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tif ( offset === undefined ) offset = 0;\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\n\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\n\n\t\t\t\tv1.x = buffer.getX( j );\n\t\t\t\tv1.y = buffer.getY( j );\n\t\t\t\tv1.z = buffer.getZ( j );\n\n\t\t\t\tv1.applyMatrix4( this );\n\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\n\n\t\t\t}\n\n\t\t\treturn buffer;\n\n\t\t};\n\n\t}(),\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArrayOffset: function ( array, offset ) {\n\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\n\t\t\t\t\"- just use .toArray instead.\" );\n\n\t\treturn this.toArray( array, offset );\n\n\t},\n\n\tgetPosition: function () {\n\n\t\tvar v1;\n\n\t\treturn function getPosition() {\n\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[ 12 ] = v.x;\n\t\tte[ 13 ] = v.y;\n\t\tte[ 14 ] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnDegenerate ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnDegenerate || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\treturn this.identity();\n\n\t\t}\n\t\t\n\t\tvar detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector, matrix;\n\n\t\treturn function decompose( position, quaternion, scale ) {\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tvector = new THREE.Vector3();\n\t\t\t\tmatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif ( det < 0 ) {\n\n\t\t\t\tsx = - sx;\n\n\t\t\t}\n\n\t\t\tposition.x = te[ 12 ];\n\t\t\tposition.y = te[ 13 ];\n\t\t\tposition.z = te[ 14 ];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[ 0 ] *= invSX;\n\t\t\tmatrix.elements[ 1 ] *= invSX;\n\t\t\tmatrix.elements[ 2 ] *= invSX;\n\n\t\t\tmatrix.elements[ 4 ] *= invSY;\n\t\t\tmatrix.elements[ 5 ] *= invSY;\n\t\t\tmatrix.elements[ 6 ] *= invSY;\n\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = 1.0 / ( right - left );\n\t\tvar h = 1.0 / ( top - bottom );\n\t\tvar p = 1.0 / ( far - near );\n\n\t\tvar x = ( right + left ) * w;\n\t\tvar y = ( top + bottom ) * h;\n\t\tvar z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( matrix ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = matrix.elements;\n\n\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function ( array, offset ) {\n\n\t\tif ( array === undefined ) array = [];\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ]  = te[ 8 ];\n\t\tarray[ offset + 9 ]  = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n};\n\n// File:src/math/Ray.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\tlookAt: function ( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function recast( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t},\n\n\tdistanceSqToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function distanceSqToPoint( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceToSquared( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function () {\n\n\t\tvar segCenter = new THREE.Vector3();\n\t\tvar segDir = new THREE.Vector3();\n\t\tvar diff = new THREE.Vector3();\n\n\t\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\n\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\t\tvar a01 = - this.direction.dot( segDir );\n\t\t\tvar b0 = diff.dot( this.direction );\n\t\t\tvar b1 = - diff.dot( segDir );\n\t\t\tvar c = diff.lengthSq();\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\t\tvar s0, s1, sqrDist, extDet;\n\n\t\t\tif ( det > 0 ) {\n\n\t\t\t\t// The ray and segment are not parallel.\n\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 5\n\n\t\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t\t// region 4\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 3\n\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 2\n\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Ray and segment are parallel.\n\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnRay ) {\n\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t\t}\n\n\t\t\tif ( optionalPointOnSegment ) {\n\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\n\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\n\t\t};\n\n\t}(),\n\n\tintersectSphere: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectSphere( sphere, optionalTarget ) {\n\n\t\t\tv1.subVectors( sphere.center, this.origin );\n\t\t\tvar tca = v1.dot( this.direction );\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\n\n\t\t\tif ( d2 > radius2 ) return null;\n\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\n\n\t\t\t// t0 = first intersect point - entrance on front of sphere\n\t\t\tvar t0 = tca - thc;\n\n\t\t\t// t1 = second intersect point - exit point on back of sphere\n\t\t\tvar t1 = tca + thc;\n\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t\t// test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\n\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\t\treturn this.at( t0, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tintersectBox: function ( box, optionalTarget ) {\n\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tvar invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectsBox: ( function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t};\n\n\t} )(),\n\n\tintersectTriangle: function () {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\n\t\t};\n\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n};\n\n// File:src/math/Sphere.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function setFromPoints( points, optionalCenter ) {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t},\n\n\tintersectsPlane: function ( plane ) {\n\n\t\t// We use the following equation to compute the signed distance from\n\t\t// the center of the sphere to the plane.\n\t\t//\n\t\t// distance = q * n - d\n\t\t//\n\t\t// If this distance is greater than the radius of the sphere,\n\t\t// then there is no intersection.\n\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n};\n\n// File:src/math/Frustum.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsObject( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null )\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere )\n\t\t\t\t.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSprite: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function intersectsSprite( sprite ) {\n\n\t\t\tsphere.center.set( 0, 0, 0 );\n\t\t\tsphere.radius = 0.7071067811865476;\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = - sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox: function () {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function intersectsBox( box ) {\n\n\t\t\tvar planes = this.planes;\n\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\n\t\t\t\tvar plane = planes[ i ];\n\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n};\n\n// File:src/math/Plane.js\n\n/**\n * @author bhouston / http://clara.io\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function setFromCoplanarPoints( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tintersectLine: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function intersectLine( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator === 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\tintersectsLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectsBox: function ( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t},\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\n\n\t\t\t// transform normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n};\n\n// File:src/math/Spherical.js\n\n/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The poles (phi) are at the positive and negative y axis.\n * The equator starts at positive z.\n */\n\nTHREE.Spherical = function ( radius, phi, theta ) {\n\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\n\n\treturn this;\n\n};\n\nTHREE.Spherical.prototype = {\n\n\tconstructor: THREE.Spherical,\n\n\tset: function ( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( other ) {\n\n\t\tthis.radius.copy( other.radius );\n\t\tthis.phi.copy( other.phi );\n\t\tthis.theta.copy( other.theta );\n\n\t\treturn this;\n\n\t},\n\n\t// restrict phi to be betwee EPS and PI-EPS\n\tmakeSafe: function() {\n\n\t\tvar EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromVector3: function( vec3 ) {\n\n\t\tthis.radius = vec3.length();\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n};\n\n// File:src/math/Math.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tDEG2RAD: Math.PI / 180,\n\tRAD2DEG: 180 / Math.PI,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\n\t\tvar uuid = new Array( 36 );\n\t\tvar rnd = 0, r;\n\n\t\treturn function generateUUID() {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\n\n\t\t\t\t\tuuid[ i ] = '-';\n\n\t\t\t\t} else if ( i === 14 ) {\n\n\t\t\t\t\tuuid[ i ] = '4';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn uuid.join( '' );\n\n\t\t};\n\n\t}(),\n\n\tclamp: function ( value, min, max ) {\n\n\t\treturn Math.max( min, Math.min( max, value ) );\n\n\t},\n\n\t// compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\teuclideanModulo: function ( n, m ) {\n\n\t\treturn ( ( n % m ) + m ) % m;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * ( 3 - 2 * x );\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min ) / ( max - min );\n\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n\t},\n\n\trandom16: function () {\n\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\n\t\treturn Math.random();\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tdegToRad: function ( degrees ) {\n\n\t\treturn degrees * THREE.Math.DEG2RAD;\n\n\t},\n\n\tradToDeg: function ( radians ) {\n\n\t\treturn radians * THREE.Math.RAD2DEG;\n\n\t},\n\n\tisPowerOfTwo: function ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n\t},\n\n\tnearestPowerOfTwo: function ( value ) {\n\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\n\n\t},\n\n\tnextPowerOfTwo: function ( value ) {\n\n\t\tvalue --;\n\t\tvalue |= value >> 1;\n\t\tvalue |= value >> 2;\n\t\tvalue |= value >> 4;\n\t\tvalue |= value >> 8;\n\t\tvalue |= value >> 16;\n\t\tvalue ++;\n\n\t\treturn value;\n\n\t}\n\n};\n\n// File:src/math/Spline.js\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function ( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint !== oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\trealDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/math/Triangle.js\n\n/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function () {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function normal( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif ( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function () {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function () {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function containsPoint( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function () {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function area() {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tclosestPointToPoint: function () {\n\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\n\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\n\n\t\t\tif ( plane === undefined ) {\n\n\t\t\t\tplane = new THREE.Plane();\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\n\t\t\t\tprojectedPoint = new THREE.Vector3();\n\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\t\tvar minDistance = Infinity;\n\n\t\t\t// project the point onto the plane of the triangle\n\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\n\t\t\tplane.projectPoint( point, projectedPoint );\n\n\t\t\t// check if the projection lies within the triangle\n\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\n\n\t\t\t\t// if so, this is the closest point\n\n\t\t\t\tresult.copy( projectedPoint );\n\n\t\t\t} else {\n\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\n\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\n\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\n\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\n\n\t\t\t\t\tif( distance < minDistance ) {\n\n\t\t\t\t\t\tminDistance = distance;\n\n\t\t\t\t\t\tresult.copy( closestPoint );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n};\n\n// File:src/math/Interpolant.js\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n * @author tschw\n */\n\nTHREE.Interpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tthis.parameterPositions = parameterPositions;\n\tthis._cachedIndex = 0;\n\n\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\tthis.sampleValues = sampleValues;\n\tthis.valueSize = sampleSize;\n\n};\n\nTHREE.Interpolant.prototype = {\n\n\tconstructor: THREE.Interpolant,\n\n\tevaluate: function( t ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\ti1 = this._cachedIndex,\n\n\t\t\tt1 = pp[   i1   ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tvar right;\n\n\t\t\t\tlinear_scan: {\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[   i1   ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t},\n\n\tsettings: null, // optional, subclass-specific settings structure\n\t// Note: The indirection allows central control of many interpolants.\n\n\t// --- Protected interface\n\n\tDefaultSettings_: {},\n\n\tgetSettings_: function() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t},\n\n\tcopySampleValue_: function( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Template methods for derived classes:\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tthrow new Error( \"call to abstract method\" );\n\t\t// implementations shall return this.resultBuffer\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\t// empty\n\n\t}\n\n};\n\nObject.assign( THREE.Interpolant.prototype, {\n\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\n\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\n\t\tTHREE.Interpolant.prototype.copySampleValue_\n\n} );\n\n// File:src/math/interpolants/CubicInterpolant.js\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n *\n * @author tschw\n */\n\nTHREE.CubicInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\tthis._weightPrev = -0;\n\tthis._offsetPrev = -0;\n\tthis._weightNext = -0;\n\tthis._offsetNext = -0;\n\n};\n\nTHREE.CubicInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.CubicInterpolant,\n\n\tDefaultSettings_: {\n\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\n\t},\n\n\tintervalChanged_: function( i1, t0, t1 ) {\n\n\t\tvar pp = this.parameterPositions,\n\t\t\tiPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase THREE.ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t},\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/DiscreteInterpolant.js\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceeding\n * the parameter.\n *\n * @author tschw\n */\n\nTHREE.DiscreteInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.DiscreteInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.DiscreteInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n} );\n\n// File:src/math/interpolants/LinearInterpolant.js\n\n/**\n * @author tschw\n */\n\nTHREE.LinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.LinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.LinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\n\n/**\n * Spherical linear unit quaternion interpolant.\n *\n * @author tschw\n */\n\nTHREE.QuaternionLinearInterpolant = function(\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\tTHREE.Interpolant.call(\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n};\n\nTHREE.QuaternionLinearInterpolant.prototype =\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\tconstructor: THREE.QuaternionLinearInterpolant,\n\n\tinterpolate_: function( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset = i1 * stride,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n} );\n\n// File:src/core/Clock.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = ( performance || Date ).now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = ( performance || Date ).now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n// File:src/core/EventDispatcher.js\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {};\n\nObject.assign( THREE.EventDispatcher.prototype, {\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function ( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\tvar array = [], i = 0;\n\t\t\tvar length = listenerArray.length;\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/core/Layers.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Layers = function () {\n\n\tthis.mask = 1;\n\n};\n\nTHREE.Layers.prototype = {\n\n\tconstructor: THREE.Layers,\n\n\tset: function ( channel ) {\n\n\t\tthis.mask = 1 << channel;\n\n\t},\n\n\tenable: function ( channel ) {\n\n\t\tthis.mask |= 1 << channel;\n\n\t},\n\n\ttoggle: function ( channel ) {\n\n\t\tthis.mask ^= 1 << channel;\n\n\t},\n\n\tdisable: function ( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel );\n\n\t},\n\n\ttest: function ( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n};\n\n// File:src/core/Raycaster.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://clara.io/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: {},\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t\tObject.defineProperties( this.params, {\n\t\t\tPointCloud: {\n\t\t\t\tget: function () {\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\n\t\t\t\t\treturn this.Points;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\n\t};\n\n\tfunction ascSort( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t}\n\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tvar children = object.children;\n\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tTHREE.Raycaster.prototype = {\n\n\t\tconstructor: THREE.Raycaster,\n\n\t\tlinePrecision: 1,\n\n\t\tset: function ( origin, direction ) {\n\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.ray.set( origin, direction );\n\n\t\t},\n\n\t\tsetFromCamera: function ( coords, camera ) {\n\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tintersectObject: function ( object, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tintersectObject( object, this, intersects, recursive );\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t},\n\n\t\tintersectObjects: function ( objects, recursive ) {\n\n\t\t\tvar intersects = [];\n\n\t\t\tif ( Array.isArray( objects ) === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t\t}\n\n\t\t\tintersects.sort( ascSort );\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t};\n\n}( THREE ) );\n\n// File:src/core/Object3D.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n */\n\nTHREE.Object3D = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Object3D';\n\n\tthis.parent = null;\n\tthis.children = [];\n\n\tthis.up = THREE.Object3D.DefaultUp.clone();\n\n\tvar position = new THREE.Vector3();\n\tvar rotation = new THREE.Euler();\n\tvar quaternion = new THREE.Quaternion();\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\n\n\tfunction onRotationChange() {\n\n\t\tquaternion.setFromEuler( rotation, false );\n\n\t}\n\n\tfunction onQuaternionChange() {\n\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t}\n\n\trotation.onChange( onRotationChange );\n\tquaternion.onChange( onQuaternionChange );\n\n\tObject.defineProperties( this, {\n\t\tposition: {\n\t\t\tenumerable: true,\n\t\t\tvalue: position\n\t\t},\n\t\trotation: {\n\t\t\tenumerable: true,\n\t\t\tvalue: rotation\n\t\t},\n\t\tquaternion: {\n\t\t\tenumerable: true,\n\t\t\tvalue: quaternion\n\t\t},\n\t\tscale: {\n\t\t\tenumerable: true,\n\t\t\tvalue: scale\n\t\t},\n\t\tmodelViewMatrix: {\n\t\t\tvalue: new THREE.Matrix4()\n\t\t},\n\t\tnormalMatrix: {\n\t\t\tvalue: new THREE.Matrix3()\n\t\t}\n\t} );\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\n\tthis.matrixWorldNeedsUpdate = false;\n\n\tthis.layers = new THREE.Layers();\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\tthis.renderOrder = 0;\n\n\tthis.userData = {};\n\n};\n\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\n\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function () {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function rotateOnAxis( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function translateOnAxis( axis, distance ) {\n\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function translateX( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function translateY( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function translateZ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function worldToLocal( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t} else {\n\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t},\n\n\tgetObjectByName: function ( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t},\n\n\tgetObjectByProperty: function ( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\t\t\tvar object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetWorldPosition: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.updateMatrixWorld( true );\n\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\n\n\t},\n\n\tgetWorldQuaternion: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function getWorldQuaternion( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldRotation: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldRotation( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Euler();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\n\n\t\t};\n\n\t}(),\n\n\tgetWorldScale: function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldScale( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tgetWorldDirection: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function getWorldDirection( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tthis.getWorldQuaternion( quaternion );\n\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\n\n\t\t};\n\n\t}(),\n\n\traycast: function () {},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseVisible: function ( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tvar children = this.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t},\n\n\ttraverseAncestors: function ( callback ) {\n\n\t\tvar parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\t// meta is '' when called from JSON.stringify\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\n\n\t\tvar output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tvar object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\n\t\tobject.matrix = this.matrix.toArray();\n\n\t\t//\n\n\t\tif ( this.geometry !== undefined ) {\n\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\n\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.geometry = this.geometry.uuid;\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\n\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\n\n\t\t\t}\n\n\t\t\tobject.material = this.material.uuid;\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tvar geometries = extractFromCache( meta.geometries );\n\t\t\tvar materials = extractFromCache( meta.materials );\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\t\t\treturn values;\n\n\t\t}\n\n\t},\n\n\tclone: function ( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t},\n\n\tcopy: function ( source, recursive ) {\n\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tvar child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n} );\n\nTHREE.Object3DIdCount = 0;\n\n// File:src/core/Face3.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/BufferAttribute.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.itemSize = itemSize;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\tthis.normalized = normalized === true;\n\n};\n\nTHREE.BufferAttribute.prototype = {\n\n\tconstructor: THREE.BufferAttribute,\n\n\tget count() {\n\n\t\treturn this.array.length / this.itemSize;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyArray: function ( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t},\n\n\tcopyColorsArray: function ( colors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\tvar color = colors[ i ];\n\n\t\t\tif ( color === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\n\t\t\t\tcolor = new THREE.Color();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = color.r;\n\t\t\tarray[ offset ++ ] = color.g;\n\t\t\tarray[ offset ++ ] = color.b;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyIndicesArray: function ( indices ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\tvar index = indices[ i ];\n\n\t\t\tarray[ offset ++ ] = index.a;\n\t\t\tarray[ offset ++ ] = index.b;\n\t\t\tarray[ offset ++ ] = index.c;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector2sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector2();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector3sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcopyVector4sArray: function ( vectors ) {\n\n\t\tvar array = this.array, offset = 0;\n\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tvar vector = vectors[ i ];\n\n\t\t\tif ( vector === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\n\t\t\t\tvector = new THREE.Vector4();\n\n\t\t\t}\n\n\t\t\tarray[ offset ++ ] = vector.x;\n\t\t\tarray[ offset ++ ] = vector.y;\n\t\t\tarray[ offset ++ ] = vector.z;\n\t\t\tarray[ offset ++ ] = vector.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize ];\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 1 ];\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 2 ];\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.array[ index * this.itemSize + 3 ];\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n//\n\nTHREE.Int8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\n\n};\n\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\n\n};\n\nTHREE.Int16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\n\n};\n\nTHREE.Uint16Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\n\n};\n\nTHREE.Int32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\n\n};\n\nTHREE.Uint32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\n\n};\n\nTHREE.Float32Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\n\n};\n\nTHREE.Float64Attribute = function ( array, itemSize ) {\n\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\n\n};\n\n\n// Deprecated\n\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\n\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\n\n};\n\n// File:src/core/InstancedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\n\n\tTHREE.BufferAttribute.call( this, array, itemSize );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\n\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\n\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBuffer = function ( array, stride ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.array = array;\n\tthis.stride = stride;\n\n\tthis.dynamic = false;\n\tthis.updateRange = { offset: 0, count: - 1 };\n\n\tthis.version = 0;\n\n};\n\nTHREE.InterleavedBuffer.prototype = {\n\n\tconstructor: THREE.InterleavedBuffer,\n\n\tget length () {\n\n\t\treturn this.array.length;\n\n\t},\n\n\tget count () {\n\n\t\treturn this.array.length / this.stride;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tsetDynamic: function ( value ) {\n\n\t\tthis.dynamic = value;\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.stride = source.stride;\n\t\tthis.dynamic = source.dynamic;\n\n\t\treturn this;\n\n\t},\n\n\tcopyAt: function ( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tset: function ( value, offset ) {\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n};\n\n// File:src/core/InstancedInterleavedBuffer.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\n\n\tTHREE.InterleavedBuffer.call( this, array, stride );\n\n\tthis.meshPerAttribute = meshPerAttribute || 1;\n\n};\n\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\n\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\n\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\n\n\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\treturn this;\n\n};\n\n// File:src/core/InterleavedBufferAttribute.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset, normalized ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.data = interleavedBuffer;\n\tthis.itemSize = itemSize;\n\tthis.offset = offset;\n\n\tthis.normalized = normalized === true;\n\n};\n\n\nTHREE.InterleavedBufferAttribute.prototype = {\n\n\tconstructor: THREE.InterleavedBufferAttribute,\n\n\tget length() {\n\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\treturn this.array.length;\n\n\t},\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t},\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t},\n\n\tsetX: function ( index, x ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( index, y ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( index, z ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( index, w ) {\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t},\n\n\tgetX: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\n\n\t},\n\n\tgetY: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t},\n\n\tgetZ: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t},\n\n\tgetW: function ( index ) {\n\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t},\n\n\tsetXY: function ( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZ: function ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetXYZW: function ( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/core/Geometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://clara.io\n */\n\nTHREE.Geometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [ [] ];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tvar scope = this;\n\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar positions = attributes.position.array;\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\n\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tvar tempNormals = [];\n\t\tvar tempUVs = [];\n\t\tvar tempUVs2 = [];\n\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\n\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\n\n\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\n\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t\tif ( uvs2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices !== undefined ) {\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\n\n\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tvar center = this.boundingSphere.center;\n\t\tvar radius = this.boundingSphere.radius;\n\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\n\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalMatrix,\n\t\tvertexOffset = this.vertices.length,\n\t\tvertices1 = this.vertices,\n\t\tvertices2 = geometry.vertices,\n\t\tfaces1 = this.faces,\n\t\tfaces2 = geometry.faces,\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tif ( uv === undefined ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i, il, face;\n\t\tvar indices, j, jl;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = - 1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tvar faces = this.faces;\n\t\tvar length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tvar newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\tvar id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tvar faces = [];\n\t\tvar normals = [];\n\t\tvar normalsHash = {};\n\t\tvar colors = [];\n\t\tvar colorsHash = {};\n\t\tvar uvs = [];\n\t\tvar uvsHash = {};\n\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\n\t\t\tvar hasMaterial = true;\n\t\t\tvar hasFaceUv = false; // deprecated\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tvar faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.vertices = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [ [] ];\n\n\t\tvar vertices = source.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = source.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tvar uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.GeometryIdCount = 0;\n\n// File:src/core/DirectGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'DirectGeometry';\n\n\tthis.indices = [];\n\tthis.vertices = [];\n\tthis.normals = [];\n\tthis.colors = [];\n\tthis.uvs = [];\n\tthis.uvs2 = [];\n\n\tthis.groups = [];\n\n\tthis.morphTargets = {};\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\t// this.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n};\n\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\n\n\tcomputeFaceNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\n\n\t},\n\n\tcomputeGroups: function ( geometry ) {\n\n\t\tvar group;\n\t\tvar groups = [];\n\t\tvar materialIndex;\n\n\t\tvar faces = geometry.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tvar faces = geometry.faces;\n\t\tvar vertices = geometry.vertices;\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tvar morphTargets = geometry.morphTargets;\n\t\tvar morphTargetsLength = morphTargets.length;\n\n\t\tvar morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tvar morphNormals = geometry.morphNormals;\n\t\tvar morphNormalsLength = morphNormals.length;\n\n\t\tvar morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = [];\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tvar skinIndices = geometry.skinIndices;\n\t\tvar skinWeights = geometry.skinWeights;\n\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tvar vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tvar vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tvar color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/core/BufferGeometry.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'BufferGeometry';\n\n\tthis.index = null;\n\tthis.attributes = {};\n\n\tthis.morphAttributes = {};\n\n\tthis.groups = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.drawRange = { start: 0, count: Infinity };\n\n};\n\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\n\n\tgetIndex: function () {\n\n\t\treturn this.index;\n\n\t},\n\n\tsetIndex: function ( index ) {\n\n\t\tthis.index = index;\n\n\t},\n\n\taddAttribute: function ( name, attribute ) {\n\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\n\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( name === 'index' ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\n\t\t\tthis.setIndex( attribute );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t},\n\n\tgetAttribute: function ( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t},\n\n\tremoveAttribute: function ( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t},\n\n\taddGroup: function ( start, count, materialIndex ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\n\n\t\t} );\n\n\t},\n\n\tclearGroups: function () {\n\n\t\tthis.groups = [];\n\n\t},\n\n\tsetDrawRange: function ( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tmatrix.applyToVector3Array( position.array );\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tvar normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function () {\n\n\t\t// rotate geometry around world x-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateX( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationX( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\t// rotate geometry around world y-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateY( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationY( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\t// rotate geometry around world z-axis\n\n\t\tvar m1;\n\n\t\treturn function rotateZ( angle ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeRotationZ( angle );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function () {\n\n\t\t// translate geometry\n\n\t\tvar m1;\n\n\t\treturn function translate( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeTranslation( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tscale: function () {\n\n\t\t// scale geometry\n\n\t\tvar m1;\n\n\t\treturn function scale( x, y, z ) {\n\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\n\n\t\t\tm1.makeScale( x, y, z );\n\n\t\t\tthis.applyMatrix( m1 );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\tvar obj;\n\n\t\treturn function lookAt( vector ) {\n\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\n\n\t\t\tobj.lookAt( vector );\n\n\t\t\tobj.updateMatrix();\n\n\t\t\tthis.applyMatrix( obj.matrix );\n\n\t\t};\n\n\t}(),\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tvar offset = this.boundingBox.center().negate();\n\n\t\tthis.translate( offset.x, offset.y, offset.z );\n\n\t\treturn offset;\n\n\t},\n\n\tsetFromObject: function ( object ) {\n\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\n\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\n\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\n\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t\t}\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tthis.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tupdateFromObject: function ( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar direct = geometry.__directGeometry;\n\n\t\t\tif ( direct === undefined || geometry.elementsNeedUpdate === true ) {\n\n\t\t\t\treturn this.fromGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate || geometry.elementsNeedUpdate;\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate || geometry.elementsNeedUpdate;\n\n\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t\tgeometry = direct;\n\n\t\t}\n\n\t\tvar attribute;\n\n\t\tif ( geometry.verticesNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.position;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.normalsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.normal;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.normalsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.colorsNeedUpdate === true ) {\n\n\t\t\tattribute = this.attributes.color;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.uvsNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.uv;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.uvsNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\n\n\t\t\tattribute = this.attributes.lineDistance;\n\n\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\n\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t}\n\n\t\tif ( geometry.groupsNeedUpdate ) {\n\n\t\t\tgeometry.computeGroups( object.geometry );\n\t\t\tthis.groups = geometry.groups;\n\n\t\t\tgeometry.groupsNeedUpdate = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tfromGeometry: function ( geometry ) {\n\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\n\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\n\n\t},\n\n\tfromDirectGeometry: function ( geometry ) {\n\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\tif ( geometry.indices.length > 0 ) {\n\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tthis.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( var name in geometry.morphTargets ) {\n\n\t\t\tvar array = [];\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tvar morphTarget = morphTargets[ i ];\n\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes.position.array;\n\n\t\tif ( positions !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromArray( positions );\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function computeBoundingSphere() {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes.position;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tvar array = positions.array;\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tbox.setFromArray( array );\n\t\t\t\tbox.center( center );\n\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.fromArray( array, i );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tcomputeFaceNormals: function () {\n\n\t\t// backwards compatibility\n\n\t},\n\n\tcomputeVertexNormals: function () {\n\n\t\tvar index = this.index;\n\t\tvar attributes = this.attributes;\n\t\tvar groups = this.groups;\n\n\t\tif ( attributes.position ) {\n\n\t\t\tvar positions = attributes.position.array;\n\n\t\t\tif ( attributes.normal === undefined ) {\n\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tvar array = attributes.normal.array;\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar normals = attributes.normal.array;\n\n\t\t\tvar vA, vB, vC,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar indices = index.array;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tthis.addGroup( 0, indices.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar group = groups[ j ];\n\n\t\t\t\t\tvar start = group.start;\n\t\t\t\t\tvar count = group.count;\n\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\n\n\t\t\t\t\t\tpA.fromArray( positions, vA );\n\t\t\t\t\t\tpB.fromArray( positions, vB );\n\t\t\t\t\t\tpC.fromArray( positions, vC );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tpA.fromArray( positions, i );\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tattributes.normal.needsUpdate = true;\n\n\t\t}\n\n\t},\n\n\tmerge: function ( geometry, offset ) {\n\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) offset = 0;\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tvar attribute1 = attributes[ key ];\n\t\t\tvar attributeArray1 = attribute1.array;\n\n\t\t\tvar attribute2 = geometry.attributes[ key ];\n\t\t\tvar attributeArray2 = attribute2.array;\n\n\t\t\tvar attributeSize = attribute2.itemSize;\n\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes.normal.array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\ttoNonIndexed: function () {\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar geometry2 = new THREE.BufferGeometry();\n\n\t\tvar indices = this.index.array;\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\n\t\t\tvar array = attribute.array;\n\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tvar index = 0, index2 = 0;\n\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tdata.data = { attributes: {} };\n\n\t\tvar index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar array = Array.prototype.slice.call( index.array );\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: array\n\t\t\t};\n\n\t\t}\n\n\t\tvar attributes = this.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\n\n\t\t\tdata.data.attributes[ key ] = {\n\t\t\t\titemSize: attribute.itemSize,\n\t\t\t\ttype: attribute.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: attribute.normalized\n\t\t\t};\n\n\t\t}\n\n\t\tvar groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tvar boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t// Handle primitives\n\n\t\tvar parameters = this.parameters;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t}\n\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\tthis.constructor.apply( geometry, values );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\treturn new this.constructor().copy( this );\n\t\t*/\n\n\t\treturn new THREE.BufferGeometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tvar index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone() );\n\n\t\t}\n\n\t\tvar attributes = source.attributes;\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar attribute = attributes[ name ];\n\t\t\tthis.addAttribute( name, attribute.clone() );\n\n\t\t}\n\n\t\tvar groups = source.groups;\n\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tvar group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nTHREE.BufferGeometry.MaxIndex = 65535;\n\n// File:src/core/InstancedBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.InstancedBufferGeometry = function () {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'InstancedBufferGeometry';\n\tthis.maxInstancedCount = undefined;\n\n};\n\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\n\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\n\n\tthis.groups.push( {\n\n\t\tstart: start,\n\t\tcount: count,\n\t\tinstances: instances\n\n\t} );\n\n};\n\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\n\n\tvar index = source.index;\n\n\tif ( index !== null ) {\n\n\t\tthis.setIndex( index.clone() );\n\n\t}\n\n\tvar attributes = source.attributes;\n\n\tfor ( var name in attributes ) {\n\n\t\tvar attribute = attributes[ name ];\n\t\tthis.addAttribute( name, attribute.clone() );\n\n\t}\n\n\tvar groups = source.groups;\n\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tvar group = groups[ i ];\n\t\tthis.addGroup( group.start, group.count, group.instances );\n\n\t}\n\n\treturn this;\n\n};\n\n// File:src/core/Uniform.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Uniform = function ( value ) {\n\n\tif ( typeof value === 'string' ) {\n\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\n\t\tvalue = arguments[ 1 ];\n\n\t}\n\n\tthis.value = value;\n\n\tthis.dynamic = false;\n\n};\n\nTHREE.Uniform.prototype = {\n\n\tconstructor: THREE.Uniform,\n\n\tonUpdate: function ( callback ) {\n\n\t\tthis.dynamic = true;\n\t\tthis.onUpdateCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n};\n\n// File:src/animation/AnimationAction.js\n\n/**\n *\n * Action provided by AnimationMixer for scheduling clip playback on specific\n * objects.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n *\n */\n\nTHREE.AnimationAction = function() {\n\n\tthrow new Error( \"THREE.AnimationAction: \" +\n\t\t\t\"Use mixer.clipAction for construction.\" );\n\n};\n\nTHREE.AnimationAction._new =\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\n\n\tthis._mixer = mixer;\n\tthis._clip = clip;\n\tthis._localRoot = localRoot || null;\n\n\tvar tracks = clip.tracks,\n\t\tnTracks = tracks.length,\n\t\tinterpolants = new Array( nTracks );\n\n\tvar interpolantSettings = {\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\n\t};\n\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\n\t\tinterpolants[ i ] = interpolant;\n\t\tinterpolant.settings = interpolantSettings;\n\n\t}\n\n\tthis._interpolantSettings = interpolantSettings;\n\n\tthis._interpolants = interpolants;\t// bound by the mixer\n\n\t// inside: PropertyMixer (managed by the mixer)\n\tthis._propertyBindings = new Array( nTracks );\n\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\n\n\tthis._timeScaleInterpolant = null;\n\tthis._weightInterpolant = null;\n\n\tthis.loop = THREE.LoopRepeat;\n\tthis._loopCount = -1;\n\n\t// global mixer time when the action is to be started\n\t// it's set back to 'null' upon start of the action\n\tthis._startTime = null;\n\n\t// scaled local time of the action\n\t// gets clamped or wrapped to 0..clip.duration according to loop\n\tthis.time = 0;\n\n\tthis.timeScale = 1;\n\tthis._effectiveTimeScale = 1;\n\n\tthis.weight = 1;\n\tthis._effectiveWeight = 1;\n\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\n\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\n\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\n\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\n\n};\n\nTHREE.AnimationAction._new.prototype = {\n\n\tconstructor: THREE.AnimationAction._new,\n\n\t// State & Scheduling\n\n\tplay: function() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t},\n\n\tstop: function() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t},\n\n\treset: function() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0;\t\t\t// restart clip\n\t\tthis._loopCount = -1;\t// forget previous loops\n\t\tthis._startTime = null;\t// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t},\n\n\tisRunning: function() {\n\n\t\tvar start = this._startTime;\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t},\n\n\t// return true when play has been called\n\tisScheduled: function() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t},\n\n\tstartAt: function( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t},\n\n\tsetLoop: function( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t},\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight: function( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t},\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight: function() {\n\n\t\treturn this._effectiveWeight;\n\n\t},\n\n\tfadeIn: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t},\n\n\tfadeOut: function( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t},\n\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\n\n\t\tvar mixer = this._mixer;\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif( warp ) {\n\n\t\t\tvar fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t},\n\n\tstopFading: function() {\n\n\t\tvar weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Time Scale Control\n\n\t// set the weight stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale: function( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale: function() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t},\n\n\tsetDuration: function( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\tsyncWith: function( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t},\n\n\thalt: function( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t},\n\n\twarp: function( startTimeScale, endTimeScale, duration ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._timeScaleInterpolant,\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t},\n\n\tstopWarping: function() {\n\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// Object Accessors\n\n\tgetMixer: function() {\n\n\t\treturn this._mixer;\n\n\t},\n\n\tgetClip: function() {\n\n\t\treturn this._clip;\n\n\t},\n\n\tgetRoot: function() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t},\n\n\t// Interna\n\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\n\t\t// called by the mixer\n\n\t\tvar startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tthis._startTime = null; // unschedule\n\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tvar clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tvar weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tvar interpolants = this._interpolants;\n\t\t\tvar propertyMixers = this._propertyBindings;\n\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_updateWeight: function( time ) {\n\n\t\tvar weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tvar interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t},\n\n\t_updateTimeScale: function( time ) {\n\n\t\tvar timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tvar interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t},\n\n\t_updateTime: function( deltaTime ) {\n\n\t\tvar time = this.time + deltaTime;\n\n\t\tif ( deltaTime === 0 ) return time;\n\n\t\tvar duration = this._clip.duration,\n\n\t\t\tloop = this.loop,\n\t\t\tloopCount = this._loopCount;\n\n\t\tif ( loop === THREE.LoopOnce ) {\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tthis.loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else break handle_stop;\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\n\n\t\t\tif ( loopCount === -1 ) {\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings(\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\t\t\t\t// wrap around\n\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tvar pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending < 0 ) {\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 0 ) {\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\tthis.time = time;\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.time = time;\n\t\treturn time;\n\n\t},\n\n\t_setEndings: function( atStart, atEnd, pingPong ) {\n\n\t\tvar settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\n\n\t\tvar mixer = this._mixer, now = mixer.time,\n\t\t\tinterpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tvar times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationClip.js\n\n/**\n *\n * Reusable set of Tracks that represent an animation.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationClip = function ( name, duration, tracks ) {\n\n\tthis.name = name;\n\tthis.tracks = tracks;\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// this means it should figure out its duration by scanning the tracks\n\tif ( this.duration < 0 ) {\n\n\t\tthis.resetDuration();\n\n\t}\n\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\n\t// but leaving these here during development as this ensures a lot of testing of these functions\n\tthis.trim();\n\tthis.optimize();\n\n};\n\nTHREE.AnimationClip.prototype = {\n\n\tconstructor: THREE.AnimationClip,\n\n\tresetDuration: function() {\n\n\t\tvar tracks = this.tracks,\n\t\t\tduration = 0;\n\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tvar track = this.tracks[ i ];\n\n\t\t\tduration = Math.max(\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t},\n\n\ttrim: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\toptimize: function() {\n\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.AnimationClip, {\n\n\tparse: function( json ) {\n\n\t\tvar tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\n\n\t},\n\n\n\ttoJSON: function( clip ) {\n\n\t\tvar tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tvar json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks\n\n\t\t};\n\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t},\n\n\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tvar numMorphTargets = morphTargetSequence.length;\n\t\tvar tracks = [];\n\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\t\ti,\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\t\ttimes, values\n\t\t\t\t\t).scale( 1.0 / fps ) );\n\t\t}\n\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\n\n\t},\n\n\tfindByName: function( objectOrClipArray, name ) {\n\n\t\tvar clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tvar o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\n\n\t\tvar animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tvar morphTarget = morphTargets[ i ];\n\t\t\tvar parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tvar name = parts[ 1 ];\n\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar clips = [];\n\n\t\tfor ( var name in animationToMorphTargets ) {\n\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t},\n\n\t// parse the animation.hierarchy format\n\tparseAnimation: function( animation, bones, nodeName ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar addNonemptyTrack = function(\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar values = [];\n\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar tracks = [];\n\n\t\tvar clipName = animation.name || 'default';\n\t\t// automatic length determination in AnimationClip.\n\t\tvar duration = animation.length || -1;\n\t\tvar fps = animation.fps || 30;\n\n\t\tvar hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets in a way exactly compatible\n\t\t\t// with AnimationHandler.init( animation )\n\t\t\tif ( animationKeys[0].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tvar morphTargetNames = {};\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var m = 0;\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\n\n\t\t\t} else {\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\n\n\t\treturn clip;\n\n\t}\n\n} );\n\n// File:src/animation/AnimationMixer.js\n\n/**\n *\n * Player for AnimationClips.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.AnimationMixer = function( root ) {\n\n\tthis._root = root;\n\tthis._initMemoryManager();\n\tthis._accuIndex = 0;\n\n\tthis.time = 0;\n\n\tthis.timeScale = 1.0;\n\n};\n\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\n\t\t\tprototypeAction = null;\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tvar existingAction =\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tvar newAction = new THREE.\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t},\n\n\t// get an existing action\n\texistingAction: function( clip, optionalRoot ) {\n\n\t\tvar root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t},\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction: function() {\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tthis._nActiveActions = 0;\n\t\tthis._nActiveBindings = 0;\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tactions[ i ].reset();\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].useCount = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// advance the time and update apply the animation\n\tupdate: function( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tvar actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\n\n\t\t\tvar action = actions[ i ];\n\n\t\t\tif ( action.enabled ) {\n\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tvar bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// return this mixer's root target object\n\tgetRoot: function() {\n\n\t\treturn this._root;\n\n\t},\n\n\t// free all resources specific to a particular clip\n\tuncacheClip: function( clip ) {\n\n\t\tvar actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tvar action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tvar cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t},\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot: function( root ) {\n\n\t\tvar rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( var clipUuid in actionsByClip ) {\n\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( var trackName in bindingByName ) {\n\n\t\t\t\tvar binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remove a targeted clip from the cache\n\tuncacheAction: function( clip, optionalRoot ) {\n\n\t\tvar action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n} );\n\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\n\n// Implementation details:\n\nObject.assign( THREE.AnimationMixer.prototype, {\n\n\t_bindAction: function( action, prototypeAction ) {\n\n\t\tvar root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tvar track = tracks[ i ],\n\t\t\t\ttrackName = track.name,\n\t\t\t\tbinding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar path = prototypeAction && prototypeAction.\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new THREE.PropertyMixer(\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t},\n\n\t_activateAction: function( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t},\n\n\t_deactivateAction: function( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tvar bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tvar binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t},\n\n\t// Memory manager\n\n\t_initMemoryManager: function() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tvar scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() { return scope._actions.length; },\n\t\t\t\tget inUse() { return scope._nActiveActions; }\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() { return scope._bindings.length; },\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\n\t\t\t}\n\n\t\t};\n\n\t},\n\n\t// Memory management for _Action objects\n\n\t_isActiveAction: function( action ) {\n\n\t\tvar index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t},\n\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\n\n\t\tvar actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tvar knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t},\n\n\t_removeInactiveAction: function( action ) {\n\n\t\tvar actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tvar clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t},\n\n\t_removeInactiveBindingsForAction: function( action ) {\n\n\t\tvar bindings = action._propertyBindings;\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tvar binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_lendAction: function( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t},\n\n\t_takeBackAction: function( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tvar actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t},\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\n\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tbindings = this._bindings;\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t},\n\n\t_removeInactiveBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tremove_empty_map: {\n\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t},\n\n\t_lendBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t},\n\n\t_takeBackBinding: function( binding ) {\n\n\t\tvar bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t},\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant: function() {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new THREE.LinearInterpolant(\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t},\n\n\t_takeBackControlInterpolant: function( interpolant ) {\n\n\t\tvar interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t},\n\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\n\n} );\n\n// File:src/animation/AnimationObjectGroup.js\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n * \t-\tAdd objects you would otherwise pass as 'root' to the\n * \t\tconstructor or the .clipAction method of AnimationMixer.\n *\n * \t-\tInstead pass this object as 'root'.\n *\n * \t-\tYou can also add and remove objects later when the mixer\n * \t\tis running.\n *\n * Note:\n *\n *  \tObjects of this class appear as one object to the mixer,\n *  \tso cache control of the individual objects must be done\n *  \ton the group.\n *\n * Limitation:\n *\n * \t- \tThe animated properties must be compatible among the\n * \t\tall objects in the group.\n *\n *  -\tA single property can either be controlled through a\n *  \ttarget group or directly, but not both.\n *\n * @author tschw\n */\n\nTHREE.AnimationObjectGroup = function( var_args ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\t// cached objects followed by the active ones\n\tthis._objects = Array.prototype.slice.call( arguments );\n\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\n\t// note: read by PropertyBinding.Composite\n\n\tvar indices = {};\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\n\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t}\n\n\tthis._paths = [];\t\t\t\t\t// inside: string\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\n\n\tvar scope = this;\n\n\tthis.stats = {\n\n\t\tobjects: {\n\t\t\tget total() { return scope._objects.length; },\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\n\t\t},\n\n\t\tget bindingsPerObject() { return scope._bindings.length; }\n\n\t};\n\n};\n\nTHREE.AnimationObjectGroup.prototype = {\n\n\tconstructor: THREE.AnimationObjectGroup,\n\n\tadd: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push(\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tvar knownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject) {\n\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\tremove: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// remove & forget\n\tuncache: function( var_args ) {\n\n\t\tvar objects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tvar object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tvar lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t},\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_: function( path, parsedPath ) {\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ],\n\t\t\tbindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tvar paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( var i = nCachedObjects,\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\n\n\t\t\tvar object = objects[ i ];\n\n\t\t\tbindingsForPath[ i ] =\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t},\n\n\tunsubscribe_: function( path ) {\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n};\n\n\n// File:src/animation/AnimationUtils.js\n\n/**\n * @author tschw\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n */\n\nTHREE.AnimationUtils = {\n\n\t// same as Array.prototype.slice, but also works on typed arrays\n\tarraySlice: function( array, from, to ) {\n\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\n\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\n\n\t\t}\n\n\t\treturn array.slice( from, to );\n\n\t},\n\n\t// converts an array to a specific type\n\tconvertArray: function( array, type, forceClone ) {\n\n\t\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t\t\t! forceClone && array.constructor === type ) return array;\n\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\t\treturn new type( array ); // create typed array\n\n\t\t}\n\n\t\treturn Array.prototype.slice.call( array ); // create Array\n\n\t},\n\n\tisTypedArray: function( object ) {\n\n\t\treturn ArrayBuffer.isView( object ) &&\n\t\t\t\t! ( object instanceof DataView );\n\n\t},\n\n\t// returns an array by which times and values can be sorted\n\tgetKeyframeOrder: function( times ) {\n\n\t\tfunction compareTime( i, j ) {\n\n\t\t\treturn times[ i ] - times[ j ];\n\n\t\t}\n\n\t\tvar n = times.length;\n\t\tvar result = new Array( n );\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\t\tresult.sort( compareTime );\n\n\t\treturn result;\n\n\t},\n\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\tsortedArray: function( values, stride, order ) {\n\n\t\tvar nValues = values.length;\n\t\tvar result = new values.constructor( nValues );\n\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\t\tvar srcOffset = order[ i ] * stride;\n\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// function for parsing AOS keyframe formats\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\n\n\t\tvar i = 1, key = jsonKeys[ 0 ];\n\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t}\n\n\t\tif ( key === undefined ) return; // no data\n\n\t\tvar value = key[ valuePropertyName ];\n\t\tif ( value === undefined ) return; // no data\n\n\t\tif ( Array.isArray( value ) ) {\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else if ( value.toArray !== undefined ) {\n\t\t\t// ...assume THREE.Math-ish\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t} else {\n\t\t\t// otherwise push as-is\n\n\t\t\tdo {\n\n\t\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\ttimes.push( key.time );\n\t\t\t\t\tvalues.push( value );\n\n\t\t\t\t}\n\n\t\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t\t} while ( key !== undefined );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/KeyframeTrack.js\n\n/**\n *\n * A timed sequence of keyframes for a specific property.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\n\n\tif( times === undefined || times.length === 0 ) {\n\n\t\tthrow new Error( \"no keyframes in track named \" + name );\n\n\t}\n\n\tthis.name = name;\n\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\n\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\tthis.validate();\n\tthis.optimize();\n\n};\n\nTHREE.KeyframeTrack.prototype = {\n\n\tconstructor: THREE.KeyframeTrack,\n\n\tTimeBufferType: Float32Array,\n\tValueBufferType: Float32Array,\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodDiscrete: function( result ) {\n\n\t\treturn new THREE.DiscreteInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.LinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: function( result ) {\n\n\t\treturn new THREE.CubicInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tsetInterpolation: function( interpolation ) {\n\n\t\tvar factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase THREE.InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tvar message = \"unsupported interpolation for \" +\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( message );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t},\n\n\tgetInterpolation: function() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn THREE.InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn THREE.InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn THREE.InterpolateSmooth;\n\n\t\t}\n\n\t},\n\n\tgetValueSize: function() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t},\n\n\t// move all keyframes either forwards or backwards in time\n\tshift: function( timeOffset ) {\n\n\t\tif( timeOffset !== 0.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale: function( timeScale ) {\n\n\t\tif( timeScale !== 1.0 ) {\n\n\t\t\tvar times = this.times;\n\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim: function( startTime, endTime ) {\n\n\t\tvar times = this.times,\n\t\t\tnKeys = times.length,\n\t\t\tfrom = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\n\n\t\t\tvar stride = this.getValueSize();\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\n\t\t\tthis.values = THREE.AnimationUtils.\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate: function() {\n\n\t\tvar valid = true;\n\n\t\tvar valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( \"invalid value size in track\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif( nKeys === 0 ) {\n\n\t\t\tconsole.error( \"track is empty\", this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tvar prevTime = null;\n\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tvar currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\n\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tvar value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t},\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize: function() {\n\n\t\tvar times = this.times,\n\t\t\tvalues = this.values,\n\t\t\tstride = this.getValueSize(),\n\n\t\t\twriteIndex = 1;\n\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\n\n\t\t\tvar keep = false;\n\n\t\t\tvar time = times[ i ];\n\t\t\tvar timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\n\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\tvar offset = i * stride,\n\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\tvar value = values[ offset + j ];\n\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tvar readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n};\n\n// Static methods:\n\nObject.assign( THREE.KeyframeTrack, {\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tparse: function( json ) {\n\n\t\tif( json.type === undefined ) {\n\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\n\n\t\t}\n\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\n\n\t\tif ( json.times === undefined ) {\n\n\t\t\tvar times = [], values = [];\n\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\n\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\n\t\t}\n\n\t\t// derived classes can define a static parse method\n\t\tif ( trackType.parse !== undefined ) {\n\n\t\t\treturn trackType.parse( json );\n\n\t\t} else {\n\n\t\t\t// by default, we asssume a constructor compatible with the base\n\t\t\treturn new trackType(\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\n\n\t\t}\n\n\t},\n\n\ttoJSON: function( track ) {\n\n\t\tvar trackType = track.constructor;\n\n\t\tvar json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== undefined ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tvar interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t},\n\n\t_getTrackTypeForValueTypeName: function( typeName ) {\n\n\t\tswitch( typeName.toLowerCase() ) {\n\n\t\t\tcase \"scalar\":\n\t\t\tcase \"double\":\n\t\t\tcase \"float\":\n\t\t\tcase \"number\":\n\t\t\tcase \"integer\":\n\n\t\t\t\treturn THREE.NumberKeyframeTrack;\n\n\t\t\tcase \"vector\":\n\t\t\tcase \"vector2\":\n\t\t\tcase \"vector3\":\n\t\t\tcase \"vector4\":\n\n\t\t\t\treturn THREE.VectorKeyframeTrack;\n\n\t\t\tcase \"color\":\n\n\t\t\t\treturn THREE.ColorKeyframeTrack;\n\n\t\t\tcase \"quaternion\":\n\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\n\n\t\t\tcase \"bool\":\n\t\t\tcase \"boolean\":\n\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\n\n\t\t\tcase \"string\":\n\n\t\t\t\treturn THREE.StringKeyframeTrack;\n\n\t\t}\n\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\n\n\t}\n\n} );\n\n// File:src/animation/PropertyBinding.js\n\n/**\n *\n * A reference to a real property in the scene graph.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\n\n\tthis.path = path;\n\tthis.parsedPath = parsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis.node = THREE.PropertyBinding.findNode(\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\n\n\tthis.rootNode = rootNode;\n\n};\n\nTHREE.PropertyBinding.prototype = {\n\n\tconstructor: THREE.PropertyBinding,\n\n\tgetValue: function getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t\t// Note: This class uses a State pattern on a per-method basis:\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t\t// prototype version of these methods with one that represents\n\t\t// the bound state. When the property is not found, the methods\n\t\t// become no-ops.\n\n\t},\n\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t},\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind: function() {\n\n\t\tvar targetObject = this.node,\n\t\t\tparsedPath = this.parsedPath,\n\n\t\t\tobjectName = parsedPath.objectName,\n\t\t\tpropertyName = parsedPath.propertyName,\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n \t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tvar objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tvar nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tvar nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tvar versioning = this.Versioning.None;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tvar bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\n\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\n\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\n\n\t\t\t\t\t\tpropertyIndex = i;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( nodeProperty.length !== undefined ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t},\n\n\tunbind: function() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n};\n\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable: function() {},\n\t_setValue_unavailable: function() {},\n\n\t// initial state of these methods that calls 'bind'\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\n\n\tBindingType: {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t},\n\n\tVersioning: {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t},\n\n\tGetterByBindingType: [\n\n\t\tfunction getValue_direct( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\n\n\t\t},\n\n\t\tfunction getValue_array( buffer, offset ) {\n\n\t\t\tvar source = this.resolvedProperty;\n\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tfunction getValue_arrayElement( buffer, offset ) {\n\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t\t},\n\n\t\tfunction getValue_toArray( buffer, offset ) {\n\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t\t}\n\n\t],\n\n\tSetterByBindingTypeAndVersioning: [\n\n\t\t[\n\t\t\t// Direct\n\n\t\t\tfunction setValue_direct( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// EntireArray\n\n\t\t\tfunction setValue_array( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tvar dest = this.resolvedProperty;\n\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t\t\t}\n\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// ArrayElement\n\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t], [\n\n\t\t\t// HasToFromArray\n\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.needsUpdate = true;\n\n\t\t\t},\n\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t]\n\n\t]\n\n} );\n\nTHREE.PropertyBinding.Composite =\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\n\n\tvar parsedPath = optionalParsedPath ||\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\n\n\tthis._targetGroup = targetGroup;\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n};\n\nTHREE.PropertyBinding.Composite.prototype = {\n\n\tconstructor: THREE.PropertyBinding.Composite,\n\n\tgetValue: function( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t},\n\n\tsetValue: function( array, offset ) {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t},\n\n\tbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t},\n\n\tunbind: function() {\n\n\t\tvar bindings = this._bindings;\n\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\n\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\n\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\n\n\t} else {\n\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\n\n\t}\n\n};\n\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\n\n\t// matches strings in the form of:\n\t//    nodeName.property\n\t//    nodeName.property[accessor]\n\t//    nodeName.material.property[accessor]\n\t//    uuid.property[accessor]\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n\t//    parentName/nodeName.property\n\t//    parentName/parentName/nodeName.property[index]\n\t//\t  .bone[Armature.DEF_cog].position\n\t// created and tested via https://regex101.com/#javascript\n\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\n\tvar matches = re.exec( trackName );\n\n\tif ( ! matches ) {\n\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\n\n\t}\n\n\tif ( matches.index === re.lastIndex ) {\n\n\t\tre.lastIndex++;\n\n\t}\n\n\tvar results = {\n\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\tnodeName: matches[ 3 ], \t// allowed to be null, specified root node.\n\t\tobjectName: matches[ 5 ],\n\t\tobjectIndex: matches[ 7 ],\n\t\tpropertyName: matches[ 9 ],\n\t\tpropertyIndex: matches[ 11 ]\t// allowed to be null, specifies that the whole property is set.\n\t};\n\n\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\n\n\t}\n\n\treturn results;\n\n};\n\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\n\n\tif ( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\treturn root;\n\n\t}\n\n\t// search into skeleton bones.\n\tif ( root.skeleton ) {\n\n\t\tvar searchSkeleton = function( skeleton ) {\n\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\n\n\t\t\t\tvar bone = skeleton.bones[ i ];\n\n\t\t\t\tif ( bone.name === nodeName ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar bone = searchSkeleton( root.skeleton );\n\n\t\tif ( bone ) {\n\n\t\t\treturn bone;\n\n\t\t}\n\t}\n\n\t// search into node subtree.\n\tif ( root.children ) {\n\n\t\tvar searchNodeSubtree = function( children ) {\n\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tvar childNode = children[ i ];\n\n\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\treturn childNode;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\n\n\t\t\t\tif ( result ) return result;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\n\n\t\tif ( subTreeNode ) {\n\n\t\t\treturn subTreeNode;\n\n\t\t}\n\n\t}\n\n\treturn null;\n\n};\n\n// File:src/animation/PropertyMixer.js\n\n/**\n *\n * Buffered scene graph property that allows weighted accumulation.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\n\n\tthis.binding = binding;\n\tthis.valueSize = valueSize;\n\n\tvar bufferType = Float64Array,\n\t\tmixFunction;\n\n\tswitch ( typeName ) {\n\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\n\n\t\tcase 'string':\n\t\tcase 'bool':\n\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\n\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\n\n\t}\n\n\tthis.buffer = new bufferType( valueSize * 4 );\n\t// layout: [ incoming | accu0 | accu1 | orig ]\n\t//\n\t// interpolators can use .buffer as their .result\n\t// the data then goes to 'incoming'\n\t//\n\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t// the cumulative result and are compared to detect\n\t// changes\n\t//\n\t// 'orig' stores the original state of the property\n\n\tthis._mixBufferRegion = mixFunction;\n\n\tthis.cumulativeWeight = 0;\n\n\tthis.useCount = 0;\n\tthis.referenceCount = 0;\n\n};\n\nTHREE.PropertyMixer.prototype = {\n\n\tconstructor: THREE.PropertyMixer,\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate: function( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tcurrentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tvar mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t},\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply: function( accuIndex ) {\n\n\t\tvar stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tvar originalValueOffset = stride * 3;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState: function() {\n\n\t\tvar binding = this.binding;\n\n\t\tvar buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * 3;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\tthis.cumulativeWeight = 0;\n\n\t},\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState: function() {\n\n\t\tvar originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t},\n\n\n\t// mix functions\n\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\n\n\t},\n\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tvar s = 1 - t;\n\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\tvar j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/animation/tracks/BooleanKeyframeTrack.js\n\n/**\n *\n * A Track of Boolean keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values );\n\n};\n\nTHREE.BooleanKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.BooleanKeyframeTrack,\n\n\tValueTypeName: 'bool',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\tInterpolantFactoryMethodSmooth: undefined\n\n\t// Note: Actually this track could have a optimized / compressed\n\t// representation of a single value and a custom interpolant that\n\t// computes \"firstValue ^ isOdd( index )\".\n\n} );\n\n// File:src/animation/tracks/ColorKeyframeTrack.js\n\n/**\n *\n * A Track of keyframe values that represent color.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.ColorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.ColorKeyframeTrack,\n\n\tValueTypeName: 'color'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n\n\t// Note: Very basic implementation and nothing special yet.\n\t// However, this is the place for color space parameterization.\n\n} );\n\n// File:src/animation/tracks/NumberKeyframeTrack.js\n\n/**\n *\n * A Track of numeric keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.NumberKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.NumberKeyframeTrack,\n\n\tValueTypeName: 'number',\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\n\n/**\n *\n * A Track of quaternion keyframe values.\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.QuaternionKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.QuaternionKeyframeTrack,\n\n\tValueTypeName: 'quaternion',\n\n\t// ValueBufferType is inherited\n\n\tDefaultInterpolation: THREE.InterpolateLinear,\n\n\tInterpolantFactoryMethodLinear: function( result ) {\n\n\t\treturn new THREE.QuaternionLinearInterpolant(\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\n\n\t},\n\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\n\n} );\n\n// File:src/animation/tracks/StringKeyframeTrack.js\n\n/**\n *\n * A Track that interpolates Strings\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.StringKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.StringKeyframeTrack,\n\n\tValueTypeName: 'string',\n\tValueBufferType: Array,\n\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\n\n\tInterpolantFactoryMethodLinear: undefined,\n\n\tInterpolantFactoryMethodSmooth: undefined\n\n} );\n\n// File:src/animation/tracks/VectorKeyframeTrack.js\n\n/**\n *\n * A Track of vectored keyframe values.\n *\n *\n * @author Ben Houston / http://clara.io/\n * @author David Sarno / http://lighthaus.us/\n * @author tschw\n */\n\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\n\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\n\n};\n\nTHREE.VectorKeyframeTrack.prototype =\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\n\n\tconstructor: THREE.VectorKeyframeTrack,\n\n\tValueTypeName: 'vector'\n\n\t// ValueBufferType is inherited\n\n\t// DefaultInterpolation is inherited\n\n} );\n\n// File:src/audio/Audio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.Audio = function ( listener ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Audio';\n\n\tthis.context = listener.context;\n\tthis.source = this.context.createBufferSource();\n\tthis.source.onended = this.onEnded.bind( this );\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( listener.getInput() );\n\n\tthis.autoplay = false;\n\n\tthis.startTime = 0;\n\tthis.playbackRate = 1;\n\tthis.isPlaying = false;\n\tthis.hasPlaybackControl = true;\n\tthis.sourceType = 'empty';\n\n\tthis.filters = [];\n\n};\n\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Audio,\n\n\tgetOutput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tsetNodeSource: function ( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t},\n\n\tsetBuffer: function ( audioBuffer ) {\n\n\t\tthis.source.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t},\n\n\tplay: function () {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar source = this.context.createBufferSource();\n\n\t\tsource.buffer = this.source.buffer;\n\t\tsource.loop = this.source.loop;\n\t\tsource.onended = this.source.onended;\n\t\tsource.start( 0, this.startTime );\n\t\tsource.playbackRate.value = this.playbackRate;\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\treturn this.connect();\n\n\t},\n\n\tpause: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = this.context.currentTime;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.stop();\n\t\tthis.startTime = 0;\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t},\n\n\tconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tdisconnect: function () {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilters: function () {\n\n\t\treturn this.filters;\n\n\t},\n\n\tsetFilters: function ( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value;\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t},\n\n\tsetFilter: function ( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t},\n\n\tsetPlaybackRate: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetPlaybackRate: function () {\n\n\t\treturn this.playbackRate;\n\n\t},\n\n\tonEnded: function () {\n\n\t\tthis.isPlaying = false;\n\n\t},\n\n\tgetLoop: function () {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.source.loop;\n\n\t},\n\n\tsetLoop: function ( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.source.loop = value;\n\n\t},\n\n\tgetVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\n\tsetVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/audio/AudioAnalyser.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\n\n\tthis.analyser = audio.context.createAnalyser();\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\n\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\taudio.getOutput().connect( this.analyser );\n\n};\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\n\tgetFrequencyData: function () {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t},\n\n\tgetAverageFrequency: function () {\n\n\t\tvar value = 0, data = this.getFrequencyData();\n\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n} );\n\n// File:src/audio/AudioContext.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.defineProperty( THREE, 'AudioContext', {\n\n\tget: ( function () {\n\n\t\tvar context;\n\n\t\treturn function get() {\n\n\t\t\tif ( context === undefined ) {\n\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t\t}\n\n\t\t\treturn context;\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/audio/PositionalAudio.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PositionalAudio = function ( listener ) {\n\n\tTHREE.Audio.call( this, listener );\n\n\tthis.panner = this.context.createPanner();\n\tthis.panner.connect( this.gain );\n\n};\n\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\n\n\tconstructor: THREE.PositionalAudio,\n\n\tgetOutput: function () {\n\n\t\treturn this.panner;\n\n\t},\n\n\tgetRefDistance: function () {\n\n\t\treturn this.panner.refDistance;\n\n\t},\n\n\tsetRefDistance: function ( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t},\n\n\tgetRolloffFactor: function () {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t},\n\n\tsetRolloffFactor: function ( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t},\n\n\tgetDistanceModel: function () {\n\n\t\treturn this.panner.distanceModel;\n\n\t},\n\n\tsetDistanceModel: function ( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t},\n\n\tgetMaxDistance: function () {\n\n\t\treturn this.panner.maxDistance;\n\n\t},\n\n\tsetMaxDistance: function ( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\n\n\t\t};\n\n\t} )()\n\n\n} );\n\n// File:src/audio/AudioListener.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AudioListener = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'AudioListener';\n\n\tthis.context = THREE.AudioContext;\n\n\tthis.gain = this.context.createGain();\n\tthis.gain.connect( this.context.destination );\n\n\tthis.filter = null;\n\n};\n\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.AudioListener,\n\n\tgetInput: function () {\n\n\t\treturn this.gain;\n\n\t},\n\n\tremoveFilter: function ( ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t},\n\n\tgetFilter: function () {\n\n\t\treturn this.filter;\n\n\t},\n\n\tsetFilter: function ( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t},\n\n\tgetMasterVolume: function () {\n\n\t\treturn this.gain.gain.value;\n\n\t},\n\n\tsetMasterVolume: function ( value ) {\n\n\t\tthis.gain.gain.value = value;\n\n\t},\n\n\tupdateMatrixWorld: ( function () {\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\tvar orientation = new THREE.Vector3();\n\n\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\tvar listener = this.context.listener;\n\t\t\tvar up = this.up;\n\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\n\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/cameras/Camera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Camera';\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Camera.prototype.constructor = THREE.Camera;\n\nTHREE.Camera.prototype.getWorldDirection = function () {\n\n\tvar quaternion = new THREE.Quaternion();\n\n\treturn function getWorldDirection( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tthis.getWorldQuaternion( quaternion );\n\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function lookAt( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function () {\n\n\treturn new this.constructor().copy( this );\n\n};\n\nTHREE.Camera.prototype.copy = function ( source ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\tthis.projectionMatrix.copy( source.projectionMatrix );\n\n\treturn this;\n\n};\n\n// File:src/cameras/CubeCamera.js\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'CubeCamera';\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, - 1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, - 1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, - 1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, - 1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, - 1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n\tthis.add( cameraNZ );\n\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t\trenderer.setRenderTarget( null );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\n\n// File:src/cameras/OrthographicCamera.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author arose / http://github.com/arose\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'OrthographicCamera';\n\n\tthis.zoom = 1;\n\tthis.view = null;\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.OrthographicCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t},\n\n\tsetViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tvar cx = ( this.right + this.left ) / 2;\n\t\tvar cy = ( this.top + this.bottom ) / 2;\n\n\t\tvar left = cx - dx;\n\t\tvar right = cx + dx;\n\t\tvar top = cy + dy;\n\t\tvar bottom = cy - dy;\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\n\t\t\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\n\t\t\tvar scaleW = ( this.right - this.left ) / this.view.width;\n\t\t\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\n\n\t\t\tleft += scaleW * ( this.view.offsetX / zoomW );\n\t\t\tright = left + scaleW * ( this.view.width / zoomW );\n\t\t\ttop -= scaleH * ( this.view.offsetY / zoomH );\n\t\t\tbottom = top - scaleH * ( this.view.height / zoomH );\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/PerspectiveCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author tschw\n */\n\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.type = 'PerspectiveCamera';\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.zoom = 1;\n\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\tthis.focus = 10;\n\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.view = null;\n\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\n\n\tconstructor: THREE.PerspectiveCamera,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Camera.prototype.copy.call( this, source );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength: function ( focalLength ) {\n\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength: function () {\n\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t},\n\n\tgetEffectiveFOV: function () {\n\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t},\n\n\tgetFilmWidth: function () {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t},\n\n\tgetFilmHeight: function () {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t},\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   var w = 1920;\n\t *   var h = 1080;\n\t *   var fullWidth = w * 3;\n\t *   var fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tthis.view = {\n\t\t\tfullWidth: fullWidth,\n\t\t\tfullHeight: fullHeight,\n\t\t\toffsetX: x,\n\t\t\toffsetY: y,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tclearViewOffset: function() {\n\n\t\tthis.view = null;\n\t\tthis.updateProjectionMatrix();\n\n\t},\n\n\tupdateProjectionMatrix: function () {\n\n\t\tvar near = this.near,\n\t\t\ttop = near * Math.tan(\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\n\t\t\theight = 2 * top,\n\t\t\twidth = this.aspect * height,\n\t\t\tleft = - 0.5 * width,\n\t\t\tview = this.view;\n\n\t\tif ( view !== null ) {\n\n\t\t\tvar fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tvar skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/cameras/StereoCamera.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.StereoCamera = function () {\n\n\tthis.type = 'StereoCamera';\n\n\tthis.aspect = 1;\n\n\tthis.cameraL = new THREE.PerspectiveCamera();\n\tthis.cameraL.layers.enable( 1 );\n\tthis.cameraL.matrixAutoUpdate = false;\n\n\tthis.cameraR = new THREE.PerspectiveCamera();\n\tthis.cameraR.layers.enable( 2 );\n\tthis.cameraR.matrixAutoUpdate = false;\n\n};\n\nObject.assign( THREE.StereoCamera.prototype, {\n\n\tupdate: ( function () {\n\n\t\tvar focus, fov, aspect, near, far;\n\n\t\tvar eyeRight = new THREE.Matrix4();\n\t\tvar eyeLeft = new THREE.Matrix4();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\n\n\t\t\tif ( needsUpdate ) {\n\n\t\t\t\tfocus = camera.focus;\n\t\t\t\tfov = camera.fov;\n\t\t\t\taspect = camera.aspect * this.aspect;\n\t\t\t\tnear = camera.near;\n\t\t\t\tfar = camera.far;\n\n\t\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tvar eyeSep = 0.064 / 2;\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\n\t\t\t\tvar xmin, xmax;\n\n\t\t\t\t// translate xOffset\n\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\n\n\t\t\t\t// for left eye\n\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t\t// for right eye\n\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\n\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\n\t\t};\n\n\t} )()\n\n} );\n\n// File:src/lights/Light.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Light = function ( color, intensity ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Light';\n\n\tthis.color = new THREE.Color( color );\n\tthis.intensity = intensity !== undefined ? intensity : 1;\n\n\tthis.receiveShadow = undefined;\n\n};\n\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Light,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/lights/LightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LightShadow = function ( camera ) {\n\n\tthis.camera = camera;\n\n\tthis.bias = 0;\n\tthis.radius = 1;\n\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\n\n\tthis.map = null;\n\tthis.matrix = new THREE.Matrix4();\n\n};\n\nObject.assign( THREE.LightShadow.prototype, {\n\n\tcopy: function ( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n} );\n\n// File:src/lights/AmbientLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'AmbientLight';\n\n\tthis.castShadow = undefined;\n\n};\n\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.AmbientLight\n\n} );\n\n// File:src/lights/DirectionalLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( color, intensity ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'DirectionalLight';\n\n\tthis.position.copy( THREE.Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tthis.shadow = new THREE.DirectionalLightShadow();\n\n};\n\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.DirectionalLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/DirectionalLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.DirectionalLightShadow = function ( light ) {\n\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n};\n\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.DirectionalLightShadow\n\n} );\n\n// File:src/lights/HemisphereLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\n\n\tTHREE.Light.call( this, skyColor, intensity );\n\n\tthis.type = 'HemisphereLight';\n\n\tthis.castShadow = undefined;\n\n\tthis.position.copy( THREE.Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.groundColor = new THREE.Color( groundColor );\n\n};\n\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.HemisphereLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/PointLight.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\n\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'PointLight';\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n};\n\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.PointLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLight.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\n\n\tTHREE.Light.call( this, color, intensity );\n\n\tthis.type = 'SpotLight';\n\n\tthis.position.copy( THREE.Object3D.DefaultUp );\n\tthis.updateMatrix();\n\n\tthis.target = new THREE.Object3D();\n\n\tObject.defineProperty( this, 'power', {\n\t\tget: function () {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t},\n\t\tset: function ( power ) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\t} );\n\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\n\n\tthis.shadow = new THREE.SpotLightShadow();\n\n};\n\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\n\n\tconstructor: THREE.SpotLight,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Light.prototype.copy.call( this, source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/lights/SpotLightShadow.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SpotLightShadow = function () {\n\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n};\n\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\n\n\tconstructor: THREE.SpotLightShadow,\n\n\tupdate: function ( light ) {\n\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\n\t\tvar far = light.distance || 500;\n\n\t\tvar camera = this.camera;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/AudioLoader.js\n\n/**\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\n */\n\nTHREE.AudioLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.AudioLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar context = THREE.AudioContext;\n\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\n\n\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t} );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n} );\n\n// File:src/loaders/Cache.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n// File:src/loaders/Loader.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Loader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function () {};\n\tthis.onLoadComplete = function () {};\n\n};\n\nTHREE.Loader.prototype = {\n\n\tconstructor: THREE.Loader,\n\n\tcrossOrigin: undefined,\n\n\textractUrlBase: function ( url ) {\n\n\t\tvar parts = url.split( '/' );\n\n\t\tif ( parts.length === 1 ) return './';\n\n\t\tparts.pop();\n\n\t\treturn parts.join( '/' ) + '/';\n\n\t},\n\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\n\n\t\tvar array = [];\n\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tcreateMaterial: ( function () {\n\n\t\tvar color, textureLoader, materialLoader;\n\n\t\treturn function createMaterial( m, texturePath, crossOrigin ) {\n\n\t\t\tif ( color === undefined ) color = new THREE.Color();\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\n\n\t\t\t// convert from old material format\n\n\t\t\tvar textures = {};\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar json = {\n\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\ttype: 'MeshLambertMaterial'\n\t\t\t};\n\n\t\t\tfor ( var name in m ) {\n\n\t\t\t\tvar value = m[ name ];\n\n\t\t\t\tswitch ( name ) {\n\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\tjson.blending = THREE[ value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\tcase 'opacity':\n\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\tcase 'visible':\n\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\tmaterialLoader.setTextures( textures );\n\n\t\t\treturn materialLoader.parse( json );\n\n\t\t};\n\n\t} )()\n\n};\n\nTHREE.Loader.Handlers = {\n\n\thandlers: [],\n\n\tadd: function ( regex, loader ) {\n\n\t\tthis.handlers.push( regex, loader );\n\n\t},\n\n\tget: function ( file ) {\n\n\t\tvar handlers = this.handlers;\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader  = handlers[ i + 1 ];\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n};\n\n// File:src/loaders/XHRLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.XHRLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\tvar scope = this;\n\n\t\tvar cached = THREE.Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar request = new XMLHttpRequest();\n\t\trequest.overrideMimeType( 'text/plain' );\n\t\trequest.open( 'GET', url, true );\n\n\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\tvar response = event.target.response;\n\n\t\t\tTHREE.Cache.add( url, response );\n\n\t\t\tif ( this.status === 200 ) {\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else if ( this.status === 0 ) {\n\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\n\n\t\t\t\tif ( onLoad ) onLoad( response );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} else {\n\n\t\t\t\tif ( onError ) onError( event );\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, false );\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}, false );\n\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn request;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t},\n\n\tsetResponseType: function ( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t},\n\n\tsetWithCredentials: function ( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/FontLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.FontLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.FontLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\n\n\t\t\t}\n\n\t\t\tvar font = scope.parse( json );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\treturn new THREE.Font( json );\n\n\t}\n\n} );\n\n// File:src/loaders/ImageLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.ImageLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\t\timage.onload = function () {\n\n\t\t\tURL.revokeObjectURL( image.src );\n\n\t\t\tif ( onLoad ) onLoad( image );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tif ( url.indexOf( 'data:' ) === 0 ) {\n\n\t\t\timage.src = url;\n\n\t\t} else {\n\n\t\t\tvar loader = new THREE.XHRLoader();\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'blob' );\n\t\t\tloader.load( url, function ( blob ) {\n\n\t\t\t\timage.src = URL.createObjectURL( blob );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/JSONLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.JSONLoader = function ( manager ) {\n\n\tif ( typeof manager === 'boolean' ) {\n\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\tmanager = undefined;\n\n\t}\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.withCredentials = false;\n\n};\n\nObject.assign( THREE.JSONLoader.prototype, {\n\n\tload: function( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tvar json = JSON.parse( text );\n\t\t\tvar metadata = json.metadata;\n\n\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\tvar type = metadata.type;\n\n\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar object = scope.parse( json, texturePath );\n\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tparse: function ( json, texturePath ) {\n\n\t\tvar geometry = new THREE.Geometry(),\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\n\n\t\tparseModel( scale );\n\n\t\tparseSkin();\n\t\tparseMorphing( scale );\n\t\tparseAnimations();\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeBoundingSphere();\n\n\t\tfunction parseModel( scale ) {\n\n\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t}\n\n\t\t\tvar i, j, fi,\n\n\t\t\toffset, zLength,\n\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\ttype,\n\t\t\tisQuad,\n\t\t\thasMaterial,\n\t\t\thasFaceVertexUv,\n\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\tuvLayer, uv, u, v,\n\n\t\t\tfaces = json.faces,\n\t\t\tvertices = json.vertices,\n\t\t\tnormals = json.normals,\n\t\t\tcolors = json.colors,\n\n\t\t\tnUvLayers = 0;\n\n\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t// disregard empty arrays\n\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = vertices.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t}\n\n\t\t\toffset = 0;\n\t\t\tzLength = faces.length;\n\n\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\ttype = faces[ offset ++ ];\n\n\n\t\t\t\tisQuad              = isBitSet( type, 0 );\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\n\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseSkin() {\n\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.bones = json.bones;\n\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseMorphing( scale ) {\n\n\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimations() {\n\n\t\t\tvar outputAnimations = [];\n\n\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\tvar animations = [];\n\n\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\tanimations.push( json.animation );\n\n\t\t\t}\n\n\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t}\n\n\t\t\t// parse implicit morph animations\n\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t}\n\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t}\n\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\treturn { geometry: geometry };\n\n\t\t} else {\n\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\n\n\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/loaders/LoadingManager.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n// File:src/loaders/BufferGeometryLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BufferGeometryLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.BufferGeometryLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar index = json.data.index;\n\n\t\tvar TYPED_ARRAYS = {\n\t\t\t'Int8Array': Int8Array,\n\t\t\t'Uint8Array': Uint8Array,\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\n\t\t\t'Int16Array': Int16Array,\n\t\t\t'Uint16Array': Uint16Array,\n\t\t\t'Int32Array': Int32Array,\n\t\t\t'Uint32Array': Uint32Array,\n\t\t\t'Float32Array': Float32Array,\n\t\t\t'Float64Array': Float64Array\n\t\t};\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tvar attributes = json.data.attributes;\n\n\t\tfor ( var key in attributes ) {\n\n\t\t\tvar attribute = attributes[ key ];\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\n\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\n\n\t\t}\n\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tvar center = new THREE.Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/loaders/MaterialLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MaterialLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.textures = {};\n\n};\n\nObject.assign( THREE.MaterialLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTextures: function ( value ) {\n\n\t\tthis.textures = value;\n\n\t},\n\n\tgetTexture: function ( name ) {\n\n\t\tvar textures = this.textures;\n\n\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t}\n\n\t\treturn textures[ name ];\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar material = new THREE[ json.type ];\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\n\t\t// for PointsMaterial\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\n\n\t\tif ( json.alphaMap !== undefined ) {\n\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\n\t\t\tmaterial.transparent = true;\n\n\t\t}\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tvar normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\n\n\t\tif ( json.envMap !== undefined ) {\n\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\n\n\t\t}\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\t// MultiMaterial\n\n\t\tif ( json.materials !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\n\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn material;\n\n\t}\n\n} );\n\n// File:src/loaders/ObjectLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.texturePath = '';\n\n};\n\nObject.assign( THREE.ObjectLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.texturePath === '' ) {\n\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\n\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetTexturePath: function ( value ) {\n\n\t\tthis.texturePath = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json, onLoad ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\n\t\tvar images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tvar textures  = this.parseTextures( json.textures, images );\n\t\tvar materials = this.parseMaterials( json.materials, textures );\n\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\tif ( json.animations ) {\n\n\t\t\tobject.animations = this.parseAnimations( json.animations );\n\n\t\t}\n\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\tcase 'PlaneBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\tcase 'CircleBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\tcase 'CylinderBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\tcase 'ConeBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\tcase 'SphereBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\tcase 'TetrahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\tcase 'RingBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.innerRadius,\n\t\t\t\t\t\t\tdata.outerRadius,\n\t\t\t\t\t\t\tdata.thetaSegments,\n\t\t\t\t\t\t\tdata.phiSegments,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\tcase 'TorusBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\tcase 'LatheBufferGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\n\t\t\t\t\t\t\tdata.points,\n\t\t\t\t\t\t\tdata.segments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json, textures ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar material = loader.parse( json[ i ] );\n\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseAnimations: function ( json ) {\n\n\t\tvar animations = [];\n\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\n\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t},\n\n\tparseImages: function ( json, onLoad ) {\n\n\t\tvar scope = this;\n\t\tvar images = {};\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\n\n\t\t\tvar loader = new THREE.ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar image = json[ i ];\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\n\n\t\t\t\timages[ image.uuid ] = loadImage( path );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t},\n\n\tparseTextures: function ( json, images ) {\n\n\t\tfunction parseConstant( value ) {\n\n\t\t\tif ( typeof( value ) === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn THREE[ value ];\n\n\t\t}\n\n\t\tvar textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function parseObject( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tfunction getGeometry( name ) {\n\n\t\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries[ name ];\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( name ) {\n\n\t\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t\t}\n\n\t\t\t\treturn materials[ name ];\n\n\t\t\t}\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\n\t\t\t\t\tvar material = getMaterial( data.material );\n\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\n\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\n\t\t\t\t\tobject = new THREE.LOD();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\n\t\t\t\t\tobject = new THREE.Group();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( data.type === 'LOD' ) {\n\n\t\t\t\tvar levels = data.levels;\n\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\t\tvar level = levels[ l ];\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t};\n\n\t}()\n\n} );\n\n// File:src/loaders/TextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.TextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tvar isJPEG = url.search( /\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/CubeTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.CubeTextureLoader.prototype, {\n\n\tload: function ( urls, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new THREE.CubeTexture();\n\n\t\tvar loader = new THREE.ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tvar loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/loaders/BinaryTextureLoader.js\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n *\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n */\n\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.BinaryTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.DataTexture();\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tvar texData = scope._parser( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( undefined !== texData.image ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( undefined !== texData.data ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\n\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\n\n\t\t\tif ( undefined !== texData.format ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\t\t\tif ( undefined !== texData.type ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( undefined !== texData.mipmaps ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\n\t\t\t}\n\n\t\t\tif ( 1 === texData.mipmapCount ) {\n\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n// File:src/loaders/CompressedTextureLoader.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n */\n\nTHREE.CompressedTextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\t// override in sub classes\n\tthis._parser = null;\n\n};\n\nObject.assign( THREE.CompressedTextureLoader.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar images = [];\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\n\t\tvar loader = new THREE.XHRLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tvar loaded = 0;\n\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/materials/Material.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Material';\n\n\tthis.fog = true;\n\tthis.lights = true;\n\n\tthis.blending = THREE.NormalBlending;\n\tthis.side = THREE.FrontSide;\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\tthis.blendSrcAlpha = null;\n\tthis.blendDstAlpha = null;\n\tthis.blendEquationAlpha = null;\n\n\tthis.depthFunc = THREE.LessEqualDepth;\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.clippingPlanes = null;\n\tthis.clipShadows = false;\n\n\tthis.colorWrite = true;\n\n\tthis.precision = null; // override the renderer's default precision for this material\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\tthis.premultipliedAlpha = false;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis._needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tget needsUpdate() {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.update();\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else if ( key === 'overdraw' ) {\n\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\n\t\t\t\tthis[ key ] = Number( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar isRoot = meta === undefined;\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tvar data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap instanceof THREE.Texture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\n\n\t\t}\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache ( cache ) {\n\n\t\t\tvar values = [];\n\n\t\t\tfor ( var key in cache ) {\n\n\t\t\t\tvar data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tvar textures = extractFromCache( meta.textures );\n\t\t\tvar images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.shading = source.shading;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.alphaTest = source.alphaTest;\n\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\n\t\tthis.overdraw = source.overdraw;\n\n\t\tthis.visible = source.visible;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tvar srcPlanes = source.clippingPlanes,\n\t\t\tdstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tvar n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\n\t\treturn this;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n// File:src/materials/LineBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\"\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\n\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\tthis.linecap = source.linecap;\n\tthis.linejoin = source.linejoin;\n\n\treturn this;\n\n};\n\n// File:src/materials/LineDashedMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'LineDashedMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\n\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.linewidth = source.linewidth;\n\n\tthis.scale = source.scale;\n\tthis.dashSize = source.dashSize;\n\tthis.gapSize = source.gapSize;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshBasicMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshBasicMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\n\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshDepthMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / https://clara.io\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshDepthMaterial';\n\n\tthis.depthPacking = THREE.BasicDepthPacking;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\n\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.depthPacking = source.depthPacking;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshLambertMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\n\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshNormalMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.type = 'MeshNormalMaterial';\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\n\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhongMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'MeshPhongMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\n\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.specular.copy( source.specular );\n\tthis.shininess = source.shininess;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshStandardMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.MeshStandardMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.roughness = 0.5;\n\tthis.metalness = 0.5;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\n\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n// File:src/materials/MeshPhysicalMaterial.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  reflectivity: <float>\n * }\n */\n\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\n\n\tTHREE.MeshStandardMaterial.call( this );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.type = 'MeshPhysicalMaterial';\n\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\tthis.clearCoat = 0.0;\n\tthis.clearCoatRoughness = 0.0;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\n\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'PHYSICAL': '' };\n\n\tthis.reflectivity = source.reflectivity;\n\n\tthis.clearCoat = source.clearCoat;\n\tthis.clearCoatRoughness = source.clearCoatRoughness;\n\n\treturn this;\n\n};\n\n// File:src/materials/MultiMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MultiMaterial = function ( materials ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.type = 'MultiMaterial';\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n\tthis.visible = true;\n\n};\n\nTHREE.MultiMaterial.prototype = {\n\n\tconstructor: THREE.MultiMaterial,\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.2,\n\t\t\t\ttype: 'material',\n\t\t\t\tgenerator: 'MaterialExporter'\n\t\t\t},\n\t\t\tuuid: this.uuid,\n\t\t\ttype: this.type,\n\t\t\tmaterials: []\n\t\t};\n\n\t\tvar materials = this.materials;\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tvar material = materials[ i ].toJSON( meta );\n\t\t\tdelete material.metadata;\n\n\t\t\toutput.materials.push( material );\n\n\t\t}\n\n\t\toutput.visible = this.visible;\n\n\t\treturn output;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar material = new this.constructor();\n\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t\t}\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t}\n\n};\n\n// File:src/materials/PointsMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n * }\n */\n\nTHREE.PointsMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\n\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShaderMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  defines: { \"label\" : \"value\" },\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n *\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'ShaderMaterial';\n\n\tthis.defines = {};\n\tthis.uniforms = {};\n\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\tthis.lights = false; // set to use scene lights\n\tthis.clipping = false; // set to use user-defined clipping planes\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\tthis.extensions = {\n\t\tderivatives: false, // set to use derivatives\n\t\tfragDepth: false, // set to use fragment depth values\n\t\tdrawBuffers: false, // set to use draw buffers\n\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t};\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t'color': [ 1, 1, 1 ],\n\t\t'uv': [ 0, 0 ],\n\t\t'uv2': [ 0, 0 ]\n\t};\n\n\tthis.index0AttributeName = undefined;\n\n\tif ( parameters !== undefined ) {\n\n\t\tif ( parameters.attributes !== undefined ) {\n\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\n\n\t\t}\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\n\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.fragmentShader = source.fragmentShader;\n\tthis.vertexShader = source.vertexShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\n\n\tthis.defines = source.defines;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\tthis.lights = source.lights;\n\tthis.clipping = source.clipping;\n\n\tthis.skinning = source.skinning;\n\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.extensions = source.extensions;\n\n\treturn this;\n\n};\n\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\n\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\n\n\tdata.uniforms = this.uniforms;\n\tdata.vertexShader = this.vertexShader;\n\tdata.fragmentShader = this.fragmentShader;\n\n\treturn data;\n\n};\n\n// File:src/materials/RawShaderMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RawShaderMaterial = function ( parameters ) {\n\n\tTHREE.ShaderMaterial.call( this, parameters );\n\n\tthis.type = 'RawShaderMaterial';\n\n};\n\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\n\n// File:src/materials/SpriteMaterial.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2()\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.type = 'SpriteMaterial';\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\tthis.lights = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\n\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\n\n\tTHREE.Material.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\tthis.map = source.map;\n\n\tthis.rotation = source.rotation;\n\n\treturn this;\n\n};\n\n// File:src/materials/ShadowMaterial.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ShadowMaterial = function () {\n\n\tTHREE.ShaderMaterial.call( this, {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\n\t} );\n\n\tthis.lights = true;\n\tthis.transparent = true;\n\n\tObject.defineProperties( this, {\n\t\topacity: {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn this.uniforms.opacity.value;\n\t\t\t},\n\t\t\tset: function ( value ) {\n\t\t\t\tthis.uniforms.opacity.value = value;\n\t\t\t}\n\t\t}\n\t} );\n\n};\n\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\n\n// File:src/textures/Texture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\tthis.sourceFile = '';\n\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t//\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\n\n\tthis.version = 0;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.DEFAULT_IMAGE = undefined;\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t},\n\n\ttoJSON: function ( meta ) {\n\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tfunction getDataURL( image ) {\n\n\t\t\tvar canvas;\n\n\t\t\tif ( image.toDataURL !== undefined ) {\n\n\t\t\t\tcanvas = image;\n\n\t\t\t} else {\n\n\t\t\t\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\t\tcanvas.width = image.width;\n\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t\t} else {\n\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.4,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tvar image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: getDataURL( image )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tmeta.textures[ this.uuid ] = output;\n\n\t\treturn output;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t},\n\n\ttransformUv: function ( uv ) {\n\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\n\n\t\tuv.multiply( this.repeat );\n\t\tuv.add( this.offset );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase THREE.RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\n\nTHREE.TextureIdCount = 0;\n\n// File:src/textures/DepthTexture.js\n\n/**\n * @author Matt DesLauriers / @mattdesl\n */\n\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\n\n  this.image = { width: width, height: height };\n\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\n\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n  this.flipY = false;\n  this.generateMipmaps  = false;\n\n};\n\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\n\n// File:src/textures/CanvasTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\n\n// File:src/textures/CubeTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\n\n\timages = images !== undefined ? images : [];\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\n\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.flipY = false;\n\n};\n\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\n\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\n\n\tget: function () {\n\n\t\treturn this.image;\n\n\t},\n\n\tset: function ( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n} );\n\n// File:src/textures/CompressedTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\t// no flipping for cube textures\n\t// (also flipping doesn't work for compressed textures )\n\n\tthis.flipY = false;\n\n\t// can't generate mipmaps for compressed textures\n\t// mips must be embedded in DDS files\n\n\tthis.generateMipmaps = false;\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\n\n// File:src/textures/DataTexture.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\n\n\tthis.image = { data: data, width: width, height: height };\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\n\n\tthis.flipY = false;\n\tthis.generateMipmaps  = false;\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\n\n// File:src/textures/VideoTexture.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.generateMipmaps = false;\n\n\tvar scope = this;\n\n\tfunction update() {\n\n\t\trequestAnimationFrame( update );\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tscope.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tupdate();\n\n};\n\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\n\n// File:src/objects/Group.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Group = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Group';\n\n};\n\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Group\n\n} );\n\n// File:src/objects/Points.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Points = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Points';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Points,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar object = this;\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\tvar threshold = raycaster.params.Points.threshold;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\n\t\t\tvar position = new THREE.Vector3();\n\n\t\t\tfunction testPoint( point, index ) {\n\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\n\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\n\n\t\t\t\t\t\ttestPoint( position, a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\n\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\n\n\t\t\t\t\t\ttestPoint( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\ttestPoint( vertices[ i ], i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Line.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, mode ) {\n\n\tif ( mode === 1 ) {\n\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\n\t\treturn new THREE.LineSegments( geometry, material );\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Line';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n};\n\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Line,\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tvar vStart = new THREE.Vector3();\n\t\t\tvar vEnd = new THREE.Vector3();\n\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\tvar interRay = new THREE.Vector3();\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvar a = indices[ i ];\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\n\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\n\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\n\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\n\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: this\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LineSegments.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LineSegments = function ( geometry, material ) {\n\n\tTHREE.Line.call( this, geometry, material );\n\n\tthis.type = 'LineSegments';\n\n};\n\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\n\n\tconstructor: THREE.LineSegments\n\n} );\n\n// File:src/objects/Mesh.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Mesh';\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.drawMode = THREE.TrianglesDrawMode;\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Mesh,\n\n\tsetDrawMode: function ( value ) {\n\n\t\tthis.drawMode = value;\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.drawMode = source.drawMode;\n\n\t\treturn this;\n\n\t},\n\n\tupdateMorphTargets: function () {\n\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\n\n\t\t\tthis.morphTargetBase = - 1;\n\t\t\tthis.morphTargetInfluences = [];\n\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tgetMorphTargetIndexByName: function ( name ) {\n\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\t\treturn this.morphTargetDictionary[ name ];\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\n\n\t\treturn 0;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar inverseMatrix = new THREE.Matrix4();\n\t\tvar ray = new THREE.Ray();\n\t\tvar sphere = new THREE.Sphere();\n\n\t\tvar vA = new THREE.Vector3();\n\t\tvar vB = new THREE.Vector3();\n\t\tvar vC = new THREE.Vector3();\n\n\t\tvar tempA = new THREE.Vector3();\n\t\tvar tempB = new THREE.Vector3();\n\t\tvar tempC = new THREE.Vector3();\n\n\t\tvar uvA = new THREE.Vector2();\n\t\tvar uvB = new THREE.Vector2();\n\t\tvar uvC = new THREE.Vector2();\n\n\t\tvar barycoord = new THREE.Vector3();\n\n\t\tvar intersectionPoint = new THREE.Vector3();\n\t\tvar intersectionPointWorld = new THREE.Vector3();\n\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n\t\t\tuv1.multiplyScalar( barycoord.x );\n\t\t\tuv2.multiplyScalar( barycoord.y );\n\t\t\tuv3.multiplyScalar( barycoord.z );\n\n\t\t\tuv1.add( uv2 ).add( uv3 );\n\n\t\t\treturn uv1.clone();\n\n\t\t}\n\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\n\n\t\t\tvar intersect;\n\t\t\tvar material = object.material;\n\n\t\t\tif ( material.side === THREE.BackSide ) {\n\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t\t} else {\n\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\n\n\t\t\t}\n\n\t\t\tif ( intersect === null ) return null;\n\n\t\t\tintersectionPointWorld.copy( point );\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\t\t\treturn {\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: intersectionPointWorld.clone(),\n\t\t\t\tobject: object\n\t\t\t};\n\n\t\t}\n\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n\t\t\tif ( intersection ) {\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n\t\t\t\t}\n\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n\t\t\t\tintersection.faceIndex = a;\n\n\t\t\t}\n\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tvar geometry = this.geometry;\n\t\t\tvar material = this.material;\n\t\t\tvar matrixWorld = this.matrixWorld;\n\n\t\t\tif ( material === undefined ) return;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( matrixWorld );\n\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\n\n\t\t\t//\n\n\t\t\tinverseMatrix.getInverse( matrixWorld );\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t// Check boundingBox before continuing\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t\t}\n\n\t\t\tvar uvs, intersection;\n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar attributes = geometry.attributes;\n\t\t\t\tvar positions = attributes.position.array;\n\n\t\t\t\tif ( attributes.uv !== undefined ) {\n\n\t\t\t\t\tuvs = attributes.uv.array;\n\n\t\t\t\t}\n\n\t\t\t\tif ( index !== null ) {\n\n\t\t\t\t\tvar indices = index.array;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\ta = indices[ i ];\n\t\t\t\t\t\tb = indices[ i + 1 ];\n\t\t\t\t\t\tc = indices[ i + 2 ];\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\n\n\t\t\t\t\t\ta = i / 3;\n\t\t\t\t\t\tb = a + 1;\n\t\t\t\t\t\tc = a + 2;\n\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar fvA, fvB, fvC;\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar faces = geometry.faces;\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = faces[ f ];\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\n\n\t\t\t\t\tfvA = vertices[ face.a ];\n\t\t\t\t\tfvB = vertices[ face.b ];\n\t\t\t\t\tfvC = vertices[ face.c ];\n\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( fvA );\n\t\t\t\t\t\tvB.add( fvB );\n\t\t\t\t\t\tvC.add( fvC );\n\n\t\t\t\t\t\tfvA = vA;\n\t\t\t\t\t\tfvB = vB;\n\t\t\t\t\t\tfvC = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\n\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tintersection.face = face;\n\t\t\t\t\t\tintersection.faceIndex = f;\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/Bone.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.Bone = function ( skin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Bone';\n\n\tthis.skin = skin;\n\n};\n\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Bone,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.skin = source.skin;\n\n\t\treturn this;\n\n\t}\n\n} );\n\n// File:src/objects/Skeleton.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author michael guerrero / http://realitymeltdown.com\n * @author ikerr / http://verold.com\n */\n\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\t// copy the bone array\n\n\tbones = bones || [];\n\n\tthis.bones = bones.slice( 0 );\n\n\t// create a bone texture or an array of floats\n\n\tif ( this.useVertexTexture ) {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\n\t\tsize = Math.max( size, 4 );\n\n\t\tthis.boneTextureWidth = size;\n\t\tthis.boneTextureHeight = size;\n\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\n\t} else {\n\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\n\n\t}\n\n\t// use the supplied bone inverses or calculate the inverses\n\n\tif ( boneInverses === undefined ) {\n\n\t\tthis.calculateInverses();\n\n\t} else {\n\n\t\tif ( this.bones.length === boneInverses.length ) {\n\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nObject.assign( THREE.Skeleton.prototype, {\n\n\tcalculateInverses: function () {\n\n\t\tthis.boneInverses = [];\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\tif ( this.bones[ b ] ) {\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t},\n\n\tpose: function () {\n\n\t\tvar bone;\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdate: ( function () {\n\n\t\tvar offsetMatrix = new THREE.Matrix4();\n\n\t\treturn function update() {\n\n\t\t\t// flatten bone matrices to array\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\t// compute the offset between the current and the original transform\n\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\n\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\n\n\t\t\t}\n\n\t\t\tif ( this.useVertexTexture ) {\n\n\t\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )(),\n\n\tclone: function () {\n\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\n\n\t}\n\n} );\n\n// File:src/objects/SkinnedMesh.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.type = 'SkinnedMesh';\n\n\tthis.bindMode = \"attached\";\n\tthis.bindMatrix = new THREE.Matrix4();\n\tthis.bindMatrixInverse = new THREE.Matrix4();\n\n\t// init bones\n\n\t// TODO: remove bone creation as there is no reason (other than\n\t// convenience) for THREE.SkinnedMesh to do this.\n\n\tvar bones = [];\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tvar bone, gbone;\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tbone = new THREE.Bone( this );\n\t\t\tbones.push( bone );\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t}\n\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\n\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.add( bones[ b ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.normalizeSkinWeights();\n\n\tthis.updateMatrixWorld( true );\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\n\n};\n\n\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.SkinnedMesh,\n\n\tbind: function( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\n\n\t},\n\n\tpose: function () {\n\n\t\tthis.skeleton.pose();\n\n\t},\n\n\tnormalizeSkinWeights: function () {\n\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\n\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar vec = new THREE.Vector4();\n\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\n\n\t\t\t\tvec.x = skinWeight.getX( i );\n\t\t\t\tvec.y = skinWeight.getY( i );\n\t\t\t\tvec.z = skinWeight.getZ( i );\n\t\t\t\tvec.w = skinWeight.getW( i );\n\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\n\n\t\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\t\tvec.multiplyScalar( scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tupdateMatrixWorld: function( force ) {\n\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\n\n\t\tif ( this.bindMode === \"attached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\n\n\t\t} else if ( this.bindMode === \"detached\" ) {\n\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t},\n\n\tclone: function() {\n\n\t\treturn new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LOD.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'LOD';\n\n\tObject.defineProperties( this, {\n\t\tlevels: {\n\t\t\tenumerable: true,\n\t\t\tvalue: []\n\t\t}\n\t} );\n\n};\n\n\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LOD,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\n\n\t\tvar levels = source.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\taddLevel: function ( object, distance ) {\n\n\t\tif ( distance === undefined ) distance = 0;\n\n\t\tdistance = Math.abs( distance );\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\n\n\t\tthis.add( object );\n\n\t},\n\n\tgetObjectForDistance: function ( distance ) {\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\tif ( distance < levels[ i ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn levels[ i - 1 ].object;\n\n\t},\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t};\n\n\t}() ),\n\n\tupdate: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function update( camera ) {\n\n\t\t\tvar levels = this.levels;\n\n\t\t\tif ( levels.length > 1 ) {\n\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\n\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\ttoJSON: function ( meta ) {\n\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\n\n\t\tdata.object.levels = [];\n\n\t\tvar levels = this.levels;\n\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tvar level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n} );\n\n// File:src/objects/Sprite.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Sprite';\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.Sprite,\n\n\traycast: ( function () {\n\n\t\tvar matrixPosition = new THREE.Vector3();\n\n\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\n\n\t\t\tif ( distanceSq > guessSizeSq ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\n\t\t\t\tpoint: this.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\n\t\t\t} );\n\n\t\t};\n\n\t}() ),\n\n\tclone: function () {\n\n\t\treturn new this.constructor( this.material ).copy( this );\n\n\t}\n\n} );\n\n// File:src/objects/LensFlare.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif ( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.LensFlare,\n\n\tcopy: function ( source ) {\n\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\n\n\t\tthis.positionScreen.copy( source.positionScreen );\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\n\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\n\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\n\n\t\tif ( size === undefined ) size = - 1;\n\t\tif ( distance === undefined ) distance = 0;\n\t\tif ( opacity === undefined ) opacity = 1;\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\n\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\t\tthis.lensFlares.push( {\n\t\t\ttexture: texture,\t// THREE.Texture\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\n\t\t\tscale: 1, \t\t// scale\n\t\t\trotation: 0, \t\t// rotation\n\t\t\topacity: opacity,\t// opacity\n\t\t\tcolor: color,\t\t// color\n\t\t\tblending: blending\t// blending\n\t\t} );\n\n\t},\n\n\t/*\n\t * Update lens flares update positions on all flares based on the screen position\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t */\n\n\tupdateLensFlares: function () {\n\n\t\tvar f, fl = this.lensFlares.length;\n\t\tvar flare;\n\t\tvar vecX = - this.positionScreen.x * 2;\n\t\tvar vecY = - this.positionScreen.y * 2;\n\n\t\tfor ( f = 0; f < fl; f ++ ) {\n\n\t\t\tflare = this.lensFlares[ f ];\n\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t\t}\n\n\t}\n\n} );\n\n// File:src/scenes/Scene.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'Scene';\n\n\tthis.background = null;\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Scene.prototype.constructor = THREE.Scene;\n\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\n\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\n\n\tif ( source.background !== null ) this.background = source.background.clone();\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\tthis.autoUpdate = source.autoUpdate;\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\treturn this;\n\n};\n\n// File:src/scenes/Fog.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( color, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n// File:src/scenes/FogExp2.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( color, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( color );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n// File:src/renderers/shaders/ShaderChunk.js\n\nTHREE.ShaderChunk = {};\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\n\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\n\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\n\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\n\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\n\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/common.glsl\n\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\n\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\n\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\n\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\n\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#include <normal_flip>\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#include <normal_flip>\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t\tfloat clearCoat;\\n\t\tfloat clearCoatRoughness;\\n\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\t#ifndef STANDARD\\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\t#else\\n\t\tfloat clearCoatDHR = 0.0;\\n\t#endif\\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\t#ifndef STANDARD\\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\t#ifndef STANDARD\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\tfloat dotNL = dotNV;\\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\t#else\\n\t\tfloat clearCoatDHR = 0.0;\\n\t#endif\\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\t#ifndef STANDARD\\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\t#endif\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\n\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\t#ifndef STANDARD\\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\t#else\\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\t#endif\\n\t\t\\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\n\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\n\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl\n\nTHREE.ShaderChunk[ 'normal_flip' ] = \"#ifdef DOUBLE_SIDED\\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\n\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\n\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\n\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\n\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\n\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\n\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\n\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\n\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\n\n// File:src/renderers/shaders/UniformsUtils.js\n\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar merged = {};\n\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( var p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar uniforms_dst = {};\n\n\t\tfor ( var u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\n\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n\n// File:src/renderers/shaders/UniformsLib.js\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"specularMap\": { value: null },\n\t\t\"alphaMap\": { value: null },\n\n\t\t\"envMap\": { value: null },\n\t\t\"flipEnvMap\": { value: - 1 },\n\t\t\"reflectivity\": { value: 1.0 },\n\t\t\"refractionRatio\": { value: 0.98 }\n\n\t},\n\n\taomap: {\n\n\t\t\"aoMap\": { value: null },\n\t\t\"aoMapIntensity\": { value: 1 }\n\n\t},\n\n\tlightmap: {\n\n\t\t\"lightMap\": { value: null },\n\t\t\"lightMapIntensity\": { value: 1 }\n\n\t},\n\n\temissivemap: {\n\n\t\t\"emissiveMap\": { value: null }\n\n\t},\n\n\tbumpmap: {\n\n\t\t\"bumpMap\": { value: null },\n\t\t\"bumpScale\": { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\": { value: null },\n\t\t\"normalScale\": { value: new THREE.Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\t\"displacementMap\": { value: null },\n\t\t\"displacementScale\": { value: 1 },\n\t\t\"displacementBias\": { value: 0 }\n\n\t},\n\n\troughnessmap: {\n\n\t\t\"roughnessMap\": { value: null }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\t\"metalnessMap\": { value: null }\n\n\t},\n\n\tfog: {\n\n\t\t\"fogDensity\": { value: 0.00025 },\n\t\t\"fogNear\": { value: 1 },\n\t\t\"fogFar\": { value: 2000 },\n\t\t\"fogColor\": { value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\": { value: [] },\n\n\t\t\"directionalLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"color\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"directionalShadowMap\": { value: [] },\n\t\t\"directionalShadowMatrix\": { value: [] },\n\n\t\t\"spotLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"direction\": {},\n\t\t\t\"distance\": {},\n\t\t\t\"coneCos\": {},\n\t\t\t\"penumbraCos\": {},\n\t\t\t\"decay\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"spotShadowMap\": { value: [] },\n\t\t\"spotShadowMatrix\": { value: [] },\n\n\t\t\"pointLights\": { value: [], properties: {\n\t\t\t\"color\": {},\n\t\t\t\"position\": {},\n\t\t\t\"decay\": {},\n\t\t\t\"distance\": {},\n\n\t\t\t\"shadow\": {},\n\t\t\t\"shadowBias\": {},\n\t\t\t\"shadowRadius\": {},\n\t\t\t\"shadowMapSize\": {}\n\t\t} },\n\n\t\t\"pointShadowMap\": { value: [] },\n\t\t\"pointShadowMatrix\": { value: [] },\n\n\t\t\"hemisphereLights\": { value: [], properties: {\n\t\t\t\"direction\": {},\n\t\t\t\"skyColor\": {},\n\t\t\t\"groundColor\": {}\n\t\t} }\n\n\t},\n\n\tpoints: {\n\n\t\t\"diffuse\": { value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\": { value: 1.0 },\n\t\t\"size\": { value: 1.0 },\n\t\t\"scale\": { value: 1.0 },\n\t\t\"map\": { value: null },\n\t\t\"offsetRepeat\": { value: new THREE.Vector4( 0, 0, 1, 1 ) }\n\n\t}\n\n};\n\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\n\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\tgl_FragColor.a *= opacity;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\n\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\n\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\n\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\n\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\n\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\n\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\n\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\n\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\n\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <normal_flip>\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\n\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\tuniform float clearCoat;\\n\tuniform float clearCoatRoughness;\\n#endif\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_flip>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\n\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\n\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\n\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\n\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\n\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\n\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\n\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\n\n// File:src/renderers/shaders/ShaderLib.js\n\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { value: 30 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\n\n\t},\n\n\t'standard': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tTHREE.UniformsLib[ 'lights' ],\n\n\t\t\t{\n\t\t\t\t\"emissive\" : { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"metalness\": { value: 0 },\n\t\t\t\t\"envMapIntensity\" : { value: 1 }, // temporary\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n\t},\n\n\t'points': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'points' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\n\t\t\t{\n\t\t\t\t\"scale\"    : { value: 1 },\n\t\t\t\t\"dashSize\" : { value: 1 },\n\t\t\t\t\"totalSize\": { value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ 'common' ],\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\n\n\t\t] ),\n\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: {\n\t\t\t\"tCube\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 },\n\t\t\t\"opacity\": { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'equirect': {\n\n\t\tuniforms: {\n\t\t\t\"tEquirect\": { value: null },\n\t\t\t\"tFlip\": { value: - 1 }\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\n\n\t},\n\n\t'distanceRGBA': {\n\n\t\tuniforms: {\n\n\t\t\t\"lightPos\": { value: new THREE.Vector3() }\n\n\t\t},\n\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\n\n\t}\n\n};\n\nTHREE.ShaderLib[ 'physical' ] = {\n\n\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\n\n\t\t{\n\t\t\t\"clearCoat\": { value: 0 },\n\t\t\t\"clearCoatRoughness\": { value: 0 }\n\t\t}\n\n\t] ),\n\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\n\n};\n\n// File:src/renderers/WebGLRenderer.js\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n * @author tschw\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\n\t_context = parameters.context !== undefined ? parameters.context : null,\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\n\n\tvar lights = [];\n\n\tvar opaqueObjects = [];\n\tvar opaqueObjectsLastIndex = - 1;\n\tvar transparentObjects = [];\n\tvar transparentObjectsLastIndex = - 1;\n\n\tvar morphInfluences = new Float32Array( 8 );\n\n\tvar sprites = [];\n\tvar lensFlares = [];\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\n\t// user-defined clipping\n\n\tthis.clippingPlanes = [];\n\tthis.localClippingEnabled = false;\n\n\t// physically based shading\n\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// physical lights\n\n\tthis.physicallyCorrectLights = false;\n\n\t// tone mapping\n\n\tthis.toneMapping = THREE.LinearToneMapping;\n\tthis.toneMappingExposure = 1.0;\n\tthis.toneMappingWhitePoint = 1.0;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentRenderTarget = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = - 1,\n\t_currentGeometryProgram = '',\n\t_currentCamera = null,\n\n\t_currentScissor = new THREE.Vector4(),\n\t_currentScissorTest = null,\n\n\t_currentViewport = new THREE.Vector4(),\n\n\t//\n\n\t_usedTextureUnits = 0,\n\n\t//\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_width = _canvas.width,\n\t_height = _canvas.height,\n\n\t_pixelRatio = 1,\n\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\n\t_scissorTest = false,\n\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t// clipping\n\n\t_clipping = new THREE.WebGLClipping(),\n\t_clippingEnabled = false,\n\t_localClippingEnabled = false,\n\n\t_sphere = new THREE.Sphere(),\n\n\t// camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_lights = {\n\n\t\thash: '',\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotShadowMap: [],\n\t\tspotShadowMatrix: [],\n\t\tpoint: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\n\t\tshadows: []\n\n\t},\n\n\t// info\n\n\t_infoRender = {\n\n\t\tcalls: 0,\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tpoints: 0\n\n\t};\n\n\tthis.info = {\n\n\t\trender: _infoRender,\n\t\tmemory: {\n\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\t\tprograms: null\n\n\t};\n\n\n\t// initialize\n\n\tvar _gl;\n\n\ttry {\n\n\t\tvar attributes = {\n\t\t\talpha: _alpha,\n\t\t\tdepth: _depth,\n\t\t\tstencil: _stencil,\n\t\t\tantialias: _antialias,\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t};\n\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\tif ( _gl === null ) {\n\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t};\n\n\t\t}\n\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\n\t} catch ( error ) {\n\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\n\n\t}\n\n\tvar extensions = new THREE.WebGLExtensions( _gl );\n\n\textensions.get( 'WEBGL_depth_texture' );\n\textensions.get( 'OES_texture_float' );\n\textensions.get( 'OES_texture_float_linear' );\n\textensions.get( 'OES_texture_half_float' );\n\textensions.get( 'OES_texture_half_float_linear' );\n\textensions.get( 'OES_standard_derivatives' );\n\textensions.get( 'ANGLE_instanced_arrays' );\n\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\n\n\t}\n\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\n\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\n\tvar properties = new THREE.WebGLProperties();\n\tvar textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\n\tvar lightCache = new THREE.WebGLLights();\n\n\tthis.info.programs = programCache.programs;\n\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\n\n\t//\n\n\tvar backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar backgroundCamera2 = new THREE.PerspectiveCamera();\n\tvar backgroundPlaneMesh = new THREE.Mesh(\n\t\tnew THREE.PlaneBufferGeometry( 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\n\t);\n\tvar backgroundBoxShader = THREE.ShaderLib[ 'cube' ];\n\tvar backgroundBoxMesh = new THREE.Mesh(\n\t\tnew THREE.BoxBufferGeometry( 5, 5, 5 ),\n\t\tnew THREE.ShaderMaterial( {\n\t\t\tuniforms: backgroundBoxShader.uniforms,\n\t\t\tvertexShader: backgroundBoxShader.vertexShader,\n\t\t\tfragmentShader: backgroundBoxShader.fragmentShader,\n\t\t\tside: THREE.BackSide,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\tfog: false\n\t\t} )\n\t);\n\n\t//\n\n\tfunction getTargetPixelRatio() {\n\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t}\n\n\tfunction glClearColor( r, g, b, a ) {\n\n\t\tif ( _premultipliedAlpha === true ) {\n\n\t\t\tr *= a; g *= a; b *= a;\n\n\t\t}\n\n\t\tstate.clearColor( r, g, b, a );\n\n\t}\n\n\tfunction setDefaultGLState() {\n\n\t\tstate.init();\n\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t}\n\n\tfunction resetGLState() {\n\n\t\t_currentProgram = null;\n\t\t_currentCamera = null;\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\n\t\tstate.reset();\n\n\t}\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\tthis.capabilities = capabilities;\n\tthis.extensions = extensions;\n\tthis.properties = properties;\n\tthis.state = state;\n\n\t// shadow map\n\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects, capabilities );\n\n\tthis.shadowMap = shadowMap;\n\n\n\t// Plugins\n\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.getContextAttributes = function () {\n\n\t\treturn _gl.getContextAttributes();\n\n\t};\n\n\tthis.forceContextLoss = function () {\n\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn capabilities.getMaxAnisotropy();\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn capabilities.precision;\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn _pixelRatio;\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\tif ( value === undefined ) return;\n\n\t\t_pixelRatio = value;\n\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn {\n\t\t\twidth: _width,\n\t\t\theight: _height\n\t\t};\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_width = width;\n\t\t_height = height;\n\n\t\t_canvas.width = width * _pixelRatio;\n\t\t_canvas.height = height * _pixelRatio;\n\n\t\tif ( updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, width, height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t};\n\n\t// Clearing\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.setClearAlpha = function ( alpha ) {\n\n\t\t_clearAlpha = alpha;\n\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\tthis.clear( true, false, false );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\tthis.clear( false, true, false );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\tthis.clear( false, false, true );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Reset\n\n\tthis.resetGLState = resetGLState;\n\n\tthis.dispose = function() {\n\n\t\ttransparentObjects = [];\n\t\ttransparentObjectsLastIndex = -1;\n\t\topaqueObjects = [];\n\t\topaqueObjectsLastIndex = -1;\n\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\n\t};\n\n\t// Events\n\n\tfunction onContextLost( event ) {\n\n\t\tevent.preventDefault();\n\n\t\tresetGLState();\n\t\tsetDefaultGLState();\n\n\t\tproperties.clear();\n\n\t}\n\n\tfunction onMaterialDispose( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t}\n\n\t// Buffer deallocation\n\n\tfunction deallocateMaterial( material ) {\n\n\t\treleaseMaterialProgramReference( material );\n\n\t\tproperties.delete( material );\n\n\t}\n\n\n\tfunction releaseMaterialProgramReference( material ) {\n\n\t\tvar programInfo = properties.get( material ).program;\n\n\t\tmaterial.program = undefined;\n\n\t\tif ( programInfo !== undefined ) {\n\n\t\t\tprogramCache.releaseProgram( programInfo );\n\n\t\t}\n\n\t}\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tstate.initAttributes();\n\n\t\tvar buffers = properties.get( object );\n\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\n\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\n\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\n\n\t\t\t\t\tvar array = object.normalArray;\n\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\n\n\t\t\t\t\tarray[ i + 0 ] = nx;\n\t\t\t\t\tarray[ i + 1 ] = ny;\n\t\t\t\t\tarray[ i + 2 ] = nz;\n\n\t\t\t\t\tarray[ i + 3 ] = nx;\n\t\t\t\t\tarray[ i + 4 ] = ny;\n\t\t\t\t\tarray[ i + 5 ] = nz;\n\n\t\t\t\t\tarray[ i + 6 ] = nx;\n\t\t\t\t\tarray[ i + 7 ] = ny;\n\t\t\t\t\tarray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.normal );\n\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.uv );\n\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\n\t\t\tstate.enableAttribute( attributes.color );\n\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\n\n\t\tsetMaterial( material );\n\n\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\tvar updateBuffers = false;\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\n\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\n\n\t\t\t_currentGeometryProgram = geometryProgram;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphTargetInfluences !== undefined ) {\n\n\t\t\tvar activeInfluences = [];\n\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\n\n\t\t\t}\n\n\t\t\tactiveInfluences.sort( absNumericalSort );\n\n\t\t\tif ( activeInfluences.length > 8 ) {\n\n\t\t\t\tactiveInfluences.length = 8;\n\n\t\t\t}\n\n\t\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\n\n\t\t\t\tvar influence = activeInfluences[ i ];\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\n\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\n\n\t\t\t\t\tvar index = influence[ 1 ];\n\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprogram.getUniforms().setValue(\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\t//\n\n\t\tvar index = geometry.index;\n\t\tvar position = geometry.attributes.position;\n\n\t\tif ( material.wireframe === true ) {\n\n\t\t\tindex = objects.getWireframeAttribute( geometry );\n\n\t\t}\n\n\t\tvar renderer;\n\n\t\tif ( index !== null ) {\n\n\t\t\trenderer = indexedBufferRenderer;\n\t\t\trenderer.setIndex( index );\n\n\t\t} else {\n\n\t\t\trenderer = bufferRenderer;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tsetupVertexAttributes( material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar dataStart = 0;\n\t\tvar dataCount = Infinity;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdataCount = index.count;\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\tdataCount = position.count;\n\n\t\t}\n\n\t\tvar rangeStart = geometry.drawRange.start;\n\t\tvar rangeCount = geometry.drawRange.count;\n\n\t\tvar groupStart = group !== null ? group.start : 0;\n\t\tvar groupCount = group !== null ? group.count : Infinity;\n\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\n\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\n\n\t\t//\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( object.drawMode ) {\n\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\tif ( object instanceof THREE.LineSegments ) {\n\n\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Points ) {\n\n\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t}\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\n\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t}\n\n\t};\n\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\n\n\t\tvar extension;\n\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( startIndex === undefined ) startIndex = 0;\n\n\t\tstate.initAttributes();\n\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar programAttributes = program.getAttributes();\n\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( var name in programAttributes ) {\n\n\t\t\tvar programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute >= 0 ) {\n\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tvar type = _gl.FLOAT;\n\t\t\t\t\tvar array = geometryAttribute.array;\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\n\n\t\t\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\t\t\ttype = _gl.FLOAT;\n\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\n\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\t\t\t\ttype = _gl.SHORT;\n\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\n\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\t\t\t\ttype = _gl.INT;\n\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\t\t\t\ttype = _gl.BYTE;\n\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\n\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tvar data = geometryAttribute.data;\n\t\t\t\t\t\tvar stride = data.stride;\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\n\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.disableUnusedAttributes();\n\n\t}\n\n\t// Sorting\n\n\tfunction absNumericalSort( a, b ) {\n\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {\n\n\t\t\treturn a.material.program.id - b.material.program.id;\n\n\t\t} else if ( a.material.id !== b.material.id ) {\n\n\t\t\treturn a.material.id - b.material.id;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn a.z - b.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\tfunction reversePainterSortStable ( a, b ) {\n\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\n\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\n\n\t\t} if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t}\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar fog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentGeometryProgram = '';\n\t\t_currentMaterialId = - 1;\n\t\t_currentCamera = null;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\tlights.length = 0;\n\n\t\topaqueObjectsLastIndex = - 1;\n\t\ttransparentObjectsLastIndex = - 1;\n\n\t\tsprites.length = 0;\n\t\tlensFlares.length = 0;\n\n\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\n\n\t\tprojectObject( scene, camera );\n\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\n\n\t\tif ( _this.sortObjects === true ) {\n\n\t\t\topaqueObjects.sort( painterSortStable );\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\n\n\t\tsetupShadows( lights );\n\n\t\tshadowMap.render( scene, camera );\n\n\t\tsetupLights( lights, camera );\n\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\n\n\t\t//\n\n\t\t_infoRender.calls = 0;\n\t\t_infoRender.vertices = 0;\n\t\t_infoRender.faces = 0;\n\t\t_infoRender.points = 0;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = null;\n\n\t\t}\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\t//\n\n\t\tvar background = scene.background;\n\n\t\tif ( background === null ) {\n\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t\t} else if ( background instanceof THREE.Color ) {\n\n\t\t\tglClearColor( background.r, background.g, background.b, 1 );\n\n\t\t}\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background instanceof THREE.CubeTexture ) {\n\n\t\t\tbackgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tbackgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );\n\t\t\tbackgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );\n\n\t\t\tbackgroundBoxMesh.material.uniforms[ \"tCube\" ].value = background;\n\t\t\tbackgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );\n\n\t\t\tobjects.update( backgroundBoxMesh );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );\n\n\t\t} else if ( background instanceof THREE.Texture ) {\n\n\t\t\tbackgroundPlaneMesh.material.map = background;\n\n\t\t\tobjects.update( backgroundPlaneMesh );\n\n\t\t\t_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\n\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\n\n\t\t} else {\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\t\t\trenderObjects( opaqueObjects, camera, fog );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( transparentObjects, camera, fog );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\tspritePlugin.render( scene, camera );\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget ) {\n\n\t\t\ttextures.updateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tstate.setDepthTest( true );\n\t\tstate.setDepthWrite( true );\n\t\tstate.setColorWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\n\n\t\tvar array, index;\n\n\t\t// allocate the next position in the appropriate array\n\n\t\tif ( material.transparent ) {\n\n\t\t\tarray = transparentObjects;\n\t\t\tindex = ++ transparentObjectsLastIndex;\n\n\t\t} else {\n\n\t\t\tarray = opaqueObjects;\n\t\t\tindex = ++ opaqueObjectsLastIndex;\n\n\t\t}\n\n\t\t// recycle existing render item or grow the array\n\n\t\tvar renderItem = array[ index ];\n\n\t\tif ( renderItem !== undefined ) {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.z = _vector3.z;\n\t\t\trenderItem.group = group;\n\n\t\t} else {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tz: _vector3.z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\t// assert( index === array.length );\n\t\t\tarray.push( renderItem );\n\n\t\t}\n\n\t}\n\n\t// TODO Duplicated code (Frustum)\n\n\tfunction isObjectViewable( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null )\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).\n\t\t\tapplyMatrix4( object.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSpriteViewable( sprite ) {\n\n\t\t_sphere.center.set( 0, 0, 0 );\n\t\t_sphere.radius = 0.7071067811865476;\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn isSphereViewable( _sphere );\n\n\t}\n\n\tfunction isSphereViewable( sphere ) {\n\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\n\n\t\tvar numPlanes = _clipping.numPlanes;\n\n\t\tif ( numPlanes === 0 ) return true;\n\n\t\tvar planes = _this.clippingPlanes,\n\n\t\t\tcenter = sphere.center,\n\t\t\tnegRad = - sphere.radius,\n\t\t\ti = 0;\n\n\t\tdo {\n\n\t\t\t// out when deeper than radius in the negative halfspace\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\n\n\t\t} while ( ++ i !== numPlanes );\n\n\t\treturn true;\n\n\t}\n\n\tfunction projectObject( object, camera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t\tlights.push( object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\n\n\t\t\t\t\tsprites.push( object );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tlensFlares.push( object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\n\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\n\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\t\tobject.skeleton.update();\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\n\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar geometry = objects.update( object );\n\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera );\n\n\t\t}\n\n\t}\n\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\n\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\tvar renderItem = renderList[ i ];\n\n\t\t\tvar object = renderItem.object;\n\t\t\tvar geometry = renderItem.geometry;\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\n\t\t\tvar group = renderItem.group;\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\n\n\t\t\t\tsetMaterial( material );\n\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\n\n\t\t\t\t_currentGeometryProgram = '';\n\n\t\t\t\tobject.render( function ( object ) {\n\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initMaterial( material, fog, object ) {\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tvar parameters = programCache.getParameters(\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\n\n\t\tvar code = programCache.getProgramCode( material, parameters );\n\n\t\tvar program = materialProperties.program;\n\t\tvar programChange = true;\n\n\t\tif ( program === undefined ) {\n\n\t\t\t// new material\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t} else if ( program.code !== code ) {\n\n\t\t\t// changed glsl or parameters\n\t\t\treleaseMaterialProgramReference( material );\n\n\t\t} else if ( parameters.shaderID !== undefined ) {\n\n\t\t\t// same glsl and uniform list\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// only rebuild uniform list\n\t\t\tprogramChange = false;\n\n\t\t}\n\n\t\tif ( programChange ) {\n\n\t\t\tif ( parameters.shaderID ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\tfragmentShader: shader.fragmentShader\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tmaterialProperties.__webglShader = {\n\t\t\t\t\tname: material.type,\n\t\t\t\t\tuniforms: material.uniforms,\n\t\t\t\t\tvertexShader: material.vertexShader,\n\t\t\t\t\tfragmentShader: material.fragmentShader\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\n\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\n\n\t\t\tmaterialProperties.program = program;\n\t\t\tmaterial.program = program;\n\n\t\t}\n\n\t\tvar attributes = program.getAttributes();\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\n\t\t\t\tmaterial.clipping === true ) {\n\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\n\n\t\t}\n\n\t\tif ( material.lights ) {\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\n\n\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\n\t\t\tuniforms.directionalLights.value = _lights.directional;\n\t\t\tuniforms.spotLights.value = _lights.spot;\n\t\t\tuniforms.pointLights.value = _lights.point;\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\n\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\n\n\t\t}\n\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\n\t\t\tuniformsList =\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\tmaterialProperties.uniformsList = uniformsList;\n\t\tmaterialProperties.dynamicUniforms =\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\n\n\t}\n\n\tfunction setMaterial( material ) {\n\n\t\tif ( material.side !== THREE.DoubleSide )\n\t\t\tstate.enable( _gl.CULL_FACE );\n\t\telse\n\t\t\tstate.disable( _gl.CULL_FACE );\n\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\n\n\t\tif ( material.transparent === true ) {\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\t} else {\n\n\t\t\tstate.setBlending( THREE.NoBlending );\n\n\t\t}\n\n\t\tstate.setDepthFunc( material.depthFunc );\n\t\tstate.setDepthTest( material.depthTest );\n\t\tstate.setDepthWrite( material.depthWrite );\n\t\tstate.setColorWrite( material.colorWrite );\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t}\n\n\tfunction setProgram( camera, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tvar materialProperties = properties.get( material );\n\n\t\tif ( _clippingEnabled ) {\n\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\n\n\t\t\t\tvar useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t// (#8465, #8379)\n\t\t\t\t_clipping.setState(\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\n\t\t\t\t\t\tcamera, materialProperties, useCache );\n\n\t\t\t}\n\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\n\n\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialProperties.program === undefined ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( materialProperties.lightsHash !== undefined &&\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\n\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tinitMaterial( material, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tvar refreshProgram = false;\n\t\tvar refreshMaterial = false;\n\t\tvar refreshLights = false;\n\n\t\tvar program = materialProperties.program,\n\t\t\tp_uniforms = program.getUniforms(),\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\n\n\t\tif ( program.id !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program.program );\n\t\t\t_currentProgram = program.id;\n\n\t\t\trefreshProgram = true;\n\t\t\trefreshMaterial = true;\n\t\t\trefreshLights = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\n\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\n\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t}\n\n\n\t\t\tif ( camera !== _currentCamera ) {\n\n\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t}\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t}\n\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\n\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\tif ( material.lights ) {\n\n\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t// values\n\t\t\t\t//\n\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t// the GL state when required\n\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t}\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\n\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\n\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tif ( material.displacementMap ) {\n\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\t}\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tTHREE.WebGLUniforms.upload(\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\n\n\t\t}\n\n\n\t\t// common matrices\n\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\n\t\t// dynamic uniforms\n\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\n\n\t\tif ( dynUniforms !== null ) {\n\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\n\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tuniforms.diffuse.value = material.color;\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.specularMap.value = material.specularMap;\n\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t// 1. color map\n\t\t// 2. specular map\n\t\t// 3. normal map\n\t\t// 4. bump map\n\t\t// 5. alpha map\n\t\t// 6. emissive map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.displacementMap ) {\n\n\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t} else if ( material.roughnessMap ) {\n\n\t\t\tuvScaleMap = material.roughnessMap;\n\n\t\t} else if ( material.metalnessMap ) {\n\n\t\t\tuvScaleMap = material.metalnessMap;\n\n\t\t} else if ( material.alphaMap ) {\n\n\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t} else if ( material.emissiveMap ) {\n\n\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t// backwards compatibility\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t}\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\n\t\t// don't flip CubeTexture envMaps, flip everything else:\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\n\n\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t}\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t}\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * _pixelRatio;\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\n\n\t\tuniforms.map.value = material.map;\n\n\t\tif ( material.map !== null ) {\n\n\t\t\tvar offset = material.map.offset;\n\t\t\tvar repeat = material.map.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.specular.value = material.specular;\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard ( uniforms, material ) {\n\n\t\tuniforms.roughness.value = material.roughness;\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t}\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\n\n\t\tuniforms.clearCoat.value = material.clearCoat;\n\t\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\n\n\t\trefreshUniformsStandard( uniforms, material );\n\n\t}\n\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\n\n\t\tuniforms.ambientLightColor.needsUpdate = value;\n\n\t\tuniforms.directionalLights.needsUpdate = value;\n\t\tuniforms.pointLights.needsUpdate = value;\n\t\tuniforms.spotLights.needsUpdate = value;\n\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t}\n\n\t// Lighting\n\n\tfunction setupShadows ( lights ) {\n\n\t\tvar lightShadowsLength = 0;\n\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tvar light = lights[ i ];\n\n\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.shadows.length = lightShadowsLength;\n\n\t}\n\n\tfunction setupLights ( lights, camera ) {\n\n\t\tvar l, ll, light,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor,\n\t\tintensity,\n\t\tdistance,\n\t\tshadowMap,\n\n\t\tviewMatrix = camera.matrixWorldInverse,\n\n\t\tdirectionalLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tr += color.r * intensity;\n\t\t\t\tg += color.g * intensity;\n\t\t\t\tb += color.b * intensity;\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( _vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\n\n\t\t\t\tuniforms.shadow = light.castShadow;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\n\n\t\t\t\t}\n\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\n\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\n\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\n\n\t\t\t\t}\n\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\n\t\t\t\t// equal to inverse of the light's position\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\n\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\tvar uniforms = lightCache.get( light );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\t\t\t\tuniforms.direction.normalize();\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\n\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_lights.ambient[ 0 ] = r;\n\t\t_lights.ambient[ 1 ] = g;\n\t\t_lights.ambient[ 2 ] = b;\n\n\t\t_lights.directional.length = directionalLength;\n\t\t_lights.spot.length = spotLength;\n\t\t_lights.point.length = pointLength;\n\t\t_lights.hemi.length = hemiLength;\n\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\n\n\t}\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tstate.setCullFace( cullFace );\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\n\n\t};\n\n\t// Textures\n\n\tfunction allocTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\n\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tthis.allocTextureUnit = allocTextureUnit;\n\n\t// this.setTexture2D = setTexture2D;\n\tthis.setTexture2D = ( function() {\n\n\t\tvar warned = false;\n\n\t\t// backwards compatibility: peel texture.texture\n\t\treturn function setTexture2D( texture, slot ) {\n\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTexture = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTexture( texture, slot ) {\n\n\t\t\tif ( ! warned ) {\n\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\n\t\t\t\twarned = true;\n\n\t\t\t}\n\n\t\t\ttextures.setTexture2D( texture, slot );\n\n\t\t};\n\n\t}() );\n\n\tthis.setTextureCube = ( function() {\n\n\t\tvar warned = false;\n\n\t\treturn function setTextureCube( texture, slot ) {\n\n\t\t\t// backwards compatibility: peel texture.texture\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\n\t\t\t\t\twarned = true;\n\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\n\t\t\t}\n\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n\t\t\t// TODO: unify these code paths\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\n\n\t\t\t\t// CompressedTexture can have Array in image :/\n\n\t\t\t\t// this function alone should take care of cube textures\n\t\t\t\ttextures.setTextureCube( texture, slot );\n\n\t\t\t} else {\n\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\n\n\t\t\t\ttextures.setTextureCubeDynamic( texture, slot );\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.getCurrentRenderTarget = function() {\n\n\t\treturn _currentRenderTarget;\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t_currentRenderTarget = renderTarget;\n\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\n\n\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t}\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar framebuffer;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t_currentViewport.copy( renderTarget.viewport );\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\n\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\n\n\t\t}\n\n\t\tif ( _currentFramebuffer !== framebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\tstate.scissor( _currentScissor );\n\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\tstate.viewport( _currentViewport );\n\n\t\tif ( isCube ) {\n\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\n\n\t\t}\n\n\t};\n\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\tif ( framebuffer ) {\n\n\t\t\tvar restore = false;\n\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\trestore = true;\n\n\t\t\t}\n\n\t\t\ttry {\n\n\t\t\t\tvar texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\n\n\t\t\t\t}\n\n\t\t\t} finally {\n\n\t\t\t\tif ( restore ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tvar extension;\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\n\n\t\t}\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t}\n\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t}\n\n};\n\n// File:src/renderers/WebGLRenderTarget.js\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n * @author Marius Kintel / https://github.com/kintel\n */\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\n\tthis.scissorTest = false;\n\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\n\n\toptions = options || {};\n\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\n\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\tthis.depthTexture = null;\n\n};\n\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\n\n\tsetSize: function ( width, height ) {\n\n\t\tif ( this.width !== width || this.height !== height ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new this.constructor().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\tthis.depthTexture = source.depthTexture;\n\n\t\treturn this;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\n// File:src/renderers/WebGLRenderTargetCube.js\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\tthis.activeMipMapLevel = 0;\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\n\n// File:src/renderers/webgl/WebGLBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawArrays( mode, start, count );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar position = geometry.attributes.position;\n\n\t\tvar count = 0;\n\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tcount = position.data.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t} else {\n\n\t\t\tcount = position.count;\n\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\n\n\t\t}\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\n\t}\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLClipping.js\n\nTHREE.WebGLClipping = function() {\n\n\tvar scope = this,\n\n\t\tglobalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false,\n\n\t\tplane = new THREE.Plane(),\n\t\tviewNormalMatrix = new THREE.Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\n\tthis.init = function( planes, enableLocalClipping, camera ) {\n\n\t\tvar enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function() {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function() {\n\n\t\trenderingShadows = false;\n\t\tresetGlobalState();\n\n\t};\n\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\n\n\t\tif ( ! localClippingEnabled ||\n\t\t\t\tplanes === null || planes.length === 0 ||\n\t\t\t\trenderingShadows && ! clipShadows ) {\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4,\n\n\t\t\t\tdstArray = cache.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\n\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tcache.clippingState = dstArray;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\n\t\t\tdstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\treturn dstArray;\n\n\t}\n\n};\n\n\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\n\n\tvar mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tvar type, size;\n\n\tfunction setIndex( index ) {\n\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\n\n\t\t\ttype = _gl.UNSIGNED_INT;\n\t\t\tsize = 4;\n\n\t\t} else {\n\n\t\t\ttype = _gl.UNSIGNED_SHORT;\n\t\t\tsize = 2;\n\n\t\t}\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\t_gl.drawElements( mode, count, type, start * size );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\n\n\t}\n\n\tfunction renderInstances( geometry, start, count ) {\n\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\n\n\t\t_infoRender.calls ++;\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\n\t}\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n};\n\n// File:src/renderers/webgl/WebGLExtensions.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLExtensions = function ( gl ) {\n\n\tvar extensions = {};\n\n\tthis.get = function ( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tvar extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\tif ( extension === null ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLCapabilities.js\n\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\n\n\tvar maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tthis.getMaxAnisotropy = getMaxAnisotropy;\n\tthis.getMaxPrecision = getMaxPrecision;\n\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\n\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tthis.vertexTextures = this.maxVertexTextures > 0;\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\n\n\tvar _maxPrecision = getMaxPrecision( this.precision );\n\n\tif ( _maxPrecision !== this.precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\n\t\tthis.precision = _maxPrecision;\n\n\t}\n\n\tif ( this.logarithmicDepthBuffer ) {\n\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLGeometries.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\n\n\tvar geometries = {};\n\n\tfunction get( object ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\n\n\t\t\treturn geometries[ geometry.id ];\n\n\t\t}\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tvar buffergeometry;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tbuffergeometry = geometry;\n\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\n\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\n\n\t\t\t}\n\n\t\t\tbuffergeometry = geometry._bufferGeometry;\n\n\t\t}\n\n\t\tgeometries[ geometry.id ] = buffergeometry;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tvar geometry = event.target;\n\t\tvar buffergeometry = geometries[ geometry.id ];\n\n\t\tif ( buffergeometry.index !== null ) {\n\n\t\t\tdeleteAttribute( buffergeometry.index );\n\n\t\t}\n\n\t\tdeleteAttributes( buffergeometry.attributes );\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\t// TODO\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe ) {\n\n\t\t\tdeleteAttribute( property.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( geometry );\n\n\t\tvar bufferproperty = properties.get( buffergeometry );\n\n\t\tif ( bufferproperty.wireframe ) {\n\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\n\n\t\t}\n\n\t\tproperties.delete( buffergeometry );\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction deleteAttribute( attribute ) {\n\n\t\tvar buffer = getAttributeBuffer( attribute );\n\n\t\tif ( buffer !== undefined ) {\n\n\t\t\tgl.deleteBuffer( buffer );\n\t\t\tremoveAttributeBuffer( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction deleteAttributes( attributes ) {\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tdeleteAttribute( attributes[ name ] );\n\n\t\t}\n\n\t}\n\n\tfunction removeAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\tproperties.delete( attribute.data );\n\n\t\t} else {\n\n\t\t\tproperties.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tthis.get = get;\n\n};\n\n// File:src/renderers/webgl/WebGLLights.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLLights = function () {\n\n\tvar lights = {};\n\n\tthis.get = function ( light ) {\n\n\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\treturn lights[ light.id ];\n\n\t\t}\n\n\t\tvar uniforms;\n\n\t\tswitch ( light.type ) {\n\n\t\t\tcase 'DirectionalLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tconeCos: 0,\n\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\tcolor: new THREE.Color(),\n\t\t\t\t\tdistance: 0,\n\t\t\t\t\tdecay: 0,\n\n\t\t\t\t\tshadow: false,\n\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\t\t\t\tuniforms = {\n\t\t\t\t\tdirection: new THREE.Vector3(),\n\t\t\t\t\tskyColor: new THREE.Color(),\n\t\t\t\t\tgroundColor: new THREE.Color()\n\t\t\t\t};\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tlights[ light.id ] = uniforms;\n\n\t\treturn uniforms;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLObjects.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLObjects = function ( gl, properties, info ) {\n\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\n\n\t//\n\n\tfunction update( object ) {\n\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\n\t\tvar geometry = geometries.get( object );\n\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\t\tgeometry.updateFromObject( object );\n\n\t\t}\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\n\t\tif ( index !== null ) {\n\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tvar morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar array = morphAttributes[ name ];\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction updateAttribute( attribute, bufferType ) {\n\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\n\n\t\tvar attributeProperties = properties.get( data );\n\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\n\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\n\n\t\t} else if ( attributeProperties.version !== data.version ) {\n\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\n\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\n\n\t\tgl.bufferData( bufferType, data.array, usage );\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\n\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\n\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\n\n\t\t} else if ( data.updateRange.count === 0 ) {\n\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\n\n\t\t} else {\n\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\n\n\t\t\tdata.updateRange.count = 0; // reset range\n\n\t\t}\n\n\t\tattributeProperties.version = data.version;\n\n\t}\n\n\tfunction getAttributeBuffer( attribute ) {\n\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\n\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\n\n\t\t}\n\n\t\treturn properties.get( attribute ).__webglBuffer;\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tvar property = properties.get( geometry );\n\n\t\tif ( property.wireframe !== undefined ) {\n\n\t\t\treturn property.wireframe;\n\n\t\t}\n\n\t\tvar indices = [];\n\n\t\tvar index = geometry.index;\n\t\tvar attributes = geometry.attributes;\n\t\tvar position = attributes.position;\n\n\t\t// console.time( 'wireframe' );\n\n\t\tif ( index !== null ) {\n\n\t\t\tvar edges = {};\n\t\t\tvar array = index.array;\n\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tvar a = array[ i + 0 ];\n\t\t\t\tvar b = array[ i + 1 ];\n\t\t\t\tvar c = array[ i + 2 ];\n\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar array = attributes.position.array;\n\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tvar a = i + 0;\n\t\t\t\tvar b = i + 1;\n\t\t\t\tvar c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// console.timeEnd( 'wireframe' );\n\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\n\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\tproperty.wireframe = attribute;\n\n\t\treturn attribute;\n\n\t}\n\n\tfunction checkEdge( edges, a, b ) {\n\n\t\tif ( a > b ) {\n\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\n\t\t}\n\n\t\tvar list = edges[ a ];\n\n\t\tif ( list === undefined ) {\n\n\t\t\tedges[ a ] = [ b ];\n\t\t\treturn true;\n\n\t\t} else if ( list.indexOf( b ) === -1 ) {\n\n\t\t\tlist.push( b );\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tthis.getAttributeBuffer = getAttributeBuffer;\n\tthis.getWireframeAttribute = getWireframeAttribute;\n\n\tthis.update = update;\n\n};\n\n// File:src/renderers/webgl/WebGLProgram.js\n\nTHREE.WebGLProgram = ( function () {\n\n\tvar programIdCount = 0;\n\n\tfunction getEncodingComponents( encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.LinearEncoding:\n\t\t\t\treturn [ 'Linear','( value )' ];\n\t\t\tcase THREE.sRGBEncoding:\n\t\t\t\treturn [ 'sRGB','( value )' ];\n\t\t\tcase THREE.RGBEEncoding:\n\t\t\t\treturn [ 'RGBE','( value )' ];\n\t\t\tcase THREE.RGBM7Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\n\t\t\tcase THREE.RGBM16Encoding:\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\n\t\t\tcase THREE.RGBDEncoding:\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\n\t\t\tcase THREE.GammaEncoding:\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\n\n\t\t}\n\n\t}\n\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\n\n\t\tvar components = getEncodingComponents( encoding );\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\n\n\t}\n\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\t\tvar toneMappingName;\n\n\t\tswitch ( toneMapping ) {\n\n\t\t\tcase THREE.LinearToneMapping:\n\t\t\t\ttoneMappingName = \"Linear\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.ReinhardToneMapping:\n\t\t\t\ttoneMappingName = \"Reinhard\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.Uncharted2ToneMapping:\n\t\t\t\ttoneMappingName = \"Uncharted2\";\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.CineonToneMapping:\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\n\n\t\t}\n\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n\n\t}\n\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\n\n\t\textensions = extensions || {};\n\n\t\tvar chunks = [\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\n\t\t];\n\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tfunction generateDefines( defines ) {\n\n\t\tvar chunks = [];\n\n\t\tfor ( var name in defines ) {\n\n\t\t\tvar value = defines[ name ];\n\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t\t}\n\n\t\treturn chunks.join( '\\n' );\n\n\t}\n\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\n\n\t\tvar attributes = {};\n\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\t\tfor ( var i = 0; i < n; i ++ ) {\n\n\t\t\tvar info = gl.getActiveAttrib( program, i );\n\t\t\tvar name = info.name;\n\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\n\n\t\t}\n\n\t\treturn attributes;\n\n\t}\n\n\tfunction filterEmptyLine( string ) {\n\n\t\treturn string !== '';\n\n\t}\n\n\tfunction replaceLightNums( string, parameters ) {\n\n\t\treturn string\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\n\n\t}\n\n\tfunction parseIncludes( string ) {\n\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\n\n\t\tfunction replace( match, include ) {\n\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\n\n\t\t\tif ( replace === undefined ) {\n\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t\t}\n\n\t\t\treturn parseIncludes( replace );\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\tfunction unrollLoops( string ) {\n\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\n\t\tfunction replace( match, start, end, snippet ) {\n\n\t\t\tvar unroll = '';\n\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\n\n\t\t\t}\n\n\t\t\treturn unroll;\n\n\t\t}\n\n\t\treturn string.replace( pattern, replace );\n\n\t}\n\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\n\n\t\tvar gl = renderer.context;\n\n\t\tvar extensions = material.extensions;\n\t\tvar defines = material.defines;\n\n\t\tvar vertexShader = material.__webglShader.vertexShader;\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\n\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t\t}\n\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\n\t\tif ( parameters.envMap ) {\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeReflectionMapping:\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.SphericalReflectionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.envMap.mapping ) {\n\n\t\t\t\tcase THREE.CubeRefractionMapping:\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tswitch ( material.combine ) {\n\n\t\t\t\tcase THREE.MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\n\n\t\t// console.log( 'building new program ' );\n\n\t\t//\n\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar prefixVertex, prefixFragment;\n\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomDefines\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t} else {\n\n\t\t\tprefixVertex = [\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\n\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec3 normal;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'#ifdef USE_COLOR',\n\n\t\t\t\t'\tattribute vec3 color;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\n\n\t\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t\t'\t#else',\n\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t\t'\t#endif',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t\t'#endif',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t\tprefixFragment = [\n\n\t\t\t\tcustomExtensions,\n\n\t\t\t\t'precision ' + parameters.precision + ' float;',\n\t\t\t\t'precision ' + parameters.precision + ' int;',\n\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\n\n\t\t\t\tcustomDefines,\n\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\n\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\n\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\n\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\n\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\n\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\n\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\n\n\t\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t\t'uniform vec3 cameraPosition;',\n\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\n\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\n\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\n\n\t\t\t\t'\\n'\n\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\t}\n\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\n\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\n\n\t\t\tvertexShader = unrollLoops( vertexShader );\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\n\n\t\t}\n\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\n\n\t\t// console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\t\tgl.attachShader( program, glVertexShader );\n\t\tgl.attachShader( program, glFragmentShader );\n\n\t\t// Force a particular attribute to index 0.\n\n\t\tif ( material.index0AttributeName !== undefined ) {\n\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\n\n\t\t} else if ( parameters.morphTargets === true ) {\n\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t\t}\n\n\t\tgl.linkProgram( program );\n\n\t\tvar programLog = gl.getProgramInfoLog( program );\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\n\n\t\tvar runnable = true;\n\t\tvar haveDiagnostics = true;\n\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\t\t\t\tmaterial: material,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t// clean up\n\n\t\tgl.deleteShader( glVertexShader );\n\t\tgl.deleteShader( glFragmentShader );\n\n\t\t// set up caching for uniform locations\n\n\t\tvar cachedUniforms;\n\n\t\tthis.getUniforms = function() {\n\n\t\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\t\tcachedUniforms =\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\n\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\n\t\t};\n\n\t\t// set up caching for attribute locations\n\n\t\tvar cachedAttributes;\n\n\t\tthis.getAttributes = function() {\n\n\t\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\n\t\t};\n\n\t\t// free resource\n\n\t\tthis.destroy = function() {\n\n\t\t\tgl.deleteProgram( program );\n\t\t\tthis.program = undefined;\n\n\t\t};\n\n\t\t// DEPRECATED\n\n\t\tObject.defineProperties( this, {\n\n\t\t\tuniforms: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\n\t\t\t\t\treturn this.getUniforms();\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tattributes: {\n\t\t\t\tget: function() {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\n\t\t\t\t\treturn this.getAttributes();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\n\t\t//\n\n\t\tthis.id = programIdCount ++;\n\t\tthis.code = code;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\n\t\treturn this;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLPrograms.js\n\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\n\n\tvar programs = [];\n\n\tvar shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points'\n\t};\n\n\tvar parameterNames = [\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\n\t\t\"roughnessMap\", \"metalnessMap\",\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\n\t];\n\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t//\n\t\t\t//  - leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\n\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t}\n\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\n\n\t\tvar encoding;\n\n\t\tif ( ! map ) {\n\n\t\t\tencoding = THREE.LinearEncoding;\n\n\t\t} else if ( map instanceof THREE.Texture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\n\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\n\t\t\tencoding = map.texture.encoding;\n\n\t\t}\n\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\n\n\t\t\tencoding = THREE.GammaEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\n\n\t\tvar shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tvar maxBones = allocateBones( object );\n\t\tvar precision = renderer.getPrecision();\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\n\n\t\tvar parameters = {\n\n\t\t\tshaderID: shaderID,\n\n\t\t\tprecision: precision,\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\n\t\t\tmap: !! material.map,\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\n\t\t\tenvMap: !! material.envMap,\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\n\t\t\tlightMap: !! material.lightMap,\n\t\t\taoMap: !! material.aoMap,\n\t\t\temissiveMap: !! material.emissiveMap,\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\n\t\t\tbumpMap: !! material.bumpMap,\n\t\t\tnormalMap: !! material.normalMap,\n\t\t\tdisplacementMap: !! material.displacementMap,\n\t\t\troughnessMap: !! material.roughnessMap,\n\t\t\tmetalnessMap: !! material.metalnessMap,\n\t\t\tspecularMap: !! material.specularMap,\n\t\t\talphaMap: !! material.alphaMap,\n\n\t\t\tcombine: material.combine,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tflatShading: material.shading === THREE.FlatShading,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumClippingPlanes: nClipPlanes,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: renderer.toneMapping,\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide,\n\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\n\n\t\t};\n\n\t\treturn parameters;\n\n\t};\n\n\tthis.getProgramCode = function ( material, parameters ) {\n\n\t\tvar array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( material.fragmentShader );\n\t\t\tarray.push( material.vertexShader );\n\n\t\t}\n\n\t\tif ( material.defines !== undefined ) {\n\n\t\t\tfor ( var name in material.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( material.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\n\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\n\n\t\t}\n\n\t\treturn array.join();\n\n\t};\n\n\tthis.acquireProgram = function ( material, parameters, code ) {\n\n\t\tvar program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\tprogram = programInfo;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\tthis.releaseProgram = function( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tvar i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t};\n\n\t// Exposed for resource monitoring & error feedback via renderer.info:\n\tthis.programs = programs;\n\n};\n\n// File:src/renderers/webgl/WebGLProperties.js\n\n/**\n* @author fordacious / fordacious.github.io\n*/\n\nTHREE.WebGLProperties = function () {\n\n\tvar properties = {};\n\n\tthis.get = function ( object ) {\n\n\t\tvar uuid = object.uuid;\n\t\tvar map = properties[ uuid ];\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties[ uuid ] = map;\n\n\t\t}\n\n\t\treturn map;\n\n\t};\n\n\tthis.delete = function ( object ) {\n\n\t\tdelete properties[ object.uuid ];\n\n\t};\n\n\tthis.clear = function () {\n\n\t\tproperties = {};\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLShader.js\n\nTHREE.WebGLShader = ( function () {\n\n\tfunction addLineNumbers( string ) {\n\n\t\tvar lines = string.split( '\\n' );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\n\n\t\t}\n\n\t\treturn lines.join( '\\n' );\n\n\t}\n\n\treturn function WebGLShader( gl, type, string ) {\n\n\t\tvar shader = gl.createShader( type );\n\n\t\tgl.shaderSource( shader, string );\n\t\tgl.compileShader( shader );\n\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\n\n\t\t}\n\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\n\n\t\t}\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\treturn shader;\n\n\t};\n\n} )();\n\n// File:src/renderers/webgl/WebGLShadowMap.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects, capabilities ) {\n\n\tvar _gl = _renderer.context,\n\t_state = _renderer.state,\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_lightShadows = _lights.shadows,\n\n\t_shadowMapSize = new THREE.Vector2(),\n\t_maxShadowMapSize = new THREE.Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),\n\n\t_lookTarget = new THREE.Vector3(),\n\t_lightPositionWorld = new THREE.Vector3(),\n\n\t_renderList = [],\n\n\t_MorphingFlag = 1,\n\t_SkinningFlag = 2,\n\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\n\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\n\n\t_materialCache = {};\n\n\tvar cubeDirections = [\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\n\t];\n\n\tvar cubeUps = [\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\n\t];\n\n\tvar cube2DViewPorts = [\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\n\t];\n\n\t// init\n\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\n\tdepthMaterialTemplate.clipping = true;\n\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\n\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\n\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\n\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\n\t\tdepthMaterial.morphTargets = useMorphing;\n\t\tdepthMaterial.skinning = useSkinning;\n\n\t\t_depthMaterials[ i ] = depthMaterial;\n\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\n\t\t\tdefines: {\n\t\t\t\t'USE_SHADOWMAP': ''\n\t\t\t},\n\t\t\tuniforms: distanceUniforms,\n\t\t\tvertexShader: distanceShader.vertexShader,\n\t\t\tfragmentShader: distanceShader.fragmentShader,\n\t\t\tmorphTargets: useMorphing,\n\t\t\tskinning: useSkinning,\n\t\t\tclipping: true\n\t\t} );\n\n\t\t_distanceMaterials[ i ] = distanceMaterial;\n\n\t}\n\n\t//\n\n\tvar scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = THREE.PCFShadowMap;\n\n\tthis.renderReverseSided = true;\n\tthis.renderSingleSided = true;\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( _lightShadows.length === 0 ) return;\n\n\t\t// Set GL state for depth map.\n\t\t_state.clearColor( 1, 1, 1, 1 );\n\t\t_state.disable( _gl.BLEND );\n\t\t_state.setDepthTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// render depth map\n\n\t\tvar faceCount, isPointLight;\n\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\n\n\t\t\tvar light = _lightShadows[ i ];\n\t\t\tvar shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar shadowCamera = shadow.camera;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\t\t\t_shadowMapSize.min( _maxShadowMapSize );\n\n\t\t\tif ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tfaceCount = 6;\n\t\t\t\tisPointLight = true;\n\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\n\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t\t// following orientation:\n\t\t\t\t//\n\t\t\t\t//  xzXZ\n\t\t\t\t//   y Y\n\t\t\t\t//\n\t\t\t\t// X - Positive x direction\n\t\t\t\t// x - Negative x direction\n\t\t\t\t// Y - Positive y direction\n\t\t\t\t// y - Negative y direction\n\t\t\t\t// Z - Positive z direction\n\t\t\t\t// z - Negative z direction\n\n\t\t\t\t// positive X\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative X\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Z\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// negative Z\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\n\t\t\t\t// positive Y\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\n\t\t\t\t// negative Y\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\n\n\t\t\t\t_shadowMapSize.x *= 4.0;\n\t\t\t\t_shadowMapSize.y *= 2.0;\n\n\t\t\t} else {\n\n\t\t\t\tfaceCount = 1;\n\t\t\t\tisPointLight = false;\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null ) {\n\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\n\t\t\t\tshadowCamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\n\n\t\t\t\tshadow.update( light );\n\n\t\t\t}\n\n\t\t\tvar shadowMap = shadow.map;\n\t\t\tvar shadowMatrix = shadow.matrix;\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// render shadow map for each cube face (if omni-directional) or\n\t\t\t// run a single pass if not\n\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\n\n\t\t\t\tif ( isPointLight ) {\n\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\n\t\t\t\t\t_state.viewport( vpDimensions );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\n\n\t\t\t\t}\n\n\t\t\t\tshadowCamera.updateMatrixWorld();\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\t\t// compute shadow matrix\n\n\t\t\t\tshadowMatrix.set(\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t\t// update camera matrices and frustum\n\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t\t// set object matrices & frustum culling\n\n\t\t\t\t_renderList.length = 0;\n\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\n\n\t\t\t\t// render shadow map\n\t\t\t\t// render regular objects\n\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar object = _renderList[ j ];\n\t\t\t\t\tvar geometry = _objects.update( object );\n\t\t\t\t\tvar material = object.material;\n\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\n\n\t\t\t\t\t\tvar groups = geometry.groups;\n\t\t\t\t\t\tvar materials = material.materials;\n\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\tvar group = groups[ k ];\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\n\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\n\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Restore GL state.\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\n\n\t\tscope.needsUpdate = false;\n\n\t};\n\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\n\n\t\tvar geometry = object.geometry;\n\n\t\tvar result = null;\n\n\t\tvar materialVariants = _depthMaterials;\n\t\tvar customMaterial = object.customDepthMaterial;\n\n\t\tif ( isPointLight ) {\n\n\t\t\tmaterialVariants = _distanceMaterials;\n\t\t\tcustomMaterial = object.customDistanceMaterial;\n\n\t\t}\n\n\t\tif ( ! customMaterial ) {\n\n\t\t\tvar useMorphing = false;\n\n\t\t\tif ( material.morphTargets ) {\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\n\n\t\t\tvar variantIndex = 0;\n\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\n\n\t\t\tresult = materialVariants[ variantIndex ];\n\n\t\t} else {\n\n\t\t\tresult = customMaterial;\n\n\t\t}\n\n\t\tif ( _renderer.localClippingEnabled &&\n\t\t\t material.clipShadows === true &&\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\n\n\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t// appropriate state\n\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\n\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\n\n\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t}\n\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t}\n\n\t\t\tresult = cachedMaterial;\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tvar side = material.side;\n\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\n\n\t\t\tside = THREE.FrontSide;\n\n\t\t}\n\n\t\tif ( scope.renderReverseSided ) {\n\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\n\n\t\t}\n\n\t\tresult.side = side;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\n\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction projectObject( object, camera, shadowCamera ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\n\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material.visible === true ) {\n\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\t\t\t\t\t_renderList.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar children = object.children;\n\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/renderers/webgl/WebGLState.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\n\n\tvar _this = this;\n\n\tthis.buffers = {\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\n\t};\n\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\n\n\tvar capabilities = {};\n\n\tvar compressedTextureFormats = null;\n\n\tvar currentBlending = null;\n\tvar currentBlendEquation = null;\n\tvar currentBlendSrc = null;\n\tvar currentBlendDst = null;\n\tvar currentBlendEquationAlpha = null;\n\tvar currentBlendSrcAlpha = null;\n\tvar currentBlendDstAlpha = null;\n\tvar currentPremultipledAlpha = false;\n\n\tvar currentFlipSided = null;\n\tvar currentCullFace = null;\n\n\tvar currentLineWidth = null;\n\n\tvar currentPolygonOffsetFactor = null;\n\tvar currentPolygonOffsetUnits = null;\n\n\tvar currentScissorTest = null;\n\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\n\tvar currentTextureSlot = null;\n\tvar currentBoundTextures = {};\n\n\tvar currentScissor = new THREE.Vector4();\n\tvar currentViewport = new THREE.Vector4();\n\n\tfunction createTexture( type, target, count ) {\n\n\t\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tvar texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tvar emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\t//\n\n\tthis.init = function () {\n\n\t\tthis.clearColor( 0, 0, 0, 1 );\n\t\tthis.clearDepth( 1 );\n\t\tthis.clearStencil( 0 );\n\n\t\tthis.enable( gl.DEPTH_TEST );\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\n\n\t\tthis.setFlipSided( false );\n\t\tthis.setCullFace( THREE.CullFaceBack );\n\t\tthis.enable( gl.CULL_FACE );\n\n\t\tthis.enable( gl.BLEND );\n\t\tthis.setBlending( THREE.NormalBlending );\n\n\t};\n\n\tthis.initAttributes = function () {\n\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttribute = function ( attribute ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\n\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\n\t\t\tattributeDivisors[ attribute ] = 0;\n\n\t\t}\n\n\t};\n\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t};\n\n\tthis.disableUnusedAttributes = function () {\n\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.enable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tcapabilities[ id ] = true;\n\n\t\t}\n\n\t};\n\n\tthis.disable = function ( id ) {\n\n\t\tif ( capabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tcapabilities[ id ] = false;\n\n\t\t}\n\n\t};\n\n\tthis.getCompressedTextureFormats = function () {\n\n\t\tif ( compressedTextureFormats === null ) {\n\n\t\t\tcompressedTextureFormats = [];\n\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\n\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\n\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\n\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn compressedTextureFormats;\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending !== THREE.NoBlending ) {\n\n\t\t\tthis.enable( gl.BLEND );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.BLEND );\n\t\t\tcurrentBlending = blending; // no blending, that is\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\n\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\n\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.setColorWrite = function ( colorWrite ) {\n\n\t\tthis.buffers.color.setMask( colorWrite );\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tthis.buffers.depth.setTest( depthTest );\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tthis.buffers.depth.setMask( depthWrite );\n\n\t};\n\n\tthis.setDepthFunc = function ( depthFunc ) {\n\n\t\tthis.buffers.depth.setFunc( depthFunc );\n\n\t};\n\n\tthis.setStencilTest = function ( stencilTest ) {\n\n\t\tthis.buffers.stencil.setTest( stencilTest );\n\n\t};\n\n\tthis.setStencilWrite = function ( stencilWrite ) {\n\n\t\tthis.buffers.stencil.setMask( stencilWrite );\n\n\t};\n\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\n\n\t};\n\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\n\n\t};\n\n\t//\n\n\tthis.setFlipSided = function ( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setCullFace = function ( cullFace ) {\n\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\n\n\t\t\tthis.enable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t};\n\n\tthis.setLineWidth = function ( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tgl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t};\n\n\tthis.getScissorTest = function () {\n\n\t\treturn currentScissorTest;\n\n\t};\n\n\tthis.setScissorTest = function ( scissorTest ) {\n\n\t\tcurrentScissorTest = scissorTest;\n\n\t\tif ( scissorTest ) {\n\n\t\t\tthis.enable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tthis.disable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t};\n\n\t// texture\n\n\tthis.activeTexture = function ( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t};\n\n\tthis.bindTexture = function ( webglType, webglTexture ) {\n\n\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t_this.activeTexture();\n\n\t\t}\n\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t};\n\n\tthis.compressedTexImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\tthis.texImage2D = function () {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t};\n\n\t// TODO Deprecate\n\n\tthis.clearColor = function ( r, g, b, a ) {\n\n\t\tthis.buffers.color.setClear( r, g, b, a );\n\n\t};\n\n\tthis.clearDepth = function ( depth ) {\n\n\t\tthis.buffers.depth.setClear( depth );\n\n\t};\n\n\tthis.clearStencil = function ( stencil ) {\n\n\t\tthis.buffers.stencil.setClear( stencil );\n\n\t};\n\n\t//\n\n\tthis.scissor = function ( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t};\n\n\tthis.viewport = function ( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t};\n\n\t//\n\n\tthis.reset = function () {\n\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcapabilities = {};\n\n\t\tcompressedTextureFormats = null;\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBlending = null;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tthis.buffers.color.reset();\n\t\tthis.buffers.depth.reset();\n\t\tthis.buffers.stencil.reset();\n\n\t};\n\n};\n\nTHREE.WebGLColorBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar color = new THREE.Vector4();\n\tvar currentColorMask = null;\n\tvar currentColorClear = new THREE.Vector4();\n\n\tthis.setMask = function ( colorMask ) {\n\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\tcurrentColorMask = colorMask;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( r, g, b, a ) {\n\n\t\tcolor.set( r, g, b, a );\n\n\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\tgl.clearColor( r, g, b, a );\n\t\t\tcurrentColorClear.copy( color );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentColorMask = null;\n\t\tcurrentColorClear = new THREE.Vector4();\n\n\t};\n\n};\n\nTHREE.WebGLDepthBuffer = function( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentDepthMask = null;\n\tvar currentDepthFunc = null;\n\tvar currentDepthClear = null;\n\n\tthis.setTest = function ( depthTest ) {\n\n\t\tif ( depthTest ) {\n\n\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function( depthMask ){\n\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\tgl.depthMask( depthMask );\n\t\t\tcurrentDepthMask = depthMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( depthFunc ) {\n\n\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\tif ( depthFunc ) {\n\n\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\tcase THREE.NeverDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.AlwaysDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.LessEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.EqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.GreaterDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.NotEqualDepth:\n\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t}\n\n\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( depth ) {\n\n\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\tgl.clearDepth( depth );\n\t\t\tcurrentDepthClear = depth;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentDepthMask = null;\n\t\tcurrentDepthFunc = null;\n\t\tcurrentDepthClear = null;\n\n\t};\n\n};\n\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\n\n\tvar locked = false;\n\n\tvar currentStencilMask = null;\n\tvar currentStencilFunc = null;\n\tvar currentStencilRef = null;\n\tvar currentStencilFuncMask = null;\n\tvar currentStencilFail  = null;\n\tvar currentStencilZFail = null;\n\tvar currentStencilZPass = null;\n\tvar currentStencilClear = null;\n\n\tthis.setTest = function ( stencilTest ) {\n\n\t\tif ( stencilTest ) {\n\n\t\t\tstate.enable( gl.STENCIL_TEST );\n\n\t\t} else {\n\n\t\t\tstate.disable( gl.STENCIL_TEST );\n\n\t\t}\n\n\t};\n\n\tthis.setMask = function ( stencilMask ) {\n\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\tgl.stencilMask( stencilMask );\n\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t     currentStencilRef \t!== stencilRef \t||\n\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\n\n\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\tcurrentStencilRef  = stencilRef;\n\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t}\n\n\t};\n\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\tif ( currentStencilFail\t !== stencilFail \t||\n\t\t     currentStencilZFail !== stencilZFail ||\n\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\n\n\t\t\tcurrentStencilFail  = stencilFail;\n\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t}\n\n\t};\n\n\tthis.setLocked = function ( lock ) {\n\n\t\tlocked = lock;\n\n\t};\n\n\tthis.setClear = function ( stencil ) {\n\n\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\tgl.clearStencil( stencil );\n\t\t\tcurrentStencilClear = stencil;\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tlocked = false;\n\n\t\tcurrentStencilMask = null;\n\t\tcurrentStencilFunc = null;\n\t\tcurrentStencilRef = null;\n\t\tcurrentStencilFuncMask = null;\n\t\tcurrentStencilFail = null;\n\t\tcurrentStencilZFail = null;\n\t\tcurrentStencilZPass = null;\n\t\tcurrentStencilClear = null;\n\n\t};\n\n};\n\n// File:src/renderers/webgl/WebGLTextures.js\n\n/**\n* @author mrdoob / http://mrdoob.com/\n*/\n\nTHREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {\n\n\tvar _infoMemory = info.memory;\n\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );\n\n\t//\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t\t// premultiplied alpha.\n\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = Math.floor( image.width * scale );\n\t\t\tcanvas.height = Math.floor( image.height * scale );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo( image ) {\n\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction makePowerOfTwo( image ) {\n\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\n\n\t\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\n\n\t\t\treturn canvas;\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\n\n\t\treturn false;\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_infoMemory.textures --;\n\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_infoMemory.textures --;\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\t// remove all webgl properties\n\t\tproperties.delete( texture );\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\tif ( ! renderTarget ) return;\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\n\t\t}\n\n\t\tproperties.delete( renderTarget.texture );\n\t\tproperties.delete( renderTarget );\n\n\t}\n\n\t//\n\n\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tvar image = texture.image;\n\n\t\t\tif ( image === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t}\n\n\tfunction setTextureCube ( texture, slot ) {\n\n\t\tvar textureProperties = properties.get( texture );\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_infoMemory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( ! isCompressed ) {\n\n\t\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__version = texture.version;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t\t} else {\n\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setTextureCubeDynamic ( texture, slot ) {\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\n\n\t}\n\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\n\n\t\tvar extension;\n\n\t\tif ( isPowerOfTwoImage ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\n\n\t\t\t}\n\n\t\t}\n\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\tif ( extension ) {\n\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t_infoMemory.textures ++;\n\n\t\t}\n\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\n\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\n\n\t\t\timage = makePowerOfTwo( image );\n\n\t\t}\n\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\n\t\tglFormat = paramThreeToGL( texture.format ),\n\t\tglType = paramThreeToGL( texture.type );\n\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\n\n\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\tif ( texture instanceof THREE.DepthTexture ) {\n\n\t\t\t// populate depth texture with dummy data\n\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\tif ( texture.type === THREE.FloatType ) {\n\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t} else if ( _isWebGL2 ) {\n\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t}\n\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t}\n\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\n\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\n\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t// use manually created mipmaps if available\n\t\t\t// if there are no manual mipmaps\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\n\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\ttextureProperties.__version = texture.version;\n\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\n\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t// FIXME: We don't support !depth !stencil\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\n\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tvar renderTargetProperties = properties.get( renderTarget );\n\t\tvar textureProperties = properties.get( renderTarget.texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t_infoMemory.textures ++;\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tvar texture = renderTarget.texture;\n\n\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\n\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\n\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\tvar webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t_gl.generateMipmap( target );\n\t\t\tstate.bindTexture( target, null );\n\n\t\t}\n\n\t}\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\n};\n\n// File:src/renderers/webgl/WebGLUniforms.js\n\n/**\n *\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [renderer] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'renderer' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (renderer factorizations):\n *\n * .upload( gl, seq, values, renderer )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n * .splitDynamic( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\n *\n *\n * Methods of the top-level container (renderer factorizations):\n *\n * .setValue( gl, name, value )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .set( gl, obj, prop )\n *\n * \t\tsets uniform from object and property with same name than uniform\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n *\n * @author tschw\n *\n */\n\nTHREE.WebGLUniforms = ( function() { // scope\n\n\tvar emptyTexture = new THREE.Texture();\n\tvar emptyCubeTexture = new THREE.CubeTexture();\n\n\t// --- Base for inner nodes (including the root) ---\n\n\tvar UniformContainer = function() {\n\n\t\t\tthis.seq = [];\n\t\t\tthis.map = {};\n\n\t\t},\n\n\t// --- Utilities ---\n\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\t\tarrayCacheF32 = [],\n\t\tarrayCacheI32 = [],\n\n\t\tuncacheTemporaryArrays = function() {\n\n\t\t\tarrayCacheF32.length = 0;\n\t\t\tarrayCacheI32.length = 0;\n\n\t\t},\n\n\t// Flattening for arrays of vectors and matrices\n\n\t\tflatten = function( array, nBlocks, blockSize ) {\n\n\t\t\tvar firstElem = array[ 0 ];\n\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t\t\t// unoptimized: ! isNaN( firstElem )\n\t\t\t// see http://jacksondunstan.com/articles/983\n\n\t\t\tvar n = nBlocks * blockSize,\n\t\t\t\tr = arrayCacheF32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Float32Array( n );\n\t\t\t\tarrayCacheF32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tif ( nBlocks !== 0 ) {\n\n\t\t\t\tfirstElem.toArray( r, 0 );\n\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\t\t\toffset += blockSize;\n\t\t\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// Texture unit allocation\n\n\t\tallocTexUnits = function( renderer, n ) {\n\n\t\t\tvar r = arrayCacheI32[ n ];\n\n\t\t\tif ( r === undefined ) {\n\n\t\t\t\tr = new Int32Array( n );\n\t\t\t\tarrayCacheI32[ n ] = r;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i !== n; ++ i )\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\n\n\t\t\treturn r;\n\n\t\t},\n\n\t// --- Setters ---\n\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\n\t\t// Single scalar\n\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\n\n\t\t// Single float vector (from flat array or THREE.VectorN)\n\n\t\tsetValue2fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\n\n\t\t},\n\n\t\tsetValue3fv = function( gl, v ) {\n\n\t\t\tif ( v.x !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\t\t\telse if ( v.r !== undefined )\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\t\t\telse\n\t\t\t\tgl.uniform3fv( this.addr, v );\n\n\t\t},\n\n\t\tsetValue4fv = function( gl, v ) {\n\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t},\n\n\t\t// Single matrix (from flat array or MatrixN)\n\n\t\tsetValue2fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue3fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\tsetValue4fm = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\n\n\t\t},\n\n\t\t// Single texture (2D / Cube)\n\n\t\tsetValueT1 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTexture2D( v || emptyTexture, unit );\n\n\t\t},\n\n\t\tsetValueT6 = function( gl, v, renderer ) {\n\n\t\t\tvar unit = renderer.allocTextureUnit();\n\t\t\tgl.uniform1i( this.addr, unit );\n\t\t\trenderer.setTextureCube( v || emptyCubeTexture, unit );\n\n\t\t},\n\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\n\n\t\t// Helper to pick the right setter for the singular case\n\n\t\tgetSingularSetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Array of scalars\n\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\n\n\t\t// Array of vectors (flat or from THREE classes)\n\n\t\tsetValueV2a = function( gl, v ) {\n\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\n\n\t\t},\n\n\t\tsetValueV3a = function( gl, v ) {\n\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\n\n\t\t},\n\n\t\tsetValueV4a = function( gl, v ) {\n\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\t// Array of matrices (flat or from THREE clases)\n\n\t\tsetValueM2a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\n\n\t\t},\n\n\t\tsetValueM3a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\n\n\t\t},\n\n\t\tsetValueM4a = function( gl, v ) {\n\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\n\n\t\t},\n\n\t\t// Array of textures (2D / Cube)\n\n\t\tsetValueT1a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetValueT6a = function( gl, v, renderer ) {\n\n\t\t\tvar n = v.length,\n\t\t\t\tunits = allocTexUnits( renderer, n );\n\n\t\t\tgl.uniform1iv( this.addr, units );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t\t\t}\n\n\t\t},\n\n\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\n\n\t\tgetPureArraySetter = function( type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\n\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\n\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\n\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\n\n\t\t\t}\n\n\t\t},\n\n\t// --- Uniform Classes ---\n\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\n\n\t\t\tthis.id = id;\n\t\t\tthis.addr = addr;\n\t\t\tthis.size = activeInfo.size;\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t\t// this.path = activeInfo.name; // DEBUG\n\n\t\t},\n\n\t\tStructuredUniform = function( id ) {\n\n\t\t\tthis.id = id;\n\n\t\t\tUniformContainer.call( this ); // mix-in\n\n\t\t};\n\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\n\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\n\t\t// are not allowed in structured uniforms.\n\n\t\tvar seq = this.seq;\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ] );\n\n\t\t}\n\n\t};\n\n\t// --- Top-level ---\n\n\t// Parser - builds up the property tree from the path strings\n\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\n\t\t// extracts\n\t\t// \t- the identifier (member name or array index)\n\t\t//  - followed by an optional right bracket (found when array index)\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\n\t\t//\n\t\t// Note: These portions can be read in a non-overlapping fashion and\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t\t// in the uniform names.\n\n\t\taddUniform = function( container, uniformObject ) {\n\n\t\t\tcontainer.seq.push( uniformObject );\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n\t\t},\n\n\t\tparseUniform = function( activeInfo, addr, container ) {\n\n\t\t\tvar path = activeInfo.name,\n\t\t\t\tpathLength = path.length;\n\n\t\t\t// reset RegExp object, because of the early exit of a previous run\n\t\t\tRePathPart.lastIndex = 0;\n\n\t\t\tfor (; ;) {\n\n\t\t\t\tvar match = RePathPart.exec( path ),\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\n\n\t\t\t\t\tid = match[ 1 ],\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\n\t\t\t\t\tsubscript = match[ 3 ];\n\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\t\t\tif ( subscript === undefined ||\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t} else {\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\t\t\tvar map = container.map,\n\t\t\t\t\t\tnext = map[ id ];\n\n\t\t\t\t\tif ( next === undefined ) {\n\n\t\t\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\t\t\taddUniform( container, next );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontainer = next;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t// Root Container\n\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\n\n\t\t\tUniformContainer.call( this );\n\n\t\t\tthis.renderer = renderer;\n\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\n\t\t\t\t\tpath = info.name,\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\n\n\t\t\t\tparseUniform( info, addr, this );\n\n\t\t\t}\n\n\t\t};\n\n\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\n\n\t\tvar u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\n\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\n\n\t\tvar v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t};\n\n\n\t// Static interface\n\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\n\t\t\t\tu.setValue( gl, v.value, renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\n\n\t\tvar r = [];\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\n\n\t\tvar r = null,\n\t\t\tn = seq.length,\n\t\t\tw = 0;\n\n\t\tfor ( var i = 0; i !== n; ++ i ) {\n\n\t\t\tvar u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v && v.dynamic === true ) {\n\n\t\t\t\tif ( r === null ) r = [];\n\t\t\t\tr.push( u );\n\n\t\t\t} else {\n\n\t\t\t\t// in-place compact 'seq', removing the matches\n\t\t\t\tif ( w < i ) seq[ w ] = u;\n\t\t\t\t++ w;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( w < n ) seq.length = w;\n\n\t\treturn r;\n\n\t};\n\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\n\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tvar v = values[ seq[ i ].id ],\n\t\t\t\tf = v.onUpdateCallback;\n\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\n\n\t\t}\n\n\t};\n\n\treturn WebGLUniforms;\n\n} )();\n\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar shader, program, attributes, uniforms;\n\n\tvar tempTexture, occlusionTexture;\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 1, - 1,  0, 0,\n\t\t\t 1, - 1,  1, 0,\n\t\t\t 1,  1,  1, 1,\n\t\t\t- 1,  1,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\t// buffers\n\n\t\tvertexBuffer     = gl.createBuffer();\n\t\telementBuffer    = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\ttempTexture      = gl.createTexture();\n\t\tocclusionTexture = gl.createTexture();\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\n\t\tshader = {\n\n\t\t\tvertexShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\t\"uniform vec2 scale;\",\n\t\t\t\t\"uniform float rotation;\",\n\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\t\"attribute vec2 position;\",\n\t\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\n\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" ),\n\n\t\t\tfragmentShader: [\n\n\t\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\t\"uniform sampler2D map;\",\n\t\t\t\t\"uniform float opacity;\",\n\t\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\t\"varying vec2 vUV;\",\n\t\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\t// pink square\n\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t\t// restore\n\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\n\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t\t// flare\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"}\"\n\n\t\t\t].join( \"\\n\" )\n\n\t\t};\n\n\t\tprogram = createProgram( shader );\n\n\t\tattributes = {\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\n\t\t};\n\n\t\tuniforms = {\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\n\t\t};\n\n\t}\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t */\n\n\tthis.render = function ( scene, camera, viewport ) {\n\n\t\tif ( flares.length === 0 ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewport.w / viewport.z,\n\t\t\thalfViewportWidth = viewport.z * 0.5,\n\t\t\thalfViewportHeight = viewport.w * 0.5;\n\n\t\tvar size = 16 / viewport.w,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar validArea = new THREE.Box2();\n\n\t\tvalidArea.min.set( 0, 0 );\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.vertex );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/uniforms\n\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\n\t\tgl.uniform1i( uniforms.map, 1 );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.setDepthWrite( false );\n\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\n\n\t\t\tsize = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tvar flare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\tstate.disable( gl.BLEND );\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\n\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\n\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition );\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\tstate.enable( gl.BLEND );\n\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\n\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\t\tstate.enable( gl.DEPTH_TEST );\n\t\tstate.setDepthWrite( true );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram ( shader ) {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\n\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\tgl.compileShader( fragmentShader );\n\t\tgl.compileShader( vertexShader );\n\n\t\tgl.attachShader( program, fragmentShader );\n\t\tgl.attachShader( program, vertexShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n};\n\n// File:src/renderers/webgl/plugins/SpritePlugin.js\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function ( renderer, sprites ) {\n\n\tvar gl = renderer.context;\n\tvar state = renderer.state;\n\n\tvar vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tvar texture;\n\n\t// decompose matrixWorld\n\n\tvar spritePosition = new THREE.Vector3();\n\tvar spriteRotation = new THREE.Quaternion();\n\tvar spriteScale = new THREE.Vector3();\n\n\tfunction init() {\n\n\t\tvar vertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5,  0, 0,\n\t\t\t  0.5, - 0.5,  1, 0,\n\t\t\t  0.5,   0.5,  1, 1,\n\t\t\t- 0.5,   0.5,  0, 1\n\t\t] );\n\n\t\tvar faces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = gl.createBuffer();\n\t\telementBuffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = 'white';\n\t\tcontext.fillRect( 0, 0, 8, 8 );\n\n\t\ttexture = new THREE.Texture( canvas );\n\t\ttexture.needsUpdate = true;\n\n\t}\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( sprites.length === 0 ) return;\n\n\t\t// setup gl\n\n\t\tif ( program === undefined ) {\n\n\t\t\tinit();\n\n\t\t}\n\n\t\tgl.useProgram( program );\n\n\t\tstate.initAttributes();\n\t\tstate.enableAttribute( attributes.position );\n\t\tstate.enableAttribute( attributes.uv );\n\t\tstate.disableUnusedAttributes();\n\n\t\tstate.disable( gl.CULL_FACE );\n\t\tstate.enable( gl.BLEND );\n\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\n\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\tstate.activeTexture( gl.TEXTURE0 );\n\t\tgl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tvar scale = [];\n\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\n\n\t\t\tvar sprite = sprites[ i ];\n\t\t\tvar material = sprite.material;\n\n\t\t\tif ( material.visible === false ) continue;\n\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\n\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\n\n\t\t\tscale[ 0 ] = spriteScale.x;\n\t\t\tscale[ 1 ] = spriteScale.y;\n\n\t\t\tvar fogType = 0;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\n\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tstate.setDepthTest( material.depthTest );\n\t\t\tstate.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map ) {\n\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\tstate.enable( gl.CULL_FACE );\n\n\t\trenderer.resetGLState();\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = gl.createProgram();\n\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\n\n\t\tgl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\tgl.compileShader( vertexShader );\n\t\tgl.compileShader( fragmentShader );\n\n\t\tgl.attachShader( program, vertexShader );\n\t\tgl.attachShader( program, fragmentShader );\n\n\t\tgl.linkProgram( program );\n\n\t\treturn program;\n\n\t}\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.renderOrder !== b.renderOrder ) {\n\n\t\t\treturn a.renderOrder - b.renderOrder;\n\n\t\t} else if ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/Three.Legacy.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nObject.assign( THREE, {\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\t},\n\tLineStrip: 0,\n\tLinePieces: 1,\n\tMeshFaceMaterial: THREE.MultiMaterial,\n\tPointCloud: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tParticle: THREE.Sprite,\n\tParticleSystem: function ( geometry, material ) {\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\n\t\treturn new THREE.Points( geometry, material );\n\t},\n\tPointCloudMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleBasicMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tParticleSystemMaterial: function ( parameters ) {\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\n\t\treturn new THREE.PointsMaterial( parameters );\n\t},\n\tVertex: function ( x, y, z ) {\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\n\t\treturn new THREE.Vector3( x, y, z );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Box2.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t}\n} );\n\nObject.assign( THREE.Box3.prototype, {\n\tempty: function () {\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\n\t\treturn this.isEmpty();\n\t},\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Matrix3.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t}\n} );\n\nObject.assign( THREE.Matrix4.prototype, {\n\textractPosition: function ( m ) {\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\t},\n\tsetRotationFromQuaternion: function ( q ) {\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\n\t\treturn this.makeRotationFromQuaternion( q );\n\t},\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\t},\n\tmultiplyVector4: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\tmultiplyVector3Array: function ( a ) {\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\n\t\treturn this.applyToVector3Array( a );\n\t},\n\trotateAxis: function ( v ) {\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\t\tv.transformDirection( this );\n\t},\n\tcrossVector: function ( vector ) {\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\t},\n\ttranslate: function ( v ) {\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\n\t},\n\trotateX: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\n\t},\n\trotateY: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\n\t},\n\trotateZ: function ( angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\n\t},\n\trotateByAxis: function ( axis, angle ) {\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\n\t}\n} );\n\nObject.assign( THREE.Plane.prototype, {\n\tisIntersectionLine: function ( line ) {\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\n\t\treturn this.intersectsLine( line );\n\t}\n} );\n\nObject.assign( THREE.Quaternion.prototype, {\n\tmultiplyVector3: function ( vector ) {\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\t}\n} );\n\nObject.assign( THREE.Ray.prototype, {\n\tisIntersectionBox: function ( box ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\n\t\treturn this.intersectsBox( box );\n\t},\n\tisIntersectionPlane: function ( plane ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\n\t\treturn this.intersectsPlane( plane );\n\t},\n\tisIntersectionSphere: function ( sphere ) {\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\n\t\treturn this.intersectsSphere( sphere );\n\t}\n} );\n\nObject.assign( THREE.Vector3.prototype, {\n\tsetEulerFromRotationMatrix: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\n\t},\n\tsetEulerFromQuaternion: function () {\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\n\t},\n\tgetPositionFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\n\t\treturn this.setFromMatrixPosition( m );\n\t},\n\tgetScaleFromMatrix: function ( m ) {\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\n\t\treturn this.setFromMatrixColumn( matrix, index );\n\t}\n} );\n\n//\n\nObject.assign( THREE.Object3D.prototype, {\n\tgetChildByName: function ( name ) {\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name );\n\t},\n\trenderDepth: function ( value ) {\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\n\t},\n\ttranslate: function ( distance, axis ) {\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\t}\n} );\n\nObject.defineProperties( THREE.Object3D.prototype, {\n\teulerOrder: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\treturn this.rotation.order;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\n\t\t\tthis.rotation.order = value;\n\t\t}\n\t},\n\tuseQuaternion: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.LOD.prototype, {\n\tobjects: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\n\t\t\treturn this.levels;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\n\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\n\tthis.setFocalLength( focalLength );\n\n};\n\n//\n\nObject.defineProperties( THREE.Light.prototype, {\n\tonlyShadow: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\n\t\t}\n\t},\n\tshadowCameraFov: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\n\t\t\tthis.shadow.camera.fov = value;\n\t\t}\n\t},\n\tshadowCameraLeft: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\n\t\t\tthis.shadow.camera.left = value;\n\t\t}\n\t},\n\tshadowCameraRight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\n\t\t\tthis.shadow.camera.right = value;\n\t\t}\n\t},\n\tshadowCameraTop: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\n\t\t\tthis.shadow.camera.top = value;\n\t\t}\n\t},\n\tshadowCameraBottom: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\n\t\t\tthis.shadow.camera.bottom = value;\n\t\t}\n\t},\n\tshadowCameraNear: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\n\t\t\tthis.shadow.camera.near = value;\n\t\t}\n\t},\n\tshadowCameraFar: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\n\t\t\tthis.shadow.camera.far = value;\n\t\t}\n\t},\n\tshadowCameraVisible: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\n\t\t}\n\t},\n\tshadowBias: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\n\t\t\tthis.shadow.bias = value;\n\t\t}\n\t},\n\tshadowDarkness: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\n\t\t}\n\t},\n\tshadowMapWidth: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\n\t\t\tthis.shadow.mapSize.width = value;\n\t\t}\n\t},\n\tshadowMapHeight: {\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\n\t\t\tthis.shadow.mapSize.height = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.BufferAttribute.prototype, {\n\tlength: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\n\t\t\treturn this.array.length;\n\t\t}\n\t}\n} );\n\nObject.assign( THREE.BufferGeometry.prototype, {\n\taddIndex: function ( index ) {\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\n\t\tthis.setIndex( index );\n\t},\n\taddDrawCall: function ( start, count, indexOffset ) {\n\t\tif ( indexOffset !== undefined ) {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\n\t\t}\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\n\t\tthis.addGroup( start, count );\n\t},\n\tclearDrawCalls: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\n\t\tthis.clearGroups();\n\t},\n\tcomputeTangents: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\n\t},\n\tcomputeOffsets: function () {\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.BufferGeometry.prototype, {\n\tdrawcalls: {\n\t\tget: function () {\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t},\n\toffsets: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\n\t\t\treturn this.groups;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.Material.prototype, {\n\twrapAround: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\n\t\t}\n\t},\n\twrapRGB: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\n\t\t\treturn new THREE.Color();\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\n\tmetal: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\n\t\t\treturn false;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\n\tderivatives: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\treturn this.extensions.derivatives;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\n\t\t\tthis.extensions.derivatives = value;\n\t\t}\n\t}\n} );\n\n//\n\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\n\n\t// Note: Extra base ensures these properties are not 'assign'ed.\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( target ) {\n\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\n\n\t\tObject.assign( target, this );\n\n\t}\n\n} ), THREE.EventDispatcher.prototype );\n\n//\n\nObject.assign( THREE.WebGLRenderer.prototype, {\n\tsupportsFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_float' );\n\t},\n\tsupportsHalfFloatTextures: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\n\t},\n\tsupportsStandardDerivatives: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\n\t},\n\tsupportsCompressedTextureS3TC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\t},\n\tsupportsCompressedTexturePVRTC: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\t},\n\tsupportsBlendMinMax: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\n\t},\n\tsupportsVertexTextures: function () {\n\t\treturn this.capabilities.vertexTextures;\n\t},\n\tsupportsInstancedArrays: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\n\t},\n\tenableScissorTest: function ( boolean ) {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\n\t\tthis.setScissorTest( boolean );\n\t},\n\tinitMaterial: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\n\t},\n\taddPrePlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\n\t},\n\taddPostPlugin: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\n\t},\n\tupdateShadowMap: function () {\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\n\tshadowMapEnabled: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.enabled;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\n\t\t\tthis.shadowMap.enabled = value;\n\t\t}\n\t},\n\tshadowMapType: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\n\t\t\tthis.shadowMap.type = value;\n\t\t}\n\t},\n\tshadowMapCullFace: {\n\t\tget: function () {\n\t\t\treturn this.shadowMap.cullFace;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\n\t\t\tthis.shadowMap.cullFace = value;\n\t\t}\n\t}\n} );\n\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\n\tcullFace: {\n\t\tget: function () {\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\n\t\t},\n\t\tset: function ( cullFace ) {\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\n\t\t\tthis.renderReverseSided = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\n\twrapS: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\treturn this.texture.wrapS;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\n\t\t\tthis.texture.wrapS = value;\n\t\t}\n\t},\n\twrapT: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\treturn this.texture.wrapT;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\n\t\t\tthis.texture.wrapT = value;\n\t\t}\n\t},\n\tmagFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\treturn this.texture.magFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\n\t\t\tthis.texture.magFilter = value;\n\t\t}\n\t},\n\tminFilter: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\treturn this.texture.minFilter;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\n\t\t\tthis.texture.minFilter = value;\n\t\t}\n\t},\n\tanisotropy: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\treturn this.texture.anisotropy;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\n\t\t\tthis.texture.anisotropy = value;\n\t\t}\n\t},\n\toffset: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\treturn this.texture.offset;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\n\t\t\tthis.texture.offset = value;\n\t\t}\n\t},\n\trepeat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\treturn this.texture.repeat;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\n\t\t\tthis.texture.repeat = value;\n\t\t}\n\t},\n\tformat: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\treturn this.texture.format;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\n\t\t\tthis.texture.format = value;\n\t\t}\n\t},\n\ttype: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\treturn this.texture.type;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\n\t\t\tthis.texture.type = value;\n\t\t}\n\t},\n\tgenerateMipmaps: {\n\t\tget: function () {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\treturn this.texture.generateMipmaps;\n\t\t},\n\t\tset: function ( value ) {\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\n\t\t\tthis.texture.generateMipmaps = value;\n\t\t}\n\t}\n} );\n\n//\n\nObject.assign( THREE.Audio.prototype, {\n\tload: function ( file ) {\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\n\t\tvar scope = this;\n\t\tvar audioLoader = new THREE.AudioLoader();\n\t\taudioLoader.load( file, function ( buffer ) {\n\t\t\tscope.setBuffer( buffer );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\nObject.assign( THREE.AudioAnalyser.prototype, {\n\tgetData: function ( file ) {\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\n\t\treturn this.getFrequencyData();\n\t}\n} );\n\n//\n\nTHREE.GeometryUtils = {\n\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\n\n\t\tvar matrix;\n\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\n\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\n\n\t\t\tmatrix = geometry2.matrix;\n\t\t\tgeometry2 = geometry2.geometry;\n\n\t\t}\n\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\n\n\t},\n\n\tcenter: function ( geometry ) {\n\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\n\t\treturn geometry.center();\n\n\t}\n\n};\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\n\n\t\tvar loader = new THREE.TextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\n\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\n\n\t\tvar loader = new THREE.CubeTextureLoader();\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\n\n\t\tif ( mapping ) texture.mapping = mapping;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\n\n\t},\n\n\tloadCompressedTextureCube: function () {\n\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\n\n\t}\n\n};\n\n//\n\nTHREE.Projector = function () {\n\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\n\t\tvector.project( camera );\n\n\t};\n\n\tthis.unprojectVector = function ( vector, camera ) {\n\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\n\t\tvector.unproject( camera );\n\n\t};\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\n\n\t};\n\n};\n\n//\n\nTHREE.CanvasRenderer = function () {\n\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\n\n\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n\tthis.clear = function () {};\n\tthis.render = function () {};\n\tthis.setClearColor = function () {};\n\tthis.setSize = function () {};\n\n};\n\n// File:src/extras/CurveUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.CurveUtils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\n\t},\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n// File:src/extras/SceneUtils.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Group();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach: function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n// File:src/extras/ShapeUtils.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.ShapeUtils = {\n\n\t// calculate area of the contour polygon\n\n\tarea: function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t},\n\n\ttriangulate: ( function () {\n\n\t\t/**\n\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t * See original code and more information here:\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t *\n\t\t * ported to actionscript by Zevan Rosser\n\t\t * www.actionsnippet.com\n\t\t *\n\t\t * ported to javascript by Joshua Koo\n\t\t * http://www.lab4games.net/zz85/blog\n\t\t *\n\t\t */\n\n\t\tfunction snip( contour, u, v, w, n, verts ) {\n\n\t\t\tvar p;\n\t\t\tvar ax, ay, bx, by;\n\t\t\tvar cx, cy, px, py;\n\n\t\t\tax = contour[ verts[ u ] ].x;\n\t\t\tay = contour[ verts[ u ] ].y;\n\n\t\t\tbx = contour[ verts[ v ] ].x;\n\t\t\tby = contour[ verts[ v ] ].y;\n\n\t\t\tcx = contour[ verts[ w ] ].x;\n\t\t\tcy = contour[ verts[ w ] ].y;\n\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\n\n\t\t\tvar aX, aY, bX, bY, cX, cY;\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\t\taX = cx - bx;  aY = cy - by;\n\t\t\tbX = ax - cx;  bY = ay - cy;\n\t\t\tcX = bx - ax;  cY = by - ay;\n\n\t\t\tfor ( p = 0; p < n; p ++ ) {\n\n\t\t\t\tpx = contour[ verts[ p ] ].x;\n\t\t\t\tpy = contour[ verts[ p ] ].y;\n\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\n\n\t\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t\t// see if p is inside triangle abc\n\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\n\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// takes in an contour array and returns\n\n\t\treturn function triangulate( contour, indices ) {\n\n\t\t\tvar n = contour.length;\n\n\t\t\tif ( n < 3 ) return null;\n\n\t\t\tvar result = [],\n\t\t\t\tverts = [],\n\t\t\t\tvertIndices = [];\n\n\t\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\t\tvar u, v, w;\n\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t\t}\n\n\t\t\tvar nv = n;\n\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\t\tvar count = 2 * nv;   /* error detection */\n\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\n\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\t\tif ( ( count -- ) <= 0 ) {\n\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t\t//return null;\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\n\n\t\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\t\treturn result;\n\n\t\t\t\t}\n\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t\t/* true names of the vertices */\n\n\t\t\t\t\ta = verts[ u ];\n\t\t\t\t\tb = verts[ v ];\n\t\t\t\t\tc = verts[ w ];\n\n\t\t\t\t\t/* output Triangle */\n\n\t\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\t\tcontour[ b ],\n\t\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\n\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnv --;\n\n\t\t\t\t\t/* reset error detection counter */\n\n\t\t\t\t\tcount = 2 * nv;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( indices ) return vertIndices;\n\t\t\treturn result;\n\n\t\t}\n\n\t} )(),\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tfunction removeDupEndPts(points) {\n\n\t\t\tvar l = points.length;\n\n\t\t\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\t\tpoints.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t\tremoveDupEndPts( contour );\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\n\n\t\t\t// inOtherPt needs to be collinear to the inSegment\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\n\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\n\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\n\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\n\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\n\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\n\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\n\n\t\t\t\t// not parallel\n\n\t\t\t\tvar perpSeg2;\n\t\t\t\tif ( limit > 0 ) {\n\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\n\n\t\t\t\t}\n\n\t\t\t\t// i.e. to reduce rounding errors\n\t\t\t\t// intersection at endpoint of segment#1?\n\t\t\t\tif ( perpSeg2 === 0 ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\tif ( perpSeg2 === limit ) {\n\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\n\t\t\t\t\treturn [ inSeg1Pt2 ];\n\n\t\t\t\t}\n\t\t\t\t// intersection at endpoint of segment#2?\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\n\n\t\t\t\t// return real intersection point\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\n\n\t\t\t} else {\n\n\t\t\t\t// parallel or collinear\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\n\n\t\t\t\t// they are collinear or degenerate\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\n\t\t\t\t// both segments are points\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\n\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\n\n\t\t\t\t}\n\t\t\t\t// segment#1  is a single point\n\t\t\t\tif ( seg1Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\n\t\t\t\t\treturn [ inSeg1Pt1 ];\n\n\t\t\t\t}\n\t\t\t\t// segment#2  is a single point\n\t\t\t\tif ( seg2Pt ) {\n\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\n\t\t\t\t\treturn [ inSeg2Pt1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// they are collinear segments, which might overlap\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\n\t\t\t\tif ( seg1dx !== 0 ) {\n\n\t\t\t\t\t// the segments are NOT on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the segments are on a vertical line\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\n\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg2min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\n\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\n\t\t\t\t\t\treturn [ seg1min ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\n\n\t\t\t// The order of legs is important\n\n\t\t\t// translation of all points, so that Vertex is at (0,0)\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\n\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\n\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\n\n\t\t\t\t// angle != 180 deg.\n\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\n\t\t\t\tif ( from2toAngle > 0 ) {\n\n\t\t\t\t\t// main angle < 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// main angle > 180 deg.\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// angle == 180 deg.\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\n\t\t\t\treturn\t( from2otherAngle > 0 );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tfunction removeHoles( contour, holes ) {\n\n\t\t\tvar shape = contour.concat(); // work on this shape\n\t\t\tvar hole;\n\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\n\n\t\t\t\t// Check if hole point lies within angle around shape point\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\n\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\n\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\n\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\t// Check if shape point lies within angle around hole point\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\n\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\n\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\n\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\n\t\t\t\tif ( ! insideAngle ) {\n\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\n\t\t\t\t\treturn\tfalse;\n\n\t\t\t\t}\n\n\t\t\t\treturn\ttrue;\n\n\t\t\t}\n\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with shape edges\n\t\t\t\tvar sIdx, nextIdx, intersection;\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\n\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t}\n\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar indepHoles = [];\n\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\n\n\t\t\t\t// checks for intersections with hole edges\n\t\t\t\tvar ihIdx, chkHole,\n\t\t\t\t\thIdx, nextIdx, intersection;\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\n\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\n\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn\tfalse;\n\n\t\t\t}\n\n\t\t\tvar holeIndex, shapeIndex,\n\t\t\t\tshapePt, holePt,\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\n\t\t\t\ttmpShape1, tmpShape2,\n\t\t\t\ttmpHole1, tmpHole2;\n\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tindepHoles.push( h );\n\n\t\t\t}\n\n\t\t\tvar minShapeIndex = 0;\n\t\t\tvar counter = indepHoles.length * 2;\n\t\t\twhile ( indepHoles.length > 0 ) {\n\n\t\t\t\tcounter --;\n\t\t\t\tif ( counter < 0 ) {\n\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// search for shape-vertex and hole-vertex,\n\t\t\t\t// which can be connected without intersections\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\n\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\n\t\t\t\t\tholeIndex\t= - 1;\n\n\t\t\t\t\t// search for hole which can be reached without intersections\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\n\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\n\n\t\t\t\t\t\t// prevent multiple checks\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\n\n\t\t\t\t\t\thole = holes[ holeIdx ];\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\n\n\t\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\n\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\n\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\n\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn shape; \t\t\t/* shape with no holes */\n\n\t\t}\n\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {};\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\tvar allpoints = contour.concat();\n\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\n\n\t\t}\n\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.warn( \"THREE.ShapeUtils: Duplicate point\", key, i );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// remove holes by cutting paths to holes and adding them to the shape\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\n\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat();\n\n\t},\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2: ( function () {\n\n\t\tfunction b2p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * p;\n\n\t\t}\n\n\t\tfunction b2p1( t, p ) {\n\n\t\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t\t}\n\n\t\tfunction b2p2( t, p ) {\n\n\t\t\treturn t * t * p;\n\n\t\t}\n\n\t\treturn function b2( t, p0, p1, p2 ) {\n\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\n\n\t\t};\n\n\t} )(),\n\n\t// Cubic Bezier Functions\n\n\tb3: ( function () {\n\n\t\tfunction b3p0( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn k * k * k * p;\n\n\t\t}\n\n\t\tfunction b3p1( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * k * t * p;\n\n\t\t}\n\n\t\tfunction b3p2( t, p ) {\n\n\t\t\tvar k = 1 - t;\n\t\t\treturn 3 * k * t * t * p;\n\n\t\t}\n\n\t\tfunction b3p3( t, p ) {\n\n\t\t\treturn t * t * t * p;\n\n\t\t}\n\n\t\treturn function b3( t, p0, p1, p2, p3 ) {\n\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\n\n\t\t};\n\n\t} )()\n\n};\n\n// File:src/extras/core/Curve.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\nTHREE.Curve.prototype = {\n\n\tconstructor: THREE.Curve,\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint: function ( t ) {\n\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\n\t\treturn null;\n\n\t},\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t );\n\n\t},\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 5;\n\n\t\tvar points = [];\n\n\t\tfor ( var d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t// Get total curve arc length\n\n\tgetLength: function () {\n\n\t\tvar lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t},\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\n\n\t\tif ( this.cacheArcLengths\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\n\t\t\t&& ! this.needsUpdate ) {\n\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tvar cache = [];\n\t\tvar current, last = this.getPoint( 0 );\n\t\tvar p, sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint ( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n\t},\n\n\tupdateArcLengths: function() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping: function ( u, distance ) {\n\n\t\tvar arcLengths = this.getLengths();\n\n\t\tvar i = 0, il = arcLengths.length;\n\n\t\tvar targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t//var time = Date.now();\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tvar low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\t//console.log('b' , i, low, high, Date.now()- time);\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\tvar t = i / ( il - 1 );\n\t\t\treturn t;\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tvar lengthBefore = arcLengths[ i ];\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\n\n\t\tvar segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t},\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent: function( t ) {\n\n\t\tvar delta = 0.0001;\n\t\tvar t1 = t - delta;\n\t\tvar t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tvar pt1 = this.getPoint( t1 );\n\t\tvar pt2 = this.getPoint( t2 );\n\n\t\tvar vec = pt2.clone().sub( pt1 );\n\t\treturn vec.normalize();\n\n\t},\n\n\tgetTangentAt: function ( u ) {\n\n\t\tvar t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t );\n\n\t}\n\n};\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.constructor = constructor;\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n// File:src/extras/core/CurvePath.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\n\tthis.autoClose = false; // Automatically closes the path\n\n};\n\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\n\n\tconstructor: THREE.CurvePath,\n\n\tadd: function ( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t},\n\n\tclosePath: function () {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t},\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint: function ( t ) {\n\n\t\tvar d = t * this.getLength();\n\t\tvar curveLengths = this.getCurveLengths();\n\t\tvar i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tvar diff = curveLengths[ i ] - d;\n\t\t\t\tvar curve = this.curves[ i ];\n\n\t\t\t\tvar segmentLength = curve.getLength();\n\t\t\t\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t},\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength: function () {\n\n\t\tvar lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t},\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths: function () {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getLengths();\n\n\t},\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths: function () {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tvar lengths = [], sums = 0;\n\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t},\n\n\tgetSpacedPoints: function ( divisions ) {\n\n\t\tif ( ! divisions ) divisions = 40;\n\n\t\tvar points = [];\n\n\t\tfor ( var i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\tgetPoints: function ( divisions ) {\n\n\t\tdivisions = divisions || 12;\n\n\t\tvar points = [], last;\n\n\t\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tvar curve = curves[ i ];\n\t\t\tvar resolution = curve instanceof THREE.EllipseCurve ? divisions * 2\n\t\t\t\t: curve instanceof THREE.LineCurve ? 1\n\t\t\t\t: curve instanceof THREE.SplineCurve ? divisions * curve.points.length\n\t\t\t\t: divisions;\n\n\t\t\tvar pts = curve.getPoints( resolution );\n\n\t\t\tfor ( var j = 0; j < pts.length; j++ ) {\n\n\t\t\t\tvar point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t},\n\n\t/**************************************************************\n\t *\tCreate Geometries Helpers\n\t **************************************************************/\n\n\t/// Generate geometry from path points (for Line or Points objects)\n\n\tcreatePointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\t// Generate geometry from equidistant sampling along the path\n\n\tcreateSpacedPointsGeometry: function ( divisions ) {\n\n\t\tvar pts = this.getSpacedPoints( divisions );\n\t\treturn this.createGeometry( pts );\n\n\t},\n\n\tcreateGeometry: function ( points ) {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tvar point = points[ i ];\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n} );\n\n// File:src/extras/core/Font.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Font = function ( data ) {\n\n\tthis.data = data;\n\n};\n\nObject.assign( THREE.Font.prototype, {\n\n\tgenerateShapes: function ( text, size, divisions ) {\n\n\t\tfunction createPaths( text ) {\n\n\t\t\tvar chars = String( text ).split( '' );\n\t\t\tvar scale = size / data.resolution;\n\t\t\tvar offset = 0;\n\n\t\t\tvar paths = [];\n\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\n\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\n\t\t\t\toffset += ret.offset;\n\n\t\t\t\tpaths.push( ret.path );\n\n\t\t\t}\n\n\t\t\treturn paths;\n\n\t\t}\n\n\t\tfunction createPath( c, scale, offset ) {\n\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\n\n\t\t\tif ( ! glyph ) return;\n\n\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\n\n\t\t\tif ( glyph.o ) {\n\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\n\n\t\t\t\t\tvar action = outline[ i ++ ];\n\n\t\t\t\t\tswitch ( action ) {\n\n\t\t\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\n\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn { offset: glyph.ha * scale, path: path };\n\n\t\t}\n\n\t\t//\n\n\t\tif ( size === undefined ) size = 100;\n\t\tif ( divisions === undefined ) divisions = 4;\n\n\t\tvar data = this.data;\n\n\t\tvar paths = createPaths( text );\n\t\tvar shapes = [];\n\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n} );\n\n// File:src/extras/core/Path.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call( this );\n\tthis.currentPoint = new THREE.Vector2();\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\n\n\tconstructor: THREE.Path,\n\n\t// Create path using straight lines to connect all points\n\t// - vectors: array of Vector2\n\tfromPoints: function ( vectors ) {\n\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\n\n\t\t}\n\n\t},\n\n\tmoveTo: function ( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t},\n\n\tlineTo: function ( x, y ) {\n\n\t\tvar curve = new THREE.LineCurve( this.currentPoint.clone(), new THREE.Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t},\n\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\n\t\tvar curve = new THREE.QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tvar curve = new THREE.CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\tnew THREE.Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t},\n\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\n\n\t\tvar npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tvar curve = new THREE.SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t},\n\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t},\n\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar x0 = this.currentPoint.x;\n\t\tvar y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t},\n\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tvar firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tvar lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t}\n\n} );\n\n\n// minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\nTHREE.ShapePath = function() {\n\tthis.subPaths = [];\n\tthis.currentPath = null;\n}\n\nTHREE.ShapePath.prototype = {\n\tmoveTo: function ( x, y ) {\n\t\tthis.currentPath = new THREE.Path();\n\t\tthis.subPaths.push(this.currentPath);\n\t\tthis.currentPath.moveTo( x, y );\n\t},\n\tlineTo: function ( x, y ) {\n\t\tthis.currentPath.lineTo( x, y );\n\t},\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\t},\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\t},\n\tsplineThru: function ( pts ) {\n\t\tthis.currentPath.splineThru( pts );\n\t},\n\n\ttoShapes: function ( isCCW, noHoles ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tvar shapes = [];\n\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\n\n\t\t\t\tvar tmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tvar polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tvar inside = false;\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\n\n\t\tvar subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new THREE.Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tvar betterShapeHoles = [];\n\t\tvar newShapes = [];\n\t\tvar newShapeHoles = [];\n\t\tvar mainIdx = 0;\n\t\tvar tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tvar ambiguous = false;\n\t\t\tvar toChange = [];\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tvar ho = sho[ hIdx ];\n\t\t\t\t\tvar hole_unassigned = true;\n\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\n\t\t\tif ( toChange.length > 0 ) {\n\n\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmpHoles;\n\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n}\n\n// File:src/extras/core/Shape.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\n\n\tconstructor: THREE.Shape,\n\n\t// Convenience method to return ExtrudeGeometry\n\n\textrude: function ( options ) {\n\n\t\treturn new THREE.ExtrudeGeometry( this, options );\n\n\t},\n\n\t// Convenience method to return ShapeGeometry\n\n\tmakeGeometry: function ( options ) {\n\n\t\treturn new THREE.ShapeGeometry( this, options );\n\n\t},\n\n\tgetPointsHoles: function ( divisions ) {\n\n\t\tvar holesPts = [];\n\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t},\n\n\t// Get points of shape and holes (keypoints based on segments parameter)\n\n\textractAllPoints: function ( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t},\n\n\textractPoints: function ( divisions ) {\n\n\t\treturn this.extractAllPoints( divisions );\n\n\t}\n\n} );\n\n// File:src/extras/curves/LineCurve.js\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tif ( t === 1 ) {\n\n\t\treturn this.v2.clone();\n\n\t}\n\n\tvar point = this.v2.clone().sub( this.v1 );\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub( this.v1 );\n\n\treturn tangent.normalize();\n\n};\n\n// File:src/extras/curves/QuadraticBezierCurve.js\n\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b2 = THREE.ShapeUtils.b2;\n\n\treturn new THREE.Vector2(\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\n\t);\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\n\n\treturn new THREE.Vector2(\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/CubicBezierCurve.js\n\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar b3 = THREE.ShapeUtils.b3;\n\n\treturn new THREE.Vector2( \n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t);\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\n\n\treturn new THREE.Vector2( \n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\n\t).normalize();\n\n};\n\n// File:src/extras/curves/SplineCurve.js\n\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = ( points == undefined ) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar points = this.points;\n\tvar point = ( points.length - 1 ) * t;\n\n\tvar intPoint = Math.floor( point );\n\tvar weight = point - intPoint;\n\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\tvar point1 = points[ intPoint ];\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\treturn new THREE.Vector2(\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\n\t);\n\n};\n\n// File:src/extras/curves/EllipseCurve.js\n\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\n\tthis.aRotation = aRotation || 0;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\n\nTHREE.EllipseCurve.prototype.getPoint = function( t ) {\n\n\tvar twoPi = Math.PI * 2;\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t// ensures that deltaAngle is 0 .. 2 PI\n\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\tif ( samePoints ) {\n\n\t\t\tdeltaAngle = 0;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = twoPi;\n\n\t\t}\n\n\t}\n\n\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\tdeltaAngle = - twoPi;\n\n\t\t} else {\n\n\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t}\n\n\t}\n\n\tvar angle = this.aStartAngle + t * deltaAngle;\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\n\n\tif ( this.aRotation !== 0 ) {\n\n\t\tvar cos = Math.cos( this.aRotation );\n\t\tvar sin = Math.sin( this.aRotation );\n\n\t\tvar tx = x - this.aX;\n\t\tvar ty = y - this.aY;\n\n\t\t// Rotate the point about the center of the ellipse.\n\t\tx = tx * cos - ty * sin + this.aX;\n\t\ty = tx * sin + ty * cos + this.aY;\n\n\t}\n\n\treturn new THREE.Vector2( x, y );\n\n};\n\n// File:src/extras/curves/ArcCurve.js\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\n\n// File:src/extras/curves/LineCurve3.js\n\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tif ( t === 1 ) {\n\n\t\t\treturn this.v2.clone();\n\n\t\t}\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\n\t\tvector.multiplyScalar( t );\n\t\tvector.add( this.v1 );\n\n\t\treturn vector;\n\n\t}\n\n);\n\n// File:src/extras/curves/QuadraticBezierCurve3.js\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\n\n\t\treturn new THREE.Vector3(\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CubicBezierCurve3.js\n\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar b3 = THREE.ShapeUtils.b3;\n\n\t\treturn new THREE.Vector3(\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/SplineCurve3.js\n\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */ ) {\n\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\n\t\tthis.points = ( points == undefined ) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar points = this.points;\n\t\tvar point = ( points.length - 1 ) * t;\n\n\t\tvar intPoint = Math.floor( point );\n\t\tvar weight = point - intPoint;\n\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\n\t\tvar point1 = points[ intPoint ];\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\n\n\t\treturn new THREE.Vector3(\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\n\t\t);\n\n\t}\n\n);\n\n// File:src/extras/curves/CatmullRomCurve3.js\n\n/**\n * @author zz85 https://github.com/zz85\n *\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\nTHREE.CatmullRomCurve3 = ( function() {\n\n\tvar\n\t\ttmp = new THREE.Vector3(),\n\t\tpx = new CubicPoly(),\n\t\tpy = new CubicPoly(),\n\t\tpz = new CubicPoly();\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\n\t}\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\n\n\t\tthis.c0 = x0;\n\t\tthis.c1 = t0;\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t};\n\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t// compute tangents when parameterized in [t1,t2]\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t// rescale tangents for parametrization in [0,1]\n\t\tt1 *= dt1;\n\t\tt2 *= dt1;\n\n\t\t// initCubicPoly\n\t\tthis.init( x1, x2, t1, t2 );\n\n\t};\n\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\n\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t};\n\n\tCubicPoly.prototype.calc = function( t ) {\n\n\t\tvar t2 = t * t;\n\t\tvar t3 = t2 * t;\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\n\n\t};\n\n\t// Subclass Three.js curve\n\treturn THREE.Curve.create(\n\n\t\tfunction ( p /* array of Vector3 */ ) {\n\n\t\t\tthis.points = p || [];\n\t\t\tthis.closed = false;\n\n\t\t},\n\n\t\tfunction ( t ) {\n\n\t\t\tvar points = this.points,\n\t\t\t\tpoint, intPoint, weight, l;\n\n\t\t\tl = points.length;\n\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\n\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\t\tintPoint = Math.floor( point );\n\t\t\tweight = point - intPoint;\n\n\t\t\tif ( this.closed ) {\n\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\n\t\t\t}\n\n\t\t\tvar p0, p1, p2, p3; // 4 points\n\n\t\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\t\tp0 = tmp;\n\n\t\t\t}\n\n\t\t\tp1 = points[ intPoint % l ];\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\n\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t\t} else {\n\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\t\tp3 = tmp;\n\n\t\t\t}\n\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\n\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t\t// safety check for repeated points\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t\t} else if ( this.type === 'catmullrom' ) {\n\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\n\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3(\n\t\t\t\tpx.calc( weight ),\n\t\t\t\tpy.calc( weight ),\n\t\t\t\tpz.calc( weight )\n\t\t\t);\n\n\t\t\treturn v;\n\n\t\t}\n\n\t);\n\n} )();\n\n// File:src/extras/curves/ClosedSplineCurve3.js\n\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = function ( points ) {\n\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\n\n\tTHREE.CatmullRomCurve3.call( this, points );\n\tthis.type = 'catmullrom';\n\tthis.closed = true;\n\n};\n\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\n\n// File:src/extras/geometries/BoxGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'BoxGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\n\nTHREE.CubeGeometry = THREE.BoxGeometry;\n\n// File:src/extras/geometries/BoxBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'BoxBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\tdepth: depth,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tdepthSegments: depthSegments\n\t};\n\n\tvar scope = this;\n\n\t// segments\n\twidthSegments = Math.floor( widthSegments ) || 1;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\tdepthSegments = Math.floor( depthSegments ) || 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\tvar numberOfVertices = 0;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// build each side of the box geometry\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\t// helper functions\n\n\tfunction calculateVertexCount ( w, h, d ) {\n\n\t\tvar vertices = 0;\n\n\t\t// calculate the amount of vertices for each side (plane)\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\n\n\t\treturn vertices;\n\n\t}\n\n\tfunction calculateIndexCount ( w, h, d ) {\n\n\t\tvar index = 0;\n\n\t\t// calculate the amount of squares for each side\n\t\tindex += w * h * 2; // xy\n\t\tindex += w * d * 2; // xz\n\t\tindex += d * h * 2; // zy\n\n\t\treturn index * 6; // two triangles per square => six vertices per square\n\n\t}\n\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\tvar segmentWidth\t= width / gridX;\n\t\tvar segmentHeight = height / gridY;\n\n\t\tvar widthHalf = width / 2;\n\t\tvar heightHalf = height / 2;\n\t\tvar depthHalf = depth / 2;\n\n\t\tvar gridX1 = gridX + 1;\n\t\tvar gridY1 = gridY + 1;\n\n\t\tvar vertexCounter = 0;\n\t\tvar groupCount = 0;\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tvar y = iy * segmentHeight - heightHalf;\n\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t// now apply vector to vertex buffer\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// set values to correct vector component\n\t\t\t\tvector[ u ] = 0;\n\t\t\t\tvector[ v ] = 0;\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t// now apply vector to normal buffer\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\n\n\t\t\t\t// uvs\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tvertexBufferOffset += 3;\n\t\t\t\tuvBufferOffset += 2;\n\t\t\t\tvertexCounter += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 1. you need three indices to draw a single face\n\t\t// 2. a single segment consists of two faces\n\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t// indices\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t// face one\n\t\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t\t// face two\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t\t// update offsets and counters\n\t\t\t\tindexBufferOffset += 6;\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t\t// update total number of vertices\n\t\tnumberOfVertices += vertexCounter;\n\n\t}\n\n};\n\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\n\n// File:src/extras/geometries/CircleGeometry.js\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CircleGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\n\n// File:src/extras/geometries/CircleBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n */\n\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CircleBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tsegments: segments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar vertices = segments + 2;\n\n\tvar positions = new Float32Array( vertices * 3 );\n\tvar normals = new Float32Array( vertices * 3 );\n\tvar uvs = new Float32Array( vertices * 2 );\n\n\t// center data is already zero, but need to set a few extras\n\tnormals[ 2 ] = 1.0;\n\tuvs[ 0 ] = 0.5;\n\tuvs[ 1 ] = 0.5;\n\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\n\n\t\tvar segment = thetaStart + s / segments * thetaLength;\n\n\t\tpositions[ i ] = radius * Math.cos( segment );\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\n\n\t\tnormals[ i + 2 ] = 1; // normal z\n\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var i = 1; i <= segments; i ++ ) {\n\n\t\tindices.push( i, i + 1, 0 );\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\n\n// File:src/extras/geometries/CylinderBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'CylinderBufferGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tvar scope = this;\n\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\theight = height !== undefined ? height : 100;\n\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\theightSegments = Math.floor( heightSegments ) || 1;\n\n\topenEnded = openEnded !== undefined ? openEnded : false;\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\n\n\t// used to calculate buffer length\n\n\tvar nbCap = 0;\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) nbCap ++;\n\t\tif ( radiusBottom > 0 ) nbCap ++;\n\n\t}\n\n\tvar vertexCount = calculateVertexCount();\n\tvar indexCount = calculateIndexCount();\n\n\t// buffers\n\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\n\tvar index = 0,\n\t    indexOffset = 0,\n\t    indexArray = [],\n\t    halfHeight = height / 2;\n\n\t// group variables\n\tvar groupStart = 0;\n\n\t// generate geometry\n\n\tgenerateTorso();\n\n\tif ( openEnded === false ) {\n\n\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// helper functions\n\n\tfunction calculateVertexCount() {\n\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction calculateIndexCount() {\n\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tcount += radialSegments * nbCap * 3;\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\tfunction generateTorso() {\n\n\t\tvar x, y;\n\t\tvar normal = new THREE.Vector3();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\t// this will be used to calculate the normal\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\tvar indexRow = [];\n\n\t\t\tvar v = y / heightSegments;\n\n\t\t\t// calculate the radius of the current row\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tvar u = x / radialSegments;\n\n\t\t\t\t// vertex\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\n\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\t\t\t\tnormal.copy( vertex );\n\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\n\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\n\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\n\n\t\t\t\t}\n\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\t\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\t\t// save index of vertex in respective row\n\t\t\t\tindexRow.push( index );\n\n\t\t\t\t// increase index\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// now save vertices of the row in our index array\n\t\t\tindexArray.push( indexRow );\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t// face one\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// face two\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\n\n\t\t\t\t// update counters\n\t\t\t\tgroupCount += 6;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n\tfunction generateCap( top ) {\n\n\t\tvar x, centerIndexStart, centerIndexEnd;\n\n\t\tvar uv = new THREE.Vector2();\n\t\tvar vertex = new THREE.Vector3();\n\n\t\tvar groupCount = 0;\n\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\tvar sign = ( top === true ) ? 1 : - 1;\n\n\t\t// save the index of the first center vertex\n\t\tcenterIndexStart = index;\n\n\t\t// first we generate the center vertex data of the cap.\n\t\t// because the geometry needs one set of uvs per face,\n\t\t// we must generate a center vertex per face/segment\n\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = 0.5;\n\t\t\tuv.y = 0.5;\n\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// save the index of the last center vertex\n\t\tcenterIndexEnd = index;\n\n\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\t\t\tvar theta = u * thetaLength + thetaStart;\n\n\t\t\tvar cosTheta = Math.cos( theta );\n\t\t\tvar sinTheta = Math.sin( theta );\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * sinTheta;\n\t\t\tvertex.y = halfHeight * sign;\n\t\t\tvertex.z = radius * cosTheta;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar c = centerIndexStart + x;\n\t\t\tvar i = centerIndexEnd + x;\n\n\t\t\tif ( top === true ) {\n\n\t\t\t\t// face top\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t} else {\n\n\t\t\t\t// face bottom\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\n\n\t\t\t}\n\n\t\t\t// update counters\n\t\t\tgroupCount += 3;\n\n\t\t}\n\n\t\t// add a group to the geometry. this will ensure multi material support\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t// calculate new start value for groups\n\t\tgroupStart += groupCount;\n\n\t}\n\n};\n\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\n\n// File:src/extras/geometries/CylinderGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'CylinderGeometry';\n\n\tthis.parameters = {\n\t\tradiusTop: radiusTop,\n\t\tradiusBottom: radiusBottom,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\n\n// File:src/extras/geometries/ConeBufferGeometry.js\n\n/*\n * @author: abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeBufferGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderBufferGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\n\n// File:src/extras/geometries/ConeGeometry.js\n\n/**\n * @author abelnation / http://github.com/abelnation\n */\n\nTHREE.ConeGeometry = function (\n\tradius, height,\n\tradialSegments, heightSegments,\n\topenEnded, thetaStart, thetaLength ) {\n\n\tTHREE.CylinderGeometry.call( this,\n\t\t0, radius, height,\n\t\tradialSegments, heightSegments,\n\t\topenEnded, thetaStart, thetaLength );\n\n\tthis.type = 'ConeGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\theight: height,\n\t\tradialSegments: radialSegments,\n\t\theightSegments: heightSegments,\n\t\topenEnded: openEnded,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n};\n\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\n\n// File:src/extras/geometries/EdgesGeometry.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\n\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tvar geometry2;\n\n\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tgeometry2 = new THREE.Geometry();\n\t\tgeometry2.fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry2 = geometry.clone();\n\n\t}\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvar coords = [];\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords.push( vertex.x );\n\t\t\tcoords.push( vertex.y );\n\t\t\tcoords.push( vertex.z );\n\n\t\t}\n\n\t}\n\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\n\n};\n\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\n\n// File:src/extras/geometries/ExtrudeGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\n\t\tshapes = [];\n\t\treturn;\n\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ExtrudeGeometry';\n\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initialization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length;\n\n\n\t// Find directions for point movement\n\n\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t//\n\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\n\n\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t// check for collinear edges\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t// not collinear\n\n\t\t\t// length of vectors for normalizing\n\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t// vector from inPt to intersection point\n\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t//  but prevent crazy spikes\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\n\n\t\t\t} else {\n\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// handle special case of collinear edges\n\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( direction_eq ) {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\tv_trans_y =  v_prev_x;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t} else {\n\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t}\n\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\n\t\t//bs = bevelSize * t; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( ! extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( -- i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\n\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\n\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\n\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\n\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( a.x, a.y ),\n\t\t\tnew THREE.Vector2( b.x, b.y ),\n\t\t\tnew THREE.Vector2( c.x, c.y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\n\n\t\tvar vertices = geometry.vertices;\n\n\t\tvar a = vertices[ indexA ];\n\t\tvar b = vertices[ indexB ];\n\t\tvar c = vertices[ indexC ];\n\t\tvar d = vertices[ indexD ];\n\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\n\t\t\t];\n\n\t\t}\n\n\t}\n};\n\n// File:src/extras/geometries/ShapeGeometry.js\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ShapeGeometry';\n\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\t//\n\n\tvar i, l, hole;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\n\n\t}\n\n};\n\n// File:src/extras/geometries/LatheBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n // points - to create a closed torus, one must use a set of points\n //    like so: [ a, b, c, d, a ], see first is the same as last.\n // segments - the number of circumference segments to create\n // phiStart - the starting radian\n // phiLength - the radian (0 to 2PI) range of the lathed section\n //    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'LatheBufferGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tsegments = Math.floor( segments ) || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || Math.PI * 2;\n\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( segments + 1 ) * points.length;\n\tvar indexCount = segments * points.length * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar index = 0, indexOffset = 0, base;\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar i, j;\n\n\t// generate vertices and uvs\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar sin = Math.sin( phi );\n\t\tvar cos = Math.cos( phi );\n\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t// vertex\n\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\tvertex.y = points[ j ].y;\n\t\t\tvertex.z = points[ j ].x * cos;\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / segments;\n\t\t\tuv.y = j / ( points.length - 1 );\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\tbase = j + i * points.length;\n\n\t\t\t// indices\n\t\t\tvar a = base;\n\t\t\tvar b = base + points.length;\n\t\t\tvar c = base + points.length + 1;\n\t\t\tvar d = base + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// generate normals\n\n\tthis.computeVertexNormals();\n\n\t// if the geometry is closed, we need to average the normals along the seam.\n\t// because the corresponding vertices are identical (but still have different UVs).\n\n\tif( phiLength === Math.PI * 2 ) {\n\n\t\tvar normals = this.attributes.normal.array;\n\t\tvar n1 = new THREE.Vector3();\n\t\tvar n2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3();\n\n\t\t// this is the buffer offset for the last line of vertices\n\t\tbase = segments * points.length * 3;\n\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\n\n\t\t\t// select the normal of the vertex in the first line\n\t\t\tn1.x = normals[ j + 0 ];\n\t\t\tn1.y = normals[ j + 1 ];\n\t\t\tn1.z = normals[ j + 2 ];\n\n\t\t\t// select the normal of the vertex in the last line\n\t\t\tn2.x = normals[ base + j + 0 ];\n\t\t\tn2.y = normals[ base + j + 1 ];\n\t\t\tn2.z = normals[ base + j + 2 ];\n\n\t\t\t// average normals\n\t\t\tn.addVectors( n1, n2 ).normalize();\n\n\t\t\t// assign the new values to both normals\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\n\n\t\t} // next row\n\n\t}\n\n};\n\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\n\n// File:src/extras/geometries/LatheGeometry.js\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://clara.io\n */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'LatheGeometry';\n\n\tthis.parameters = {\n\t\tpoints: points,\n\t\tsegments: segments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\n\n// File:src/extras/geometries/PlaneGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PlaneGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\n\n// File:src/extras/geometries/PlaneBufferGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'PlaneBufferGeometry';\n\n\tthis.parameters = {\n\t\twidth: width,\n\t\theight: height,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments\n\t};\n\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = Math.floor( widthSegments ) || 1;\n\tvar gridY = Math.floor( heightSegments ) || 1;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridY1 = gridY + 1;\n\n\tvar segment_width = width / gridX;\n\tvar segment_height = height / gridY;\n\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\n\n\tvar offset = 0;\n\tvar offset2 = 0;\n\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\n\n\t\tvar y = iy * segment_height - height_half;\n\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\n\t\t\tvertices[ offset ] = x;\n\t\t\tvertices[ offset + 1 ] = - y;\n\n\t\t\tnormals[ offset + 2 ] = 1;\n\n\t\t\tuvs[ offset2 ] = ix / gridX;\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\n\n\t\t\toffset += 3;\n\t\t\toffset2 += 2;\n\n\t\t}\n\n\t}\n\n\toffset = 0;\n\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\n\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\n\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iy;\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\tindices[ offset ] = a;\n\t\t\tindices[ offset + 1 ] = b;\n\t\t\tindices[ offset + 2 ] = d;\n\n\t\t\tindices[ offset + 3 ] = b;\n\t\t\tindices[ offset + 4 ] = c;\n\t\t\tindices[ offset + 5 ] = d;\n\n\t\t\toffset += 6;\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\n\n// File:src/extras/geometries/RingBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'RingBufferGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tinnerRadius = innerRadius || 20;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\n\n\t// these are used to calculate buffer length\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// some helper variables\n\tvar index = 0, indexOffset = 0, segment;\n\tvar radius = innerRadius;\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\tvar vertex = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\t// values are generate from the inside of the ring to the outside\n\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t// vertex\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\n\n\t\t\t// uv\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex++;\n\n\t\t}\n\n\t\t// increase the radius for next row of vertices\n\t\tradius += radiusStep;\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 0; j < phiSegments; j ++ ) {\n\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\tsegment = i + thetaSegmentLevel;\n\n\t\t\t// indices\n\t\t\tvar a = segment;\n\t\t\tvar b = segment + thetaSegments + 1;\n\t\t\tvar c = segment + thetaSegments + 2;\n\t\t\tvar d = segment + 1;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n};\n\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\n\n// File:src/extras/geometries/RingGeometry.js\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'RingGeometry';\n\n\tthis.parameters = {\n\t\tinnerRadius: innerRadius,\n\t\touterRadius: outerRadius,\n\t\tthetaSegments: thetaSegments,\n\t\tphiSegments: phiSegments,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\n\n// File:src/extras/geometries/SphereGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'SphereGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\n\n// File:src/extras/geometries/SphereBufferGeometry.js\n\n/**\n * @author benaadams / https://twitter.com/ben_a_adams\n * based on THREE.SphereGeometry\n */\n\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'SphereBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\twidthSegments: widthSegments,\n\t\theightSegments: heightSegments,\n\t\tphiStart: phiStart,\n\t\tphiLength: phiLength,\n\t\tthetaStart: thetaStart,\n\t\tthetaLength: thetaLength\n\t};\n\n\tradius = radius || 50;\n\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tphiStart = phiStart !== undefined ? phiStart : 0;\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar thetaEnd = thetaStart + thetaLength;\n\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\n\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\n\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\n\t\tvar v = y / heightSegments;\n\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tnormal.set( px, py, pz ).normalize();\n\n\t\t\tpositions.setXYZ( index, px, py, pz );\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\t\t\tuvs.setXY( index, u, 1 - v );\n\n\t\t\tverticesRow.push( index );\n\n\t\t\tindex ++;\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\n\t}\n\n\tvar indices = [];\n\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\n\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\n\n\t\t}\n\n\t}\n\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\n\tthis.addAttribute( 'position', positions );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\n\n// File:src/extras/geometries/TextGeometry.js\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * Text = 3D Text\n *\n * parameters = {\n *  font: <THREE.Font>, // font\n *\n *  size: <float>, // size of the text\n *  height: <float>, // thickness to extrude text\n *  curveSegments: <int>, // number of points on the curves\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into text bevel goes\n *  bevelSize: <float> // how far from text outline is bevel\n * }\n */\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar font = parameters.font;\n\n\tif ( font instanceof THREE.Font === false ) {\n\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\n\t\treturn new THREE.Geometry();\n\n\t}\n\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\n\n\tthis.type = 'TextGeometry';\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\n\n// File:src/extras/geometries/TorusBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\n\tarc = arc || Math.PI * 2;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\n\tvar vertices = new Float32Array( vertexCount * 3 );\n\tvar normals = new Float32Array( vertexCount * 3 );\n\tvar uvs = new Float32Array( vertexCount * 2 );\n\n\t// offset variables\n\tvar vertexBufferOffset = 0;\n\tvar uvBufferOffset = 0;\n\tvar indexBufferOffset = 0;\n\n\t// helper variables\n\tvar center = new THREE.Vector3();\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\n\tvar j, i;\n\n\t// generate vertices, normals and uvs\n\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / tubularSegments * arc;\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\n\t\t\t// vertex\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\n\n\t\t\t// this vector is used to calculate the normal\n\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\tcenter.y = radius * Math.sin( u );\n\n\t\t\t// normal\n\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\n\n\t\t\t// uv\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\n\n\t\t\t// update offsets\n\t\t\tvertexBufferOffset += 3;\n\t\t\tuvBufferOffset += 2;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t// face one\n\t\t\tindices[ indexBufferOffset ] = a;\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\n\n\t\t\t// face two\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\n\n\t\t\t// update offset\n\t\t\tindexBufferOffset += 6;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n};\n\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\n\n// File:src/extras/geometries/TorusGeometry.js\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\tradialSegments: radialSegments,\n\t\ttubularSegments: tubularSegments,\n\t\tarc: arc\n\t};\n\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\n\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * see: http://www.blackpawn.com/texts/pqtorus/\n */\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tthis.type = 'TorusKnotBufferGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tradius = radius || 100;\n\ttube = tube || 40;\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\n\tradialSegments = Math.floor( radialSegments ) || 8;\n\tp = p || 2;\n\tq = q || 3;\n\n\t// used to calculate buffer length\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\n\n\t// buffers\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\n\n\t// helper variables\n\tvar i, j, index = 0, indexOffset = 0;\n\n\tvar vertex = new THREE.Vector3();\n\tvar normal = new THREE.Vector3();\n\tvar uv = new THREE.Vector2();\n\n\tvar P1 = new THREE.Vector3();\n\tvar P2 = new THREE.Vector3();\n\n\tvar B = new THREE.Vector3();\n\tvar T = new THREE.Vector3();\n\tvar N = new THREE.Vector3();\n\n\t// generate vertices, normals and uvs\n\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t// calculate orthonormal basis\n\n\t\tT.subVectors( P2, P1 );\n\t\tN.addVectors( P2, P1 );\n\t\tB.crossVectors( T, N );\n\t\tN.crossVectors( B, T );\n\n\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\tB.normalize();\n\t\tN.normalize();\n\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\n\t\t\tvar cx = - tube * Math.cos( v );\n\t\t\tvar cy = tube * Math.sin( v );\n\n\t\t\t// now calculate the final vertex position.\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t// vertex\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\n\n\t\t\t// uv\n\t\t\tuv.x = i / tubularSegments;\n\t\t\tuv.y = j / radialSegments;\n\t\t\tuvs.setXY( index, uv.x, uv.y );\n\n\t\t\t// increase index\n\t\t\tindex ++;\n\n\t\t}\n\n\t}\n\n\t// generate indices\n\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\n\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t// indices\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t// face one\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t\t// face two\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\n\n\t\t}\n\n\t}\n\n\t// build geometry\n\n\tthis.setIndex( indices );\n\tthis.addAttribute( 'position', vertices );\n\tthis.addAttribute( 'normal', normals );\n\tthis.addAttribute( 'uv', uvs );\n\n\t// this function calculates the current position on the torus curve\n\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = q / p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t}\n\n};\n\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\n\n// File:src/extras/geometries/TorusKnotGeometry.js\n\n/**\n * @author oosmoxiecode\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TorusKnotGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\ttube: tube,\n\t\ttubularSegments: tubularSegments,\n\t\tradialSegments: radialSegments,\n\t\tp: p,\n\t\tq: q\n\t};\n\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\n\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\n\tthis.mergeVertices();\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\n\n// File:src/extras/geometries/TubeGeometry.js\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n * @author jonobr1 / https://github.com/jonobr1\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'TubeGeometry';\n\n\tthis.parameters = {\n\t\tpath: path,\n\t\tsegments: segments,\n\t\tradius: radius,\n\t\tradialSegments: radialSegments,\n\t\tclosed: closed,\n\t\ttaper: taper\n\t};\n\n\tsegments = segments || 64;\n\tradius = radius || 1;\n\tradialSegments = radialSegments || 8;\n\tclosed = closed || false;\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\n\n\tvar grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = segments + 1,\n\n\t\tu, v, r,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\t// construct the grid\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tgrid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tr = radius * taper( u );\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tv = j / radialSegments * 2 * Math.PI;\n\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = r * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < segments; i ++ ) {\n\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\n\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\n\t\t\tjp = ( j + 1 ) % radialSegments;\n\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = grid[ ip ][ j ];\n\t\t\tc = grid[ ip ][ jp ];\n\t\t\td = grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\n\nTHREE.TubeGeometry.NoTaper = function ( u ) {\n\n\treturn 1;\n\n};\n\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\n\n\treturn Math.sin( Math.PI * u );\n\n};\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\n\n\tvar\tnormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i ++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\t/*\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\t*/\n\n\tfunction initialNormal3() {\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\n\n\t\t\ttheta = - theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n\n};\n\n// File:src/extras/geometries/PolyhedronGeometry.js\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'PolyhedronGeometry';\n\n\tthis.parameters = {\n\t\tvertices: vertices,\n\t\tindices: indices,\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\n\n\t}\n\n\tvar p = this.vertices;\n\n\tvar faces = [];\n\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\n\n\t\tvar v1 = p[ indices[ i ] ];\n\t\tvar v2 = p[ indices[ i + 1 ] ];\n\t\tvar v3 = p[ indices[ i + 2 ] ];\n\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tvar centroid = new THREE.Vector3();\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tsubdivide( faces[ i ], detail );\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, x1, x2 );\n\t\tvar min = Math.min( x0, x1, x2 );\n\n\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tthat.faces.push( face );\n\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\n\t\tvar azi = azimuth( centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide( face, detail ) {\n\n\t\tvar cols = Math.pow( 2, detail );\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\n\n\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\n\n// File:src/extras/geometries/DodecahedronGeometry.js\n\n/**\n * @author Abe Pazos / https://hamoid.com\n */\n\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\tvar r = 1 / t;\n\n\tvar vertices = [\n\n\t\t// (1, 1, 1)\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\n\t\t- 1,  1, - 1,    - 1,  1,  1,\n\t\t 1, - 1, - 1,     1, - 1,  1,\n\t\t 1,  1, - 1,     1,  1,  1,\n\n\t\t// (0, 1/, )\n\t\t 0, - r, - t,     0, - r,  t,\n\t\t 0,  r, - t,     0,  r,  t,\n\n\t\t// (1/, , 0)\n\t\t- r, - t,  0,    - r,  t,  0,\n\t\t r, - t,  0,     r,  t,  0,\n\n\t\t// (, 0, 1/)\n\t\t- t,  0, - r,     t,  0, - r,\n\t\t- t,  0,  r,     t,  0,  r\n\t];\n\n\tvar indices = [\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'DodecahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\n\n// File:src/extras/geometries/IcosahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\n\t];\n\n\tvar indices = [\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'IcosahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\n\n// File:src/extras/geometries/OctahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\n\t];\n\n\tvar indices = [\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'OctahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\n\n// File:src/extras/geometries/TetrahedronGeometry.js\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\n\t];\n\n\tvar indices = [\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\n\n\tthis.type = 'TetrahedronGeometry';\n\n\tthis.parameters = {\n\t\tradius: radius,\n\t\tdetail: detail\n\t};\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\n\n// File:src/extras/geometries/ParametricGeometry.js\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.type = 'ParametricGeometry';\n\n\tthis.parameters = {\n\t\tfunc: func,\n\t\tslices: slices,\n\t\tstacks: stacks\n\t};\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, j, p;\n\tvar u, v;\n\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\n\t\t\td = ( i + 1 ) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\n\n// File:src/extras/geometries/WireframeGeometry.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeGeometry = function ( geometry ) {\n\n\tTHREE.BufferGeometry.call( this );\n\n\tvar edge = [ 0, 0 ], hash = {};\n\n\tfunction sortFunction( a, b ) {\n\n\t\treturn a - b;\n\n\t}\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\n\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = geometry.vertices;\n\t\tvar faces = geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\t// Indexed BufferGeometry\n\n\t\t\tvar indices = geometry.index.array;\n\t\t\tvar vertices = geometry.attributes.position;\n\t\t\tvar groups = geometry.groups;\n\t\t\tvar numEdges = 0;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgeometry.addGroup( 0, indices.length );\n\n\t\t\t}\n\n\t\t\t// allocate maximal size\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\tvar group = groups[ o ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\n\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t} else {\n\n\t\t\t// non-indexed BufferGeometry\n\n\t\t\tvar vertices = geometry.attributes.position.array;\n\t\t\tvar numEdges = vertices.length / 3;\n\t\t\tvar numTris = numEdges / 3;\n\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\n\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\n\n// File:src/extras/helpers/AxisHelper.js\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar vertices = new Float32Array( [\n\t\t0, 0, 0,  size, 0, 0,\n\t\t0, 0, 0,  0, size, 0,\n\t\t0, 0, 0,  0, 0, size\n\t] );\n\n\tvar colors = new Float32Array( [\n\t\t1, 0, 0,  1, 0.6, 0,\n\t\t0, 1, 0,  0.6, 1, 0,\n\t\t0, 0, 1,  0, 0.6, 1\n\t] );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\n\n// File:src/extras/helpers/ArrowHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://clara.io\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  color - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = ( function () {\n\n\tvar lineGeometry = new THREE.BufferGeometry();\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.translate( 0, - 0.5, 0 );\n\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tTHREE.Object3D.call( this );\n\n\t\tif ( color === undefined ) color = 0xffff00;\n\t\tif ( length === undefined ) length = 1;\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\n\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function setDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}() );\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\n\n\tthis.line.material.color.copy( color );\n\tthis.cone.material.color.copy( color );\n\n};\n\n// File:src/extras/helpers/BoxHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object, color ) {\n\n\tif ( color === undefined ) color = 0xffff00;\n\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\tvar positions = new Float32Array( 8 * 3 );\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\n\nTHREE.BoxHelper.prototype.update = ( function () {\n\n\tvar box = new THREE.Box3();\n\n\treturn function update( object ) {\n\n\t\tif ( object instanceof THREE.Box3 ) {\n\n\t\t\tbox.copy( object );\n\n\t\t} else {\n\n\t\t\tbox.setFromObject( object );\n\n\t\t}\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tvar min = box.min;\n\t\tvar max = box.max;\n\n\t\t/*\n\t\t  5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tvar position = this.geometry.attributes.position;\n\t\tvar array = position.array;\n\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t};\n\n} )();\n\n// File:src/extras/helpers/BoundingBoxHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n// File:src/extras/helpers/CameraHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.camera = camera;\n\tif( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\tthis.matrix = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar geometry, pointMap;\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\n\tfunction setPoint( point, x, y, z ) {\n\n\t\tvector.set( x, y, z ).unproject( camera );\n\n\t\tvar points = pointMap[ point ];\n\n\t\tif ( points !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn function update() {\n\n\t\tgeometry = this.geometry;\n\t\tpointMap = this.pointMap;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, - 1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", - w, - h, 1 );\n\t\tsetPoint( \"f2\",   w, - h, 1 );\n\t\tsetPoint( \"f3\", - w,   h, 1 );\n\t\tsetPoint( \"f4\",   w,   h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\n\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\n\n\t\tgeometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/DirectionalLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tif ( size === undefined ) size = 1;\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\n\t\t- size,   size, 0,\n\t\t  size,   size, 0,\n\t\t  size, - size, 0,\n\t\t- size, - size, 0,\n\t\t- size,   size, 0\n\t], 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.add( new THREE.Line( geometry, material ) );\n\n\tgeometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\tthis.add( new THREE.Line( geometry, material ));\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\n\tvar lightPlane = this.children[ 0 ];\n\tvar targetLine = this.children[ 1 ];\n\n\tlightPlane.geometry.dispose();\n\tlightPlane.material.dispose();\n\ttargetLine.geometry.dispose();\n\ttargetLine.material.dispose();\n\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tvar lightPlane = this.children[ 0 ];\n\t\tvar targetLine = this.children[ 1 ];\n\n\t\tlightPlane.lookAt( v3 );\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\ttargetLine.lookAt( v3 );\n\t\ttargetLine.scale.z = v3.length();\n\n\t};\n\n}();\n\n// File:src/extras/helpers/EdgesHelper.js\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @param object THREE.Mesh whose geometry will be used\n * @param hex line color\n * @param thresholdAngle the minimum angle (in degrees),\n * between the face normals of adjacent faces,\n * that is required to render an edge. A value of 10 means\n * an edge is only rendered if the angle is at least 10 degrees.\n */\n\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\n\n// File:src/extras/helpers/FaceNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\t// FaceNormalsHelper only supports THREE.Geometry\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length;\n\n\t} else {\n\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\n\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tvar vertices = objGeometry.vertices;\n\n\t\tvar faces = objGeometry.faces;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tvar normal = face.normal;\n\n\t\t\tv1.copy( vertices[ face.a ] )\n\t\t\t\t.add( vertices[ face.b ] )\n\t\t\t\t.add( vertices[ face.c ] )\n\t\t\t\t.divideScalar( 3 )\n\t\t\t\t.applyMatrix4( matrixWorld );\n\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\tidx = idx + 1;\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/GridHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, divisions, color1, color2 ) {\n\n\tdivisions = divisions || 1;\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\n\n\tvar center = divisions / 2;\n\tvar step = ( size * 2 ) / divisions;\n\tvar vertices = [], colors = [];\n\n\tfor ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {\n\n\t\tvertices.push( - size, 0, k, size, 0, k );\n\t\tvertices.push( k, 0, - size, k, 0, size );\n\n\t\tvar color = i === center ? color1 : color2;\n\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\t\tcolor.toArray( colors, j ); j += 3;\n\n\t}\n\n\tvar geometry = new THREE.BufferGeometry();\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\n\nTHREE.GridHelper.prototype.setColors = function () {\n\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\n\n};\n\n// File:src/extras/helpers/HemisphereLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.rotateX( - Math.PI / 2 );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t};\n\n}();\n\n// File:src/extras/helpers/PointLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrix = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n// File:src/extras/helpers/SkeletonHelper.js\n\n/**\n * @author Sean Griffin / http://twitter.com/sgrif\n * @author Michael Guerrero / http://realitymeltdown.com\n * @author mrdoob / http://mrdoob.com/\n * @author ikerr / http://verold.com\n */\n\nTHREE.SkeletonHelper = function ( object ) {\n\n\tthis.bones = this.getBoneList( object );\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dynamic = true;\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\n\n\tTHREE.LineSegments.call( this, geometry, material );\n\n\tthis.root = object;\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\n\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\n\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\n\n\tvar boneList = [];\n\n\tif ( object instanceof THREE.Bone ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n};\n\nTHREE.SkeletonHelper.prototype.update = function () {\n\n\tvar geometry = this.geometry;\n\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\n\n\tvar boneMatrix = new THREE.Matrix4();\n\n\tvar j = 0;\n\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\n\n\t\tvar bone = this.bones[ i ];\n\n\t\tif ( bone.parent instanceof THREE.Bone ) {\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\n\n\t\t\tj += 2;\n\n\t\t}\n\n\t}\n\n\tgeometry.verticesNeedUpdate = true;\n\n\tgeometry.computeBoundingSphere();\n\n};\n\n// File:src/extras/helpers/SpotLightHelper.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrix = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = [\n\t\t0, 0, 0,   0,   0,   1,\n\t\t0, 0, 0,   1,   0,   1,\n\t\t0, 0, 0, - 1,   0,   1,\n\t\t0, 0, 0,   0,   1,   1,\n\t\t0, 0, 0,   0, - 1,   1\n\t];\n\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\n\n\t\tpositions.push(\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t);\n\n\t}\n\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\n\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\n\n\tthis.cone = new THREE.LineSegments( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function update() {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n// File:src/extras/helpers/VertexNormalsHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\t//\n\n\tvar nNormals = 0;\n\n\tvar objGeometry = this.object.geometry;\n\n\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\tnNormals = objGeometry.faces.length * 3;\n\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\tnNormals = objGeometry.attributes.normal.count;\n\n\t}\n\n\t//\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\n\n\tgeometry.addAttribute( 'position', positions );\n\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\n\n\t//\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\n\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar normalMatrix = new THREE.Matrix3();\n\n\treturn function update() {\n\n\t\tvar keys = [ 'a', 'b', 'c' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar matrixWorld = this.object.matrixWorld;\n\n\t\tvar position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tvar objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\n\n\t\t\tvar vertices = objGeometry.vertices;\n\n\t\t\tvar faces = objGeometry.faces;\n\n\t\t\tvar idx = 0;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\n\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\t\tidx = idx + 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar objPos = objGeometry.attributes.position;\n\n\t\t\tvar objNorm = objGeometry.attributes.normal;\n\n\t\t\tvar idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\n\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\n\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\n\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t\treturn this;\n\n\t};\n\n}() );\n\n// File:src/extras/helpers/WireframeHelper.js\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\n\n\tthis.matrix = object.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\n\n// File:src/extras/objects/ImmediateRenderObject.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = material;\n\tthis.render = function ( renderCallback ) {};\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\n\n// File:src/extras/objects/MorphBlendMesh.js\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphBlendMesh = function( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.animationsMap = {};\n\tthis.animationsList = [];\n\n\t// prepare default animation\n\t// (all frames played together in 1 second)\n\n\tvar numFrames = this.geometry.morphTargets.length;\n\n\tvar name = \"__default\";\n\n\tvar startFrame = 0;\n\tvar endFrame = numFrames - 1;\n\n\tvar fps = numFrames / 1;\n\n\tthis.createAnimation( name, startFrame, endFrame, fps );\n\tthis.setAnimationWeight( name, 1 );\n\n};\n\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\n\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\n\n\tvar animation = {\n\n\t\tstart: start,\n\t\tend: end,\n\n\t\tlength: end - start + 1,\n\n\t\tfps: fps,\n\t\tduration: ( end - start ) / fps,\n\n\t\tlastFrame: 0,\n\t\tcurrentFrame: 0,\n\n\t\tactive: false,\n\n\t\ttime: 0,\n\t\tdirection: 1,\n\t\tweight: 1,\n\n\t\tdirectionBackwards: false,\n\t\tmirroredLoop: false\n\n\t};\n\n\tthis.animationsMap[ name ] = animation;\n\tthis.animationsList.push( animation );\n\n};\n\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\n\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\tvar firstAnimation, frameRanges = {};\n\n\tvar geometry = this.geometry;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar chunks = morph.name.match( pattern );\n\n\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\tvar name = chunks[ 1 ];\n\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\tvar range = frameRanges[ name ];\n\n\t\t\tif ( i < range.start ) range.start = i;\n\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t}\n\n\t}\n\n\tfor ( var name in frameRanges ) {\n\n\t\tvar range = frameRanges[ name ];\n\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t}\n\n\tthis.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = 1;\n\t\tanimation.directionBackwards = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.direction = - 1;\n\t\tanimation.directionBackwards = true;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.fps = fps;\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.duration = duration;\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.weight = weight;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = time;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\n\n\tvar time = 0;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\ttime = animation.time;\n\n\t}\n\n\treturn time;\n\n};\n\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\n\n\tvar duration = - 1;\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tduration = animation.duration;\n\n\t}\n\n\treturn duration;\n\n};\n\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.time = 0;\n\t\tanimation.active = true;\n\n\t} else {\n\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\n\n\tvar animation = this.animationsMap[ name ];\n\n\tif ( animation ) {\n\n\t\tanimation.active = false;\n\n\t}\n\n};\n\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\n\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\tvar animation = this.animationsList[ i ];\n\n\t\tif ( ! animation.active ) continue;\n\n\t\tvar frameTime = animation.duration / animation.length;\n\n\t\tanimation.time += animation.direction * delta;\n\n\t\tif ( animation.mirroredLoop ) {\n\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t}\n\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\tvar weight = animation.weight;\n\n\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\tanimation.currentFrame = keyframe;\n\n\t\t}\n\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t} else {\n\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t}\n\n\t}\n\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/build/three.js\n ** module id = 93\n ** module chunks = 0\n **/","import * as THREE from 'three';\r\n\r\nimport {Loop} from '../extensions/Loop';\r\nimport {defaults} from '../utils/defaults';\r\nimport {WHSObject} from './Object';\r\n\r\nclass Camera extends WHSObject {\r\n  constructor(params, type) {\r\n    if (!type) console.error('@constructor: Please specify \" type \".');\r\n\r\n    const _set = (x, y, z) => {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    };\r\n\r\n    params.useTarget = Boolean(params.target);\r\n\r\n    super({\r\n      camera: {\r\n        fov: 45,\r\n        aspect: window.innerWidth / window.innerHeight,\r\n        near: 1,\r\n        far: 1000,\r\n        left: window.innerWidth / -2,\r\n        right: window.innerWidth / 2,\r\n        top: window.innerHeight / 2,\r\n        bottom: window.innerHeight / -2,\r\n        cubeResolution: 128\r\n      },\r\n\r\n      helper: false,\r\n\r\n      pos: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      rot: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      target: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      }\r\n    });\r\n\r\n    super.setParams(params);\r\n\r\n    const scope = Object.assign(this, {\r\n      _type: type,\r\n      helper: false\r\n    });\r\n\r\n    if (defaults.debug)\r\n      console.debug(`@WHS.Camera: Camera ${scope._type} found.`, scope);\r\n\r\n    return scope;\r\n  }\r\n\r\n  wrap(...tags) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        this.position.set(\r\n          this.__params.pos.x,\r\n          this.__params.pos.y,\r\n          this.__params.pos.z\r\n        );\r\n\r\n        this.rotation.set(\r\n          this.__params.rot.x,\r\n          this.__params.rot.y,\r\n          this.__params.rot.z\r\n        );\r\n\r\n        if (this.__params.useTarget) this.lookAt(this.__params.target);\r\n\r\n        if (this.__params.helper) {\r\n          this.helper = new THREE.CameraHelper(\r\n            this.getNative()\r\n          );\r\n        }\r\n\r\n        tags.forEach(tag => {\r\n          this[tag] = true;\r\n        });\r\n\r\n        if (defaults.debug)\r\n          console.debug(`@WHS.Camera: Camera ${this._type} is ready.`, this);\r\n\r\n        this.emit('ready');\r\n\r\n        resolve(this);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      }\r\n    });\r\n  }\r\n\r\n  addTo(parent) {\r\n    this.parent = parent;\r\n\r\n    const _helper = this.helper,\r\n      _scope = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        _scope.parent.getScene().add(_scope.getNative());\r\n        _scope.parent.children.push(_scope);\r\n\r\n        if (_helper) _scope.parent.getScene().add(_helper);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      } finally {\r\n        if (defaults.debug) {\r\n          console.debug(\r\n            `@WHS.Camera: Camera ${_scope._type} was added to world.`,\r\n            [_scope, _scope.parent]\r\n          );\r\n        }\r\n\r\n        resolve(_scope);\r\n\r\n        _scope.emit('ready');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clone camera.\r\n   */\r\n  clone() {\r\n    return new Shape(this.__params, this._type).copy(this);\r\n  }\r\n\r\n  /**\r\n   * Copy camera.\r\n   *\r\n   * @param {WHS.Camera} source - Source object, that will be applied to this.\r\n   */\r\n  copy(source) {\r\n    this.mesh = source.mesh.clone();\r\n\r\n    this.wrap();\r\n\r\n    this.position = source.position.clone();\r\n    this.rotation = source.rotation.clone();\r\n\r\n    this._type = source._type;\r\n\r\n    return this;\r\n  }\r\n\r\n  get position() {\r\n    return this.getNative().position;\r\n  }\r\n\r\n  set position(vector3) {\r\n    return this.getNative().position.copy(vector3);\r\n  }\r\n\r\n  get rotation() {\r\n    return this.getNative().rotation;\r\n  }\r\n\r\n  set rotation(euler) {\r\n    return this.getNative().rotation.copy(euler);\r\n  }\r\n\r\n  follow(curve, time = 1000, loop, lookAt) {\r\n    const _scope = this,\r\n      gEnd = time;\r\n\r\n    let animation = new Loop(clock => {\r\n      const u = clock.getElapsedTime() * 1000 / gEnd,\r\n        vec1 = curve.getPoint(u),\r\n        vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n      _scope.position.set(vec1.x, vec1.y, vec1.z);\r\n\r\n      if (!lookAt) _scope.lookAt(vec2);\r\n      else if (lookAt instanceof TVector3) _scope.lookAt(lookAt);\r\n      else if (\r\n          lookAt instanceof TCurve\r\n          || lookAt instanceof TCurvePath\r\n        ) _scope.lookAt(lookAt.getPoint(u));\r\n    });\r\n\r\n    animation.start();\r\n\r\n    if (loop) {\r\n      setInterval(() => {\r\n        animation.stop();\r\n\r\n        animation = new Loop(clock => {\r\n          const u = clock.getElapsedTime() * 1000 / gEnd,\r\n            vec1 = curve.getPoint(u),\r\n            vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n          _scope.position.set(vec1.x, vec1.y, vec1.z);\r\n\r\n          if (!lookAt) _scope.lookAt(vec2);\r\n          else if (lookAt instanceof TVector3) _scope.lookAt(lookAt);\r\n          else if (\r\n              lookAt instanceof TCurve\r\n              || lookAt instanceof TCurvePath\r\n            ) _scope.lookAt(lookAt.getPoint(u));\r\n        });\r\n\r\n        animation.start();\r\n      }, time);\r\n    } else {\r\n      setTimeout(() => {\r\n        animation.stop();\r\n      }, time);\r\n    }\r\n  }\r\n\r\n  lookAt(vector3) {\r\n    return this.getNative().lookAt(vector3);\r\n  }\r\n\r\n  getWorldDirection(vector3) {\r\n    return this.getNative().getWorldDirection(vector3);\r\n  }\r\n}\r\n\r\nexport {\r\n  Camera\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Camera.js\n **/","import * as THREE from 'three';\r\n\r\nclass Loop {\r\n  constructor(func) {\r\n    this.func = func;\r\n    this.clock = new THREE.Clock();\r\n    this.enabled = false;\r\n  }\r\n\r\n  start() {\r\n    this.clock.start();\r\n    this.enabled = true;\r\n  }\r\n\r\n  stop() {\r\n    this.clock.stop();\r\n    this.enabled = false;\r\n  }\r\n\r\n  execute() {\r\n    return this.func(this.clock);\r\n  }\r\n}\r\n\r\nexport {\r\n  Loop\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/Loop.js\n **/","const defaults = {\r\n  debug: false\r\n};\r\n\r\nexport {\r\n  defaults\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/defaults.js\n **/","import Events from 'minivents';\r\nimport {extend} from '../extras/api';\r\n\r\nclass WHSObject {\r\n  /**\r\n   * Constructing WHS.Shape object.\r\n   *\r\n   * @param {Boolean} structurable - true if object has parents and children.\r\n   * @param {String} type - Shape type.\r\n   * @return {WHS.Object}\r\n   */\r\n  constructor(defaults = {}, structurable = true) {\r\n    const scope = structurable\r\n    ? Object.assign(this,\r\n      {\r\n        __whsobject: true,\r\n        __releaseTime: new Date().getTime(),\r\n        __params: {},\r\n        __defaults: defaults,\r\n\r\n        parent: null,\r\n        children: []\r\n      },\r\n    new Events())\r\n    : Object.assign(this,\r\n      {\r\n        __whsobject: true,\r\n        __releaseTime: new Date().getTime(),\r\n        __params: {},\r\n        __defaults: defaults\r\n      },\r\n    new Events());\r\n\r\n    return scope;\r\n  }\r\n\r\n  setParams(params = {}) {\r\n    this.__params = extend(params, this.__defaults);\r\n  }\r\n\r\n  updateParams(params = {}) {\r\n    this.__params = extend(params, this.__params);\r\n    return this.__params;\r\n  }\r\n\r\n  getParams() {\r\n    return this.__params;\r\n  }\r\n\r\n  setNative(native) {\r\n    this._native = native;\r\n    return this.native;\r\n  }\r\n\r\n  getNative() {\r\n    return this._native;\r\n  }\r\n\r\n  add(children) {\r\n    const _scope = this;\r\n\r\n    if (children.addTo)\r\n      return children.addTo(this);\r\n    else if (children instanceof Object) {\r\n      return new Promise((resolve) => {\r\n        children.parent = _scope;\r\n\r\n        _scope.getNative().add(children.getNative());\r\n        _scope.children.push(_scope);\r\n\r\n        resolve();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove this shape from world.\r\n   *\r\n   * @return {WHS.Shape} - this.\r\n   */\r\n  remove(source) {\r\n    this.getNative().remove(source.getNative());\r\n\r\n    this.children.splice(this.children.indexOf(source), 1);\r\n    source.parent = null;\r\n\r\n    source.emit('remove');\r\n\r\n    if (WHS.debug) {\r\n      console.debug(\r\n        `@WHS.Shape: Shape ${source._type} was removed from world`,\r\n        [source]\r\n      );\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport {\r\n  WHSObject\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Object.js\n **/","module.exports=function(n){var t={},e=[];n=n||this,n.on=function(n,e,l){(t[n]=t[n]||[]).push([e,l])},n.off=function(n,l){n||(t={});for(var o=t[n]||e,i=o.length=l?o.length:0;i--;)l==o[i][0]&&o.splice(i,1)},n.emit=function(n){for(var l,o=t[n]||e,i=o.length>0?o.slice(0,o.length):o,c=0;l=i[c++];)l[0].apply(l[1],e.slice.call(arguments,1))}};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/minivents/dist/minivents.commonjs.min.js\n ** module id = 98\n ** module chunks = 0\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {JSONLoader, TextureLoader, FontLoader} from '../utils/loaders';\r\n\r\nconst extend = (object, ...extensions) => { // $.extend alternative, ... is the spread operator.\r\n  for (const extension of extensions) {\r\n    // console.log(extension);\r\n    // console.log(typeof extension);\r\n\r\n    if (!extension)\r\n      continue; // Ignore null and undefined objects and paramaters.\r\n\r\n    for (const prop of Object.getOwnPropertyNames(extension)) { // Do not traverse the prototype chain.\r\n      if (object[prop] !== undefined\r\n        && object[prop].toString() === '[object Object]'\r\n        && extension[prop].toString() === '[object Object]')\r\n\r\n        // Goes deep only if object[prop] and extension[prop] are both objects !\r\n        extend(object[prop], extension[prop]);\r\n\r\n      else\r\n        object[prop] = (object[prop] === 0) ? 0 : object[prop];\r\n      if (typeof object[prop] === 'undefined') object[prop] = extension[prop]; // Add values that do not already exist.\r\n    }\r\n  }\r\n\r\n  return object;\r\n};\r\n\r\nconst texture = (url, repeat = {}) => {\r\n  const texture = TextureLoader.load(url);\r\n\r\n  if (repeat) {\r\n    const opt = extend(repeat, {\r\n      offset: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      repeat: {\r\n        x: 1,\r\n        y: 1\r\n      }\r\n    });\r\n\r\n    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n\r\n    texture.offset.set(opt.offset.x, opt.offset.y);\r\n    texture.repeat.set(opt.repeat.x, opt.repeat.y);\r\n\r\n    texture.magFilter = THREE.NearestFilter;\r\n    texture.minFilter = THREE.LinearMipMapLinearFilter;\r\n  }\r\n\r\n  return texture;\r\n};\r\n\r\nconst loadMaterial = (material = {}) => {\r\n  if (typeof material.kind !== 'string')\r\n    console.error('Type of material is undefined or not a string. @loadMaterial');\r\n\r\n  let materialThree;\r\n\r\n  const params = Object.assign({}, material);\r\n\r\n  delete params.kind;\r\n  delete params.useCustomMaterial;\r\n  delete params.useVertexColors;\r\n\r\n  switch (material.kind) {\r\n    case 'basic':\r\n      materialThree = new THREE.MeshBasicMaterial(params);\r\n      break;\r\n\r\n    case 'linebasic':\r\n      materialThree = new THREE.LineBasicMaterial(params);\r\n      break;\r\n\r\n    case 'linedashed':\r\n      materialThree = new THREE.LineDashedMaterial(params);\r\n      break;\r\n\r\n    case 'material':\r\n      materialThree = new THREE.Material(params);\r\n      break;\r\n\r\n    case 'depth':\r\n      materialThree = new THREE.MeshDepthMaterial(params);\r\n      break;\r\n\r\n    case 'face':\r\n      materialThree = new THREE.MeshFaceMaterial(params);\r\n      break;\r\n\r\n    case 'lambert':\r\n      materialThree = new THREE.MeshLambertMaterial(params);\r\n      break;\r\n\r\n    case 'normal':\r\n      materialThree = new THREE.MeshNormalMaterial(params);\r\n      break;\r\n\r\n    case 'phong':\r\n      materialThree = new THREE.MeshPhongMaterial(params);\r\n      break;\r\n\r\n    case 'points':\r\n      materialThree = new THREE.PointsMaterial(params);\r\n      break;\r\n\r\n    case 'standard':\r\n      materialThree = new THREE.MeshStandardMaterial(params);\r\n      break;\r\n\r\n    case 'pointcloud':\r\n      materialThree = new THREE.PointCloudMaterial(params);\r\n      break;\r\n\r\n    case 'rawshader':\r\n      materialThree = new THREE.RawShaderMaterial(params);\r\n      break;\r\n\r\n    case 'shader':\r\n      materialThree = new THREE.ShaderMaterial(params);\r\n      break;\r\n\r\n    case 'spritecanvas':\r\n      materialThree = new THREE.SpriteCanvasMaterial(params);\r\n      break;\r\n\r\n    case 'sprite':\r\n      materialThree = new THREE.SpriteMaterial(params);\r\n      break;\r\n\r\n    default:\r\n  }\r\n\r\n  return materialThree;\r\n};\r\n\r\nexport {\r\n  FontLoader,\r\n  JSONLoader,\r\n  TextureLoader,\r\n  texture,\r\n  extend,\r\n  loadMaterial\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/api.js\n **/","export default function () {\r\n  return {};\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/physics/nophysi.js\n **/","import * as THREE from 'three';\r\nimport TOBJLoader from 'three-obj-loader';\r\nTOBJLoader(THREE);\r\n\r\n// Models.\r\nconst JSONLoader = new THREE.JSONLoader();\r\nconst OBJLoader = new THREE.OBJLoader();\r\n// const BabylonLoader = new THREE.BabylonLoader();\r\nconst BufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n// const ColladaLoader = new THREE.ColladaLoader();\r\n// const glTFLoader = new THREE.glTFLoader();\r\nconst ObjectLoader = new THREE.ObjectLoader();\r\n// const PDBLoader = new THREE.PDBLoader();\r\n// const SVGLoader = new THREE.SVGLoader();\r\n// const TGALoader = new THREE.TGALoader();\r\n\r\n\r\n// Other.\r\nconst TextureLoader = new THREE.TextureLoader();\r\nconst FontLoader = new THREE.FontLoader();\r\nconst XHRLoader = new THREE.XHRLoader();\r\nconst AudioLoader = new THREE.AudioLoader();\r\nconst ImageLoader = new THREE.ImageLoader();\r\nconst MaterialLoader = new THREE.MaterialLoader();\r\n// const MTLLoader = new THREE.MTLLoader();\r\n\r\nexport {\r\n  JSONLoader,\r\n  OBJLoader,\r\n  // BabylonLoader,\r\n  BufferGeometryLoader,\r\n  // ColladaLoader,\r\n  // glTFLoader,\r\n  ObjectLoader,\r\n  // PDBLoader,\r\n  // SVGLoader,\r\n  // TGALoader,\r\n\tTextureLoader,\r\n\tFontLoader,\r\n\tXHRLoader,\r\n\tAudioLoader,\r\n\tImageLoader,\r\n\tMaterialLoader,\r\n\t// MTLLoader\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/loaders.js\n **/","'use strict';\n\nmodule.exports = function (THREE) {\n\n  /**\n   * @author mrdoob / http://mrdoob.com/\n   */\n  THREE.OBJLoader = function (manager) {\n\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  THREE.OBJLoader.prototype = {\n\n    constructor: THREE.OBJLoader,\n\n    load: function load(url, onLoad, onProgress, onError) {\n\n      var scope = this;\n\n      var loader = new THREE.XHRLoader(scope.manager);\n      loader.load(url, function (text) {\n\n        onLoad(scope.parse(text));\n      }, onProgress, onError);\n    },\n\n    parse: function parse(text) {\n\n      console.time('OBJLoader');\n\n      var object,\n          objects = [];\n      var geometry, material;\n\n      function parseVertexIndex(value) {\n\n        var index = parseInt(value);\n\n        return (index >= 0 ? index - 1 : index + vertices.length / 3) * 3;\n      }\n\n      function parseNormalIndex(value) {\n\n        var index = parseInt(value);\n\n        return (index >= 0 ? index - 1 : index + normals.length / 3) * 3;\n      }\n\n      function parseUVIndex(value) {\n\n        var index = parseInt(value);\n\n        return (index >= 0 ? index - 1 : index + uvs.length / 2) * 2;\n      }\n\n      function addVertex(a, b, c) {\n\n        geometry.vertices.push(vertices[a], vertices[a + 1], vertices[a + 2], vertices[b], vertices[b + 1], vertices[b + 2], vertices[c], vertices[c + 1], vertices[c + 2]);\n      }\n\n      function addNormal(a, b, c) {\n\n        geometry.normals.push(normals[a], normals[a + 1], normals[a + 2], normals[b], normals[b + 1], normals[b + 2], normals[c], normals[c + 1], normals[c + 2]);\n      }\n\n      function addUV(a, b, c) {\n\n        geometry.uvs.push(uvs[a], uvs[a + 1], uvs[b], uvs[b + 1], uvs[c], uvs[c + 1]);\n      }\n\n      function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {\n\n        var ia = parseVertexIndex(a);\n        var ib = parseVertexIndex(b);\n        var ic = parseVertexIndex(c);\n        var id;\n\n        if (d === undefined) {\n\n          addVertex(ia, ib, ic);\n        } else {\n\n          id = parseVertexIndex(d);\n\n          addVertex(ia, ib, id);\n          addVertex(ib, ic, id);\n        }\n\n        if (ua !== undefined) {\n\n          ia = parseUVIndex(ua);\n          ib = parseUVIndex(ub);\n          ic = parseUVIndex(uc);\n\n          if (d === undefined) {\n\n            addUV(ia, ib, ic);\n          } else {\n\n            id = parseUVIndex(ud);\n\n            addUV(ia, ib, id);\n            addUV(ib, ic, id);\n          }\n        }\n\n        if (na !== undefined) {\n\n          ia = parseNormalIndex(na);\n          ib = parseNormalIndex(nb);\n          ic = parseNormalIndex(nc);\n\n          if (d === undefined) {\n\n            addNormal(ia, ib, ic);\n          } else {\n\n            id = parseNormalIndex(nd);\n\n            addNormal(ia, ib, id);\n            addNormal(ib, ic, id);\n          }\n        }\n      }\n\n      // create mesh if no objects in text\n\n      if (/^o /gm.test(text) === false) {\n\n        geometry = {\n          vertices: [],\n          normals: [],\n          uvs: []\n        };\n\n        material = {\n          name: ''\n        };\n\n        object = {\n          name: '',\n          geometry: geometry,\n          material: material\n        };\n\n        objects.push(object);\n      }\n\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n\n      // v float float float\n\n      var vertex_pattern = /v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\n      // vn float float float\n\n      var normal_pattern = /vn( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\n      // vt float float\n\n      var uv_pattern = /vt( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/;\n\n      // f vertex vertex vertex ...\n\n      var face_pattern1 = /f( +-?\\d+)( +-?\\d+)( +-?\\d+)( +-?\\d+)?/;\n\n      // f vertex/uv vertex/uv vertex/uv ...\n\n      var face_pattern2 = /f( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+))?/;\n\n      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n\n      var face_pattern3 = /f( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))( +(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/;\n\n      // f vertex//normal vertex//normal vertex//normal ...\n\n      var face_pattern4 = /f( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))( +(-?\\d+)\\/\\/(-?\\d+))?/;\n\n      //\n\n      var lines = text.split('\\n');\n\n      for (var i = 0; i < lines.length; i++) {\n\n        var line = lines[i];\n        line = line.trim();\n\n        var result;\n\n        if (line.length === 0 || line.charAt(0) === '#') {\n\n          continue;\n        } else if ((result = vertex_pattern.exec(line)) !== null) {\n\n          // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n          vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n        } else if ((result = normal_pattern.exec(line)) !== null) {\n\n          // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n          normals.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n        } else if ((result = uv_pattern.exec(line)) !== null) {\n\n          // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n          uvs.push(parseFloat(result[1]), parseFloat(result[2]));\n        } else if ((result = face_pattern1.exec(line)) !== null) {\n\n          // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n          addFace(result[1], result[2], result[3], result[4]);\n        } else if ((result = face_pattern2.exec(line)) !== null) {\n\n          // [\"f 1/1 2/2 3/3\", \" 1/1\", \"1\", \"1\", \" 2/2\", \"2\", \"2\", \" 3/3\", \"3\", \"3\", undefined, undefined, undefined]\n\n          addFace(result[2], result[5], result[8], result[11], result[3], result[6], result[9], result[12]);\n        } else if ((result = face_pattern3.exec(line)) !== null) {\n\n          // [\"f 1/1/1 2/2/2 3/3/3\", \" 1/1/1\", \"1\", \"1\", \"1\", \" 2/2/2\", \"2\", \"2\", \"2\", \" 3/3/3\", \"3\", \"3\", \"3\", undefined, undefined, undefined, undefined]\n\n          addFace(result[2], result[6], result[10], result[14], result[3], result[7], result[11], result[15], result[4], result[8], result[12], result[16]);\n        } else if ((result = face_pattern4.exec(line)) !== null) {\n\n          // [\"f 1//1 2//2 3//3\", \" 1//1\", \"1\", \"1\", \" 2//2\", \"2\", \"2\", \" 3//3\", \"3\", \"3\", undefined, undefined, undefined]\n\n          addFace(result[2], result[5], result[8], result[11], undefined, undefined, undefined, undefined, result[3], result[6], result[9], result[12]);\n        } else if (/^o /.test(line)) {\n\n          geometry = {\n            vertices: [],\n            normals: [],\n            uvs: []\n          };\n\n          material = {\n            name: ''\n          };\n\n          object = {\n            name: line.substring(2).trim(),\n            geometry: geometry,\n            material: material\n          };\n\n          objects.push(object);\n        } else if (/^g /.test(line)) {\n\n          // group\n\n        } else if (/^usemtl /.test(line)) {\n\n            // material\n\n            material.name = line.substring(7).trim();\n          } else if (/^mtllib /.test(line)) {\n\n            // mtl file\n\n          } else if (/^s /.test(line)) {\n\n              // smooth shading\n\n            } else {\n\n                // console.log( \"THREE.OBJLoader: Unhandled line \" + line );\n\n              }\n      }\n\n      var container = new THREE.Object3D();\n      var l;\n\n      for (i = 0, l = objects.length; i < l; i++) {\n\n        object = objects[i];\n        geometry = object.geometry;\n\n        var buffergeometry = new THREE.BufferGeometry();\n\n        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));\n\n        if (geometry.normals.length > 0) {\n\n          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));\n        }\n\n        if (geometry.uvs.length > 0) {\n\n          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));\n        }\n\n        material = new THREE.MeshLambertMaterial({\n          color: 0xff0000\n        });\n        material.name = object.material.name;\n\n        var mesh = new THREE.Mesh(buffergeometry, material);\n        mesh.name = object.name;\n\n        container.add(mesh);\n      }\n\n      console.timeEnd('OBJLoader');\n\n      return container;\n    }\n\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three-obj-loader/dist/index.js\n ** module id = 102\n ** module chunks = 0\n **/","import * as THREE from 'three';\r\nimport {Camera} from '../core/Camera';\r\n\r\nclass OrtographicCamera extends Camera {\r\n  constructor(params = {}) {\r\n    super(params, 'ortographiccamera');\r\n\r\n    this.build(params);\r\n    super.wrap();\r\n  }\r\n\r\n  build(params = {}) {\r\n    return new Promise((resolve) => {\r\n      this.setNative(new THREE.OrtographicCamera(\r\n        params.camera.left,\r\n        params.camera.right,\r\n        params.camera.top,\r\n        params.camera.bottom,\r\n        params.camera.near,\r\n        params.camera.far\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  OrtographicCamera\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cameras/OrtographicCamera.js\n **/","import * as THREE from 'three';\r\nimport {Camera} from '../core/Camera';\r\n\r\nclass PerspectiveCamera extends Camera {\r\n  constructor(params = {}) {\r\n    super(params, 'perspectivecamera');\r\n\r\n    this.build(params);\r\n    super.wrap();\r\n  }\r\n\r\n  build(params = {}) {\r\n    return new Promise((resolve) => {\r\n      this.setNative(new THREE.PerspectiveCamera(\r\n        params.camera.fov,\r\n        params.camera.aspect,\r\n        params.camera.near,\r\n        params.camera.far\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  PerspectiveCamera\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/cameras/PerspectiveCamera.js\n **/","export * from './Camera';\r\nexport * from './Light';\r\nexport * from './Object';\r\nexport * from './Shape';\r\nexport * from './World';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/index.js\n **/","import * as THREE from 'three';\r\n\r\nimport {Loop} from '../extensions/Loop';\r\nimport {defaults} from '../utils/defaults';\r\nimport {WHSObject} from './Object';\r\n\r\nclass Light extends WHSObject {\r\n  /**\r\n   * Constructing WHS.Light object.\r\n   *\r\n   * @param {Object} params - Inputed parameters.\r\n   * @param {String} type - Light type.\r\n   * @return {WHS.Light}\r\n   */\r\n  constructor(params, type) {\r\n    if (!type)\r\n      console.error('@constructor: Please specify \" type \".');\r\n\r\n    const _set = (x, y, z) => {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    };\r\n\r\n    super({\r\n      light: {\r\n        color: 0xffffff,\r\n        skyColor: 0xffffff,\r\n        groundColor: 0xffffff,\r\n\r\n        intensity: 1,\r\n        distance: 100,\r\n        angle: Math.PI / 3,\r\n        exponent: 0,\r\n        decay: 1\r\n      },\r\n\r\n      helper: false,\r\n\r\n      shadowmap: {\r\n        cast: true,\r\n\r\n        bias: 0,\r\n\r\n        width: 1024,\r\n        height: 1024,\r\n\r\n        near: true,\r\n        far: 400,\r\n        fov: 60,\r\n\r\n        top: 200,\r\n        bottom: -200,\r\n        left: -200,\r\n        right: 200\r\n      },\r\n\r\n      pos: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      rot: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      target: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      }\r\n    });\r\n\r\n    super.setParams(params);\r\n\r\n    const scope = Object.assign(this,\r\n      {\r\n        _type: type,\r\n\r\n        _light: this.__params.light,\r\n        _shadowmap: this.__params.shadowmap\r\n      });\r\n\r\n    if (defaults.debug)\r\n      console.debug(`@WHS.Light: Light ${scope._type} found.`, scope);\r\n\r\n    return scope;\r\n  }\r\n\r\n  /**\r\n   * Applying shadow & position & rotation.\r\n   *\r\n   * @param {...String} tags - Tags that defines what to do with light\r\n   * additionally.\r\n   */\r\n  wrap(...tags) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        if (tags.indexOf('no-shadows') < 0) {\r\n          _scope.getNative().castShadow = this._shadowmap.cast;\r\n        }\r\n\r\n        if (tags.indexOf('no-transforms') < 0) {\r\n          _scope.position.set(\r\n            _scope.__params.pos.x,\r\n            _scope.__params.pos.y,\r\n            _scope.__params.pos.z\r\n          );\r\n\r\n          _scope.rotation.set(\r\n            _scope.__params.rot.x,\r\n            _scope.__params.rot.y,\r\n            _scope.__params.rot.z\r\n          );\r\n\r\n          if (_scope.getNative().target) {\r\n            _scope.target.set(\r\n              _scope.__params.target.x,\r\n              _scope.__params.target.y,\r\n              _scope.__params.target.z\r\n            );\r\n          }\r\n        }\r\n\r\n        tags.forEach(tag => {\r\n          _scope[tag] = true;\r\n        });\r\n\r\n        if (defaults.debug)\r\n          console.debug(`@WHS.Light: Light ${_scope._type} + ' is ready.`, _scope);\r\n\r\n        _scope.emit('ready');\r\n\r\n        resolve(_scope);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add light to WHS.World object.\r\n   *\r\n   * @param {WHS.World} root - World, were this light will be.\r\n   * @param {...String} tags - Tags for compiling.\r\n   */\r\n  addTo(parent) {\r\n    this.parent = parent;\r\n\r\n    const _helper = this.helper,\r\n      _scope = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        _scope.parent.getScene().add(_scope.getNative());\r\n        _scope.parent.children.push(_scope);\r\n\r\n        if (_helper) _scope.parent.getScene().add(_helper);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      } finally {\r\n        if (defaults.debug) {\r\n          console.debug(\r\n            `@WHS.Camera: Camera ${_scope._type} was added to world.`,\r\n            [_scope, _scope.parent]\r\n          );\r\n        }\r\n\r\n        resolve(_scope);\r\n        _scope.emit('ready');\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set shadow properties for light.\r\n   */\r\n  wrapShadow() {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        _scope.getNative().shadow.mapSize.width = this._shadowmap.width;\r\n        _scope.getNative().shadow.mapSize.height = this._shadowmap.height;\r\n        _scope.getNative().shadow.bias = this._shadowmap.bias;\r\n\r\n        _scope.getNative().shadow.camera.near = this._shadowmap.near;\r\n        _scope.getNative().shadow.camera.far = this._shadowmap.far;\r\n        _scope.getNative().shadow.camera.fov = this._shadowmap.fov;\r\n\r\n        _scope.getNative().shadow.camera.left = this._shadowmap.left;\r\n        _scope.getNative().shadow.camera.right = this._shadowmap.right;\r\n        _scope.getNative().shadow.camera.top = this._shadowmap.top;\r\n        _scope.getNative().shadow.camera.bottom = this._shadowmap.bottom;\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      } finally {\r\n        resolve(_scope);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clone light.\r\n   */\r\n  clone() {\r\n    return new Light(this.__params, this._type).copy(this);\r\n  }\r\n\r\n  /**\r\n   * Copy light.\r\n   *\r\n   * @param {WHS.Light} source - Source object, that will be applied to this.\r\n   */\r\n  copy(source) {\r\n    this.light = source.getNative().clone();\r\n    if (source.helper) this.helper = source.helper.clone();\r\n\r\n    this.wrap();\r\n\r\n    this.position = source.position.clone();\r\n    this.rotation = source.rotation.clone();\r\n\r\n    this._type = source._type;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove this light from world.\r\n   */\r\n  remove() {\r\n    this.parent.getScene().remove(this.getNative());\r\n    if (source.helper) this.parent.getScene().remove(this.helper);\r\n\r\n    this.parent.children.splice(this.parent.children.indexOf(this), 1);\r\n    this.parent = null;\r\n\r\n    this.emit('remove');\r\n\r\n    return this;\r\n  }\r\n\r\n  get position() {\r\n    return this.getNative().position;\r\n  }\r\n\r\n  set position(vector3) {\r\n    return this.getNative().position.copy(vector3);\r\n  }\r\n\r\n  get rotation() {\r\n    return this.getNative().rotation;\r\n  }\r\n\r\n  set rotation(euler) {\r\n    return this.getNative().rotation.copy(euler);\r\n  }\r\n\r\n  get target() {\r\n    return this.getNative().target.position;\r\n  }\r\n\r\n  set target(vector3) {\r\n    return this.getNative().target.position.copy(vector3);\r\n  }\r\n\r\n  follow(curve, time = 1000, loop, lookAt) {\r\n    const _scope = this,\r\n      gEnd = time;\r\n\r\n    let animation = new Loop(clock => {\r\n      const u = clock.getElapsedTime() * 1000 / gEnd,\r\n        vec1 = curve.getPoint(u),\r\n        vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n      _scope.position.set(vec1.x, vec1.y, vec1.z);\r\n\r\n      if (!lookAt) _scope.lookAt(vec2);\r\n      else if (lookAt instanceof THREE.Vector3) _scope.lookAt(lookAt);\r\n      else if (\r\n          lookAt instanceof THREE.Curve\r\n          || lookAt instanceof THREE.CurvePath\r\n        ) _scope.lookAt(lookAt.getPoint(u));\r\n    });\r\n\r\n    animation.start();\r\n\r\n    if (loop) {\r\n      setInterval(() => {\r\n        animation.stop();\r\n\r\n        animation = new Loop(clock => {\r\n          const u = clock.getElapsedtime() * 1000 / gEnd,\r\n            vec1 = curve.getPoint(u),\r\n            vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n          _scope.position.set(vec1.x, vec1.y, vec1.z);\r\n\r\n          if (!lookAt) _scope.lookAt(vec2);\r\n          else if (lookAt instanceof THREE.Vector3) _scope.lookAt(lookAt);\r\n          else if (\r\n              lookAt instanceof THREE.Curve\r\n              || lookAt instanceof THREE.CurvePath\r\n            ) _scope.lookAt(lookAt.getPoint(u));\r\n        });\r\n\r\n        animation.start();\r\n      }, time);\r\n    } else {\r\n      setTimeout(() => {\r\n        animation.stop();\r\n      }, time);\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  Light\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Light.js\n **/","import * as THREE from 'three';\r\n\r\nimport {loadMaterial, extend} from '../extras/api';\r\nimport {Loop} from '../extensions/Loop';\r\nimport {defaults} from '../utils/defaults';\r\nimport {World} from './World';\r\nimport {WHSObject} from './Object';\r\n\r\nclass Shape extends WHSObject {\r\n  /**\r\n   * Constructing WHS.Shape object.\r\n   *\r\n   * @param {Object} params - Inputed parameters.\r\n   * @param {String} type - Shape type.\r\n   * @return {WHS.Shape}\r\n   */\r\n  constructor(params = {}, type = 'mesh') {\r\n    const _set = (x, y, z) => {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    };\r\n\r\n    const physicsDefaults = false ? {\r\n      restitution: 0.3,\r\n      friction: 0.8,\r\n      damping: 0,\r\n      pressure: 100,\r\n      margin: 0\r\n    } : false;\r\n\r\n    super({\r\n      mass: 10,\r\n      build: true,\r\n      softbody: false,\r\n      geometry: {},\r\n\r\n      material: {\r\n        kind: 'basic'\r\n      },\r\n\r\n      helpers: {\r\n        box: false,\r\n        boundingBox: false,\r\n        edges: false,\r\n        faceNormals: false\r\n      },\r\n\r\n      pos: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      rot: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      scale: {\r\n        x: 1,\r\n        y: 1,\r\n        z: 1,\r\n        set: _set\r\n      },\r\n\r\n      target: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0,\r\n        set: _set\r\n      },\r\n\r\n      physics: physicsDefaults\r\n    });\r\n\r\n    if (params instanceof THREE.Object3D) {\r\n      super.setParams({\r\n        pos: {x: params.position.x, y: params.position.y, z: params.position.z},\r\n        rot: {x: params.rotation.x, y: params.rotation.y, z: params.rotation.z},\r\n        scale: {x: params.scale.x, y: params.scale.y, z: params.scale.z},\r\n        mass: params.mass,\r\n        physics: Boolean(params._physijs)\r\n      });\r\n    } else super.setParams(params);\r\n\r\n    const scope = Object.assign(this,\r\n      {\r\n        _type: type,\r\n        __c_rot: false,\r\n\r\n        _wait: [],\r\n\r\n        helpers: {\r\n          box: false,\r\n          boundingBox: false,\r\n          edges: false,\r\n          faceNormals: false\r\n        },\r\n\r\n        physics: params.physics\r\n      }\r\n    );\r\n\r\n    if (params instanceof THREE.Object3D) this.setNative(params);\r\n    if (defaults.debug) console.debug(`@WHS.Shape: Shape ${scope._type} found.`, scope);\r\n\r\n    return scope;\r\n  }\r\n\r\n  wait(promise) {\r\n    this._wait.push(promise);\r\n  }\r\n\r\n  /**\r\n   * Applying shadow & position & rotation.\r\n   *\r\n   * @param {...String} tags - Tags that defines what to do with shape\r\n   * additionally.\r\n   */\r\n  wrap(...tags) {\r\n    if (this._wait.length) {\r\n      return new Promise((resolve, reject) => {\r\n        Promise.all(this._wait).then(() => {\r\n          const _native = this.getNative(),\r\n            _params = this.getParams(),\r\n            _params_helpers = _params.helpers;\r\n\r\n          if (!_native) reject();\r\n\r\n          if (tags.indexOf('no-shadows') < 0) {\r\n            _native.castShadow = true;\r\n            _native.receiveShadow = true;\r\n          }\r\n\r\n          if (tags.indexOf('no-transforms') < 0) {\r\n            if (!_params.softbody) {\r\n              const _params_pos = _params.pos,\r\n                _params_rot = _params.rot,\r\n                _params_scale = _params.scale;\r\n\r\n              this.position.set(\r\n                _params_pos.x,\r\n                _params_pos.y,\r\n                _params_pos.z\r\n              );\r\n\r\n              this.rotation.set(\r\n                _params_rot.x,\r\n                _params_rot.y,\r\n                _params_rot.z\r\n              );\r\n\r\n              this.scale.set(\r\n                _params_scale.x,\r\n                _params_scale.y,\r\n                _params_scale.z\r\n              );\r\n            }\r\n          }\r\n\r\n          // Box helper.\r\n          if (_params_helpers.box) {\r\n            this.helpers.box = new THREE.BoxHelper(\r\n              _native\r\n            );\r\n          }\r\n\r\n          // Bounding box helper.\r\n          if (_params_helpers.boundingBox) {\r\n            extend(_params_helpers.boundingBox, {\r\n              color: 0xffffff\r\n            });\r\n\r\n            this.helpers.boundingBox = new THREE.BoundingBoxHelper(\r\n              _native,\r\n              _params_helpers.boundingBox.color\r\n              ? _params_helpers.boundingBox.color\r\n              : 0xffffff\r\n            );\r\n          }\r\n\r\n          // Edges helper.\r\n          if (_params_helpers.edges) {\r\n            extend(_params_helpers.edges, {\r\n              color: 0xffffff\r\n            });\r\n\r\n            this.helpers.edges = new THREE.EdgesHelper(\r\n              _native,\r\n              _params_helpers.edges.color\r\n            );\r\n          }\r\n\r\n          // faceNormals helper.\r\n          if (_params_helpers.faceNormals) {\r\n            const _params_helpers_faceNormals = _params_helpers.faceNormals;\r\n\r\n            extend(_params_helpers_faceNormals, {\r\n              size: 2,\r\n              color: 0xffffff,\r\n              linewidth: 1\r\n            });\r\n\r\n            this.helpers.faceNormals = new THREE.FaceNormalsHelper(\r\n              _native,\r\n              _params_helpers_faceNormals.size,\r\n              _params_helpers_faceNormals.color,\r\n              _params_helpers_faceNormals.linewidth\r\n            );\r\n          }\r\n\r\n          // vertexNormals helper.\r\n          if (_params_helpers.vertexNormals) {\r\n            const _params_helpers_vertexNormals = _params_helpers.vertexNormals;\r\n\r\n            extend(_params_helpers_vertexNormals, {\r\n              size: 2,\r\n              color: 0xffffff,\r\n              linewidth: 1\r\n            });\r\n\r\n            this.helpers.vertexNormals = new THREE.VertexNormalsHelper(\r\n              _native,\r\n              _params_helpers_vertexNormals.size,\r\n              _params_helpers_vertexNormals.color,\r\n              _params_helpers_vertexNormals.linewidth\r\n            );\r\n          }\r\n\r\n          resolve(this);\r\n\r\n          if (WHS.debug) console.debug(`@WHS.Shape: Shape ${this._type} is ready.`, this);\r\n        });\r\n      });\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        const _native = this.getNative(),\r\n          _params = this.getParams(),\r\n          _params_helpers = _params.helpers;\r\n\r\n        if (!_native) reject();\r\n\r\n        if (tags.indexOf('no-shadows') < 0) {\r\n          _native.castShadow = true;\r\n          _native.receiveShadow = true;\r\n        }\r\n\r\n        if (tags.indexOf('no-transforms') < 0) {\r\n          if (!_params.softbody) {\r\n            const _params_pos = _params.pos,\r\n              _params_rot = _params.rot,\r\n              _params_scale = _params.scale;\r\n\r\n            this.position.set(\r\n              _params_pos.x,\r\n              _params_pos.y,\r\n              _params_pos.z\r\n            );\r\n\r\n            this.rotation.set(\r\n              _params_rot.x,\r\n              _params_rot.y,\r\n              _params_rot.z\r\n            );\r\n\r\n            this.scale.set(\r\n              _params_scale.x,\r\n              _params_scale.y,\r\n              _params_scale.z\r\n            );\r\n          }\r\n        }\r\n\r\n        // Box helper.\r\n        if (_params_helpers.box) {\r\n          this.helpers.box = new THREE.BoxHelper(\r\n            _native\r\n          );\r\n        }\r\n\r\n        // Bounding box helper.\r\n        if (_params_helpers.boundingBox) {\r\n          extend(_params_helpers.boundingBox, {\r\n            color: 0xffffff\r\n          });\r\n\r\n          this.helpers.boundingBox = new THREE.BoundingBoxHelper(\r\n            _native,\r\n            _params_helpers.boundingBox.color\r\n            ? _params_helpers.boundingBox.color\r\n            : 0xffffff\r\n          );\r\n        }\r\n\r\n        // Edges helper.\r\n        if (_params_helpers.edges) {\r\n          extend(_params_helpers.edges, {\r\n            color: 0xffffff\r\n          });\r\n\r\n          this.helpers.edges = new THREE.EdgesHelper(\r\n            _native,\r\n            _params_helpers.edges.color\r\n          );\r\n        }\r\n\r\n        // faceNormals helper.\r\n        if (_params_helpers.faceNormals) {\r\n          const _params_helpers_faceNormals = _params_helpers.faceNormals;\r\n\r\n          extend(_params_helpers_faceNormals, {\r\n            size: 2,\r\n            color: 0xffffff,\r\n            linewidth: 1\r\n          });\r\n\r\n          this.helpers.faceNormals = new THREE.FaceNormalsHelper(\r\n            _native,\r\n            _params_helpers_faceNormals.size,\r\n            _params_helpers_faceNormals.color,\r\n            _params_helpers_faceNormals.linewidth\r\n          );\r\n        }\r\n\r\n        // vertexNormals helper.\r\n        if (_params_helpers.vertexNormals) {\r\n          const _params_helpers_vertexNormals = _params_helpers.vertexNormals;\r\n\r\n          extend(_params_helpers_vertexNormals, {\r\n            size: 2,\r\n            color: 0xffffff,\r\n            linewidth: 1\r\n          });\r\n\r\n          this.helpers.vertexNormals = new THREE.VertexNormalsHelper(\r\n            _native,\r\n            _params_helpers_vertexNormals.size,\r\n            _params_helpers_vertexNormals.color,\r\n            _params_helpers_vertexNormals.linewidth\r\n          );\r\n        }\r\n\r\n        resolve(this);\r\n\r\n        if (WHS.debug) console.debug(`@WHS.Shape: Shape ${this._type} is ready.`, this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add shape to WHS.World object.\r\n   *\r\n   * @param {WHS.World} parent - World, were this shape will be.\r\n   * @param {...String} tags - Tags for compiling.\r\n   */\r\n  addTo(parent) {\r\n    const _helpers = this.helpers;\r\n    this.parent = parent;\r\n\r\n    if (this._wait.length) {\r\n      return new Promise((resolve, reject) => {\r\n        Promise.all(this._wait).then(() => {\r\n          const _native = this.getNative(),\r\n            _params = this.getParams(),\r\n            _params_helpers = _params.helpers,\r\n            _parent = this.parent;\r\n\r\n          if (!_native) reject();\r\n\r\n          const parentNative = _parent instanceof World ? _parent.getScene()\r\n            : _parent.getNative();\r\n\r\n          parentNative.add(_native);\r\n          this.parent.children.push(this);\r\n\r\n          if (_params.softbody) {\r\n            _native.position.set(0, 0, 0);\r\n            _native.rotation.set(0, 0, 0);\r\n          }\r\n\r\n          if (_params_helpers.box) parentNative.add(_helpers.box);\r\n          if (_params_helpers.boundingBox) parentNative.add(_helpers.boundingBox);\r\n          if (_params_helpers.edges) parentNative.add(_helpers.edges);\r\n          if (_params_helpers.faceNormals) parentNative.add(_helpers.faceNormals);\r\n          if (_params_helpers.vertexNormals) parentNative.add(_helpers.vertexNormals);\r\n\r\n          resolve(this);\r\n\r\n          _native.addEventListener('collide', () => {\r\n            this.emit('collide');\r\n          });\r\n\r\n          if (WHS.debug) {\r\n            console.debug(\r\n              `@WHS.Shape: Shape ${this._type} was added to world.`,\r\n              [this, _parent]\r\n            );\r\n          }\r\n        });\r\n      });\r\n    } else {\r\n      return new Promise((resolve, reject) => {\r\n        const _native = this.getNative(),\r\n          _params = this.getParams(),\r\n          _params_helpers = _params.helpers,\r\n          _parent = this.parent;\r\n\r\n        if (!_native) reject();\r\n\r\n        const parentNative = _parent instanceof World ? _parent.getScene()\r\n          : _parent.getNative();\r\n\r\n        parentNative.add(_native);\r\n        this.parent.children.push(this);\r\n\r\n        if (_params.softbody) {\r\n          _native.position.set(0, 0, 0);\r\n          _native.rotation.set(0, 0, 0);\r\n        }\r\n\r\n        if (_params_helpers.box) parentNative.add(_helpers.box);\r\n        if (_params_helpers.boundingBox) parentNative.add(_helpers.boundingBox);\r\n        if (_params_helpers.edges) parentNative.add(_helpers.edges);\r\n        if (_params_helpers.faceNormals) parentNative.add(_helpers.faceNormals);\r\n        if (_params_helpers.vertexNormals) parentNative.add(_helpers.vertexNormals);\r\n\r\n        resolve(this);\r\n\r\n        _native.addEventListener('collide', () => {\r\n          this.emit('collide');\r\n        });\r\n\r\n        if (WHS.debug) {\r\n          console.debug(\r\n            `@WHS.Shape: Shape ${this._type} was added to world.`,\r\n            [this, _parent]\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize shape's material object.\r\n   */\r\n  _initMaterial(params = {}) {\r\n    return loadMaterial(params);\r\n  }\r\n\r\n  /**\r\n   * Clone shape.\r\n   */\r\n  clone() {\r\n    return new WHS.Shape(this.getParams(), this._type).copy(this);\r\n  }\r\n\r\n  /**\r\n   * Copy shape.\r\n   *\r\n   * @param {WHS.Shape} source - Source object, that will be applied to this.\r\n   */\r\n  copy(source) {\r\n    const sourceNative = source.getNative();\r\n\r\n\r\n    if (source.getParams().softbody)\r\n      this.setNative(new sourceNative.constructor(sourceNative.tempGeometry.clone(), sourceNative.material, source.getParams()));\r\n    else this.setNative(sourceNative.clone(source.getParams()));\r\n\r\n    this.wrap();\r\n\r\n    this.position.copy(source.position);\r\n    this.rotation.copy(source.rotation);\r\n    this.quaternion.copy(source.quaternion);\r\n\r\n    this.getNative().mass = source.getNative().mass;\r\n\r\n    return this;\r\n  }\r\n\r\n  getParent() {\r\n    return this.parent;\r\n  }\r\n\r\n  /**\r\n   * @return {WHS.World} - World object.\r\n   */\r\n  getWorld() {\r\n    let p = this.parent;\r\n\r\n    while (!(p instanceof World)) {\r\n      if (p) p = p.parent;\r\n      else return false;\r\n    }\r\n\r\n    return p;\r\n  }\r\n\r\n  get position() {\r\n    return this.getNative().position;\r\n  }\r\n\r\n  set position(vector3) {\r\n    const pos = this.getNative().position,\r\n      native = this.getNative();\r\n\r\n    Object.defineProperties(pos, {\r\n      x: {\r\n        get() {\r\n          return this._x;\r\n        },\r\n\r\n        set(x) {\r\n          native.__dirtyPosition = true;\r\n          this._x = x;\r\n        }\r\n      },\r\n      y: {\r\n        get() {\r\n          return this._y;\r\n        },\r\n\r\n        set(y) {\r\n          native.__dirtyPosition = true;\r\n          this._y = y;\r\n        }\r\n      },\r\n      z: {\r\n        get() {\r\n          return this._z;\r\n        },\r\n\r\n        set(z) {\r\n          native.__dirtyPosition = true;\r\n          this._z = z;\r\n        }\r\n      }\r\n    });\r\n\r\n    native.__dirtyPosition = true;\r\n\r\n    return pos.copy(vector3);\r\n  }\r\n\r\n  get quaternion() {\r\n    this.__c_rot = true;\r\n    return this.getNative().quaternion;\r\n  }\r\n\r\n  set quaternion(quaternion) {\r\n    const quat = this.getNative().quaternion,\r\n      native = this.getNative();\r\n\r\n    quat.copy(quaternion);\r\n\r\n    quat.onChange(() => {\r\n      if (this.__c_rot) {\r\n        if (native.__dirtyRotation === true) {\r\n          this.__c_rot = false;\r\n          native.__dirtyRotation = false;\r\n        }\r\n        native.__dirtyRotation = true;\r\n      }\r\n    });\r\n\r\n    return quat;\r\n  }\r\n\r\n  get rotation() {\r\n    this.__c_rot = true;\r\n    return this.getNative().rotation;\r\n  }\r\n\r\n  set rotation(euler) {\r\n    const rot = this.getNative().rotation,\r\n      native = this.getNative();\r\n\r\n    rot.copy(euler);\r\n\r\n    rot.onChange(() => {\r\n      if (this.__c_rot) {\r\n        this.quaternion.copy(new THREE.Quaternion().setFromEuler(rot));\r\n        native.__dirtyRotation = true;\r\n      }\r\n    });\r\n\r\n    return rot;\r\n  }\r\n\r\n  get scale() {\r\n    return this.getNative().scale;\r\n  }\r\n\r\n  set scale(vector3) {\r\n    this.getNative().scale = vector3;\r\n    return this.getNative().scale;\r\n  }\r\n\r\n  G_(params = {}) {\r\n    if (this.buildGeometry) {\r\n      this.getNative().geometry = this.buildGeometry(\r\n        this.updateParams({geometry: params})\r\n      );\r\n    }\r\n  }\r\n\r\n  M_(params = {}) {\r\n    this.getNative().material = this._initMaterial(\r\n      this.updateParams({material: params}).material\r\n    );\r\n  }\r\n\r\n  set M_color(val) {\r\n    this.updateParams({material: {color: val}});\r\n    this.getNative().material.color = new THREE.Color(val);\r\n  }\r\n\r\n  get M_color() {\r\n    return this.getNative().material.color;\r\n  }\r\n\r\n  proccessSoftbodyGeometry(geometry) {\r\n    geometry.rotateX(this.__params.rot.x);\r\n    geometry.rotateY(this.__params.rot.x);\r\n    geometry.rotateZ(this.__params.rot.x);\r\n\r\n    geometry.scale(\r\n      this.__params.scale.x,\r\n      this.__params.scale.y,\r\n      this.__params.scale.z\r\n    );\r\n\r\n    geometry.translate(\r\n      this.__params.pos.x,\r\n      this.__params.pos.y,\r\n      this.__params.pos.z\r\n    );\r\n  }\r\n\r\n  /* Access private data */\r\n\r\n  setNative(native) {\r\n    this._native = native;\r\n\r\n    this.position = native.position.clone();\r\n    this.quaternion = native.quaternion.clone();\r\n    this.rotation = native.rotation.clone();\r\n  }\r\n\r\n  setMaterial(material) {\r\n    this._native.material = material;\r\n    return this._native.material;\r\n  }\r\n\r\n  /* Physics */\r\n\r\n  setAngularVelocity(...args) {\r\n    return this.getNative().setAngularVelocity(...args);\r\n  }\r\n\r\n  setLinearVelocity(...args) {\r\n    return this.getNative().setLinearVelocity(...args);\r\n  }\r\n\r\n  applyCentralImpulse(...args) {\r\n    return this.getNative().applyCentralImpulse(...args);\r\n  }\r\n\r\n  applyImpulse(...args) {\r\n    return this.getNative().applyImpulse(...args);\r\n  }\r\n\r\n  applyTorque(...args) {\r\n    return this.getNative().applyTorque(...args);\r\n  }\r\n\r\n  applyCentralForce(...args) {\r\n    return this.getNative().applyCentralForce(...args);\r\n  }\r\n\r\n  applyForce(...args) {\r\n    return this.getNative().applyForce(...args);\r\n  }\r\n\r\n  getAngularVelocity(...args) {\r\n    return this.getNative().getAngularVelocity(...args);\r\n  }\r\n\r\n  getLinearVelocity(...args) {\r\n    return this.getNative().getLinearVelocity(...args);\r\n  }\r\n\r\n  setAngularFactor(...args) {\r\n    return this.getNative().setAngularFactor(...args);\r\n  }\r\n\r\n  setLinearFactor(...args) {\r\n    return this.getNative().setLinearFactor(...args);\r\n  }\r\n\r\n  setDamping(...args) {\r\n    return this.getNative().setDamping(...args);\r\n  }\r\n\r\n  setCcdMotionThreshold(...args) {\r\n    return this.getNative().setCcdMotionThreshold(...args);\r\n  }\r\n\r\n  setCcdSweptSphereRadius(...args) {\r\n    return this.getNative().setCcdSweptSphereRadius(...args);\r\n  }\r\n\r\n  /* Three.js */\r\n\r\n  raycast(...args) {\r\n    return this.getNative().lookAt(...args);\r\n  }\r\n\r\n  /* API */\r\n\r\n  follow(curve, time = 1000, loop) {\r\n    const gEnd = time;\r\n\r\n    let animation = new Loop(clock => {\r\n      const u = clock.getElapsedTime() * 1000 / gEnd,\r\n        vec1 = curve.getPoint(u % 1),\r\n        vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n      this.position.set(vec1.x, vec1.y, vec1.z);\r\n      this.getNative().lookAt(vec2);\r\n    });\r\n\r\n    this.getWorld().addLoop(animation);\r\n\r\n    animation.start();\r\n\r\n    if (loop) {\r\n      setInterval(() => {\r\n        animation.stop();\r\n\r\n        animation = new Loop(clock => {\r\n          const u = clock.getElapsedTime() * 1000 / gEnd,\r\n            vec1 = curve.getPoint(u % 1),\r\n            vec2 = curve.getPoint((u + 0.01) % 1);\r\n\r\n          this.position.set(vec1.x, vec1.y, vec1.z);\r\n          this.getNative().lookAt(vec2);\r\n        });\r\n\r\n        this.getWorld().addLoop(animation);\r\n\r\n        animation.start();\r\n      }, time);\r\n    } else {\r\n      setTimeout(() => {\r\n        animation.stop();\r\n        this.getWorld().removeLoop(animation);\r\n      }, time);\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  Shape\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Shape.js\n **/","import * as THREE from 'three';\r\nimport Stats from 'stats.js';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {PerspectiveCamera} from '../cameras/PerspectiveCamera';\r\nimport {Camera} from './Camera';\r\nimport {Shape} from './Shape';\r\nimport {Light} from './Light';\r\nimport {WHSObject} from './Object';\r\n\r\nclass World extends WHSObject {\r\n  /**\r\n   * Create a 3D world and define defaults.\r\n   *\r\n   * @param {object} params - The scene settings object.\r\n   * @return {World} A 3D world whs object.\r\n   */\r\n  constructor(params = {}) {\r\n    super({\r\n      stats: false,\r\n      autoresize: false,\r\n      softbody: false,\r\n\r\n      shadowmap: {\r\n        enabled: true,\r\n        type: THREE.PCFSoftShadowMap\r\n      },\r\n\r\n      helpers: {\r\n        grid: false,\r\n        axis: false\r\n      },\r\n\r\n      gravity: {\r\n        x: 0,\r\n        y: 0,\r\n        z: 0\r\n      },\r\n\r\n      camera: {\r\n        aspect: 75,\r\n        near: 1,\r\n        far: 1000,\r\n\r\n        x: 0,\r\n        y: 0,\r\n        z: 0\r\n      },\r\n\r\n      rWidth: 1, // Resolution(width).\r\n      rHeight: 1, // Resolution(height).\r\n\r\n      width: window.innerWidth, // Container(width).\r\n      height: window.innerHeight, // Container(height).\r\n\r\n      physics: {\r\n        fixedTimeStep: 1 / 60\r\n      },\r\n\r\n      fog: {\r\n        type: false,\r\n\r\n        density: 0.00025,\r\n        hex: 0x000000,\r\n        near: 1,\r\n        far: 1000\r\n      },\r\n\r\n      init: {\r\n        scene: true,\r\n        stats: true,\r\n        camera: true,\r\n        helpers: true,\r\n        renderer: true\r\n      },\r\n\r\n      background: {\r\n        color: 0x000000,\r\n        opacity: 1\r\n      },\r\n\r\n      renderer: {},\r\n      container: document.body\r\n    });\r\n\r\n    super.setParams(params);\r\n\r\n    const initParams = this.getParams().init;\r\n\r\n    // INIT.\r\n    this._initDOM();\r\n    if (initParams.scene) this._initScene();\r\n    if (initParams.scene && initParams.stats) this._initStats();\r\n\r\n    if (initParams.scene && initParams.camera) this._initCamera();\r\n    if (initParams.scene && initParams.renderer) this._initRenderer();\r\n    if (initParams.scene && initParams.helpers) this._initHelpers();\r\n\r\n    // NOTE: ==================== Autoresize. ======================\r\n    const scope = this;\r\n\r\n    if (this.getParams().autoresize) {\r\n      window.addEventListener('resize', () => {\r\n        scope.setSize(window.innerWidth, window.innerHeight);\r\n      });\r\n    }\r\n\r\n    scope.loops = [];\r\n\r\n    return scope;\r\n  }\r\n\r\n  /**\r\n   * Initialize THREE.js scene object.\r\n   */\r\n  _initScene() {\r\n    const params = this.getParams(),\r\n      scene = false\r\n      ? new Physijs.Scene(\r\n        {\r\n          fixedTimeStep: params.physics.fixedTimeStep\r\n        },\r\n        {\r\n          stats: params.stats,\r\n          world: this,\r\n          softbody: params.softbody\r\n        }\r\n      ) : new THREE.Scene();\r\n\r\n    if (false) {\r\n      scene.setGravity(\r\n        new THREE.Vector3(\r\n          params.gravity.x,\r\n          params.gravity.y,\r\n          params.gravity.z\r\n        )\r\n      );\r\n\r\n      this.simulate = true;\r\n      scene.addEventListener('update', () => {\r\n        if (this.simulate) scene.simulate(undefined, 1);\r\n      });\r\n\r\n      scene.simulate();\r\n    } else this.simulate = false;\r\n\r\n    if (params.fog.type === 'regular')\r\n      scene.fog = new THREE.Fog(params.fog.hex, params.fog.near, params.fog.far);\r\n    else if (params.fog.type === 'exp'\r\n      || params.fog.type === 'expodential')\r\n      scene.fog = new THREE.FogExp2(params.fog.hex, params.fog.density);\r\n\r\n    this.setScene(scene, false);\r\n\r\n    // Array for processing.\r\n    this.children = [];\r\n  }\r\n\r\n  addLoop(loop) {\r\n    this.loops.push(loop); // TODO: Process loops on start\r\n    // like: this.loops.forEach((elem) => elem.start());\r\n  }\r\n\r\n  removeLoop(loop) {\r\n    this.loops.filter((l) => l !== loop);\r\n  }\r\n\r\n  /**\r\n   * Initialize DOM structure for whitestorm.\r\n   */\r\n  _initDOM() {\r\n    const params = this.getParams();\r\n\r\n    params.container.style.margin = 0;\r\n    params.container.style.padding = 0;\r\n    params.container.style.position = 'relative';\r\n    params.container.style.overflow = 'hidden';\r\n\r\n    this._dom = document.createElement('div');\r\n    this._dom.className = 'whs';\r\n\r\n    params.container.appendChild(this._dom);\r\n\r\n    return this._dom;\r\n  }\r\n\r\n  /**\r\n   * Inititialize stats plugin.\r\n   */\r\n  _initStats() {\r\n    const params = this.getParams();\r\n\r\n    if (params.stats) {\r\n      this._stats = new Stats();\r\n\r\n      if (params.stats === 'fps')\r\n        this._stats.setMode(0);\r\n\r\n      else if (params.stats === 'ms')\r\n        this._stats.setMode(1);\r\n\r\n      else if (params.stats === 'mb')\r\n        this._stats.setMode(1);\r\n\r\n      else {\r\n        this._stats.setMode(0);\r\n        console.warn([this._stats], 'Please, apply stats mode [fps, ms, mb] .');\r\n      }\r\n\r\n      this._stats.domElement.style.position = 'absolute';\r\n      this._stats.domElement.style.left = '0px';\r\n      this._stats.domElement.style.bottom = '0px';\r\n\r\n      this._dom.appendChild(this._stats.domElement);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a camera and add it to scene.\r\n   */\r\n  _initCamera() {\r\n    const params = this.getParams();\r\n\r\n    this.setCamera(new PerspectiveCamera({\r\n      camera: {\r\n        fov: params.camera.aspect,\r\n        aspect: params.width / params.height,\r\n        near: params.camera.near,\r\n        far: params.camera.far\r\n      },\r\n\r\n      pos: {\r\n        x: params.camera.x,\r\n        y: params.camera.y,\r\n        z: params.camera.z\r\n      }\r\n    }));\r\n\r\n    this.getCamera().addTo(this);\r\n  }\r\n\r\n  /**\r\n   * Create a renderer and apply it's options.\r\n   */\r\n  _initRenderer() {\r\n    this.render = true;\r\n\r\n    // Renderer.\r\n    this.setRenderer(new THREE.WebGLRenderer(this.getParams().renderer));\r\n\r\n    const renderer = this.getRenderer();\r\n    renderer.setClearColor(this.getParams().background.color, this.getParams().background.opacity);\r\n\r\n    // Shadowmap.\r\n    renderer.shadowMap.enabled = this.getParams().shadowmap.enabled;\r\n    renderer.shadowMap.type = this.getParams().shadowmap.type;\r\n    renderer.shadowMap.cascade = true;\r\n\r\n    renderer.setSize(\r\n      Number(this.getParams().width * this.getParams().rWidth).toFixed(),\r\n      Number(this.getParams().height * this.getParams().rHeight).toFixed()\r\n    );\r\n\r\n    renderer.render(this.getScene(), this.getCamera().getNative());\r\n\r\n    this._dom.appendChild(renderer.domElement);\r\n\r\n    renderer.domElement.style.width = '100%';\r\n    renderer.domElement.style.height = '100%';\r\n  }\r\n\r\n  /**\r\n   * Add helpers to scene.\r\n   */\r\n  _initHelpers() {\r\n    const params = this.getParams(),\r\n      scene = this.getScene();\r\n\r\n    if (params.helpers.axis) {\r\n      scene.add(\r\n        new THREE.AxisHelper(\r\n          params.helpers.axis.size\r\n          ? params.helpers.axis.size\r\n          : 5\r\n        )\r\n      );\r\n    }\r\n\r\n    if (params.helpers.grid) {\r\n      scene.add(\r\n        new THREE.GridHelper(\r\n          params.helpers.grid.size\r\n          ? params.helpers.grid.size\r\n          : 10,\r\n          params.helpers.grid.step\r\n          ? params.helpers.grid.step\r\n          : 1,\r\n          params.helpers.grid.color1,\r\n          params.helpers.grid.color2\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start animation.\r\n   */\r\n  start() {\r\n    const clock = new THREE.Clock(),\r\n      _scope = this,\r\n      scene = _scope.getScene(),\r\n      cameraNative = _scope.getCamera().getNative(),\r\n      renderer = _scope.getRenderer();\r\n\r\n    window.requestAnimFrame = (() => {\r\n      return window.requestAnimationFrame\r\n        || window.webkitRequestAnimationFrame\r\n        || window.mozRequestAnimationFrame\r\n        || function (callback) {\r\n          window.setTimeout(callback, 1000 / 60);\r\n        };\r\n    })();\r\n\r\n    function reDraw(time) {\r\n      window.requestAnimFrame(reDraw);\r\n\r\n      // Init stats.\r\n      if (_scope._stats) _scope._stats.begin();\r\n\r\n      _scope._process(clock.getDelta());\r\n      if (_scope.controls) _scope._updateControls();\r\n\r\n      // Effects rendering.\r\n      if (_scope._composer && _scope.render) {\r\n        _scope._composer.reset();\r\n        _scope._composer.render(scene, cameraNative);\r\n        _scope._composer.pass(_scope._composer.stack);\r\n        _scope._composer.toScreen();\r\n      } else if (_scope.render) renderer.render(scene, cameraNative);\r\n\r\n      _scope._execLoops();\r\n\r\n      // End helper.\r\n      if (_scope._stats) _scope._stats.end();\r\n    }\r\n\r\n    this._update = reDraw;\r\n\r\n    _scope._update();\r\n  }\r\n\r\n  /**\r\n   * Execute all loops with a specific time.\r\n   *\r\n   * @params {number} time - The time value that will be passed to loops.\r\n   */\r\n  _execLoops() {\r\n    for (let i = 0; i < this.loops.length; i++) {\r\n      const e = this.loops[i];\r\n      if (e.enabled) e.execute(e.clock);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update controls time values.\r\n   */\r\n  _updateControls() {\r\n    this.controls.update(Date.now() - this.time);\r\n    this.time = Date.now();\r\n  }\r\n\r\n  /**\r\n   * Update morphs animations.\r\n   *\r\n   * @params {THREE.Clock} clock - The clock object, which.\r\n   */\r\n  _process(delta) {\r\n    for (let i = 0; i < this.children.length; i++)\r\n      if (this.children[i]._type === 'morph') this.children[i].getNative().mixer.update(delta);\r\n  }\r\n\r\n  /**\r\n   * This functon will scene properties when it's called.\r\n   */\r\n  setSize(width = 1, height = 1) {\r\n    this.getCamera().getNative().aspect = width / height;\r\n    this.getCamera().getNative().updateProjectionMatrix();\r\n\r\n    this.getRenderer().setSize(\r\n      Number(width * this.getParams().rWidth).toFixed(),\r\n      Number(height * this.getParams().rHeight).toFixed()\r\n    );\r\n  }\r\n\r\n  setScene(scene, import_three = true) {\r\n    this.scene = scene;\r\n\r\n    if (import_three) {\r\n      this.children = [];\r\n\r\n      const moveChildren = (object) => {\r\n        for (let i = 0, max = object.children.length; i < max; i++) {\r\n          const obj3D = object.children[i];\r\n          let WHSobj;\r\n\r\n          if (obj3D instanceof THREE.Light) WHSobj = new Light(obj3D);\r\n          else WHSobj = new Shape(obj3D);\r\n\r\n          WHSobj.addTo(this);\r\n\r\n          if (obj3D.children.length) moveChildren(obj3D, WHSobj);\r\n        }\r\n      }\r\n\r\n      moveChildren(scene, this);\r\n    }\r\n\r\n    return this.scene;\r\n  }\r\n\r\n  getScene() {\r\n    return this.scene;\r\n  }\r\n\r\n  setRenderer(renderer) {\r\n    this.renderer = renderer;\r\n    return this.renderer;\r\n  }\r\n\r\n  getRenderer() {\r\n    return this.renderer;\r\n  }\r\n\r\n  setControls(controls) {\r\n    const recieved = controls(this);\r\n\r\n    this.controls = recieved instanceof Array ? recieved[0] : recieved;\r\n\r\n    if (\r\n      recieved instanceof Array\r\n      && typeof recieved[1] === 'function'\r\n    ) recieved[1](this);\r\n\r\n    return this.controls;\r\n  }\r\n\r\n  /**\r\n   * Set a camera for rendering world.\r\n   *\r\n   * @params {WHS.Camera} camera - The camera to be rendered.\r\n   */\r\n  setCamera(camera) {\r\n    if (camera instanceof Camera)\r\n      this.camera = camera;\r\n    else\r\n      console.error('@WHS.World: camera in not an instance of WHS.Camera.');\r\n  }\r\n\r\n  getCamera() {\r\n    return this.camera;\r\n  }\r\n\r\n  /**\r\n   * Remove this shape from world.\r\n   *\r\n   * @return {WHS.Shape} - this.\r\n   */\r\n  remove(source) {\r\n    this.getScene().remove(source.getNative());\r\n\r\n    this.children.splice(this.children.indexOf(source), 1);\r\n    source.parent = null;\r\n\r\n    source.emit('remove');\r\n\r\n    if (WHS.debug) {\r\n      console.debug(\r\n        `@WHS.Shape: Shape ${source._type} was removed from world`,\r\n        [source]\r\n      );\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport {\r\n  World\r\n};\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/World.js\n **/","// stats.js - http://github.com/mrdoob/stats.js\nvar Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel(\"FPS\",\"#0ff\",\"#002\")),f=h(new Stats.Panel(\"MS\",\"#0f0\",\"#020\"));\nif(self.performance&&self.performance.memory)var t=h(new Stats.Panel(\"MB\",\"#f08\",\"#201\"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};\nStats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=f;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,\nv){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+\" \"+h+\" (\"+e(c)+\"-\"+e(g)+\")\",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};\"object\"===typeof module&&(module.exports=Stats);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/stats.js/build/stats.min.js\n ** module id = 109\n ** module chunks = 0\n **/","export * from './Loop';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extensions/index.js\n **/","export * from './controls/firstPersonControls';\r\nexport * from './controls/orbitControls';\r\nexport * from './api';\r\nexport * from './Curve';\r\nexport * from './Points';\r\nexport * from './Group';\r\nexport * from './Skybox';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/index.js\n **/","import * as THREE from 'three';\r\nimport {extend} from '../api';\r\n\r\nconst PI_2 = Math.PI / 2;\r\n\r\nexport function firstPersonControls(object, params = {}) {\r\n  return function (world) {\r\n    const target = extend(params, {\r\n      block: document.getElementById('blocker'),\r\n      speed: 1,\r\n      ypos: 1\r\n    });\r\n\r\n    let controls = new (function (camera, mesh, params) {\r\n      const velocityFactor = 1;\r\n      let runVelocity = 0.25;\r\n\r\n      mesh.setAngularFactor({x: 0, y: 0, z: 0});\r\n\r\n      /* Init */\r\n      let scope = this;\r\n      const player = mesh,\r\n        pitchObject = new THREE.Object3D();\r\n\r\n      pitchObject.add(camera.getNative());\r\n\r\n      const yawObject = new THREE.Object3D();\r\n\r\n      yawObject.position.y = params.ypos; // eyes are 2 meters above the ground\r\n      yawObject.add(pitchObject);\r\n\r\n      const quat = new THREE.Quaternion();\r\n\r\n      let canJump = false,\r\n        // Moves.\r\n        moveForward = false,\r\n        moveBackward = false,\r\n        moveLeft = false,\r\n        moveRight = false;\r\n\r\n      player.addEventListener('collision', (otherObject, v, r, contactNormal) => {\r\n        if (contactNormal.y < 0.5) // Use a \"good\" threshold value between 0 and 1 here!\r\n          canJump = true;\r\n      });\r\n\r\n      function onMouseMove(event) {\r\n        if (scope.enabled === false) return;\r\n\r\n        const movementX = typeof event.movementX === 'number'\r\n          ? event.movementX : typeof event.mozMovementX === 'number'\r\n          ? event.mozMovementX : typeof event.getMovementX === 'function'\r\n          ? event.getMovementX() : 0;\r\n        const movementY = typeof event.movementY === 'number'\r\n          ? event.movementY : typeof event.mozMovementY === 'number'\r\n          ? event.mozMovementY : typeof event.getMovementY === 'function'\r\n          ? event.getMovementY() : 0;\r\n\r\n        yawObject.rotation.y -= movementX * 0.002;\r\n        pitchObject.rotation.x -= movementY * 0.002;\r\n\r\n        pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));\r\n      }\r\n\r\n      function onKeyDown(event) {\r\n        switch (event.keyCode) {\r\n          case 38: // up\r\n          case 87: // w\r\n            moveForward = true;\r\n            break;\r\n\r\n          case 37: // left\r\n          case 65: // a\r\n            moveLeft = true;\r\n            break;\r\n\r\n          case 40: // down\r\n          case 83: // s\r\n            moveBackward = true;\r\n            break;\r\n\r\n          case 39: // right\r\n          case 68: // d\r\n            moveRight = true;\r\n            break;\r\n\r\n          case 32: // space\r\n            if (canJump === true) {\r\n              player.applyCentralImpulse({x: 0, y: 300, z: 0});\r\n            }\r\n            canJump = false;\r\n            break;\r\n\r\n          case 16: // shift\r\n            runVelocity = 0.5;\r\n            break;\r\n\r\n          default:\r\n        }\r\n      }\r\n\r\n      function onKeyUp(event) {\r\n        switch (event.keyCode) {\r\n          case 38: // up\r\n          case 87: // w\r\n            moveForward = false;\r\n            break;\r\n\r\n          case 37: // left\r\n          case 65: // a\r\n            moveLeft = false;\r\n            break;\r\n\r\n          case 40: // down\r\n          case 83: // a\r\n            moveBackward = false;\r\n            break;\r\n\r\n          case 39: // right\r\n          case 68: // d\r\n            moveRight = false;\r\n            break;\r\n\r\n          case 16: // shift\r\n            runVelocity = 0.25;\r\n            break;\r\n\r\n          default:\r\n        }\r\n      }\r\n\r\n      document.body.addEventListener('mousemove', onMouseMove, false);\r\n      document.body.addEventListener('keydown', onKeyDown, false);\r\n      document.body.addEventListener('keyup', onKeyUp, false);\r\n\r\n      this.enabled = false;\r\n\r\n      this.getObject = () => {\r\n        return yawObject;\r\n      };\r\n\r\n      this.getDirection = (targetVec) => {\r\n        targetVec.set(0, 0, -1);\r\n        quat.multiplyVector3(targetVec);\r\n      };\r\n\r\n      // Moves the camera to the Cannon.js object position\r\n      // and adds velocity to the object if the run key is down.\r\n      const inputVelocity = new THREE.Vector3(),\r\n        euler = new THREE.Euler();\r\n\r\n      this.update = (delta) => {\r\n        if (scope.enabled === false) return;\r\n\r\n        delta = delta || 0.5;\r\n        delta = Math.min(delta, 0.5);\r\n\r\n        inputVelocity.set(0, 0, 0);\r\n\r\n        const speed = velocityFactor * delta * params.speed * runVelocity;\r\n\r\n        if (moveForward) inputVelocity.z = -speed;\r\n        if (moveBackward) inputVelocity.z = speed;\r\n        if (moveLeft) inputVelocity.x = -speed;\r\n        if (moveRight) inputVelocity.x = speed;\r\n\r\n        // Convert velocity to world coordinates\r\n        euler.x = pitchObject.rotation.x;\r\n        euler.y = yawObject.rotation.y;\r\n        euler.order = 'XYZ';\r\n\r\n        quat.setFromEuler(euler);\r\n\r\n        inputVelocity.applyQuaternion(quat);\r\n\r\n        player.applyCentralImpulse({x: inputVelocity.x * 10, y: 0, z: inputVelocity.z * 10});\r\n        player.setAngularVelocity({x: inputVelocity.z * 10, y: 0, z: -inputVelocity.x * 10});\r\n        player.setAngularFactor({x: 0, y: 0, z: 0});\r\n\r\n        yawObject.position.copy(player.position);\r\n      };\r\n    })(world.getCamera(), object.getNative(), target);\r\n\r\n    if ('pointerLockElement' in document\r\n        || 'mozPointerLockElement' in document\r\n        || 'webkitPointerLockElement' in document) {\r\n      const element = document.body;\r\n\r\n      world.pointerlockchange = function () {\r\n        if (document.pointerLockElement === element\r\n          || document.mozPointerLockElement === element\r\n          || document.webkitPointerLockElement === element) {\r\n          controls.enabled = true;\r\n          target.block.style.display = 'none';\r\n        } else {\r\n          controls.enabled = false;\r\n          target.block.style.display = 'block';\r\n        }\r\n      };\r\n\r\n      document.addEventListener('pointerlockchange', world.pointerlockchange, false);\r\n      document.addEventListener('mozpointerlockchange', world.pointerlockchange, false);\r\n      document.addEventListener('webkitpointerlockchange', world.pointerlockchange, false);\r\n\r\n      world.pointerlockerror = function () {\r\n        console.warn('Pointer lock error.');\r\n      };\r\n\r\n      document.addEventListener('pointerlockerror', world.pointerlockerror, false);\r\n      document.addEventListener('mozpointerlockerror', world.pointerlockerror, false);\r\n      document.addEventListener('webkitpointerlockerror', world.pointerlockerror, false);\r\n\r\n      target.block.addEventListener('click', () => {\r\n        element.requestPointerLock = element.requestPointerLock\r\n          || element.mozRequestPointerLock\r\n          || element.webkitRequestPointerLock;\r\n\r\n        element.requestFullscreen = element.requestFullscreen\r\n          || element.mozRequestFullscreen\r\n          || element.mozRequestFullScreen\r\n          || element.webkitRequestFullscreen;\r\n\r\n        if (/Firefox/i.test(navigator.userAgent)) {\r\n          const fullscreenchange = () => {\r\n            if (document.fullscreenElement === element\r\n              || document.mozFullscreenElement === element\r\n              || document.mozFullScreenElement === element) {\r\n              document.removeEventListener('fullscreenchange', fullscreenchange);\r\n              document.removeEventListener('mozfullscreenchange', fullscreenchange);\r\n\r\n              element.requestPointerLock();\r\n            }\r\n          };\r\n\r\n          document.addEventListener('fullscreenchange', fullscreenchange, false);\r\n          document.addEventListener('mozfullscreenchange', fullscreenchange, false);\r\n\r\n          element.requestFullscreen();\r\n        } else element.requestPointerLock();\r\n      });\r\n    } else console.warn('Your browser does not support the PointerLock WHS.API.');\r\n\r\n    function callback(world) {\r\n      world.getScene().add(world.controls.getObject());\r\n    }\r\n\r\n    return [controls, callback];\r\n  };\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/controls/firstPersonControls.js\n **/","import * as THREE from 'three';\r\nimport getOrbitControls from 'three-orbit-controls';\r\n\r\nconst ThreeOrbitControls = getOrbitControls(THREE);\r\n\r\nexport function orbitControls(object) {\r\n  return function (world) {\r\n    const controls = new ThreeOrbitControls(\r\n      world.getCamera().getNative(),\r\n      world.getRenderer().domElement\r\n    );\r\n\r\n    if (object && object.__whsobject) {\r\n      const target = object ? object.mesh.position\r\n        : new THREE.Vector3(0, 0, 0);\r\n\r\n      controls.target = target;\r\n    } else if (object instanceof THREE.Vector3)\r\n      controls.target.copy(object);\r\n\r\n    return controls;\r\n  };\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/controls/orbitControls.js\n **/","module.exports = function(THREE) {\n\tvar MOUSE = THREE.MOUSE\n\tif (!MOUSE)\n\t\tMOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\t/*global THREE, console */\n\n\tfunction OrbitConstraint ( object ) {\n\n\t\tthis.object = object;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\t// and where it pans with respect to.\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// Limits to how far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// Limits to how far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t////////////\n\t\t// internals\n\n\t\tvar scope = this;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// Current position in spherical coordinate system.\n\t\tvar theta;\n\t\tvar phi;\n\n\t\t// Pending changes\n\t\tvar phiDelta = 0;\n\t\tvar thetaDelta = 0;\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\t// API\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn theta;\n\n\t\t};\n\n\t\tthis.rotateLeft = function ( angle ) {\n\n\t\t\tthetaDelta -= angle;\n\n\t\t};\n\n\t\tthis.rotateUp = function ( angle ) {\n\n\t\t\tphiDelta -= angle;\n\n\t\t};\n\n\t\t// pass in distance in world space to move left\n\t\tthis.panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft ( distance ) {\n\n\t\t\t\tvar te = this.object.matrix.elements;\n\n\t\t\t\t// get X column of matrix\n\t\t\t\tv.set( te[ 0 ], te[ 1 ], te[ 2 ] );\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// pass in distance in world space to move up\n\t\tthis.panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp ( distance ) {\n\n\t\t\t\tvar te = this.object.matrix.elements;\n\n\t\t\t\t// get Y column of matrix\n\t\t\t\tv.set( te[ 4 ], te[ 5 ], te[ 6 ] );\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// pass in x,y of change desired in pixel space,\n\t\t// right and down are positive\n\t\tthis.pan = function ( deltaX, deltaY, screenWidth, screenHeight ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\tvar offset = position.clone().sub( scope.target );\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\tscope.panLeft( 2 * deltaX * targetDistance / screenHeight );\n\t\t\t\tscope.panUp( 2 * deltaY * targetDistance / screenHeight );\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t// orthographic\n\t\t\t\tscope.panLeft( deltaX * ( scope.object.right - scope.object.left ) / screenWidth );\n\t\t\t\tscope.panUp( deltaY * ( scope.object.top - scope.object.bottom ) / screenHeight );\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic or perspective\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dollyIn = function ( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dollyOut = function ( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( this.minZoom, Math.min( this.maxZoom, this.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function () {\n\n\t\t\t\tvar position = this.object.position;\n\n\t\t\t\toffset.copy( position ).sub( this.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\n\t\t\t\ttheta = Math.atan2( offset.x, offset.z );\n\n\t\t\t\t// angle from y-axis\n\n\t\t\t\tphi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );\n\n\t\t\t\ttheta += thetaDelta;\n\t\t\t\tphi += phiDelta;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\ttheta = Math.max( this.minAzimuthAngle, Math.min( this.maxAzimuthAngle, theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tphi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );\n\n\t\t\t\t// restrict phi to be betwee EPS and PI-EPS\n\t\t\t\tphi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );\n\n\t\t\t\tvar radius = offset.length() * scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tradius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tthis.target.add( panOffset );\n\n\t\t\t\toffset.x = radius * Math.sin( phi ) * Math.sin( theta );\n\t\t\t\toffset.y = radius * Math.cos( phi );\n\t\t\t\toffset.z = radius * Math.sin( phi ) * Math.cos( theta );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( this.target ).add( offset );\n\n\t\t\t\tthis.object.lookAt( this.target );\n\n\t\t\t\tif ( this.enableDamping === true ) {\n\n\t\t\t\t\tthetaDelta *= ( 1 - this.dampingFactor );\n\t\t\t\t\tphiDelta *= ( 1 - this.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthetaDelta = 0;\n\t\t\t\t\tphiDelta = 0;\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\t lastPosition.distanceToSquared( this.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( this.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tlastPosition.copy( this.object.position );\n\t\t\t\t\tlastQuaternion.copy( this.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t};\n\n\n\t// This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n\t// the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n\t// supported.\n\t//\n\t//    Orbit - left mouse / touch: one finger move\n\t//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n\t//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls ( object, domElement ) {\n\n\t\tvar constraint = new OrbitConstraint( object );\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// API\n\n\t\tObject.defineProperty( this, 'constraint', {\n\n\t\t\tget: function() {\n\n\t\t\t\treturn constraint;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn constraint.getPolarAngle();\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn constraint.getAzimuthalAngle();\n\n\t\t};\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// center is old, deprecated; use \"target\" instead\n\t\tthis.center = this.target;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for\n\t\t// backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t////////////\n\t\t// internals\n\n\t\tvar scope = this;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\t// for reset\n\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t// events\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\t// pass in x,y of change desired in pixel space,\n\t\t// right and down are positive\n\t\tfunction pan( deltaX, deltaY ) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tconstraint.pan( deltaX, deltaY, element.clientWidth, element.clientHeight );\n\n\t\t}\n\n\t\tthis.update = function () {\n\n\t\t\tif ( this.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\tconstraint.rotateLeft( getAutoRotationAngle() );\n\n\t\t\t}\n\n\t\t\tif ( constraint.update() === true ) {\n\n\t\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tstate = STATE.NONE;\n\n\t\t\tthis.target.copy( this.target0 );\n\t\t\tthis.object.position.copy( this.position0 );\n\t\t\tthis.object.zoom = this.zoom0;\n\n\t\t\tthis.object.updateProjectionMatrix();\n\t\t\tthis.dispatchEvent( changeEvent );\n\n\t\t\tthis.update();\n\n\t\t};\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t\t}\n\n\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\tpanEnd.set( event.clientX, event.clientY );\n\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) scope.update();\n\n\t\t}\n\n\t\tfunction onMouseUp( /* event */ ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tvar delta = 0;\n\n\t\t\tif ( event.wheelDelta !== undefined ) {\n\n\t\t\t\t// WebKit / Opera / Explorer 9\n\n\t\t\t\tdelta = event.wheelDelta;\n\n\t\t\t} else if ( event.detail !== undefined ) {\n\n\t\t\t\t// Firefox\n\n\t\t\t\tdelta = - event.detail;\n\n\t\t\t}\n\n\t\t\tif ( delta > 0 ) {\n\n\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t} else if ( delta < 0 ) {\n\n\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\t\t\tscope.dispatchEvent( startEvent );\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction touchstart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\t\tdollyStart.set( 0, distance );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) scope.dispatchEvent( startEvent );\n\n\t\t}\n\n\t\tfunction touchmove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return;\n\n\t\t\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\t\t\tconstraint.rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\t\t\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\t\t\tconstraint.rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return;\n\n\t\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\t\tdollyEnd.set( 0, distance );\n\t\t\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\t\t\tconstraint.dollyOut( getZoomScale() );\n\n\t\t\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\t\t\tconstraint.dollyIn( getZoomScale() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return;\n\n\t\t\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\t\t\tpanStart.copy( panEnd );\n\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction touchend( /* event */ ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tscope.dispatchEvent( endEvent );\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction contextmenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\tthis.dispose = function() {\n\n\t\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\t\tthis.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tthis.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );\n\t\t\tthis.domElement.removeEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\n\t\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\n\t\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\n\t\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t}\n\n\t\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\n\t\tthis.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tthis.domElement.addEventListener( 'mousewheel', onMouseWheel, false );\n\t\tthis.domElement.addEventListener( 'MozMousePixelScroll', onMouseWheel, false ); // firefox\n\n\t\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\t\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\t\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tobject: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.object;\n\n\t\t\t}\n\n\t\t},\n\n\t\ttarget: {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.target;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: target is now immutable. Use target.set() instead.' );\n\t\t\t\tthis.constraint.target.copy( value );\n\n\t\t\t}\n\n\t\t},\n\n\t\tminDistance : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minDistance;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minDistance = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxDistance : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxDistance;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxDistance = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminZoom : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minZoom = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxZoom : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxZoom = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminPolarAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minPolarAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minPolarAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxPolarAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxPolarAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxPolarAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tminAzimuthAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.minAzimuthAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.minAzimuthAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmaxAzimuthAngle : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.maxAzimuthAngle;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.maxAzimuthAngle = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tenableDamping : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.enableDamping = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.constraint.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.constraint.dampingFactor = value;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.constraint.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.constraint.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.constraint.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.constraint.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three-orbit-controls/index.js\n ** module id = 114\n ** module chunks = 0\n **/","import * as THREE from 'three';\r\n\r\nimport {loadMaterial} from './api';\r\nimport {WHSObject} from '../core/Object';\r\n\r\nclass Curve extends WHSObject {\r\n  /**\r\n   * Create curve.\r\n   *\r\n   * Todo\r\n   */\r\n  constructor(params) {\r\n    super({\r\n      curve: false,\r\n      points: 50\r\n    });\r\n\r\n    super.setParams(params);\r\n\r\n    const geometry = new THREE.Geometry();\r\n    geometry.vertices = params.curve.getPoints(params.points);\r\n\r\n    const curve = new THREE.Line(\r\n      geometry,\r\n      loadMaterial(params.material)._material\r\n    );\r\n\r\n    this.setNative(curve);\r\n\r\n    const scope = Object.assign(this, {\r\n      _type: 'curve'\r\n    });\r\n\r\n    scope.setNative(param.curve);\r\n\r\n    return scope;\r\n  }\r\n\r\n    /**\r\n     * Add curve to scene.\r\n     */\r\n  addTo(parent) {\r\n    const _scope = this;\r\n    _scope.parent = parent;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        _scope.parent.getScene().add(_scope.getNative());\r\n        _scope.parent.children.push(_scope);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      } finally {\r\n        if (defaults.debug) {\r\n          console.debug(\r\n            `@WHS.Curve: Curve ${_scope._type} was added to world.`,\r\n            [_scope, _scope.parent]\r\n          );\r\n        }\r\n\r\n        resolve(_scope);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clone curve.\r\n   */\r\n  clone() {\r\n    return new Curve(this.__params).copy(this);\r\n  }\r\n\r\n  /**\r\n   * Copy curve.\r\n   *\r\n   * @param {WHS.Curve} source - Source object, that will be applied to this.\r\n   */\r\n  copy(source) {\r\n    this.setNative(source.getNative().clone());\r\n\r\n    this._type = source._type;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove this curve from world.\r\n   *\r\n   * @return {WHS.Curve} - this.\r\n   */\r\n  remove() {\r\n    this.parent.getScene().remove(this.getNative());\r\n\r\n    this.parent.children.splice(this.parent.children.indexOf(this), 1);\r\n    this.parent = null;\r\n\r\n    this.emit('remove');\r\n\r\n    if (defaults.debug) {\r\n      console.debug(\r\n        `@WHS.Curve: Curve ${this._type} was removed from world`,\r\n        [_scope]\r\n      );\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport {\r\n  Curve\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/Curve.js\n **/","import * as THREE from 'three';\r\n\r\nimport {loadMaterial} from './api';\r\nimport {defaults} from '../utils/defaults';\r\nimport {WHSObject} from '../core/Object';\r\n\r\nclass Points extends WHSObject {\r\n  /**\r\n   * Create points.\r\n   *\r\n   * Todo\r\n   */\r\n  constructor(params) {\r\n    super({\r\n      geometry: false,\r\n\r\n      material: {\r\n        kind: 'points'\r\n      }\r\n    });\r\n\r\n    super.setParams(params);\r\n\r\n    const _verts = params.geometry.points;\r\n\r\n    const points = new THREE.Points(\r\n      params.geometry,\r\n      loadMaterial(params.material)\r\n    );\r\n\r\n    this.setNative(points);\r\n\r\n    const scope = Object.assign(this, {\r\n      _type: 'points'\r\n    });\r\n\r\n    return scope;\r\n  }\r\n\r\n    /**\r\n     * Add curve to scene.\r\n     */\r\n  addTo(parent) {\r\n    const _scope = this;\r\n    _scope.parent = parent;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        _scope.parent.getScene().add(_scope.getNative());\r\n        _scope.parent.children.push(_scope);\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        reject();\r\n      } finally {\r\n        if (defaults.debug) {\r\n          console.debug(\r\n            `@WHS.Curve: Curve ${_scope._type} was added to world.`,\r\n            [_scope, _scope.parent]\r\n          );\r\n        }\r\n\r\n        resolve(_scope);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clone curve.\r\n   */\r\n  clone() {\r\n    return new Points(this.__params).copy(this);\r\n  }\r\n\r\n  /**\r\n   * Copy curve.\r\n   *\r\n   * @param {WHS.Points} source - Source object, that will be applied to this.\r\n   */\r\n  copy(source) {\r\n    this.setNative(source.getNative().clone());\r\n\r\n    this._type = source._type;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Remove this curve from world.\r\n   *\r\n   * @return {WHS.Points} - this.\r\n   */\r\n  remove() {\r\n    this.parent.getScene().remove(this.getNative());\r\n\r\n    this.parent.children.splice(this.parent.children.indexOf(this), 1);\r\n    this.parent = null;\r\n\r\n    this.emit('remove');\r\n\r\n    if (defaults.debug) {\r\n      console.debug(\r\n        `@WHS.Points: Curve ${this._type} was removed from world`,\r\n        [_scope]\r\n      );\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\nexport {\r\n  Points\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/Points.js\n **/","import * as THREE from 'three';\r\nimport {Shape} from '../core/Shape';\r\nimport {WHSObject} from '../core/Object';\r\n\r\nclass Group extends Shape {\r\n  constructor(...objects) {\r\n    super({}, 'group');\r\n\r\n    super.setNative(new THREE.Object3D());\r\n    super.wrap();\r\n\r\n    for (let i = 0; i < objects.length; i++) {\r\n    \tconst obj = objects[i];\r\n\r\n    \tif (obj instanceof WHSObject) obj.addTo(this);\r\n    \telse if (obj instanceof THREE.Object3D) this.getNative().add(obj);\r\n    }\r\n  }\r\n}\r\n\r\nexport {\r\n  Group\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/Group.js\n **/","import * as THREE from 'three';\r\n\r\nimport {extend, texture} from '../extras/api';\r\nimport {Shape} from '../core/Shape';\r\n\r\nclass Skybox extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'skybox');\r\n\r\n    extend(params, {\r\n      skyType: 'box',\r\n      imgSuffix: '.png',\r\n      radius: 10,\r\n      fog: true,\r\n      path: ''\r\n    });\r\n\r\n    let skyGeometry, skyMat;\r\n\r\n    switch (params.skyType) {\r\n      case 'box': {\r\n        const directions = ['xpos', 'xneg', 'ypos', 'yneg', 'zpos', 'zneg'],\r\n          matArray = [];\r\n\r\n        skyGeometry = new THREE.CubeGeometry(params.radius, params.radius, params.radius);\r\n\r\n        for (let i = 0; i < 6; i++) {\r\n          matArray.push(new MeshBasicMaterial({\r\n            map: texture(params.path + directions[i] + params.imgSuffix, false),\r\n            side: THREE.BackSide,\r\n            fog: params.fog\r\n          }));\r\n        }\r\n\r\n        skyMat = new THREE.MeshFaceMaterial(matArray);\r\n\r\n        break;\r\n      }\r\n      case 'sphere': {\r\n        skyGeometry = new THREE.SphereGeometry(params.radius / 2, 60, 40);\r\n        skyMat = new THREE.MeshBasicMaterial({\r\n          map: texture(params.path + params.imgSuffix, false),\r\n          side: THREE.BackSide,\r\n          fog: params.fog\r\n        });\r\n\r\n        break;\r\n      }\r\n      default:\r\n    }\r\n\r\n    const mesh = new THREE.Mesh(skyGeometry, skyMat);\r\n    mesh.renderDepth = 1000.0;\r\n\r\n    super.setNative(mesh);\r\n    super.wrap();\r\n  }\r\n}\r\n\r\nexport {\r\n  Skybox\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/extras/Skybox.js\n **/","export * from './AmbientLight';\r\nexport * from './DirectionalLight';\r\nexport * from './HemisphereLight';\r\nexport * from './NormalLight';\r\nexport * from './PointLight';\r\nexport * from './SpotLight';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/index.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass AmbientLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'ambientlight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap('no-shadows');\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.AmbientLight(\r\n        params.light.color,\r\n        params.light.intensity\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  AmbientLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/AmbientLight.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass DirectionalLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'directionallight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap();\r\n    super.wrapShadow();\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.DirectionalLight(\r\n        params.light.color,\r\n        params.light.intensity\r\n      ));\r\n\r\n      if (params.helper) {\r\n        _scope.helper = new THREE.DirectionalLightHelper(\r\n          _scope.light,\r\n          params.helper.size ? params.helper.size : 0\r\n        );\r\n      }\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  DirectionalLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/DirectionalLight.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass HemisphereLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'hemispherelight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap();\r\n    super.wrapShadow();\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.HemisphereLight(\r\n        params.light.skyColor,\r\n        params.light.groundColor,\r\n        params.light.intensity\r\n      ));\r\n\r\n      if (params.helper) {\r\n        _scope.helper = new THREE.HemisphereLightHelper(\r\n          _scope.light,\r\n          params.helper.size ? params.helper.size : 0\r\n        );\r\n      }\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  HemisphereLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/HemisphereLight.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass NormalLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'normallight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap();\r\n    super.wrapShadow();\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.Light(\r\n        params.light.color\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  NormalLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/NormalLight.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass PointLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'pointlight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap();\r\n    super.wrapShadow();\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.PointLight(\r\n        params.light.color,\r\n        params.light.intensity,\r\n        params.light.distance,\r\n        params.light.decay\r\n      ));\r\n\r\n      if (params.helper) {\r\n        _scope.helper = new THREE.PointLightHelper(\r\n          _scope.light,\r\n          params.helper.size ? params.helper.size : 0\r\n        );\r\n      }\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  PointLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/PointLight.js\n **/","import * as THREE from 'three';\r\nimport {Light} from '../core/Light';\r\n\r\nclass SpotLight extends Light {\r\n  constructor(params = {}) {\r\n    super(params, 'spotlight');\r\n\r\n    this.build(params);\r\n\r\n    super.wrap();\r\n    super.wrapShadow();\r\n  }\r\n\r\n  build(params = {}) {\r\n    const _scope = this;\r\n\r\n    return new Promise((resolve) => {\r\n      _scope.setNative(new THREE.SpotLight(\r\n        params.light.color,\r\n        params.light.intensity,\r\n        params.light.distance,\r\n        params.light.angle,\r\n        params.light.exponent,\r\n        params.light.decay\r\n      ));\r\n\r\n      if (params.helper)\r\n        _scope.helper = new THREE.SpotLightHelper(_scope.light);\r\n\r\n      resolve();\r\n    });\r\n  }\r\n}\r\n\r\nexport {\r\n  SpotLight\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lights/SpotLight.js\n **/","export * from './Box';\r\nexport * from './Cylinder';\r\nexport * from './Dodecahedron';\r\nexport * from './Extrude';\r\nexport * from './Icosahedron';\r\nexport * from './Lathe';\r\nexport * from './Model';\r\nexport * from './Morph';\r\nexport * from './Octahedron';\r\nexport * from './Parametric';\r\nexport * from './Plane';\r\nexport * from './Polyhedron';\r\nexport * from './Ring';\r\nexport * from './Shape2D';\r\nexport * from './Sphere';\r\nexport * from './Tetrahedron';\r\nexport * from './Text';\r\nexport * from './Torus';\r\nexport * from './Torusknot';\r\nexport * from './Tube';\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/index.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Box extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'box');\r\n\r\n    extend(params.geometry, {\r\n      width: 1,\r\n      height: 1,\r\n      depth: 1\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.BoxMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.BoxBufferGeometry : THREE.BoxGeometry;\r\n\r\n    const geometry = new GConstruct(\r\n      params.geometry.width,\r\n      params.geometry.height,\r\n      params.geometry.depth\r\n    );\r\n\r\n    if (params.softbody) this.proccessSoftbodyGeometry(geometry);\r\n\r\n    return geometry;\r\n  }\r\n\r\n  set G_width(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {width: val}}));\r\n  }\r\n\r\n  get G_width() {\r\n    return this.native.geometry.parameters.width;\r\n  }\r\n\r\n  set G_height(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {height: val}}));\r\n  }\r\n\r\n  get G_height() {\r\n    return this.native.geometry.parameters.height;\r\n  }\r\n\r\n  set G_depth(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {depth: val}}));\r\n  }\r\n\r\n  get G_depth() {\r\n    return this.native.geometry.parameters.depth;\r\n  }\r\n\r\n  clone() {\r\n    return this.getParams().softbody ? new Box(this.getParams()) : new Box({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Box\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Box.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Cylinder extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'cylinder');\r\n\r\n    extend(params.geometry, {\r\n      radiusTop: 0,\r\n      radiusBottom: 1,\r\n      height: 1,\r\n      radiusSegments: 32\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.CylinderMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.CylinderBufferGeometry : THREE.CylinderGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radiusTop,\r\n      params.geometry.radiusBottom,\r\n      params.geometry.height,\r\n      params.geometry.radiusSegments\r\n    );\r\n  }\r\n\r\n  set G_radiusTop(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radiusTop: val}}));\r\n  }\r\n\r\n  get G_radiusTop() {\r\n    return this.native.geometry.parameters.radiusTop;\r\n  }\r\n\r\n  set G_radiusBottom(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radiusBottom: val}}));\r\n  }\r\n\r\n  get G_radiusBottom() {\r\n    return this.native.geometry.parameters.radiusBottom;\r\n  }\r\n\r\n  set G_height(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {height: val}}));\r\n  }\r\n\r\n  get G_height() {\r\n    return this.native.geometry.parameters.height;\r\n  }\r\n\r\n  set G_radiusSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radiusSegments: val}}));\r\n  }\r\n\r\n  get G_radiusSegments() {\r\n    return this.native.geometry.parameters.radiusSegments;\r\n  }\r\n\r\n  clone() {\r\n    return new Cylinder({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Cylinder\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Cylinder.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Dodecahedron extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'dodecahedron');\r\n\r\n    extend(params.geometry, {\r\n      radius: 1,\r\n      detail: 0\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.DodecahedronBufferGeometry : THREE.DodecahedronGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.detail\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_detail(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {detail: val}}));\r\n  }\r\n\r\n  get G_detail() {\r\n    return this.native.geometry.parameters.detail;\r\n  }\r\n\r\n  clone() {\r\n    return new Dodecahedron({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Dodecahedron\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Dodecahedron.js\n **/","import * as THREE from 'three';\r\nimport Physijs  from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Extrude extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'extrude');\r\n\r\n    extend(params.geometry, {\r\n      shapes: [],\r\n      options: {}\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.ExtrudeBufferGeometry : THREE.ExtrudeGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.shapes,\r\n      params.geometry.options\r\n    );\r\n  }\r\n\r\n  set G_shapes(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {shapes: val}}));\r\n  }\r\n\r\n  get G_shapes() {\r\n    return this.native.geometry.parameters.shapes;\r\n  }\r\n\r\n  set G_options(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {options: val}}));\r\n  }\r\n\r\n  get G_options() {\r\n    return this.native.geometry.parameters.options;\r\n  }\r\n\r\n  clone() {\r\n    return new Extrude({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Extrude\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Extrude.js\n **/","import * as THREE from 'three';\r\nimport Physijs  from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Icosahedron extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'icosahedron');\r\n\r\n    extend(params.geometry, {\r\n      radius: 1,\r\n      detail: 0\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.IcosahedronBufferGeometry : THREE.IcosahedronGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.detail\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_detail(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {detail: val}}));\r\n  }\r\n\r\n  get G_detail() {\r\n    return this.native.geometry.parameters.detail;\r\n  }\r\n\r\n  clone() {\r\n    return new Icosahderon({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Icosahedron\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Icosahedron.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Lathe extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'lathe');\r\n\r\n    extend(params.geometry, {\r\n      points: []\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.LatheBufferGeometry : THREE.LatheGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.points\r\n    );\r\n  }\r\n\r\n  set G_points(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {points: val}}));\r\n  }\r\n\r\n  get G_points() {\r\n    return this.native.geometry.parameters.points;\r\n  }\r\n\r\n  clone() {\r\n    return new Lathe({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Lathe\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Lathe.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend, loadMaterial, JSONLoader} from '../extras/api';\r\n\r\nclass Model extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'model');\r\n\r\n    extend(params.geometry, {\r\n      path: '',\r\n      physics: '',\r\n      loader: JSONLoader\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('wait');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    let Mesh;\r\n\r\n    if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh\r\n\r\n    const promise = new Promise((resolve) => {\r\n      const pGeometry = params.geometry;\r\n      const Loader = pGeometry.loader\r\n\r\n      Loader.load(pGeometry.path, (data, materials) => {\r\n        if (pGeometry.physics) {\r\n          Loader.load(pGeometry.physics, data2 => {\r\n            let material;\r\n\r\n            if (params.material.useVertexColors) {\r\n              material = loadMaterial(\r\n                extend(params.material, {\r\n                  morphTargets: true,\r\n                  vertexColors: THREE.FaceColors\r\n                })\r\n              );\r\n            } else if (!materials || params.material.useCustomMaterial) {\r\n              material = loadMaterial(params.material);\r\n            } else material = new THREE.MultiMaterial(materials);\r\n\r\n            data.computeFaceNormals();\r\n            data.computeVertexNormals();\r\n\r\n            this.setNative(new Mesh(\r\n              data,\r\n              material,\r\n              this.getParams(),\r\n              data2\r\n            ));\r\n\r\n            resolve();\r\n          });\r\n        } else {\r\n          let material;\r\n\r\n          if (params.material.useVertexColors) {\r\n            material = loadMaterial(\r\n              extend(params.material, {\r\n                morphTargets: true,\r\n                vertexColors: THREE.FaceColors\r\n              })\r\n            );\r\n          } else if (!materials || params.material.useCustomMaterial) {\r\n            material = loadMaterial(params.material);\r\n          } else material = new THREE.MultiMaterial(materials);\r\n\r\n          data.computeFaceNormals();\r\n          data.computeVertexNormals();\r\n\r\n          console.log(this.getParams());\r\n\r\n          this.setNative(new Mesh(\r\n            data,\r\n            material,\r\n            this.getParams()\r\n          ));\r\n\r\n          resolve();\r\n        }\r\n      });\r\n    });\r\n\r\n    super.wait(promise);\r\n\r\n    return promise;\r\n  }\r\n\r\n  clone() {\r\n    return new Model({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Model\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Model.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend, loadMaterial} from '../extras/api';\r\nimport {JSONLoader} from '../utils/loaders';\r\n\r\nclass Morph extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'morph');\r\n\r\n    extend(params.geometry, {\r\n      path: '',\r\n      loader: JSONLoader\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('wait');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const promise = new Promise((resolve) => {\r\n      const Loader = params.geometry.loader;\r\n\r\n      Loader.load(params.geometry.path, (data, materials) => {\r\n        let material;\r\n        if (params.material.useVertexColors) {\r\n          material = loadMaterial(\r\n            extend(params.material, {\r\n              morphTargets: true,\r\n              vertexColors: THREE.FaceColors\r\n            })\r\n          );\r\n        } else if (!materials || params.material.useCustomMaterial) {\r\n          material = loadMaterial(params.material);\r\n        } else material = new THREE.MultiMaterial(materials);\r\n\r\n        data.computeFaceNormals();\r\n        data.computeVertexNormals();\r\n\r\n        // Visualization.\r\n        const mesh = new THREE.Mesh(data, material);\r\n        mesh.speed = params.morph.speed;\r\n        mesh.mixer = new THREE.AnimationMixer(mesh);\r\n\r\n        mesh.mixer\r\n          .clipAction(data.animations[0])\r\n          .setDuration(params.morph.duration)\r\n          .play();\r\n\r\n        this.setNative(mesh);\r\n\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    super.wait(promise);\r\n    return promise;\r\n  }\r\n\r\n  clone() {\r\n    return new Morph({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Morph\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Morph.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Octahedron extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'octahedron');\r\n\r\n    extend(params.geometry, {\r\n      radius: 1,\r\n      detail: 0\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.OctahedronBufferGeometry : THREE.OctahedronGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.detail\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_detail(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {detail: val}}));\r\n  }\r\n\r\n  get G_detail() {\r\n    return this.native.geometry.parameters.detail;\r\n  }\r\n\r\n  clone() {\r\n    return new Octahedron({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Octahedron\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Octahedron.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Parametric extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'parametric');\r\n\r\n    extend(params.geometry, {\r\n      func() {},\r\n      slices: 10,\r\n      stacks: 10\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.ParametricBufferGeometry : THREE.ParametricGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.func,\r\n      params.geometry.slices,\r\n      params.geometry.stacks\r\n    );\r\n  }\r\n\r\n  set G_func(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {func: val}}));\r\n  }\r\n\r\n  get G_func() {\r\n    return this.native.geometry.parameters.func;\r\n  }\r\n\r\n  set G_slices(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {slices: val}}));\r\n  }\r\n\r\n  get G_slices() {\r\n    return this.native.geometry.parameters.slices;\r\n  }\r\n\r\n  set G_stacks(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {stacks: val}}));\r\n  }\r\n\r\n  get G_stacks() {\r\n    return this.native.geometry.parameters.stacks;\r\n  }\r\n\r\n  clone() {\r\n    return new Parametric({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Parametric\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Parametric.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Plane extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'plane');\r\n\r\n    extend(params.geometry, {\r\n      width: 10,\r\n      height: 10,\r\n      wSegments: 32,\r\n      hSegments: 32\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.PlaneMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.PlaneBufferGeometry : THREE.PlaneGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.width,\r\n      params.geometry.height,\r\n      params.geometry.wSegments,\r\n      params.geometry.hSegments\r\n    );\r\n  }\r\n\r\n  set G_width(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {width: val}}));\r\n  }\r\n\r\n  get G_width() {\r\n    return this.native.geometry.parameters.width;\r\n  }\r\n\r\n  set G_height(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {height: val}}));\r\n  }\r\n\r\n  get G_height() {\r\n    return this.native.geometry.parameters.height;\r\n  }\r\n\r\n  set G_segments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {segments: val}}));\r\n  }\r\n\r\n  get G_segments() {\r\n    return this.native.geometry.parameters.segments;\r\n  }\r\n\r\n  clone() {\r\n    return new Plane({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Plane\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Plane.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Polyhedron extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'polyhedron');\r\n\r\n    extend(params.geometry, {\r\n      verticesOfCube: this.verticesOfCube,\r\n      indicesOfFaces: this.indicesOfFaces,\r\n      radius: 6,\r\n      detail: 2\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  get verticesOfCube() {\r\n    return [\r\n      -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1,\r\n      -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1\r\n    ];\r\n  }\r\n\r\n  get indicesOfFaces() {\r\n    return [\r\n      2, 1, 0, 0, 3, 2,\r\n      0, 4, 7, 7, 3, 0,\r\n      0, 1, 5, 5, 4, 0,\r\n      1, 2, 6, 6, 5, 1,\r\n      2, 3, 7, 7, 6, 2,\r\n      4, 5, 6, 6, 7, 4\r\n    ];\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.PolyhedronBufferGeometry : THREE.PolyhedronGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.verticesOfCube,\r\n      params.geometry.indicesOfFaces,\r\n      params.geometry.radius,\r\n      params.geometry.detail\r\n    );\r\n  }\r\n\r\n  set G_verticesOfCube(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {verticesOfCube: val}}));\r\n  }\r\n\r\n  get G_verticesOfCube() {\r\n    return this.native.geometry.parameters.verticesOfCube;\r\n  }\r\n\r\n  set G_indicesOfFaces(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {indicesOfFaces: val}}));\r\n  }\r\n\r\n  get G_indicesOfFaces() {\r\n    return this.native.geometry.parameters.indicesOfFaces;\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_detail(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {detail: val}}));\r\n  }\r\n\r\n  get G_detail() {\r\n    return this.native.geometry.parameters.detail;\r\n  }\r\n\r\n  clone() {\r\n    return new Polyhedron({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Polyhedron\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Polyhedron.js\n **/","import * as THREE from 'three';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Ring extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'ring');\r\n\r\n    extend(params.geometry, {\r\n      innerRadius: 0,\r\n      outerRadius: 50,\r\n      thetaSegments: 8,\r\n      phiSegments: 8,\r\n      thetaStart: 0,\r\n      thetaLength: Math.PI * 2\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('onlyvis');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new THREE.Mesh(\r\n        new THREE.RingGeometry(\r\n          params.geometry.innerRadius,\r\n          params.geometry.outerRadius,\r\n          params.geometry.thetaSegments,\r\n          params.geometry.phiSegments,\r\n          params.geometry.thetaStart,\r\n          params.geometry.thetaLength\r\n        ),\r\n\r\n        material\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.RingBufferGeometry : THREE.RingGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.innerRadius,\r\n      params.geometry.outerRadius,\r\n      params.geometry.thetaSegments,\r\n      params.geometry.phiSegments,\r\n      params.geometry.thetaStart,\r\n      params.geometry.thetaLength\r\n    );\r\n  }\r\n\r\n  set G_innerRadius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {innerRadius: val}}));\r\n  }\r\n\r\n  get G_innerRadius() {\r\n    return this.native.geometry.parameters.innerRadius;\r\n  }\r\n\r\n  set G_outerRadius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {outerRadius: val}}));\r\n  }\r\n\r\n  get G_outerRadius() {\r\n    return this.native.geometry.parameters.outerRadius;\r\n  }\r\n\r\n  set G_thetaSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {thetaSegments: val}}));\r\n  }\r\n\r\n  get G_thetaSegments() {\r\n    return this.native.geometry.parameters.thetaSegments;\r\n  }\r\n\r\n  set G_phiSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {phiSegments: val}}));\r\n  }\r\n\r\n  get G_phiSegments() {\r\n    return this.native.geometry.parameters.phiSegments;\r\n  }\r\n\r\n  set G_thetaStart(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {thetaStart: val}}));\r\n  }\r\n\r\n  get G_thetaStart() {\r\n    return this.native.geometry.parameters.thetaStart;\r\n  }\r\n\r\n  set G_thetaLength(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {thetaLength: val}}));\r\n  }\r\n\r\n  get G_thetaLength() {\r\n    return this.native.geometry.parameters.thetaLength;\r\n  }\r\n\r\n  clone() {\r\n    return new Ring({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Ring\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Ring.js\n **/","import * as THREE from 'three';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Shape2D extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'shape2D');\r\n\r\n    extend(params.geometry, {\r\n      shapes: []\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('onlyvis');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new THREE.Mesh(\r\n        this.buildGeometry(params),\r\n        material\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.ShapeBufferGeometry : THREE.ShapeGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.shapes\r\n    );\r\n  }\r\n\r\n  set G_shapes(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {shapes: val}}));\r\n  }\r\n\r\n  get G_shapes() {\r\n    return this.native.geometry.parameters.shapes;\r\n  }\r\n\r\n  clone() {\r\n    return new Shape2D({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Shape2D\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Shape2D.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Sphere extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'sphere');\r\n\r\n    extend(params.geometry, {\r\n      radius: 1,\r\n      widthSegments: 8,\r\n      heightSegments: 6\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.SphereMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.SphereBufferGeometry : THREE.SphereGeometry;\r\n\r\n    const geometry = new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.widthSegments,\r\n      params.geometry.heightSegments\r\n    );\r\n\r\n    if (params.softbody) this.proccessSoftbodyGeometry(geometry);\r\n\r\n    return geometry;\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_widthSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {widthSegments: val}}));\r\n  }\r\n\r\n  get G_widthSegments() {\r\n    return this.native.geometry.parameters.widthSegments;\r\n  }\r\n\r\n  set G_heightSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {widthSegments: val}}));\r\n  }\r\n\r\n  get G_heightSegments() {\r\n    return this.native.geometry.parameters.widthSegments;\r\n  }\r\n\r\n  clone() {\r\n    return this.getParams().softbody ? new Sphere(this.getParams()) : new Sphere({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Sphere\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Sphere.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Tetrahedron extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'tetrahedron');\r\n\r\n    extend(params.geometry, {\r\n      radius: 1,\r\n      detail: 0\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.TetrahedronBufferGeometry : THREE.TetrahedronGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.detail\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_detail(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {detail: val}}));\r\n  }\r\n\r\n  get G_detail() {\r\n    return this.native.geometry.parameters.detail;\r\n  }\r\n\r\n  clone() {\r\n    return new Tetrahedron({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Tetrahedron\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Tetrahedron.js\n **/","import * as THREE from 'three';\r\nimport Physijs  from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend, loadMaterial, FontLoader} from '../extras/api';\r\n\r\nclass Text extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'text');\r\n\r\n    extend(params.geometry, {\r\n      text: 'Hello World!',\r\n\r\n      parameters: {\r\n        size: 12,\r\n        height: 50,\r\n        curveSegments: 12,\r\n        font: new THREE.Font(),\r\n        bevelEnabled: false,\r\n        bevelThickness: 10,\r\n        bevelSize: 8\r\n      }\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap('wait');\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    const promise = new Promise((resolve) => {\r\n      FontLoader.load(params.geometry.parameters.font, font => {\r\n        params.geometry.parameters.font = font;\r\n\r\n        this.setNative(new Mesh(\r\n          new THREE.TextGeometry(\r\n            params.geometry.text,\r\n            params.geometry.parameters\r\n          ),\r\n\r\n          material,\r\n          this.getParams()\r\n        ));\r\n\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    super.wait(promise);\r\n\r\n    return promise;\r\n  }\r\n\r\n  clone() {\r\n    return new Text({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Text\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Text.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs  from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Torus extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'torus');\r\n\r\n    extend(params.geometry, {\r\n      radius: 100,\r\n      tube: 40,\r\n      radialSegments: 8,\r\n      tubularSegments: 6,\r\n      arc: Math.PI * 2\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.TorusBufferGeometry : THREE.TorusGeometry;\r\n\r\n    return new THREE.TorusGeometry(\r\n      params.geometry.radius,\r\n      params.geometry.tube,\r\n      params.geometry.radialSegments,\r\n      params.geometry.tubularSegments,\r\n      params.geometry.arc\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_tube(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {tube: val}}));\r\n  }\r\n\r\n  get G_tube() {\r\n    return this.native.geometry.parameters.tube;\r\n  }\r\n\r\n  set G_radialSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radialSegments: val}}));\r\n  }\r\n\r\n  get G_radialSegments() {\r\n    return this.native.geometry.parameters.radialSegments;\r\n  }\r\n\r\n  set G_tubularSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {tubularSegments: val}}));\r\n  }\r\n\r\n  get G_tubularSegments() {\r\n    return this.native.geometry.parameters.tubularSegments;\r\n  }\r\n\r\n  set G_arc(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {arc: val}}));\r\n  }\r\n\r\n  get G_arc() {\r\n    return this.native.geometry.parameters.arc;\r\n  }\r\n\r\n  clone() {\r\n    return new Torus({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Torus\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Torus.js\n **/","import * as THREE from 'three';\r\nimport * as Physijs from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Torusknot extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'Torusknot');\r\n\r\n    extend(params.geometry, {\r\n      radius: 100,\r\n      tube: 40,\r\n      radialSegments: 64,\r\n      tubularSegments: 8,\r\n      p: 2,\r\n      q: 3,\r\n      heightScale: 1\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.TorusKnotBufferGeometry : THREE.TorusKnotGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.radius,\r\n      params.geometry.tube,\r\n      params.geometry.radialSegments,\r\n      params.geometry.tubularSegments,\r\n      params.geometry.p,\r\n      params.geometry.q,\r\n      params.geometry.heightScale\r\n    );\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_tube(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {tube: val}}));\r\n  }\r\n\r\n  get G_tube() {\r\n    return this.native.geometry.parameters.tube;\r\n  }\r\n\r\n  set G_radialSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radialSegments: val}}));\r\n  }\r\n\r\n  get G_radialSegments() {\r\n    return this.native.geometry.parameters.radialSegments;\r\n  }\r\n\r\n  set G_tubularSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {tubularSegments: val}}));\r\n  }\r\n\r\n  get G_tubularSegments() {\r\n    return this.native.geometry.parameters.tubularSegments;\r\n  }\r\n\r\n  set G_p(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {p: val}}));\r\n  }\r\n\r\n  get G_p() {\r\n    return this.native.geometry.parameters.p;\r\n  }\r\n\r\n  set G_q(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {q: val}}));\r\n  }\r\n\r\n  get G_q() {\r\n    return this.native.geometry.parameters.q;\r\n  }\r\n\r\n  set G_heightScale(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {heightScale: val}}));\r\n  }\r\n\r\n  get G_heightScale() {\r\n    return this.native.geometry.parameters.heightScale;\r\n  }\r\n\r\n  clone() {\r\n    return new Torusknot(this.getParams(), this._type).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Torusknot\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Torusknot.js\n **/","import * as THREE from 'three';\r\nimport Physijs  from '../physics/nophysi.js';\r\n\r\nimport {Shape} from '../core/Shape';\r\nimport {extend} from '../extras/api';\r\n\r\nclass Tube extends Shape {\r\n  constructor(params = {}) {\r\n    super(params, 'tube');\r\n\r\n    extend(params.geometry, {\r\n      path: options.geometryOptions.path ? new this.CustomSinCurve(100) : false,\r\n      segments: 20,\r\n      radius: 2,\r\n      radiusSegments: 8,\r\n      closed: false\r\n    });\r\n\r\n    if (params.build) {\r\n      this.build(params);\r\n      super.wrap();\r\n    }\r\n  }\r\n\r\n  build(params = {}) {\r\n    const material = super._initMaterial(params.material);\r\n\r\n    let Mesh;\r\n\r\n    if (this.physics && this.getParams().softbody) Mesh = Physijs.SoftMesh;\r\n    else if (this.physics && this.physics.type === 'concave') Mesh = Physijs.ConcaveMesh;\r\n    else if (this.physics) Mesh = Physijs.ConvexMesh;\r\n    else Mesh = THREE.Mesh;\r\n\r\n    return new Promise((resolve) => {\r\n      this.setNative(new Mesh(\r\n        this.buildGeometry(params),\r\n        material,\r\n        this.getParams()\r\n      ));\r\n\r\n      resolve();\r\n    });\r\n  }\r\n\r\n  get CustomSinCurve() {\r\n    return THREE.Curve.create(\r\n\r\n      (scale) => { // custom curve constructor\r\n        this.scale = scale || 1;\r\n      },\r\n\r\n      (t) => { // getPoint: t is between 0-1\r\n        const tx = t * 3 - 1.5,\r\n          ty = Math.sin(2 * Math.PI * t),\r\n          tz = 0;\r\n\r\n        return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);\r\n      }\r\n\r\n    );\r\n  }\r\n\r\n  buildGeometry(params = {}) {\r\n    const GConstruct = params.buffer && !params.softbody ? THREE.TubeBufferGeometry : THREE.TubeGeometry;\r\n\r\n    return new GConstruct(\r\n      params.geometry.path,\r\n      params.geometry.segments,\r\n      params.geometry.radius,\r\n      params.geometry.radiusSegments,\r\n      params.geometry.closed\r\n    );\r\n  }\r\n\r\n  set G_path(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {path: val}}));\r\n  }\r\n\r\n  get G_path() {\r\n    return this.native.geometry.parameters.path;\r\n  }\r\n\r\n  set G_segments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {segments: val}}));\r\n  }\r\n\r\n  get G_segments() {\r\n    return this.native.geometry.parameters.segments;\r\n  }\r\n\r\n  set G_radius(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radius: val}}));\r\n  }\r\n\r\n  get G_radius() {\r\n    return this.native.geometry.parameters.radius;\r\n  }\r\n\r\n  set G_radiusSegments(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {radiusSegments: val}}));\r\n  }\r\n\r\n  get G_radiusSegments() {\r\n    return this.native.geometry.parameters.radiusSegments;\r\n  }\r\n\r\n  set G_closed(val) {\r\n    this.native.geometry = this.buildGeometry(this.updateParams({geometry: {closed: val}}));\r\n  }\r\n\r\n  get G_closed() {\r\n    return this.native.geometry.parameters.closed;\r\n  }\r\n\r\n  clone() {\r\n    return new Tube({build: false}).copy(this);\r\n  }\r\n}\r\n\r\nexport {\r\n  Tube\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/meshes/Tube.js\n **/"],"sourceRoot":""}